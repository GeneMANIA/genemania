/*!
 * This file is part of Cytoscape.js 2.5.4.
 *
 * Cytoscape.js is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License along with
 * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.
 */

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.cytoscape = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('./util');
var is = _dereq_('./is');
var Promise = _dereq_('./promise');

var Animation = function( target, opts, opts2 ){
  if( !(this instanceof Animation) ){
    return new Animation( target, opts, opts2 );
  }

  var _p = this._private = util.extend( {
    duration: 1000
  }, opts, opts2 );

  _p.target = target;
  _p.style = _p.style || _p.css;
  _p.started = false;
  _p.playing = false;
  _p.hooked = false;
  _p.applying = false;
  _p.progress = 0;
  _p.completes = [];
  _p.frames = [];

  if( _p.complete && is.fn(_p.complete) ){
    _p.completes.push( _p.complete );
  }

  // for future timeline/animations impl
  this.length = 1;
  this[0] = this;
};

var anifn = Animation.prototype;

util.extend( anifn, {

  instanceString: function(){ return 'animation'; },

  hook: function(){
    var _p = this._private;

    if( !_p.hooked ){
      // add to target's animation queue
      var q;
      var tAni = _p.target._private.animation;
      if( _p.queue ){
        q = tAni.queue;
      } else {
        q = tAni.current;
      }
      q.push( this );

      // add to the animation loop pool
      if( is.elementOrCollection( _p.target ) ){
        _p.target.cy().addToAnimationPool( _p.target );
      }

      _p.hooked = true;
    }

    return this;
  },

  play: function(){
    var _p = this._private;

    // autorewind
    if( _p.progress === 1 ){
      _p.progress = 0;
    }

    _p.playing = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will start the animation...

    return this;
  },

  playing: function(){
    return this._private.playing;
  },

  apply: function(){
    var _p = this._private;

    _p.applying = true;
    _p.started = false; // needs to be started by animation loop
    _p.stopped = false;

    this.hook();

    // the animation loop will apply the animation at this progress

    return this;
  },

  applying: function(){
    return this._private.applying;
  },

  pause: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;

    return this;
  },

  stop: function(){
    var _p = this._private;

    _p.playing = false;
    _p.started = false;
    _p.stopped = true; // to be removed from animation queues

    return this;
  },

  rewind: function(){
    return this.progress(0);
  },

  fastforward: function(){
    return this.progress(1);
  },

  time: function( t ){
    var _p = this._private;

    if( t === undefined ){
      return _p.progress * _p.duration;
    } else {
      return this.progress( t / _p.duration );
    }
  },

  progress: function( p ){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( p === undefined ){
      return _p.progress;
    } else {
      if( wasPlaying ){
        this.pause();
      }

      _p.progress = p;
      _p.started = false;

      if( wasPlaying ){
        this.play();
      }
    }

    return this;
  },

  completed: function(){
    return this._private.progress === 1;
  },

  reverse: function(){
    var _p = this._private;
    var wasPlaying = _p.playing;

    if( wasPlaying ){
      this.pause();
    }

    _p.progress = 1 - _p.progress;
    _p.started = false;

    var swap = function( a, b ){
      var _pa = _p[a];

      _p[a] = _p[b];
      _p[b] = _pa;
    };

    swap( 'zoom', 'startZoom' );
    swap( 'pan', 'startPan' );
    swap( 'position', 'startPosition' );

    // swap styles
    for( var i = 0; i < _p.style.length; i++ ){
      var prop = _p.style[i];
      var name = prop.name;
      var startStyleProp = _p.startStyle[ name ];

      _p.startStyle[ name ] = _p.startStyle[ util.dash2camel( name ) ] = prop;
      _p.style[i] = startStyleProp;
    }

    if( wasPlaying ){
      this.play();
    }

    return this;
  },

  promise: function( type ){
    var _p = this._private;

    var arr;

    switch( type ){
      case 'frame':
        arr = _p.frames;
        break;
      default:
      case 'complete':
      case 'completed':
        arr = _p.completes;
    }

    return new Promise(function( resolve, reject ){
      arr.push(function(){
        resolve();
      });
    });
  }

} );

anifn.complete = anifn.completed;

module.exports = Animation;

},{"./is":77,"./promise":80,"./util":94}],2:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  aStar: function(options) {
    var eles = this;

    options = options || {};

    // Reconstructs the path from Start to End, acumulating the result in pathAcum
    var reconstructPath = function(start, end, cameFromMap, pathAcum) {
      // Base case
      if (start == end) {
        pathAcum.push( cy.getElementById(end) );
        return pathAcum;
      }

      if (end in cameFromMap) {
        // We know which node is before the last one
        var previous = cameFromMap[end];
        var previousEdge = cameFromEdge[end];

        pathAcum.push( cy.getElementById(end) );
        pathAcum.push( cy.getElementById(previousEdge) );


        return reconstructPath(start,
                     previous,
                     cameFromMap,
                     pathAcum);
      }

      // We should not reach here!
      return undefined;
    };

    // Returns the index of the element in openSet which has minimum fScore
    var findMin = function(openSet, fScore) {
      if (openSet.length === 0) {
        // Should never be the case
        return undefined;
      }
      var minPos = 0;
      var tempScore = fScore[openSet[0]];
      for (var i = 1; i < openSet.length; i++) {
        var s = fScore[openSet[i]];
        if (s < tempScore) {
          tempScore = s;
          minPos = i;
        }
      }
      return minPos;
    };

    var cy = this._private.cy;

    // root - mandatory!
    if (options != null && options.root != null) {
      var source = is.string(options.root) ?
        // use it as a selector, e.g. "#rootID
        this.filter(options.root)[0] :
        options.root[0];
    } else {
      return undefined;
    }

    // goal - mandatory!
    if (options.goal != null) {
      var target = is.string(options.goal) ?
        // use it as a selector, e.g. "#goalID
        this.filter(options.goal)[0] :
        options.goal[0];
    } else {
      return undefined;
    }

    // Heuristic function - optional
    if (options.heuristic != null && is.fn(options.heuristic)) {
      var heuristic = options.heuristic;
    } else {
      var heuristic = function(){ return 0; }; // use constant if unspecified
    }

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function(e) {return 1;};
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var closedSet = [];
    var openSet = [source.id()];
    var cameFrom = {};
    var cameFromEdge = {};
    var gScore = {};
    var fScore = {};

    gScore[source.id()] = 0;
    fScore[source.id()] = heuristic(source);

    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();

    // Counter
    var steps = 0;

    // Main loop
    while (openSet.length > 0) {
      var minPos = findMin(openSet, fScore);
      var cMin = cy.getElementById( openSet[minPos] );
      steps++;

      // If we've found our goal, then we are done
      if (cMin.id() == target.id()) {
        var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);
        rPath.reverse();
        return {
          found : true,
          distance : gScore[cMin.id()],
          path : eles.spawn(rPath),
          steps : steps
        };
      }

      // Add cMin to processed nodes
      closedSet.push(cMin.id());
      // Remove cMin from boundary nodes
      openSet.splice(minPos, 1);

      // Update scores for neighbors of cMin
      // Take into account if graph is directed or not
      var vwEdges = cMin.connectedEdges();
      if( directed ){ vwEdges = vwEdges.stdFilter(function(ele){ return ele.data('source') === cMin.id(); }); }
      vwEdges = vwEdges.intersect(edges);

      for (var i = 0; i < vwEdges.length; i++) {
        var e = vwEdges[i];
        var w = e.connectedNodes().stdFilter(function(n){ return n.id() !== cMin.id(); }).intersect(nodes);

        // if node is in closedSet, ignore it
        if (closedSet.indexOf(w.id()) != -1) {
          continue;
        }

        // New tentative score for node w
        var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);

        // Update gScore for node w if:
        //   w not present in openSet
        // OR
        //   tentative gScore is less than previous value

        // w not in openSet
        if (openSet.indexOf(w.id()) == -1) {
          gScore[w.id()] = tempScore;
          fScore[w.id()] = tempScore + heuristic(w);
          openSet.push(w.id()); // Add node to openSet
          cameFrom[w.id()] = cMin.id();
          cameFromEdge[w.id()] = e.id();
          continue;
        }
        // w already in openSet, but with greater gScore
        if (tempScore < gScore[w.id()]) {
          gScore[w.id()] = tempScore;
          fScore[w.id()] = tempScore + heuristic(w);
          cameFrom[w.id()] = cMin.id();
        }

      } // End of neighbors update

    } // End of main loop

    // If we've reached here, then we've not reached our goal
    return {
      found : false,
      distance : undefined,
      path : undefined,
      steps : steps
    };
  }

}); // elesfn


module.exports = elesfn;

},{"../../is":77}],3:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');
var util = _dereq_('../../util');

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  bellmanFord: function(options) {
    var eles = this;

    options = options || {};

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function(e) {return 1;};
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // root - mandatory!
    if (options.root != null) {
      if (is.string(options.root)) {
        // use it as a selector, e.g. "#rootID
        var source = this.filter(options.root)[0];
      } else {
        var source = options.root[0];
      }
    } else {
      return undefined;
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Initializations
    var cost = [];
    var predecessor = [];
    var predEdge = [];

    for (var i = 0; i < numNodes; i++) {
      if (nodes[i].id() === source.id()) {
        cost[i] = 0;
      } else {
        cost[i] = Infinity;
      }
      predecessor[i] = undefined;
    }

    // Edges relaxation
    var flag = false;
    for (var i = 1; i < numNodes; i++) {
      flag = false;
      for (var e = 0; e < edges.length; e++) {
        var sourceIndex = id2position[edges[e].source().id()];
        var targetIndex = id2position[edges[e].target().id()];
        var weight = weightFn.apply(edges[e], [edges[e]]);

        var temp = cost[sourceIndex] + weight;
        if (temp < cost[targetIndex]) {
          cost[targetIndex] = temp;
          predecessor[targetIndex] = sourceIndex;
          predEdge[targetIndex] = edges[e];
          flag = true;
        }

        // If undirected graph, we need to take into account the 'reverse' edge
        if (!directed) {
          var temp = cost[targetIndex] + weight;
          if (temp < cost[sourceIndex]) {
            cost[sourceIndex] = temp;
            predecessor[sourceIndex] = targetIndex;
            predEdge[sourceIndex] = edges[e];
            flag = true;
          }
        }
      }

      if (!flag) {
        break;
      }
    }

    if (flag) {
      // Check for negative weight cycles
      for (var e = 0; e < edges.length; e++) {
        var sourceIndex = id2position[edges[e].source().id()];
        var targetIndex = id2position[edges[e].target().id()];
        var weight = weightFn.apply(edges[e], [edges[e]]);

        if (cost[sourceIndex] + weight < cost[targetIndex]) {
          util.error("Graph contains a negative weight cycle for Bellman-Ford");
          return { pathTo: undefined,
               distanceTo: undefined,
               hasNegativeWeightCycle: true};
        }
      }
    }

    // Build result object
    var position2id = [];
    for (var i = 0; i < numNodes; i++) {
      position2id.push(nodes[i].id());
    }


    var res = {
      distanceTo : function(to) {
        if (is.string(to)) {
          // to is a selector string
          var toId = (cy.filter(to)[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return cost[id2position[toId]];
      },

      pathTo : function(to) {

        var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
          for(;;){
            // Add toId to path
            acumPath.push( cy.getElementById(position2id[toPos]) );
            acumPath.push( predEdge[toPos] );

            if (fromPos === toPos) {
              // reached starting node
              return acumPath;
            }

            // If no path exists, discart acumulated path and return undefined
            var predPos = predecessor[toPos];
            if (typeof predPos === "undefined") {
              return undefined;
            }

            toPos = predPos;
          }

        };

        if (is.string(to)) {
          // to is a selector string
          var toId = (cy.filter(to)[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }
        var path = [];

        // This returns a reversed path
        var res =  reconstructPathAux(predecessor,
                      id2position[source.id()],
                      id2position[toId],
                      position2id,
                      path,
                      predEdge);

        // Get it in the correct order and return it
        if (res != null) {
          res.reverse();
        }

        return eles.spawn(res);
      },

      hasNegativeWeightCycle: false
    };

    return res;

  } // bellmanFord

}); // elesfn

module.exports = elesfn;

},{"../../is":77,"../../util":94}],4:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
  betweennessCentrality: function (options) {
    options = options || {};

    // Weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
      var weighted = true;
    } else {
      var weighted = false;
    }

    // Directed - default false
    if (options.directed != null && is.bool(options.directed)) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var priorityInsert = function (queue, ele) {
      queue.unshift(ele);
      for (var i = 0; d[queue[i]] < d[queue[i + 1]] && i < queue.length - 1; i++) {
        var tmp = queue[i];
        queue[i] = queue[i + 1];
        queue[i + 1] = tmp;
      }
    };

    var cy = this._private.cy;

    // starting
    var V = this.nodes();
    var A = {};
    var C = {};

    // A contains the neighborhoods of every node
    for (var i = 0; i < V.length; i++) {
      if (directed) {
        A[V[i].id()] = V[i].outgoers("node"); // get outgoers of every node
      } else {
        A[V[i].id()] = V[i].openNeighborhood("node"); // get neighbors of every node
      }
    }

    // C contains the betweenness values
    for (var i = 0; i < V.length; i++) {
      C[V[i].id()] = 0;
    }

    for (var s = 0; s < V.length; s++) {
      var S = []; // stack
      var P = {};
      var g = {};
      var d = {};
      var Q = []; // queue

      // init dictionaries
      for (var i = 0; i < V.length; i++) {
        P[V[i].id()] = [];
        g[V[i].id()] = 0;
        d[V[i].id()] = Number.POSITIVE_INFINITY;
      }

      g[V[s].id()] = 1; // sigma
      d[V[s].id()] = 0; // distance to s

      Q.unshift(V[s].id());

      while (Q.length > 0) {
        var v = Q.pop();
        S.push(v);
        if (weighted) {
          A[v].forEach(function (w) {
            if (cy.$('#' + v).edgesTo(w).length > 0) {
              var edge = cy.$('#' + v).edgesTo(w)[0];
            } else {
              var edge = w.edgesTo('#' + v)[0];
            }

            var edgeWeight = weightFn.apply(edge, [edge]);

            if (d[w.id()] > d[v] + edgeWeight) {
              d[w.id()] = d[v] + edgeWeight;
              if (Q.indexOf(w.id()) < 0) { //if w is not in Q
                priorityInsert(Q, w.id());
              } else { // update position if w is in Q
                Q.splice(Q.indexOf(w.id()), 1);
                priorityInsert(Q, w.id());
              }
              g[w.id()] = 0;
              P[w.id()] = [];
            }
            if (d[w.id()] == d[v] + edgeWeight) {
              g[w.id()] = g[w.id()] + g[v];
              P[w.id()].push(v);
            }
          });
        } else {
          A[v].forEach(function (w) {
            if (d[w.id()] == Number.POSITIVE_INFINITY) {
              Q.unshift(w.id());
              d[w.id()] = d[v] + 1;
            }
            if (d[w.id()] == d[v] + 1) {
              g[w.id()] = g[w.id()] + g[v];
              P[w.id()].push(v);
            }
          });
        }
      }

      var e = {};
      for (var i = 0; i < V.length; i++) {
        e[V[i].id()] = 0;
      }

      while (S.length > 0) {
        var w = S.pop();
        P[w].forEach(function (v) {
          e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);
          if (w != V[s].id())
            C[w] = C[w] + e[w];
        });
      }
    }

    var max = 0;
    for (var key in C) {
      if (max < C[key])
        max = C[key];
    }

    var ret = {
      betweenness: function (node) {
        if (is.string(node)) {
          var node = (cy.filter(node)[0]).id();
        } else {
          var node = node.id();
        }

        return C[node];
      },

      betweennessNormalized: function (node) {
        if (is.string(node)) {
          var node = (cy.filter(node)[0]).id();
        } else {
          var node = node.id();
        }

        return C[node] / max;
      }
    };

    // alias
    ret.betweennessNormalised = ret.betweennessNormalized;

    return ret;
  } // betweennessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.bc = elesfn.betweennessCentrality;

module.exports = elesfn;

},{"../../is":77}],5:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');
var Heap = _dereq_('../../heap');

var defineSearch = function( params ){
  params = {
    bfs: params.bfs || !params.dfs,
    dfs: params.dfs || !params.bfs
  };

  // from pseudocode on wikipedia
  return function searchFn( roots, fn, directed ){
    var options;
    var std;
    var thisArg;
    if( is.plainObject(roots) && !is.elementOrCollection(roots) ){
      options = roots;
      roots = options.roots || options.root;
      fn = options.visit;
      directed = options.directed;
      std = options.std;
      thisArg = options.thisArg;
    }

    directed = arguments.length === 2 && !is.fn(fn) ? fn : directed;
    fn = is.fn(fn) ? fn : function(){};

    var cy = this._private.cy;
    var v = roots = is.string(roots) ? this.filter(roots) : roots;
    var Q = [];
    var connectedNodes = [];
    var connectedBy = {};
    var id2depth = {};
    var V = {};
    var j = 0;
    var found;
    var nodes = this.nodes();
    var edges = this.edges();

    // enqueue v
    for( var i = 0; i < v.length; i++ ){
      if( v[i].isNode() ){
        Q.unshift( v[i] );

        if( params.bfs ){
          V[ v[i].id() ] = true;

          connectedNodes.push( v[i] );
        }

        id2depth[ v[i].id() ] = 0;
      }
    }

    while( Q.length !== 0 ){
      var v = params.bfs ? Q.shift() : Q.pop();

      if( params.dfs ){
        if( V[ v.id() ] ){ continue; }

        V[ v.id() ] = true;

        connectedNodes.push( v );
      }

      var depth = id2depth[ v.id() ];
      var prevEdge = connectedBy[ v.id() ];
      var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
      var ret;

      if( std ){
        ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
      } else {
        ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
      }

      if( ret === true ){
        found = v;
        break;
      }

      if( ret === false ){
        break;
      }

      var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
      for( var i = 0; i < vwEdges.length; i++ ){
        var e = vwEdges[i];
        var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

        if( w.length !== 0 && !V[ w.id() ] ){
          w = w[0];

          Q.push( w );

          if( params.bfs ){
            V[ w.id() ] = true;

            connectedNodes.push( w );
          }

          connectedBy[ w.id() ] = e;

          id2depth[ w.id() ] = id2depth[ v.id() ] + 1;
        }
      }

    }

    var connectedEles = [];

    for( var i = 0; i < connectedNodes.length; i++ ){
      var node = connectedNodes[i];
      var edge = connectedBy[ node.id() ];

      if( edge ){
        connectedEles.push( edge );
      }

      connectedEles.push( node );
    }

    return {
      path: cy.collection( connectedEles, { unique: true } ),
      found: cy.collection( found )
    };
  };
};

// search, spanning trees, etc
var elesfn = ({

  breadthFirstSearch: defineSearch({ bfs: true }),
  depthFirstSearch: defineSearch({ dfs: true }),

  // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
  // implemented from pseudocode from wikipedia
  kruskal: function( weightFn ){
    var cy = this.cy();

    weightFn = is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    function findSet(ele){
      for( var i = 0; i < forest.length; i++ ){
        var eles = forest[i];

        if( eles.anySame(ele) ){
          return {
            eles: eles,
            index: i
          };
        }
      }
    }

    var A = cy.collection(cy, []);
    var forest = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      forest.push( nodes[i].collection() );
    }

    var edges = this.edges();
    var S = edges.toArray().sort(function(a, b){
      var weightA = weightFn.call(a, a);
      var weightB = weightFn.call(b, b);

      return weightA - weightB;
    });

    for(var i = 0; i < S.length; i++){
      var edge = S[i];
      var u = edge.source()[0];
      var v = edge.target()[0];
      var setU = findSet(u);
      var setV = findSet(v);

      if( setU.index !== setV.index ){
        A = A.add( edge );

        // combine forests for u and v
        forest[ setU.index ] = setU.eles.add( setV.eles );
        forest.splice( setV.index, 1 );
      }
    }

    return nodes.add( A );

  },

  dijkstra: function( root, weightFn, directed ){
    var options;
    if( is.plainObject(root) && !is.elementOrCollection(root) ){
      options = root;
      root = options.root;
      weightFn = options.weight;
      directed = options.directed;
    }

    var cy = this._private.cy;
    weightFn = is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

    var source = is.string(root) ? this.filter(root)[0] : root[0];
    var dist = {};
    var prev = {};
    var knownDist = {};

    var edges = this.edges().filter(function(){ return !this.isLoop(); });
    var nodes = this.nodes();

    var getDist = function(node){
      return dist[ node.id() ];
    };

    var setDist = function(node, d){
      dist[ node.id() ] = d;

      Q.updateItem( node );
    };

    var Q = new Heap(function( a, b ){
      return getDist(a) - getDist(b);
    });

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];

      dist[ node.id() ] = node.same( source ) ? 0 : Infinity;
      Q.push( node );
    }

    var distBetween = function(u, v){
      var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);
      var smallestDistance = Infinity;
      var smallestEdge;

      for( var i = 0; i < uvs.length; i++ ){
        var edge = uvs[i];
        var weight = weightFn.apply( edge, [edge] );

        if( weight < smallestDistance || !smallestEdge ){
          smallestDistance = weight;
          smallestEdge = edge;
        }
      }

      return {
        edge: smallestEdge,
        dist: smallestDistance
      };
    };

    while( Q.size() > 0 ){
      var u = Q.pop();
      var smalletsDist = getDist(u);
      var uid = u.id();

      knownDist[uid] = smalletsDist;

      if( smalletsDist === Math.Infinite ){
        break;
      }

      var neighbors = u.neighborhood().intersect(nodes);
      for( var i = 0; i < neighbors.length; i++ ){
        var v = neighbors[i];
        var vid = v.id();
        var vDist = distBetween(u, v);

        var alt = smalletsDist + vDist.dist;

        if( alt < getDist(v) ){
          setDist(v, alt);

          prev[ vid ] = {
            node: u,
            edge: vDist.edge
          };
        }
      } // for
    } // while

    return {
      distanceTo: function(node){
        var target = is.string(node) ? nodes.filter(node)[0] : node[0];

        return knownDist[ target.id() ];
      },

      pathTo: function(node){
        var target = is.string(node) ? nodes.filter(node)[0] : node[0];
        var S = [];
        var u = target;

        if( target.length > 0 ){
          S.unshift( target );

          while( prev[ u.id() ] ){
            var p = prev[ u.id() ];

            S.unshift( p.edge );
            S.unshift( p.node );

            u = p.node;
          }
        }

        return cy.collection( S );
      }
    };
  }
});

// nice, short mathemathical alias
elesfn.bfs = elesfn.breadthFirstSearch;
elesfn.dfs = elesfn.depthFirstSearch;

module.exports = elesfn;

},{"../../heap":75,"../../is":77}],6:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  closenessCentralityNormalized: function (options) {
    options = options || {};

    var cy = this.cy();

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    var closenesses = {};
    var maxCloseness = 0;
    var nodes = this.nodes();
    var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

    // Compute closeness for every node and find the maximum closeness
    for(var i = 0; i < nodes.length; i++){
      var currCloseness = 0;
      for (var j = 0; j < nodes.length; j++) {
        if (i != j) {
          var d = fw.distance(nodes[i], nodes[j]);

          if( harmonic ){
            currCloseness += 1 / d;
          } else {
            currCloseness += d;
          }
        }
      }

      if( !harmonic ){
        currCloseness = 1 / currCloseness;
      }

      if (maxCloseness < currCloseness){
        maxCloseness = currCloseness;
      }

      closenesses[nodes[i].id()] = currCloseness;
    }

    return {
      closeness: function (node) {
        if (is.string(node)) {
          // from is a selector string
          var node = (cy.filter(node)[0]).id();
        } else {
          // from is a node
          var node = node.id();
        }

        return closenesses[node] / maxCloseness;
      }
    };
  },

  // Implemented from pseudocode from wikipedia
  closenessCentrality: function (options) {
    options = options || {};

    // root - mandatory!
    if (options.root != null) {
      if (is.string(options.root)) {
        // use it as a selector, e.g. "#rootID
        var root = this.filter(options.root)[0];
      } else {
        var root = options.root[0];
      }
    } else {
      return undefined;
    }

    // weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weight = options.weight;
    } else {
      var weight = function(){return 1;};
    }

    // directed - optional
    if (options.directed != null && is.bool(options.directed)) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var harmonic = options.harmonic;
    if( harmonic === undefined ){
      harmonic = true;
    }

    // we need distance from this node to every other node
    var dijkstra = this.dijkstra({
      root: root,
      weight: weight,
      directed: directed
    });
    var totalDistance = 0;

    var nodes = this.nodes();
    for (var i = 0; i < nodes.length; i++){
      if (nodes[i].id() != root.id()){
        var d = dijkstra.distanceTo(nodes[i]);

        if( harmonic ){
          totalDistance += 1 / d;
        } else {
          totalDistance += d;
        }
      }
    }

    return harmonic ? totalDistance : 1 / totalDistance;
  } // closenessCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.cc = elesfn.closenessCentrality;
elesfn.ccn = elesfn.closenessCentralityNormalised = elesfn.closenessCentralityNormalized;

module.exports = elesfn;

},{"../../is":77}],7:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');
var util = _dereq_('../../util');

var elesfn = ({

  degreeCentralityNormalized: function (options) {
    options = options || {};

    var cy = this.cy();

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var nodes = this.nodes();
    var numNodes = nodes.length;

    if (!directed) {
      var degrees = {};
      var maxDegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality(util.extend({}, options, {root: node}));
        if (maxDegree < currDegree.degree)
          maxDegree = currDegree.degree;

        degrees[node.id()] = currDegree.degree;
      }

      return {
        degree: function (node) {
          if (is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return degrees[node] / maxDegree;
        }
      };
    } else {
      var indegrees = {};
      var outdegrees = {};
      var maxIndegree = 0;
      var maxOutdegree = 0;

      for (var i = 0; i < numNodes; i++) {
        var node = nodes[i];
        // add current node to the current options object and call degreeCentrality
        var currDegree = this.degreeCentrality(util.extend({}, options, {root: node}));

        if (maxIndegree < currDegree.indegree)
          maxIndegree = currDegree.indegree;

        if (maxOutdegree < currDegree.outdegree)
          maxOutdegree = currDegree.outdegree;

        indegrees[node.id()] = currDegree.indegree;
        outdegrees[node.id()] = currDegree.outdegree;
      }

      return {
        indegree: function (node) {
          if (is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return indegrees[node] / maxIndegree;
        },
        outdegree: function (node) {
          if (is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return outdegrees[node] / maxOutdegree;
        }

      };
    }

  }, // degreeCentralityNormalized

  // Implemented from the algorithm in Opsahl's paper
  // "Node centrality in weighted networks: Generalizing degree and shortest paths"
  // check the heading 2 "Degree"
  degreeCentrality: function (options) {
    options = options || {};

    var callingEles = this;

    // root - mandatory!
    if (options != null && options.root != null) {
      var root = is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
    } else {
      return undefined;
    }

    // weight - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function (e) {
        return 1;
      };
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    // alpha - optional
    if (options.alpha != null && is.number(options.alpha)) {
      var alpha = options.alpha;
    } else {
      alpha = 0;
    }


    if (!directed) {
      var connEdges = root.connectedEdges().intersection( callingEles );
      var k = connEdges.length;
      var s = 0;

      // Now, sum edge weights
      for (var i = 0; i < connEdges.length; i++) {
        var edge = connEdges[i];
        s += weightFn.apply(edge, [edge]);
      }

      return {
        degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
      };
    } else {
      var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection( callingEles );
      var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection( callingEles );
      var k_in = incoming.length;
      var k_out = outgoing.length;
      var s_in = 0;
      var s_out = 0;

      // Now, sum incoming edge weights
      for (var i = 0; i < incoming.length; i++) {
        var edge = incoming[i];
        s_in += weightFn.apply(edge, [edge]);
      }

      // Now, sum outgoing edge weights
      for (var i = 0; i < outgoing.length; i++) {
        var edge = outgoing[i];
        s_out += weightFn.apply(edge, [edge]);
      }

      return {
        indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
        outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
      };
    }
  } // degreeCentrality

}); // elesfn

// nice, short mathemathical alias
elesfn.dc = elesfn.degreeCentrality;
elesfn.dcn = elesfn.degreeCentralityNormalised = elesfn.degreeCentralityNormalized;

module.exports = elesfn;

},{"../../is":77,"../../util":94}],8:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  // Implemented from pseudocode from wikipedia
  floydWarshall: function(options) {
    options = options || {};

    var cy = this.cy();

    // Weight function - optional
    if (options.weight != null && is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function(e) {return 1;};
    }

    // directed - optional
    if (options.directed != null) {
      var directed = options.directed;
    } else {
      var directed = false;
    }

    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();
    var numNodes = nodes.length;

    // mapping: node id -> position in nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Initialize distance matrix
    var dist = [];
    for (var i = 0; i < numNodes; i++) {
      var newRow = new Array(numNodes);
      for (var j = 0; j < numNodes; j++) {
        if (i == j) {
          newRow[j] = 0;
        } else {
          newRow[j] = Infinity;
        }
      }
      dist.push(newRow);
    }

    // Initialize matrix used for path reconstruction
    // Initialize distance matrix
    var next = [];
    var edgeNext = [];

    var initMatrix = function(next){
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          newRow[j] = undefined;
        }
        next.push(newRow);
      }
    };

    initMatrix(next);
    initMatrix(edgeNext);

    // Process edges
    for (var i = 0; i < edges.length ; i++) {
      var sourceIndex = id2position[edges[i].source().id()];
      var targetIndex = id2position[edges[i].target().id()];
      var weight = weightFn.apply(edges[i], [edges[i]]);

      // Check if already process another edge between same 2 nodes
      if (dist[sourceIndex][targetIndex] > weight) {
        dist[sourceIndex][targetIndex] = weight;
        next[sourceIndex][targetIndex] = targetIndex;
        edgeNext[sourceIndex][targetIndex] = edges[i];
      }
    }

    // If undirected graph, process 'reversed' edges
    if (!directed) {
      for (var i = 0; i < edges.length ; i++) {
        var sourceIndex = id2position[edges[i].target().id()];
        var targetIndex = id2position[edges[i].source().id()];
        var weight = weightFn.apply(edges[i], [edges[i]]);

        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }
    }

    // Main loop
    for (var k = 0; k < numNodes; k++) {
      for (var i = 0; i < numNodes; i++) {
        for (var j = 0; j < numNodes; j++) {
          if (dist[i][k] + dist[k][j] < dist[i][j]) {
            dist[i][j] = dist[i][k] + dist[k][j];
            next[i][j] = next[i][k];
          }
        }
      }
    }

    // Build result object
    var position2id = [];
    for (var i = 0; i < numNodes; i++) {
      position2id.push(nodes[i].id());
    }

    var res = {
      distance: function(from, to) {
        if (is.string(from)) {
          // from is a selector string
          var fromId = (cy.filter(from)[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if (is.string(to)) {
          // to is a selector string
          var toId = (cy.filter(to)[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        return dist[id2position[fromId]][id2position[toId]];
      },

      path: function(from, to) {
        var reconstructPathAux = function(from, to, next, position2id, edgeNext) {
          if (from === to) {
            return cy.getElementById( position2id[from] );
          }
          if (next[from][to] === undefined) {
            return undefined;
          }

          var path = [ cy.getElementById(position2id[from]) ];
          var prev = from;
          while (from !== to) {
            prev = from;
            from = next[from][to];

            var edge = edgeNext[prev][from];
            path.push( edge );

            path.push( cy.getElementById(position2id[from]) );
          }
          return path;
        };

        if (is.string(from)) {
          // from is a selector string
          var fromId = (cy.filter(from)[0]).id();
        } else {
          // from is a node
          var fromId = from.id();
        }

        if (is.string(to)) {
          // to is a selector string
          var toId = (cy.filter(to)[0]).id();
        } else {
          // to is a node
          var toId = to.id();
        }

        var pathArr = reconstructPathAux(id2position[fromId],
                      id2position[toId],
                      next,
                      position2id,
                      edgeNext);

        return cy.collection( pathArr );
      }
    };

    return res;

  } // floydWarshall

}); // elesfn

module.exports = elesfn;

},{"../../is":77}],9:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');

var elesfn = {};

[
  _dereq_('./bfs-dfs'),
  _dereq_('./a-star'),
  _dereq_('./floyd-warshall'),
  _dereq_('./bellman-ford'),
  _dereq_('./kerger-stein'),
  _dereq_('./page-rank'),
  _dereq_('./degree-centrality'),
  _dereq_('./closeness-centrality'),
  _dereq_('./betweenness-centrality')
].forEach(function( props ){
  util.extend( elesfn, props );
});

module.exports = elesfn;

},{"../../util":94,"./a-star":2,"./bellman-ford":3,"./betweenness-centrality":4,"./bfs-dfs":5,"./closeness-centrality":6,"./degree-centrality":7,"./floyd-warshall":8,"./kerger-stein":10,"./page-rank":11}],10:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');

var elesfn = ({

  // Computes the minimum cut of an undirected graph
  // Returns the correct answer with high probability
  kargerStein: function(options) {
    var eles = this;

    options = options || {};

    // Function which colapses 2 (meta) nodes into one
    // Updates the remaining edge lists
    // Receives as a paramater the edge which causes the collapse
    var colapse = function(edgeIndex, nodeMap, remainingEdges) {
      var edgeInfo = remainingEdges[edgeIndex];
      var sourceIn = edgeInfo[1];
      var targetIn = edgeInfo[2];
      var partition1 = nodeMap[sourceIn];
      var partition2 = nodeMap[targetIn];

      // Delete all edges between partition1 and partition2
      var newEdges = remainingEdges.filter(function(edge) {
        if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
          return false;
        }
        if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
          return false;
        }
        return true;
      });

      // All edges pointing to partition2 should now point to partition1
      for (var i = 0; i < newEdges.length; i++) {
        var edge = newEdges[i];
        if (edge[1] === partition2) { // Check source
          newEdges[i] = edge.slice(0);
          newEdges[i][1] = partition1;
        } else if (edge[2] === partition2) { // Check target
          newEdges[i] = edge.slice(0);
          newEdges[i][2] = partition1;
        }
      }

      // Move all nodes from partition2 to partition1
      for (var i = 0; i < nodeMap.length; i++) {
        if (nodeMap[i] === partition2) {
          nodeMap[i] = partition1;
        }
      }

      return newEdges;
    };


    // Contracts a graph until we reach a certain number of meta nodes
    var contractUntil = function(metaNodeMap,
                   remainingEdges,
                   size,
                   sizeLimit) {
      // Stop condition
      if (size <= sizeLimit) {
        return remainingEdges;
      }

      // Choose an edge randomly
      var edgeIndex = Math.floor((Math.random() * remainingEdges.length));

      // Colapse graph based on edge
      var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);

      return contractUntil(metaNodeMap,
                 newEdges,
                 size - 1,
                 sizeLimit);
    };

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;
    var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
    var stopSize = Math.floor(numNodes / Math.sqrt(2));

    if (numNodes < 2) {
      util.error("At least 2 nodes are required for Karger-Stein algorithm");
      return undefined;
    }

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Now store edge destination as indexes
    // Format for each edge (edge index, source node index, target node index)
    var edgeIndexes = [];
    for (var i = 0; i < numEdges; i++) {
      var e = edges[i];
      edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
    }

    // We will store the best cut found here
    var minCutSize = Infinity;
    var minCut;

    // Initial meta node partition
    var originalMetaNode = [];
    for (var i = 0; i < numNodes; i++) {
      originalMetaNode.push(i);
    }

    // Main loop
    for (var iter = 0; iter <= numIter; iter++) {
      // Create new meta node partition
      var metaNodeMap = originalMetaNode.slice(0);

      // Contract until stop point (stopSize nodes)
      var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);

      // Create a copy of the colapsed nodes state
      var metaNodeMap2 = metaNodeMap.slice(0);

      // Run 2 iterations starting in the stop state
      var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
      var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

      // Is any of the 2 results the best cut so far?
      if (res1.length <= res2.length && res1.length < minCutSize) {
        minCutSize = res1.length;
        minCut = [res1, metaNodeMap];
      } else if (res2.length <= res1.length && res2.length < minCutSize) {
        minCutSize = res2.length;
        minCut = [res2, metaNodeMap2];
      }
    } // end of main loop


    // Construct result
    var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });
    var partition1 = [];
    var partition2 = [];

    // traverse metaNodeMap for best cut
    var witnessNodePartition = minCut[1][0];
    for (var i = 0; i < minCut[1].length; i++) {
      var partitionId = minCut[1][i];
      if (partitionId === witnessNodePartition) {
        partition1.push(nodes[i]);
      } else {
        partition2.push(nodes[i]);
      }
    }

    var ret = {
      cut: eles.spawn(cy, resEdges),
      partition1: eles.spawn(partition1),
      partition2: eles.spawn(partition2)
    };

    return ret;
  }
}); // elesfn


module.exports = elesfn;

},{"../../util":94}],11:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../is');

var elesfn = ({

  pageRank: function(options) {
    options = options || {};

    var normalizeVector = function(vector) {
      var length = vector.length;

      // First, get sum of all elements
      var total = 0;
      for (var i = 0; i < length; i++) {
        total += vector[i];
      }

      // Now, divide each by the sum of all elements
      for (var i = 0; i < length; i++) {
        vector[i] = vector[i] / total;
      }
    };

    // dampingFactor - optional
    if (options != null &&
      options.dampingFactor != null) {
      var dampingFactor = options.dampingFactor;
    } else {
      var dampingFactor = 0.8; // Default damping factor
    }

    // desired precision - optional
    if (options != null &&
      options.precision != null) {
      var epsilon = options.precision;
    } else {
      var epsilon = 0.000001; // Default precision
    }

    // Max number of iterations - optional
    if (options != null &&
      options.iterations != null) {
      var numIter = options.iterations;
    } else {
      var numIter = 200; // Default number of iterations
    }

    // Weight function - optional
    if (options != null &&
      options.weight != null &&
      is.fn(options.weight)) {
      var weightFn = options.weight;
    } else {
      // If not specified, assume each edge has equal weight (1)
      var weightFn = function(e) {return 1;};
    }

    var cy = this._private.cy;
    var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
    var nodes = this.nodes();
    var numNodes = nodes.length;
    var numEdges = edges.length;

    // Create numerical identifiers for each node
    // mapping: node id -> position in nodes array
    // for reverse mapping, simply use nodes array
    var id2position = {};
    for (var i = 0; i < numNodes; i++) {
      id2position[nodes[i].id()] = i;
    }

    // Construct transposed adjacency matrix
    // First lets have a zeroed matrix of the right size
    // We'll also keep track of the sum of each column
    var matrix = [];
    var columnSum = [];
    var additionalProb = (1 - dampingFactor) / numNodes;

    // Create null matric
    for (var i = 0; i < numNodes; i++) {
      var newRow = [];
      for (var j = 0; j < numNodes; j++) {
        newRow.push(0.0);
      }
      matrix.push(newRow);
      columnSum.push(0.0);
    }

    // Now, process edges
    for (var i = 0; i < numEdges; i++) {
      var edge = edges[i];
      var s = id2position[edge.source().id()];
      var t = id2position[edge.target().id()];
      var w = weightFn.apply(edge, [edge]);

      // Update matrix
      matrix[t][s] += w;

      // Update column sum
      columnSum[s] += w;
    }

    // Add additional probability based on damping factor
    // Also, take into account columns that have sum = 0
    var p = 1.0 / numNodes + additionalProb; // Shorthand
    // Traverse matrix, column by column
    for (var j = 0; j < numNodes; j++) {
      if (columnSum[j] === 0) {
        // No 'links' out from node jth, assume equal probability for each possible node
        for (var i = 0; i < numNodes; i++) {
          matrix[i][j] = p;
        }
      } else {
        // Node jth has outgoing link, compute normalized probabilities
        for (var i = 0; i < numNodes; i++) {
          matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
        }
      }
    }

    // Compute dominant eigenvector using power method
    var eigenvector = [];
    var nullVector = [];
    var previous;

    // Start with a vector of all 1's
    // Also, initialize a null vector which will be used as shorthand
    for (var i = 0; i < numNodes; i++) {
      eigenvector.push(1.0);
      nullVector.push(0.0);
    }

    for (var iter = 0; iter < numIter; iter++) {
      // New array with all 0's
      var temp = nullVector.slice(0);

      // Multiply matrix with previous result
      for (var i = 0; i < numNodes; i++) {
        for (var j = 0; j < numNodes; j++) {
          temp[i] += matrix[i][j] * eigenvector[j];
        }
      }

      normalizeVector(temp);
      previous = eigenvector;
      eigenvector = temp;

      var diff = 0;
      // Compute difference (squared module) of both vectors
      for (var i = 0; i < numNodes; i++) {
        diff += Math.pow(previous[i] - eigenvector[i], 2);
      }

      // If difference is less than the desired threshold, stop iterating
      if (diff < epsilon) {
        break;
      }
    }

    // Construct result
    var res = {
      rank : function(node) {
        if (is.string(node)) {
          // is a selector string
          var nodeId = (cy.filter(node)[0]).id();
        } else {
          // is a node object
          var nodeId = node.id();
        }
        return eigenvector[id2position[nodeId]];
      }
    };


    return res;
  } // pageRank

}); // elesfn

module.exports = elesfn;

},{"../../is":77}],12:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');

var elesfn = ({
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop()
});

module.exports = elesfn;

},{"../define":41}],13:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');

var elesfn = ({
  classes: function( classes ){
    classes = classes.match(/\S+/g) || [];
    var self = this;
    var changed = [];
    var classesMap = {};

    // fill in classes map
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[i];

      classesMap[ cls ] = true;
    }

    // check and update each ele
    for( var j = 0; j < self.length; j++ ){
      var ele = self[j];
      var _p = ele._private;
      var eleClasses = _p.classes;
      var changedEle = false;

      // check if ele has all of the passed classes
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[i];
        var eleHasClass = eleClasses[ cls ];

        if( !eleHasClass ){
          changedEle = true;
          break;
        }
      }

      // check if ele has classes outside of those passed
      if( !changedEle ){ for( var eleCls in eleClasses ){
        var eleHasClass = eleClasses[ eleCls ];
        var specdClass = classesMap[ eleCls ]; // i.e. this class is passed to the function

        if( eleHasClass && !specdClass ){
          changedEle = true;
          break;
        }
      } }

      if( changedEle ){
        _p.classes = util.copy( classesMap );

        changed.push( ele );
      }
    }

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn(changed)
        .updateStyle()
        .trigger('class')
      ;
    }

    return self;
  },

  addClass: function( classes ){
    return this.toggleClass( classes, true );
  },

  hasClass: function( className ){
    var ele = this[0];
    return ( ele != null && ele._private.classes[className] ) ? true : false;
  },

  toggleClass: function( classesStr, toggle ){
    var classes = classesStr.match(/\S+/g) || [];
    var self = this;
    var changed = []; // eles who had classes changed

    for( var i = 0, il = self.length; i < il; i++ ){
      var ele = self[i];
      var changedEle = false;

      for( var j = 0; j < classes.length; j++ ){
        var cls = classes[j];
        var eleClasses = ele._private.classes;
        var hasClass = eleClasses[cls];
        var shouldAdd = toggle || (toggle === undefined && !hasClass);

        if( shouldAdd ){
          eleClasses[cls] = true;

          if( !hasClass && !changedEle ){
            changed.push(ele);
            changedEle = true;
          }
        } else { // then remove
          eleClasses[cls] = false;

          if( hasClass && !changedEle ){
            changed.push(ele);
            changedEle = true;
          }
        }

      } // for j classes
    } // for i eles

    // trigger update style on those eles that had class changes
    if( changed.length > 0 ){
      this.spawn(changed)
        .updateStyle()
        .trigger('class')
      ;
    }

    return self;
  },

  removeClass: function( classes ){
    return this.toggleClass( classes, false );
  },

  flashClass: function( classes, duration ){
    var self = this;

    if( duration == null ){
      duration = 250;
    } else if( duration === 0 ){
      return self; // nothing to do really
    }

    self.addClass( classes );
    setTimeout(function(){
      self.removeClass( classes );
    }, duration);

    return self;
  }
});

module.exports = elesfn;

},{"../util":94}],14:[function(_dereq_,module,exports){
'use strict';

var elesfn = ({
  allAre: function( selector ){
    return this.filter(selector).length === this.length;
  },

  is: function( selector ){
    return this.filter(selector).length > 0;
  },

  some: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

      if( ret ){
        return true;
      }
    }

    return false;
  },

  every: function( fn, thisArg ){
    for( var i = 0; i < this.length; i++ ){
      var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

      if( !ret ){
        return false;
      }
    }

    return true;
  },

  same: function( collection ){
    collection = this.cy().collection( collection );

    // cheap extra check
    if( this.length !== collection.length ){
      return false;
    }

    return this.intersect( collection ).length === this.length;
  },

  anySame: function( collection ){
    collection = this.cy().collection( collection );

    return this.intersect( collection ).length > 0;
  },

  allAreNeighbors: function( collection ){
    collection = this.cy().collection( collection );

    return this.neighborhood().intersect( collection ).length === collection.length;
  }
});

elesfn.allAreNeighbours = elesfn.allAreNeighbors;

module.exports = elesfn;

},{}],15:[function(_dereq_,module,exports){
'use strict';

var elesfn = ({
  parent: function( selector ){
    var parents = [];
    var cy = this._private.cy;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var parent = cy.getElementById( ele._private.data.parent );

      if( parent.size() > 0 ){
        parents.push( parent );
      }
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  parents: function( selector ){
    var parents = [];

    var eles = this.parent();
    while( eles.nonempty() ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        parents.push( ele );
      }

      eles = eles.parent();
    }

    return this.spawn( parents, { unique: true } ).filter( selector );
  },

  commonAncestors: function( selector ){
    var ancestors;

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var parents = ele.parents();

      ancestors = ancestors || parents;

      ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
    }

    return ancestors.filter( selector );
  },

  orphans: function( selector ){
    return this.stdFilter(function( ele ){
      return ele.isNode() && ele.parent().empty();
    }).filter( selector );
  },

  nonorphans: function( selector ){
    return this.stdFilter(function( ele ){
      return ele.isNode() && ele.parent().nonempty();
    }).filter( selector );
  },

  children: function( selector ){
    var children = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      children = children.concat( ele._private.children );
    }

    return this.spawn( children, { unique: true } ).filter( selector );
  },

  siblings: function( selector ){
    return this.parent().children().not( this ).filter( selector );
  },

  isParent: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.children.length !== 0;
    }
  },

  isChild: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.parent !== undefined && ele.parent().length !== 0;
    }
  },

  descendants: function( selector ){
    var elements = [];

    function add( eles ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        elements.push( ele );

        if( ele.children().nonempty() ){
          add( ele.children() );
        }
      }
    }

    add( this.children() );

    return this.spawn( elements, { unique: true } ).filter( selector );
  }
});

// aliases
elesfn.ancestors = elesfn.parents;

module.exports = elesfn;

},{}],16:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');
var fn, elesfn;

fn = elesfn = ({

  data: define.data({
    field: 'data',
    bindingEvent: 'data',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'data',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),

  removeData: define.removeData({
    field: 'data',
    event: 'data',
    triggerFnName: 'trigger',
    triggerEvent: true,
    immutableKeys: {
      'id': true,
      'source': true,
      'target': true,
      'parent': true
    },
    updateStyle: true
  }),

  scratch: define.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true,
    updateStyle: true
  }),

  removeScratch: define.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true,
    updateStyle: true
  }),

  rscratch: define.data({
    field: 'rscratch',
    allowBinding: false,
    allowSetting: true,
    settingTriggersEvent: false,
    allowGetting: true
  }),

  removeRscratch: define.removeData({
    field: 'rscratch',
    triggerEvent: false
  }),

  id: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.data.id;
    }
  }

});

// aliases
fn.attr = fn.data;
fn.removeAttr = fn.removeData;

module.exports = elesfn;

},{"../define":41}],17:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');

var elesfn = {};

function defineDegreeFunction(callback){
  return function( includeLoops ){
    var self = this;

    if( includeLoops === undefined ){
      includeLoops = true;
    }

    if( self.length === 0 ){ return; }

    if( self.isNode() && !self.removed() ){
      var degree = 0;
      var node = self[0];
      var connectedEdges = node._private.edges;

      for( var i = 0; i < connectedEdges.length; i++ ){
        var edge = connectedEdges[i];

        if( !includeLoops && edge.isLoop() ){
          continue;
        }

        degree += callback( node, edge );
      }

      return degree;
    } else {
      return;
    }
  };
}

util.extend(elesfn, {
  degree: defineDegreeFunction(function(node, edge){
    if( edge.source().same( edge.target() ) ){
      return 2;
    } else {
      return 1;
    }
  }),

  indegree: defineDegreeFunction(function(node, edge){
    if( edge.target().same(node) ){
      return 1;
    } else {
      return 0;
    }
  }),

  outdegree: defineDegreeFunction(function(node, edge){
    if( edge.source().same(node) ){
      return 1;
    } else {
      return 0;
    }
  })
});

function defineDegreeBoundsFunction(degreeFn, callback){
  return function( includeLoops ){
    var ret;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[i];
      var degree = ele[degreeFn]( includeLoops );
      if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){
        ret = degree;
      }
    }

    return ret;
  };
}

util.extend(elesfn, {
  minDegree: defineDegreeBoundsFunction('degree', function(degree, min){
    return degree < min;
  }),

  maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){
    return degree > max;
  }),

  minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){
    return degree < min;
  }),

  maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){
    return degree > max;
  }),

  minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){
    return degree < min;
  }),

  maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){
    return degree > max;
  })
});

util.extend(elesfn, {
  totalDegree: function( includeLoops ){
    var total = 0;
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){
      total += nodes[i].degree( includeLoops );
    }

    return total;
  }
});

module.exports = elesfn;

},{"../util":94}],18:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');
var is = _dereq_('../is');
var util = _dereq_('../util');
var fn, elesfn;

fn = elesfn = ({

  position: define.data({
    field: 'position',
    bindingEvent: 'position',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: true,
    triggerFnName: 'rtrigger',
    allowGetting: true,
    validKeys: ['x', 'y'],
    onSet: function( eles ){
      var updatedEles = eles.updateCompoundBounds();
      updatedEles.rtrigger('position');
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  }),

  // position but no notification to renderer
  silentPosition: define.data({
    field: 'position',
    bindingEvent: 'position',
    allowBinding: false,
    allowSetting: true,
    settingEvent: 'position',
    settingTriggersEvent: false,
    triggerFnName: 'trigger',
    allowGetting: true,
    validKeys: ['x', 'y'],
    onSet: function( eles ){
      eles.updateCompoundBounds();
    },
    canSet: function( ele ){
      return !ele.locked() && !ele.isParent();
    }
  }),

  positions: function( pos, silent ){
    if( is.plainObject(pos) ){
      this.position(pos);

    } else if( is.fn(pos) ){
      var fn = pos;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];

        var pos = fn.apply(ele, [i, ele]);

        if( pos && !ele.locked() && !ele.isParent() ){
          var elePos = ele._private.position;
          elePos.x = pos.x;
          elePos.y = pos.y;
        }
      }

      var updatedEles = this.updateCompoundBounds();
      var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

      if( silent ){
        toTrigger.trigger('position');
      } else {
        toTrigger.rtrigger('position');
      }
    }

    return this; // chaining
  },

  silentPositions: function( pos ){
    return this.positions( pos, true );
  },

  // get/set the rendered (i.e. on screen) positon of the element
  renderedPosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();
    var rpos = is.plainObject( dim ) ? dim : undefined;
    var setting = rpos !== undefined || ( val !== undefined && is.string(dim) );

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( val !== undefined ){ // set one dimension
            ele._private.position[dim] = ( val - pan[dim] )/zoom;
          } else if( rpos !== undefined ){ // set whole position
            ele._private.position = {
              x: ( rpos.x - pan.x ) /zoom,
              y: ( rpos.y - pan.y ) /zoom
            };
          }
        }

        this.rtrigger('position');
      } else { // getting
        var pos = ele._private.position;
        rpos = {
          x: pos.x * zoom + pan.x,
          y: pos.y * zoom + pan.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return rpos;
        } else { // then return the specified dimension
          return rpos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  // get/set the position relative to the parent
  relativePosition: function( dim, val ){
    var ele = this[0];
    var cy = this.cy();
    var ppos = is.plainObject( dim ) ? dim : undefined;
    var setting = ppos !== undefined || ( val !== undefined && is.string(dim) );
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele && ele.isNode() ){ // must have an element and must be a node to return position
      if( setting ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          if( val !== undefined ){ // set one dimension
            ele._private.position[dim] = val + origin[dim];
          } else if( ppos !== undefined ){ // set whole position
            ele._private.position = {
              x: ppos.x + origin.x,
              y: ppos.y + origin.y
            };
          }
        }

        this.rtrigger('position');

      } else { // getting
        var pos = ele._private.position;
        var parent = hasCompoundNodes ? ele.parent() : null;
        var hasParent = parent && parent.length > 0;
        var relativeToParent = hasParent;

        if( hasParent ){
          parent = parent[0];
        }

        var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

        ppos = {
          x: pos.x - origin.x,
          y: pos.y - origin.y
        };

        if( dim === undefined ){ // then return the whole rendered position
          return ppos;
        } else { // then return the specified dimension
          return ppos[ dim ];
        }
      }
    } else if( !setting ){
      return undefined; // for empty collection case
    }

    return this; // chaining
  },

  renderedBoundingBox: function( options ){
    var bb = this.boundingBox( options );
    var cy = this.cy();
    var zoom = cy.zoom();
    var pan = cy.pan();

    var x1 = bb.x1 * zoom + pan.x;
    var x2 = bb.x2 * zoom + pan.x;
    var y1 = bb.y1 * zoom + pan.y;
    var y2 = bb.y2 * zoom + pan.y;

    return {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2,
      w: x2 - x1,
      h: y2 - y1
    };
  },

  updateCompoundBounds: function(){
    var cy = this.cy();

    if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled

    var updated = [];

    function update( parent ){
      var children = parent.children();
      var style = parent._private.style;
      var includeLabels = style['compound-sizing-wrt-labels'].value === 'include';
      var bb = children.boundingBox({ includeLabels: includeLabels, includeEdges: true });
      var padding = {
        top: style['padding-top'].pfValue,
        bottom: style['padding-bottom'].pfValue,
        left: style['padding-left'].pfValue,
        right: style['padding-right'].pfValue
      };
      var pos = parent._private.position;
      var didUpdate = false;

      if( style['width'].value === 'auto' ){
        parent._private.autoWidth = bb.w;
        pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;
        didUpdate = true;
      }

      if( style['height'].value === 'auto' ){
        parent._private.autoHeight = bb.h;
        pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;
        didUpdate = true;
      }

      if( didUpdate ){
        updated.push( parent );
      }
    }

    // go up, level by level
    var eles = this.parent();
    while( eles.nonempty() ){

      // update each parent node in this level
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        update( ele );
      }

      // next level
      eles = eles.parent();
    }

    // return changed
    return this.spawn( updated );
  },

  // get the bounding box of the elements (in raw model position)
  boundingBox: function( options ){
    var eles = this;
    var cy = eles._private.cy;
    var cy_p = cy._private;
    var styleEnabled = cy_p.styleEnabled;

    options = options || util.staticEmptyObject();

    var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;
    var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;
    var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;

    // recalculate projections etc
    if( styleEnabled ){
      cy_p.renderer.recalculateRenderedStyle( this );
    }

    var x1 = Infinity;
    var x2 = -Infinity;
    var y1 = Infinity;
    var y2 = -Infinity;

    // find bounds of elements
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var style = _p.style;
      var display = styleEnabled ? _p.style['display'].value : 'element';
      var isNode = _p.group === 'nodes';
      var ex1, ex2, ey1, ey2, x, y;
      var includedEle = false;

      if( display === 'none' ){ continue; } // then ele doesn't take up space

      if( isNode && includeNodes ){
        includedEle = true;

        var pos = _p.position;
        x = pos.x;
        y = pos.y;
        var w = ele.outerWidth();
        var halfW = w/2;
        var h = ele.outerHeight();
        var halfH = h/2;

        // handle node dimensions
        /////////////////////////

        ex1 = x - halfW;
        ex2 = x + halfW;
        ey1 = y - halfH;
        ey2 = y + halfH;

        x1 = ex1 < x1 ? ex1 : x1;
        x2 = ex2 > x2 ? ex2 : x2;
        y1 = ey1 < y1 ? ey1 : y1;
        y2 = ey2 > y2 ? ey2 : y2;

      } else if( ele.isEdge() && includeEdges ){
        includedEle = true;

        var n1 = _p.source;
        var n1_p = n1._private;
        var n1pos = n1_p.position;

        var n2 = _p.target;
        var n2_p = n2._private;
        var n2pos = n2_p.position;


        // handle edge dimensions (rough box estimate)
        //////////////////////////////////////////////

        var rstyle = _p.rstyle || {};
        var w = 0;
        var wHalf = 0;

        if( styleEnabled ){
          w = style['width'].pfValue;
          wHalf = w/2;
        }

        ex1 = n1pos.x;
        ex2 = n2pos.x;
        ey1 = n1pos.y;
        ey2 = n2pos.y;

        if( ex1 > ex2 ){
          var temp = ex1;
          ex1 = ex2;
          ex2 = temp;
        }

        if( ey1 > ey2 ){
          var temp = ey1;
          ey1 = ey2;
          ey2 = temp;
        }

        // take into account edge width
        ex1 -= wHalf;
        ex2 += wHalf;
        ey1 -= wHalf;
        ey2 += wHalf;

        x1 = ex1 < x1 ? ex1 : x1;
        x2 = ex2 > x2 ? ex2 : x2;
        y1 = ey1 < y1 ? ey1 : y1;
        y2 = ey2 > y2 ? ey2 : y2;

        // handle points along edge (sanity check)
        //////////////////////////////////////////

        if( styleEnabled ){
          var pts = rstyle.bezierPts || rstyle.linePts || [];

          for( var j = 0; j < pts.length; j++ ){
            var pt = pts[j];

            ex1 = pt.x - wHalf;
            ex2 = pt.x + wHalf;
            ey1 = pt.y - wHalf;
            ey2 = pt.y + wHalf;

            x1 = ex1 < x1 ? ex1 : x1;
            x2 = ex2 > x2 ? ex2 : x2;
            y1 = ey1 < y1 ? ey1 : y1;
            y2 = ey2 > y2 ? ey2 : y2;
          }
        }

        // precise haystacks (sanity check)
        ///////////////////////////////////

        if( styleEnabled && style['curve-style'].strValue === 'haystack' ){
          var hpts = rstyle.haystackPts;

          ex1 = hpts[0].x;
          ey1 = hpts[0].y;
          ex2 = hpts[1].x;
          ey2 = hpts[1].y;

          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;
        }

      } // edges


      // handle label dimensions
      //////////////////////////

      if( styleEnabled ){

        var _p = ele._private;
        var style = _p.style;
        var rstyle = _p.rstyle;
        var label = style['label'].strValue;
        var fontSize = style['font-size'];
        var halign = style['text-halign'];
        var valign = style['text-valign'];
        var labelWidth = rstyle.labelWidth;
        var labelHeight = rstyle.labelHeight;
        var labelX = rstyle.labelX;
        var labelY = rstyle.labelY;
        var isEdge = ele.isEdge();
        var autorotate = style['edge-text-rotation'].strValue === 'autorotate';

        if( includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){
          var lh = labelHeight;
          var lw = labelWidth;
          var lx1, lx2, ly1, ly2;

          if( isEdge ){
            lx1 = labelX - lw/2;
            lx2 = labelX + lw/2;
            ly1 = labelY - lh/2;
            ly2 = labelY + lh/2;

            if( autorotate ){
              var theta = _p.rscratch.labelAngle;
              var cos = Math.cos( theta );
              var sin = Math.sin( theta );

              var rotate = function( x, y ){
                x = x - labelX;
                y = y - labelY;

                return {
                  x: x*cos - y*sin + labelX,
                  y: x*sin + y*cos + labelY
                };
              };

              var px1y1 = rotate( lx1, ly1 );
              var px1y2 = rotate( lx1, ly2 );
              var px2y1 = rotate( lx2, ly1 );
              var px2y2 = rotate( lx2, ly2 );

              lx1 = Math.min( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
              lx2 = Math.max( px1y1.x, px1y2.x, px2y1.x, px2y2.x );
              ly1 = Math.min( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
              ly2 = Math.max( px1y1.y, px1y2.y, px2y1.y, px2y2.y );
            }
          } else {
            switch( halign.value ){
              case 'left':
                lx1 = labelX - lw;
                lx2 = labelX;
                break;

              case 'center':
                lx1 = labelX - lw/2;
                lx2 = labelX + lw/2;
                break;

              case 'right':
                lx1 = labelX;
                lx2 = labelX + lw;
                break;
            }

            switch( valign.value ){
              case 'top':
                ly1 = labelY - lh;
                ly2 = labelY;
                break;

              case 'center':
                ly1 = labelY - lh/2;
                ly2 = labelY + lh/2;
                break;

              case 'bottom':
                ly1 = labelY;
                ly2 = labelY + lh;
                break;
            }
          }

          x1 = lx1 < x1 ? lx1 : x1;
          x2 = lx2 > x2 ? lx2 : x2;
          y1 = ly1 < y1 ? ly1 : y1;
          y2 = ly2 > y2 ? ly2 : y2;
        }
      } // style enabled for labels
    } // for

    var noninf = function(x){
      if( x === Infinity || x === -Infinity ){
        return 0;
      }

      return x;
    };

    x1 = noninf(x1);
    x2 = noninf(x2);
    y1 = noninf(y1);
    y2 = noninf(y2);

    return {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2,
      w: x2 - x1,
      h: y2 - y1
    };
  }
});

var defineDimFns = function( opts ){
  opts.uppercaseName = util.capitalize( opts.name );
  opts.autoName = 'auto' + opts.uppercaseName;
  opts.labelName = 'label' + opts.uppercaseName;
  opts.outerName = 'outer' + opts.uppercaseName;
  opts.uppercaseOuterName = util.capitalize( opts.outerName );

  fn[ opts.name ] = function dimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        var d = _p.style[ opts.name ];

        switch( d.strValue ){
          case 'auto':
            return _p[ opts.autoName ] || 0;
          case 'label':
            return _p.rstyle[ opts.labelName ] || 0;
          default:
            return d.pfValue;
        }
      } else {
        return 1;
      }
    }
  };

  fn[ 'outer' + opts.uppercaseName ] = function outerDimImpl(){
    var ele = this[0];
    var _p = ele._private;
    var cy = _p.cy;
    var styleEnabled = cy._private.styleEnabled;

    if( ele ){
      if( styleEnabled ){
        var style = _p.style;
        var dim = ele[ opts.name ]();
        var border = style['border-width'].pfValue;
        var padding = style[ opts.paddings[0] ].pfValue + style[ opts.paddings[1] ].pfValue;

        return dim + border + padding;
      } else {
        return 1;
      }
    }
  };

  fn[ 'rendered' + opts.uppercaseName ] = function renderedDimImpl(){
    var ele = this[0];

    if( ele ){
      var d = ele[ opts.name ]();
      return d * this.cy().zoom();
    }
  };

  fn[ 'rendered' + opts.uppercaseOuterName ] = function renderedOuterDimImpl(){
    var ele = this[0];

    if( ele ){
      var od = ele[ opts.outerName ]();
      return od * this.cy().zoom();
    }
  };
};

defineDimFns({
  name: 'width',
  paddings: ['padding-left', 'padding-right']
});

defineDimFns({
  name: 'height',
  paddings: ['padding-top', 'padding-bottom']
});

// aliases
fn.modelPosition = fn.point = fn.position;
fn.modelPositions = fn.points = fn.positions;
fn.renderedPoint = fn.renderedPosition;
fn.relativePoint = fn.relativePosition;
fn.boundingbox = fn.boundingBox;
fn.renderedBoundingbox = fn.renderedBoundingBox;

module.exports = elesfn;

},{"../define":41,"../is":77,"../util":94}],19:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

// represents a node or an edge
var Element = function(cy, params, restore){
  if( !(this instanceof Element) ){
    return new Element(cy, params, restore);
  }

  var self = this;
  restore = (restore === undefined || restore ? true : false);

  if( cy === undefined || params === undefined || !is.core(cy) ){
    util.error('An element must have a core reference and parameters set');
    return;
  }

  var group = params.group;

  // try to automatically infer the group if unspecified
  if( group == null ){
    if( params.data.source != null && params.data.target != null ){
      group = 'edges';
    } else {
      group = 'nodes';
    }
  }

  // validate group
  if( group !== 'nodes' && group !== 'edges' ){
    util.error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');
    return;
  }

  // make the element array-like, just like a collection
  this.length = 1;
  this[0] = this;

  // NOTE: when something is added here, add also to ele.json()
  this._private = {
    cy: cy,
    single: true, // indicates this is an element
    data: params.data || {}, // data object
    position: params.position || {}, // (x, y) position pair
    autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
    autoHeight: undefined,
    listeners: [], // array of bound listeners
    group: group, // string; 'nodes' or 'edges'
    style: {}, // properties as set by the style
    rstyle: {}, // properties for style sent from the renderer to the core
    styleCxts: [], // applied style contexts from the styler
    removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
    selected: params.selected ? true : false, // whether it's selected
    selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
    locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
    grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
    grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
    active: false, // whether the element is active from user interaction
    classes: {}, // map ( className => true )
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    rscratch: {}, // object in which the renderer can store information
    scratch: params.scratch || {}, // scratch objects
    edges: [], // array of connected edges
    children: [] // array of children
  };

  // renderedPosition overrides if specified
  if( params.renderedPosition ){
    var rpos = params.renderedPosition;
    var pan = cy.pan();
    var zoom = cy.zoom();

    this._private.position = {
      x: (rpos.x - pan.x)/zoom,
      y: (rpos.y - pan.y)/zoom
    };
  }

  if( is.string(params.classes) ){
    var classes = params.classes.split(/\s+/);
    for( var i = 0, l = classes.length; i < l; i++ ){
      var cls = classes[i];
      if( !cls || cls === '' ){ continue; }

      self._private.classes[cls] = true;
    }
  }

  if( params.style || params.css ){
    cy.style().applyBypass( this, params.style || params.css );
  }

  if( restore === undefined || restore ){
    this.restore();
  }

};

module.exports = Element;

},{"../is":77,"../util":94}],20:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');

var elesfn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on({ unbindSelfOnTrigger: true }),
  once: define.on({ unbindAllBindersOnTrigger: true }),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger(), // .trigger( events [, extraParams] )

  rtrigger: function(event, extraParams){ // for internal use only
    if( this.length === 0 ){ return; } // empty collections don't need to notify anything

    // notify renderer
    this.cy().notify({
      type: event,
      collection: this
    });

    this.trigger(event, extraParams);
    return this;
  }
});

// aliases:
define.eventAliasesOn( elesfn );

module.exports = elesfn;

},{"../define":41}],21:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var Selector = _dereq_('../selector');

var elesfn = ({
  nodes: function( selector ){
    return this.filter(function(i, element){
      return element.isNode();
    }).filter(selector);
  },

  edges: function( selector ){
    return this.filter(function(i, element){
      return element.isEdge();
    }).filter(selector);
  },

  filter: function( filter ){
    if( is.fn(filter) ){
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];

        if( filter.apply(ele, [i, ele]) ){
          elements.push(ele);
        }
      }

      return this.spawn(elements);

    } else if( is.string(filter) || is.elementOrCollection(filter) ){
      return Selector(filter).filter(this);

    } else if( filter === undefined ){
      return this;
    }

    return this.spawn(); // if not handled by above, give 'em an empty collection
  },

  not: function( toRemove ){
    if( !toRemove ){
      return this;
    } else {

      if( is.string( toRemove ) ){
        toRemove = this.filter( toRemove );
      }

      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        var element = this[i];

        var remove = toRemove._private.ids[ element.id() ];
        if( !remove ){
          elements.push( element );
        }
      }

      return this.spawn( elements );
    }

  },

  absoluteComplement: function(){
    var cy = this._private.cy;

    return cy.elements().not( this );
  },

  intersect: function( other ){
    // if a selector is specified, then filter by it instead
    if( is.string(other) ){
      var selector = other;
      return this.filter( selector );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;
    var col1Smaller = this.length < other.length;
    // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
    var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
    var col = col1Smaller ? col1 : col2;

    for( var i = 0; i < col.length; i++ ){
      var id = col[i]._private.data.id;
      var ele = ids2[ id ];

      if( ele ){
        elements.push( ele );
      }
    }

    return this.spawn( elements );
  },

  xor: function( other ){
    var cy = this._private.cy;

    if( is.string(other) ){
      other = cy.$( other );
    }

    var elements = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other._private.ids[ id ];

        if( !inOther ){
          elements.push( ele );
        }
      }

    };

    add( col1, col2 );
    add( col2, col1 );

    return this.spawn( elements );
  },

  diff: function( other ){
    var cy = this._private.cy;

    if( is.string(other) ){
      other = cy.$( other );
    }

    var left = [];
    var right = [];
    var both = [];
    var col1 = this;
    var col2 = other;

    var add = function( col, other, retEles ){

      for( var i = 0; i < col.length; i++ ){
        var ele = col[i];
        var id = ele._private.data.id;
        var inOther = other._private.ids[ id ];

        if( inOther ){
          both.push( ele );
        } else {
          retEles.push( ele );
        }
      }

    };

    add( col1, col2, left );
    add( col2, col1, right );

    return {
      left: this.spawn( left, { unique: true } ),
      right: this.spawn( right, { unique: true } ),
      both: this.spawn( both, { unique: true } )
    };
  },

  add: function( toAdd ){
    var cy = this._private.cy;

    if( !toAdd ){
      return this;
    }

    if( is.string(toAdd) ){
      var selector = toAdd;
      toAdd = cy.elements(selector);
    }

    var elements = [];

    for( var i = 0; i < this.length; i++ ){
      elements.push( this[i] );
    }

    for( var i = 0; i < toAdd.length; i++ ){

      var add = !this._private.ids[ toAdd[i].id() ];
      if( add ){
        elements.push( toAdd[i] );
      }
    }

    return this.spawn(elements);
  },

  // in place merge on calling collection
  merge: function( toAdd ){
    var _p = this._private;
    var cy = _p.cy;

    if( !toAdd ){
      return this;
    }

    if( is.string(toAdd) ){
      var selector = toAdd;
      toAdd = cy.elements(selector);
    }

    for( var i = 0; i < toAdd.length; i++ ){
      var toAddEle = toAdd[i];
      var id = toAddEle.id();
      var add = !_p.ids[ id ];

      if( add ){
        var index = this.length++;

        this[ index ] = toAddEle;
        _p.ids[ id ] = toAddEle;
        _p.indexes[ id ] = index;
      }
    }

    return this; // chaining
  },

  // remove single ele in place in calling collection
  unmergeOne: function( ele ){
    ele = ele[0];

    var _p = this._private;
    var id = ele.id();
    var i = _p.indexes[ id ];

    if( i == null ){
      return this; // no need to remove
    }

    // remove ele
    this[i] = undefined;
    _p.ids[ id ] = undefined;
    _p.indexes[ id ] = undefined;

    var unmergedLastEle = i === this.length - 1;

    // replace empty spot with last ele in collection
    if( this.length > 1 && !unmergedLastEle ){
      var lastEleI = this.length - 1;
      var lastEle = this[ lastEleI ];

      this[ lastEleI ] = undefined;
      this[i] = lastEle;
      _p.indexes[ lastEle.id() ] = i;
    }

    // the collection is now 1 ele smaller
    this.length--;

    return this;
  },

  // remove eles in place on calling collection
  unmerge: function( toRemove ){
    var cy = this._private.cy;

    if( !toRemove ){
      return this;
    }

    if( is.string(toRemove) ){
      var selector = toRemove;
      toRemove = cy.elements(selector);
    }

    for( var i = 0; i < toRemove.length; i++ ){
      this.unmergeOne( toRemove[i] );
    }

    return this; // chaining
  },

  map: function( mapFn, thisArg ){
    var arr = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var ret = thisArg ? mapFn.apply( thisArg, [ele, i, eles] ) : mapFn( ele, i, eles );

      arr.push( ret );
    }

    return arr;
  },

  stdFilter: function( fn, thisArg ){
    var filterEles = [];
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var include = thisArg ? fn.apply( thisArg, [ele, i, eles] ) : fn( ele, i, eles );

      if( include ){
        filterEles.push( ele );
      }
    }

    return this.spawn( filterEles );
  },

  max: function( valFn, thisArg ){
    var max = -Infinity;
    var maxEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val > max ){
        max = val;
        maxEle = ele;
      }
    }

    return {
      value: max,
      ele: maxEle
    };
  },

  min: function( valFn, thisArg ){
    var min = Infinity;
    var minEle;
    var eles = this;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

      if( val < min ){
        min = val;
        minEle = ele;
      }
    }

    return {
      value: min,
      ele: minEle
    };
  }
});

// aliases
var fn = elesfn;
fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.subtract = fn.not;
fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
fn.fnFilter = fn.filterFn = fn.stdFilter;
fn.complement = fn.abscomp = fn.absoluteComplement;

module.exports = elesfn;

},{"../is":77,"../selector":81}],22:[function(_dereq_,module,exports){
'use strict';

var elesfn = ({
  isNode: function(){
    return this.group() === 'nodes';
  },

  isEdge: function(){
    return this.group() === 'edges';
  },

  isLoop: function(){
    return this.isEdge() && this.source().id() === this.target().id();
  },

  isSimple: function(){
    return this.isEdge() && this.source().id() !== this.target().id();
  },

  group: function(){
    var ele = this[0];

    if( ele ){
      return ele._private.group;
    }
  }
});


module.exports = elesfn;

},{}],23:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var Element = _dereq_('./element');

// factory for generating edge ids when no id is specified for a new element
var idFactory = {
  prefix: 'ele',
  id: 0,
  generate: function(cy, element, tryThisId){
    var json = is.element( element ) ? element._private : element;
    var id = tryThisId != null ? tryThisId : this.prefix + this.id;

    if( cy.getElementById(id).empty() ){
      this.id++; // we've used the current id, so move it up
    } else { // otherwise keep trying successive unused ids
      while( !cy.getElementById(id).empty() ){
        id = this.prefix + ( ++this.id );
      }
    }

    return id;
  }
};

// represents a set of nodes, edges, or both together
var Collection = function(cy, elements, options){
  if( !(this instanceof Collection) ){
    return new Collection(cy, elements, options);
  }

  if( cy === undefined || !is.core(cy) ){
    util.error('A collection must have a reference to the core');
    return;
  }

  var ids = {};
  var indexes = {};
  var createdElements = false;

  if( !elements ){
    elements = [];
  } else if( elements.length > 0 && is.plainObject( elements[0] ) && !is.element( elements[0] ) ){
    createdElements = true;

    // make elements from json and restore all at once later
    var eles = [];
    var elesIds = {};

    for( var i = 0, l = elements.length; i < l; i++ ){
      var json = elements[i];

      if( json.data == null ){
        json.data = {};
      }

      var data = json.data;

      // make sure newly created elements have valid ids
      if( data.id == null ){
        data.id = idFactory.generate( cy, json );
      } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){
        continue; // can't create element if prior id already exists
      }

      var ele = new Element( cy, json, false );
      eles.push( ele );
      elesIds[ data.id ] = true;
    }

    elements = eles;
  }

  this.length = 0;

  for( var i = 0, l = elements.length; i < l; i++ ){
    var element = elements[i];
    if( !element ){  continue; }

    var id = element._private.data.id;

    if( !options || (options.unique && !ids[ id ] ) ){
      ids[ id ] = element;
      indexes[ id ] = this.length;

      this[ this.length ] = element;
      this.length++;
    }
  }

  this._private = {
    cy: cy,
    ids: ids,
    indexes: indexes
  };

  // restore the elements if we created them from json
  if( createdElements ){
    this.restore();
  }
};

// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////

// keep the prototypes in sync (an element has the same functions as a collection)
// and use elefn and elesfn as shorthands to the prototypes
var elesfn = Element.prototype = Collection.prototype;

elesfn.instanceString = function(){
  return 'collection';
};

elesfn.spawn = function( cy, eles, opts ){
  if( !is.core(cy) ){ // cy is optional
    opts = eles;
    eles = cy;
    cy = this.cy();
  }

  return new Collection( cy, eles, opts );
};

elesfn.cy = function(){
  return this._private.cy;
};

elesfn.element = function(){
  return this[0];
};

elesfn.collection = function(){
  if( is.collection(this) ){
    return this;
  } else { // an element
    return new Collection( this._private.cy, [this] );
  }
};

elesfn.unique = function(){
  return new Collection( this._private.cy, this, { unique: true } );
};

elesfn.getElementById = function( id ){
  var cy = this._private.cy;
  var ele = this._private.ids[ id ];

  return ele ? ele : new Collection(cy); // get ele or empty collection
};

elesfn.json = function( obj ){
  var ele = this.element();
  var cy = this.cy();

  if( ele == null && obj ){ return this; } // can't set to no eles

  if( ele == null ){ return undefined; } // can't get from no eles

  var p = ele._private;

  if( is.plainObject(obj) ){ // set

    cy.startBatch();

    if( obj.data ){
      ele.data( obj.data );
    }

    if( obj.position ){
      ele.position( obj.position );
    }

    // ignore group -- immutable

    var checkSwitch = function( k, trueFnName, falseFnName ){
      var obj_k = obj[k];

      if( obj_k != null && obj_k !== p[k] ){
        if( obj_k ){
          ele[ trueFnName ]();
        } else {
          ele[ falseFnName ]();
        }
      }
    };

    checkSwitch( 'removed', 'remove', 'restore' );

    checkSwitch( 'selected', 'select', 'unselect' );

    checkSwitch( 'selectable', 'selectify', 'unselectify' );

    checkSwitch( 'locked', 'lock', 'unlock' );

    checkSwitch( 'grabbable', 'grabify', 'ungrabify' );

    if( obj.classes != null ){
      ele.classes( obj.classes );
    }

    cy.endBatch();

    return this;

  } else if( obj === undefined ){ // get

    var json = {
      data: util.copy( p.data ),
      position: util.copy( p.position ),
      group: p.group,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbable: p.grabbable,
      classes: null
    };

    var classes = [];
    for( var cls in p.classes ){
      if( p.classes[cls] ){
        classes.push(cls);
      }
    }
    json.classes = classes.join(' ');

    return json;
  }
};

elesfn.jsons = function(){
  var jsons = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[i];
    var json = ele.json();

    jsons.push( json );
  }

  return jsons;
};

elesfn.clone = function(){
  var cy = this.cy();
  var elesArr = [];

  for( var i = 0; i < this.length; i++ ){
    var ele = this[i];
    var json = ele.json();
    var clone = new Element(cy, json, false); // NB no restore

    elesArr.push( clone );
  }

  return new Collection( cy, elesArr );
};
elesfn.copy = elesfn.clone;

elesfn.restore = function( notifyRenderer ){
  var self = this;
  var restored = [];
  var cy = self.cy();

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // create arrays of nodes and edges, since we need to
  // restore the nodes first
  var elements = [];
  var nodes = [], edges = [];
  var numNodes = 0;
  var numEdges = 0;
  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[i];

    // keep nodes first in the array and edges after
    if( ele.isNode() ){ // put to front of array if node
      nodes.push( ele );
      numNodes++;
    } else { // put to end of array if edge
      edges.push( ele );
      numEdges++;
    }
  }

  elements = nodes.concat( edges );

  // now, restore each element
  for( var i = 0, l = elements.length; i < l; i++ ){
    var ele = elements[i];

    if( !ele.removed() ){
      // don't need to do anything
      continue;
    }

    var _private = ele._private;
    var data = _private.data;

    // set id and validate
    if( data.id === undefined ){
      data.id = idFactory.generate( cy, ele );

    } else if( is.number(data.id) ){
      data.id = '' + data.id; // now it's a string

    } else if( is.emptyString(data.id) || !is.string(data.id) ){
      util.error('Can not create element with invalid string ID `' + data.id + '`');

      // can't create element if it has empty string as id or non-string id
      continue;
    } else if( cy.getElementById( data.id ).length !== 0 ){
      util.error('Can not create second element with ID `' + data.id + '`');

      // can't create element if one already has that id
      continue;
    }

    var id = data.id; // id is finalised, now let's keep a ref

    if( ele.isNode() ){ // extra checks for nodes
      var node = ele;
      var pos = _private.position;

      // make sure the nodes have a defined position

      if( pos.x == null ){
        pos.x = 0;
      }

      if( pos.y == null ){
        pos.y = 0;
      }
    }

    if( ele.isEdge() ){ // extra checks for edges

      var edge = ele;
      var fields = ['source', 'target'];
      var fieldsLength = fields.length;
      var badSourceOrTarget = false;
      for(var j = 0; j < fieldsLength; j++){

        var field = fields[j];
        var val = data[field];

        if( is.number(val) ){
          val = data[field] = '' + data[field]; // now string
        }

        if( val == null || val === '' ){
          // can't create if source or target is not defined properly
          util.error('Can not create edge `' + id + '` with unspecified ' + field);
          badSourceOrTarget = true;
        } else if( cy.getElementById(val).empty() ){
          // can't create edge if one of its nodes doesn't exist
          util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
          badSourceOrTarget = true;
        }
      }

      if( badSourceOrTarget ){ continue; } // can't create this

      var src = cy.getElementById( data.source );
      var tgt = cy.getElementById( data.target );

      src._private.edges.push( edge );
      tgt._private.edges.push( edge );

      edge._private.source = src;
      edge._private.target = tgt;

    } // if is edge

    // create mock ids map for element so it can be used like collections
    _private.ids = {};
    _private.ids[ id ] = ele;

    _private.removed = false;
    cy.addToPool( ele );

    restored.push( ele );
  } // for each element

  // do compound node sanity checks
  for( var i = 0; i < numNodes; i++ ){ // each node
    var node = elements[i];
    var data = node._private.data;

    if( is.number(data.parent) ){ // then automake string
      data.parent = '' + data.parent;
    }

    var parentId = data.parent;

    var specifiedParent = parentId != null;

    if( specifiedParent ){
      var parent = cy.getElementById( parentId );

      if( parent.empty() ){
        // non-existant parent; just remove it
        data.parent = undefined;
      } else {
        var selfAsParent = false;
        var ancestor = parent;
        while( !ancestor.empty() ){
          if( node.same(ancestor) ){
            // mark self as parent and remove from data
            selfAsParent = true;
            data.parent = undefined; // remove parent reference

            // exit or we loop forever
            break;
          }

          ancestor = ancestor.parent();
        }

        if( !selfAsParent ){
          // connect with children
          parent[0]._private.children.push( node );
          node._private.parent = parent[0];

          // let the core know we have a compound graph
          cy._private.hasCompoundNodes = true;
        }
      } // else
    } // if specified parent
  } // for each node

  restored = new Collection( cy, restored );
  if( restored.length > 0 ){

    var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
    toUpdateStyle.updateStyle( notifyRenderer );

    if( notifyRenderer ){
      restored.rtrigger('add');
    } else {
      restored.trigger('add');
    }
  }

  return self; // chainability
};

elesfn.removed = function(){
  var ele = this[0];
  return ele && ele._private.removed;
};

elesfn.inside = function(){
  var ele = this[0];
  return ele && !ele._private.removed;
};

elesfn.remove = function( notifyRenderer ){
  var self = this;
  var removed = [];
  var elesToRemove = [];
  var elesToRemoveIds = {};
  var cy = self._private.cy;

  if( notifyRenderer === undefined ){
    notifyRenderer = true;
  }

  // add connected edges
  function addConnectedEdges(node){
    var edges = node._private.edges;
    for( var i = 0; i < edges.length; i++ ){
      add( edges[i] );
    }
  }


  // add descendant nodes
  function addChildren(node){
    var children = node._private.children;

    for( var i = 0; i < children.length; i++ ){
      add( children[i] );
    }
  }

  function add( ele ){
    var alreadyAdded =  elesToRemoveIds[ ele.id() ];
    if( alreadyAdded ){
      return;
    } else {
      elesToRemoveIds[ ele.id() ] = true;
    }

    if( ele.isNode() ){
      elesToRemove.push( ele ); // nodes are removed last

      addConnectedEdges( ele );
      addChildren( ele );
    } else {
      elesToRemove.unshift( ele ); // edges are removed first
    }
  }

  // make the list of elements to remove
  // (may be removing more than specified due to connected edges etc)

  for( var i = 0, l = self.length; i < l; i++ ){
    var ele = self[i];

    add( ele );
  }

  function removeEdgeRef(node, edge){
    var connectedEdges = node._private.edges;
    for( var j = 0; j < connectedEdges.length; j++ ){
      var connectedEdge = connectedEdges[j];

      if( edge === connectedEdge ){
        connectedEdges.splice( j, 1 );
        break;
      }
    }
  }

  function removeChildRef(parent, ele){
    ele = ele[0];
    parent = parent[0];
    var children = parent._private.children;

    for( var j = 0; j < children.length; j++ ){
      if( children[j][0] === ele[0] ){
        children.splice(j, 1);
        break;
      }
    }
  }

  for( var i = 0; i < elesToRemove.length; i++ ){
    var ele = elesToRemove[i];

    // mark as removed
    ele._private.removed = true;

    // remove from core pool
    cy.removeFromPool( ele );

    // add to list of removed elements
    removed.push( ele );

    if( ele.isEdge() ){ // remove references to this edge in its connected nodes
      var src = ele.source()[0];
      var tgt = ele.target()[0];

      removeEdgeRef( src, ele );
      removeEdgeRef( tgt, ele );

    } else { // remove reference to parent
      var parent = ele.parent();

      if( parent.length !== 0 ){
        removeChildRef(parent, ele);
      }
    }
  }

  // check to see if we have a compound graph or not
  var elesStillInside = cy._private.elements;
  cy._private.hasCompoundNodes = false;
  for( var i = 0; i < elesStillInside.length; i++ ){
    var ele = elesStillInside[i];

    if( ele.isParent() ){
      cy._private.hasCompoundNodes = true;
      break;
    }
  }

  var removedElements = new Collection( this.cy(), removed );
  if( removedElements.size() > 0 ){
    // must manually notify since trigger won't do this automatically once removed

    if( notifyRenderer ){
      this.cy().notify({
        type: 'remove',
        collection: removedElements
      });
    }

    removedElements.trigger('remove');
  }

  // check for empty remaining parent nodes
  var checkedParentId = {};
  for( var i = 0; i < elesToRemove.length; i++ ){
    var ele = elesToRemove[i];
    var isNode = ele._private.group === 'nodes';
    var parentId = ele._private.data.parent;

    if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){
      checkedParentId[ parentId ] = true;
      var parent = cy.getElementById( parentId );

      if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){
        parent.updateStyle();
      }
    }
  }

  return new Collection( cy, removed );
};

elesfn.move = function( struct ){
  var cy = this._private.cy;

  if( struct.source !== undefined || struct.target !== undefined ){
    var srcId = struct.source;
    var tgtId = struct.target;
    var srcExists = cy.getElementById( srcId ).length > 0;
    var tgtExists = cy.getElementById( tgtId ).length > 0;

    if( srcExists || tgtExists ){
      var jsons = this.jsons();

      this.remove();

      for( var i = 0; i < jsons.length; i++ ){
        var json = jsons[i];

        if( json.group === 'edges' ){
          if( srcExists ){ json.data.source = srcId; }
          if( tgtExists ){ json.data.target = tgtId; }
        }
      }

      return cy.add( jsons );
    }

  } else if( struct.parent !== undefined ){ // move node to new parent
    var parentId = struct.parent;
    var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;

    if( parentExists ){
      var jsons = this.jsons();
      var descs = this.descendants();
      var descsEtc = descs.merge( descs.add(this).connectedEdges() );

      this.remove(); // NB: also removes descendants and their connected edges

      for( var i = 0; i < this.length; i++ ){
        var json = jsons[i];

        if( json.group === 'nodes' ){
          json.data.parent = parentId === null ? undefined : parentId;
        }
      }
    }

    return cy.add( jsons ).merge( descsEtc.restore() );
  }

  return this; // if nothing done
};

[
  _dereq_('./algorithms'),
  _dereq_('./animation'),
  _dereq_('./class'),
  _dereq_('./comparators'),
  _dereq_('./compounds'),
  _dereq_('./data'),
  _dereq_('./degree'),
  _dereq_('./dimensions'),
  _dereq_('./events'),
  _dereq_('./filter'),
  _dereq_('./group'),
  _dereq_('./index'),
  _dereq_('./iteration'),
  _dereq_('./layout'),
  _dereq_('./style'),
  _dereq_('./switch-functions'),
  _dereq_('./traversing')
].forEach(function( props ){
  util.extend( elesfn, props );
});

module.exports = Collection;

},{"../is":77,"../util":94,"./algorithms":9,"./animation":12,"./class":13,"./comparators":14,"./compounds":15,"./data":16,"./degree":17,"./dimensions":18,"./element":19,"./events":20,"./filter":21,"./group":22,"./index":23,"./iteration":24,"./layout":25,"./style":26,"./switch-functions":27,"./traversing":28}],24:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var zIndexSort = _dereq_('./zsort');

var elesfn = ({
  each: function(fn){
    if( is.fn(fn) ){
      for(var i = 0; i < this.length; i++){
        var ele = this[i];
        var ret = fn.apply( ele, [ i, ele ] );

        if( ret === false ){ break; } // exit each early on return false
      }
    }
    return this;
  },

  forEach: function(fn, thisArg){
    if( is.fn(fn) ){

      for(var i = 0; i < this.length; i++){
        var ele = this[i];
        var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );

        if( ret === false ){ break; } // exit each early on return false
      }
    }

    return this;
  },

  toArray: function(){
    var array = [];

    for(var i = 0; i < this.length; i++){
      array.push( this[i] );
    }

    return array;
  },

  slice: function(start, end){
    var array = [];
    var thisSize = this.length;

    if( end == null ){
      end = thisSize;
    }

    if( start == null ){
      start = 0;
    }

    if( start < 0 ){
      start = thisSize + start;
    }

    if( end < 0 ){
      end = thisSize + end;
    }

    for(var i = start; i >= 0 && i < end && i < thisSize; i++){
      array.push( this[i] );
    }

    return this.spawn(array);
  },

  size: function(){
    return this.length;
  },

  eq: function(i){
    return this[i] || this.spawn();
  },

  first: function(){
    return this[0] || this.spawn();
  },

  last: function(){
    return this[ this.length - 1 ] || this.spawn();
  },

  empty: function(){
    return this.length === 0;
  },

  nonempty: function(){
    return !this.empty();
  },

  sort: function( sortFn ){
    if( !is.fn( sortFn ) ){
      return this;
    }

    var sorted = this.toArray().sort( sortFn );

    return this.spawn(sorted);
  },

  sortByZIndex: function(){
    return this.sort( zIndexSort );
  },

  zDepth: function(){
    var ele = this[0];
    if( !ele ){ return undefined; }

    // var cy = ele.cy();
    var _p = ele._private;
    var group = _p.group;

    if( group === 'nodes' ){
      var depth = _p.data.parent ? ele.parents().size() : 0;

      if( !ele.isParent() ){
        return Number.MAX_VALUE; // childless nodes always on top
      }

      return depth;
    } else {
      var src = _p.source;
      var tgt = _p.target;
      var srcDepth = src.zDepth();
      var tgtDepth = tgt.zDepth();

      return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
    }
  }
});

module.exports = elesfn;

},{"../is":77,"./zsort":29}],25:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var util = _dereq_('../util');

var elesfn = ({

  // using standard layout options, apply position function (w/ or w/o animation)
  layoutPositions: function( layout, options, fn ){
    var nodes = this.nodes();
    var cy = this.cy();

    layout.trigger({ type: 'layoutstart', layout: layout });

    layout.animations = [];

    if( options.animate ){
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var lastNode = i === nodes.length - 1;

        var newPos = fn.call( node, i, node );
        var pos = node.position();

        if( !is.number(pos.x) || !is.number(pos.y) ){
          node.silentPosition({ x: 0, y: 0 });
        }

        var ani = node.animation({
          position: newPos,
          duration: options.animationDuration,
          easing: options.animationEasing,
          step: !lastNode ? undefined : function(){
            if( options.fit ){
              cy.fit( options.eles, options.padding );
            }
          },
          complete: !lastNode ? undefined : function(){
            if( options.zoom != null ){
              cy.zoom( options.zoom );
            }

            if( options.pan ){
              cy.pan( options.pan );
            }

            if( options.fit ){
              cy.fit( options.eles, options.padding );
            }

            layout.one('layoutstop', options.stop);
            layout.trigger({ type: 'layoutstop', layout: layout });
          }
        });

        layout.animations.push( ani );

        ani.play();
      }

      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: layout });
    } else {
      nodes.positions( fn );

      if( options.fit ){
        cy.fit( options.eles, options.padding );
      }

      if( options.zoom != null ){
        cy.zoom( options.zoom );
      }

      if( options.pan ){
        cy.pan( options.pan );
      }

      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: layout });

      layout.one('layoutstop', options.stop);
      layout.trigger({ type: 'layoutstop', layout: layout });
    }

    return this; // chaining
  },

  layout: function( options ){
    var cy = this.cy();

    cy.layout( util.extend({}, options, {
      eles: this
    }) );

    return this;
  },

  makeLayout: function( options ){
    var cy = this.cy();

    return cy.makeLayout( util.extend({}, options, {
      eles: this
    }) );
  }

});

// aliases:
elesfn.createLayout = elesfn.makeLayout;

module.exports = elesfn;

},{"../is":77,"../util":94}],26:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');

var elesfn = ({

  // fully updates (recalculates) the style for the elements
  updateStyle: function( notifyRenderer ){
    var cy = this._private.cy;

    if( !cy.styleEnabled() ){ return this; }

    if( cy._private.batchingStyle ){
      var bEles = cy._private.batchStyleEles;

      bEles.merge( this );

      return this; // chaining and exit early when batching
    }

    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    style.apply( this );

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

    if( notifyRenderer ){
      toNotify.rtrigger('style'); // let renderer know we changed style
    } else {
      toNotify.trigger('style'); // just fire the event
    }
    return this; // chaining
  },

  // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
  updateMappers: function( notifyRenderer ){
    var cy = this._private.cy;
    var style = cy.style();
    notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

    if( !cy.styleEnabled() ){ return this; }

    style.updateMappers( this );

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

    if( notifyRenderer ){
      toNotify.rtrigger('style'); // let renderer know we changed style
    } else {
      toNotify.trigger('style'); // just fire the event
    }
    return this; // chaining
  },

  // get the specified css property as a rendered value (i.e. on-screen value)
  // or get the whole rendered style if no property specified (NB doesn't allow setting)
  renderedCss: function( property ){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return this; }

    var ele = this[0];

    if( ele ){
      var renstyle = ele.cy().style().getRenderedStyle( ele );

      if( property === undefined ){
        return renstyle;
      } else {
        return renstyle[ property ];
      }
    }
  },

  // read the calculated css style of the element or override the style (via a bypass)
  css: function( name, value ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();

    if( is.plainObject(name) ){ // then extend the bypass
      var props = name;
      style.applyBypass( this, props, updateTransitions );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger('style'); // let the renderer know we've updated style

    } else if( is.string(name) ){

      if( value === undefined ){ // then get the property from the style
        var ele = this[0];

        if( ele ){
          return style.getStylePropertyValue( ele, name );
        } else { // empty collection => can't get any value
          return;
        }

      } else { // then set the bypass with the property value
        style.applyBypass( this, name, value, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger('style'); // let the renderer know we've updated style
      }

    } else if( name === undefined ){
      var ele = this[0];

      if( ele ){
        return style.getRawStyle( ele );
      } else { // empty collection => can't get any value
        return;
      }
    }

    return this; // chaining
  },

  removeCss: function( names ){
    var cy = this.cy();

    if( !cy.styleEnabled() ){ return this; }

    var updateTransitions = false;
    var style = cy.style();
    var eles = this;

    if( names === undefined ){
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        style.removeAllBypasses( ele, updateTransitions );
      }
    } else {
      names = names.split(/\s+/);

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        style.removeBypasses( ele, names, updateTransitions );
      }
    }

    var updatedCompounds = this.updateCompoundBounds();
    var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
    toNotify.rtrigger('style'); // let the renderer know we've updated style

    return this; // chaining
  },

  show: function(){
    this.css('display', 'element');
    return this; // chaining
  },

  hide: function(){
    this.css('display', 'none');
    return this; // chaining
  },

  visible: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return true; }

    var ele = this[0];
    var hasCompoundNodes = cy.hasCompoundNodes();

    if( ele ){
      var style = ele._private.style;

      if(
        style['visibility'].value !== 'visible'
        || style['display'].value !== 'element'
      ){
        return false;
      }

      if( ele._private.group === 'nodes' ){
        if( !hasCompoundNodes ){ return true; }

        var parents = ele._private.data.parent ? ele.parents() : null;

        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[i];
            var pStyle = parent._private.style;
            var pVis = pStyle['visibility'].value;
            var pDis = pStyle['display'].value;

            if( pVis !== 'visible' || pDis !== 'element' ){
              return false;
            }
          }
        }

        return true;
      } else {
        var src = ele._private.source;
        var tgt = ele._private.target;

        return src.visible() && tgt.visible();
      }

    }
  },

  hidden: function(){
    var ele = this[0];

    if( ele ){
      return !ele.visible();
    }
  },

  effectiveOpacity: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return 1; }

    var hasCompoundNodes = cy.hasCompoundNodes();
    var ele = this[0];

    if( ele ){
      var _p = ele._private;
      var parentOpacity = _p.style.opacity.value;

      if( !hasCompoundNodes ){ return parentOpacity; }

      var parents = !_p.data.parent ? null : ele.parents();

      if( parents ){
        for( var i = 0; i < parents.length; i++ ){
          var parent = parents[i];
          var opacity = parent._private.style.opacity.value;

          parentOpacity = opacity * parentOpacity;
        }
      }

      return parentOpacity;
    }
  },

  transparent: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];
    var hasCompoundNodes = ele.cy().hasCompoundNodes();

    if( ele ){
      if( !hasCompoundNodes ){
        return ele._private.style.opacity.value === 0;
      } else {
        return ele.effectiveOpacity() === 0;
      }
    }
  },

  isFullAutoParent: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];

    if( ele ){
      var autoW = ele._private.style['width'].value === 'auto';
      var autoH = ele._private.style['height'].value === 'auto';

      return ele.isParent() && autoW && autoH;
    }
  },

  backgrounding: function(){
    var cy = this.cy();
    if( !cy.styleEnabled() ){ return false; }

    var ele = this[0];

    return ele._private.backgrounding ? true : false;
  }

});


elesfn.bypass = elesfn.style = elesfn.css;
elesfn.renderedStyle = elesfn.renderedCss;
elesfn.removeBypass = elesfn.removeStyle = elesfn.removeCss;

module.exports = elesfn;

},{"../is":77}],27:[function(_dereq_,module,exports){
'use strict';

var elesfn = {};

function defineSwitchFunction(params){
  return function(){
    var args = arguments;
    var changedEles = [];

    // e.g. cy.nodes().select( data, handler )
    if( args.length === 2 ){
      var data = args[0];
      var handler = args[1];
      this.bind( params.event, data, handler );
    }

    // e.g. cy.nodes().select( handler )
    else if( args.length === 1 ){
      var handler = args[0];
      this.bind( params.event, handler );
    }

    // e.g. cy.nodes().select()
    else if( args.length === 0 ){
      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var able = !params.ableField || ele._private[params.ableField];
        var changed = ele._private[params.field] != params.value;

        if( params.overrideAble ){
          var overrideAble = params.overrideAble(ele);

          if( overrideAble !== undefined ){
            able = overrideAble;

            if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
          }
        }

        if( able ){
          ele._private[params.field] = params.value;

          if( changed ){
            changedEles.push( ele );
          }
        }
      }

      var changedColl = this.spawn( changedEles );
      changedColl.updateStyle(); // change of state => possible change of style
      changedColl.trigger( params.event );
    }

    return this;
  };
}

function defineSwitchSet( params ){
  elesfn[ params.field ] = function(){
    var ele = this[0];

    if( ele ){
      if( params.overrideField ){
        var val = params.overrideField(ele);

        if( val !== undefined ){
          return val;
        }
      }

      return ele._private[ params.field ];
    }
  };

  elesfn[ params.on ] = defineSwitchFunction({
    event: params.on,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: true
  });

  elesfn[ params.off ] = defineSwitchFunction({
    event: params.off,
    field: params.field,
    ableField: params.ableField,
    overrideAble: params.overrideAble,
    value: false
  });
}

defineSwitchSet({
  field: 'locked',
  overrideField: function(ele){
    return ele.cy().autolock() ? true : undefined;
  },
  on: 'lock',
  off: 'unlock'
});

defineSwitchSet({
  field: 'grabbable',
  overrideField: function(ele){
    return ele.cy().autoungrabify() ? false : undefined;
  },
  on: 'grabify',
  off: 'ungrabify'
});

defineSwitchSet({
  field: 'selected',
  ableField: 'selectable',
  overrideAble: function(ele){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'select',
  off: 'unselect'
});

defineSwitchSet({
  field: 'selectable',
  overrideField: function(ele){
    return ele.cy().autounselectify() ? false : undefined;
  },
  on: 'selectify',
  off: 'unselectify'
});

elesfn.deselect = elesfn.unselect;

elesfn.grabbed = function(){
  var ele = this[0];
  if( ele ){
    return ele._private.grabbed;
  }
};

defineSwitchSet({
  field: 'active',
  on: 'activate',
  off: 'unactivate'
});

elesfn.inactive = function(){
  var ele = this[0];
  if( ele ){
    return !ele._private.active;
  }
};

module.exports = elesfn;

},{}],28:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var elesfn = {};

util.extend(elesfn, {
  // get the root nodes in the DAG
  roots: function( selector ){
    var eles = this;
    var roots = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      if( !ele.isNode() ){
        continue;
      }

      var hasEdgesPointingIn = ele.connectedEdges(function(){
        return this.data('target') === ele.id() && this.data('source') !== ele.id();
      }).length > 0;

      if( !hasEdgesPointingIn ){
        roots.push( ele );
      }
    }

    return this.spawn( roots, { unique: true } ).filter( selector );
  },

  // get the leaf nodes in the DAG
  leaves: function( selector ){
    var eles = this;
    var leaves = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      if( !ele.isNode() ){
        continue;
      }

      var hasEdgesPointingOut = ele.connectedEdges(function(){
        return this.data('source') === ele.id() && this.data('target') !== ele.id();
      }).length > 0;

      if( !hasEdgesPointingOut ){
        leaves.push( ele );
      }
    }

    return this.spawn( leaves, { unique: true } ).filter( selector );
  },

  // normally called children in graph theory
  // these nodes =edges=> outgoing nodes
  outgoers: function( selector ){
    var eles = this;
    var oEles = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var eleId = ele.id();

      if( !ele.isNode() ){ continue; }

      var edges = ele._private.edges;
      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        var srcId = edge._private.data.source;
        var tgtId = edge._private.data.target;

        if( srcId === eleId && tgtId !== eleId ){
          oEles.push( edge );
          oEles.push( edge.target()[0] );
        }
      }
    }

    return this.spawn( oEles, { unique: true } ).filter( selector );
  },

  // aka DAG descendants
  successors: function( selector ){
    var eles = this;
    var sEles = [];
    var sElesIds = {};

    for(;;){
      var outgoers = eles.outgoers();

      if( outgoers.length === 0 ){ break; } // done if no outgoers left

      var newOutgoers = false;
      for( var i = 0; i < outgoers.length; i++ ){
        var outgoer = outgoers[i];
        var outgoerId = outgoer.id();

        if( !sElesIds[ outgoerId ] ){
          sElesIds[ outgoerId ] = true;
          sEles.push( outgoer );
          newOutgoers = true;
        }
      }

      if( !newOutgoers ){ break; } // done if touched all outgoers already

      eles = outgoers;
    }

    return this.spawn( sEles, { unique: true } ).filter( selector );
  },

  // normally called parents in graph theory
  // these nodes <=edges= incoming nodes
  incomers: function( selector ){
    var eles = this;
    var oEles = [];

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var eleId = ele.id();

      if( !ele.isNode() ){ continue; }

      var edges = ele._private.edges;
      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        var srcId = edge._private.data.source;
        var tgtId = edge._private.data.target;

        if( tgtId === eleId && srcId !== eleId ){
          oEles.push( edge );
          oEles.push( edge.source()[0] );
        }
      }
    }

    return this.spawn( oEles, { unique: true } ).filter( selector );
  },

  // aka DAG ancestors
  predecessors: function( selector ){
    var eles = this;
    var pEles = [];
    var pElesIds = {};

    for(;;){
      var incomers = eles.incomers();

      if( incomers.length === 0 ){ break; } // done if no incomers left

      var newIncomers = false;
      for( var i = 0; i < incomers.length; i++ ){
        var incomer = incomers[i];
        var incomerId = incomer.id();

        if( !pElesIds[ incomerId ] ){
          pElesIds[ incomerId ] = true;
          pEles.push( incomer );
          newIncomers = true;
        }
      }

      if( !newIncomers ){ break; } // done if touched all incomers already

      eles = incomers;
    }

    return this.spawn( pEles, { unique: true } ).filter( selector );
  }
});


// Neighbourhood functions
//////////////////////////

util.extend(elesfn, {
  neighborhood: function(selector){
    var elements = [];
    var nodes = this.nodes();

    for( var i = 0; i < nodes.length; i++ ){ // for all nodes
      var node = nodes[i];
      var connectedEdges = node.connectedEdges();

      // for each connected edge, add the edge and the other node
      for( var j = 0; j < connectedEdges.length; j++ ){
        var edge = connectedEdges[j];
        var src = edge._private.source;
        var tgt = edge._private.target;
        var otherNode = node === src ? tgt : src;

        // need check in case of loop
        if( otherNode.length > 0 ){
          elements.push( otherNode[0] ); // add node 1 hop away
        }

        // add connected edge
        elements.push( edge[0] );
      }

    }

    return ( this.spawn( elements, { unique: true } ) ).filter( selector );
  },

  closedNeighborhood: function(selector){
    return this.neighborhood().add( this ).filter( selector );
  },

  openNeighborhood: function(selector){
    return this.neighborhood( selector );
  }
});

// aliases
elesfn.neighbourhood = elesfn.neighborhood;
elesfn.closedNeighbourhood = elesfn.closedNeighborhood;
elesfn.openNeighbourhood = elesfn.openNeighborhood;

// Edge functions
/////////////////

util.extend(elesfn, {
  source: function( selector ){
    var ele = this[0];
    var src;

    if( ele ){
      src = ele._private.source;
    }

    return src && selector ? src.filter( selector ) : src;
  },

  target: function( selector ){
    var ele = this[0];
    var tgt;

    if( ele ){
      tgt = ele._private.target;
    }

    return tgt && selector ? tgt.filter( selector ) : tgt;
  },

  sources: defineSourceFunction({
    attr: 'source'
  }),

  targets: defineSourceFunction({
    attr: 'target'
  })
});

function defineSourceFunction( params ){
  return function( selector ){
    var sources = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var src = ele._private[ params.attr ];

      if( src ){
        sources.push( src );
      }
    }

    return this.spawn( sources, { unique: true } ).filter( selector );
  };
}

util.extend(elesfn, {
  edgesWith: defineEdgesWithFunction(),

  edgesTo: defineEdgesWithFunction({
    thisIs: 'source'
  })
});

function defineEdgesWithFunction( params ){

  return function edgesWithImpl( otherNodes ){
    var elements = [];
    var cy = this._private.cy;
    var p = params || {};

    // get elements if a selector is specified
    if( is.string(otherNodes) ){
      otherNodes = cy.$( otherNodes );
    }

    var thisIds = this._private.ids;
    var otherIds = otherNodes._private.ids;

    for( var h = 0; h < otherNodes.length; h++ ){
      var edges = otherNodes[h]._private.edges;

      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var edgeData = edge._private.data;
        var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];
        var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];
        var edgeConnectsThisAndOther = thisToOther || otherToThis;

        if( !edgeConnectsThisAndOther ){ continue; }

        if( p.thisIs ){
          if( p.thisIs === 'source' && !thisToOther ){ continue; }

          if( p.thisIs === 'target' && !otherToThis ){ continue; }
        }

        elements.push( edge );
      }
    }

    return this.spawn( elements, { unique: true } );
  };
}

util.extend(elesfn, {
  connectedEdges: function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var node = eles[i];
      if( !node.isNode() ){ continue; }

      var edges = node._private.edges;

      for( var j = 0; j < edges.length; j++ ){
        var edge = edges[j];
        retEles.push( edge );
      }
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  },

  connectedNodes: function( selector ){
    var retEles = [];

    var eles = this;
    for( var i = 0; i < eles.length; i++ ){
      var edge = eles[i];
      if( !edge.isEdge() ){ continue; }

      retEles.push( edge.source()[0] );
      retEles.push( edge.target()[0] );
    }

    return this.spawn( retEles, { unique: true } ).filter( selector );
  },

  parallelEdges: defineParallelEdgesFunction(),

  codirectedEdges: defineParallelEdgesFunction({
    codirected: true
  })
});

function defineParallelEdgesFunction(params){
  var defaults = {
    codirected: false
  };
  params = util.extend({}, defaults, params);

  return function( selector ){
    var elements = [];
    var edges = this.edges();
    var p = params;

    // look at all the edges in the collection
    for( var i = 0; i < edges.length; i++ ){
      var edge1 = edges[i];
      var src1 = edge1.source()[0];
      var srcid1 = src1.id();
      var tgt1 = edge1.target()[0];
      var tgtid1 = tgt1.id();
      var srcEdges1 = src1._private.edges;

      // look at edges connected to the src node of this edge
      for( var j = 0; j < srcEdges1.length; j++ ){
        var edge2 = srcEdges1[j];
        var edge2data = edge2._private.data;
        var tgtid2 = edge2data.target;
        var srcid2 = edge2data.source;

        var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
        var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;

        if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
          elements.push( edge2 );
        }
      }
    }

    return this.spawn( elements, { unique: true } ).filter( selector );
  };

}

// Misc functions
/////////////////

util.extend(elesfn, {
  components: function(){
    var cy = this.cy();
    var visited = cy.collection();
    var unvisited = this.nodes();
    var components = [];

    var visitInComponent = function( node, component ){
      visited.merge( node );
      unvisited.unmerge( node );
      component.merge( node );
    };

    do {
      var component = cy.collection();
      components.push( component );

      var root = unvisited[0];
      visitInComponent( root, component );

      this.bfs({
        directed: false,
        roots: root,
        visit: function( i, depth, v, e, u ){
          visitInComponent( v, component );
        }
      });

    } while( unvisited.length > 0 );

    return components.map(function( component ){
      return component.closedNeighborhood(); // add the edges
    });
  }
});

module.exports = elesfn;

},{"../is":77,"../util":94}],29:[function(_dereq_,module,exports){
'use strict';

var zIndexSort = function( a, b ){
  var cy = a.cy();
  var a_p = a._private;
  var b_p = b._private;
  var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;
  var depthA = 0;
  var depthB = 0;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var aIsNode = a_p.group === 'nodes';
  var aIsEdge = a_p.group === 'edges';
  var bIsNode = b_p.group === 'nodes';
  var bIsEdge = b_p.group === 'edges';

  // no need to calculate element depth if there is no compound node
  if( hasCompoundNodes ){
    depthA = a.zDepth();
    depthB = b.zDepth();
  }

  var depthDiff = depthA - depthB;
  var sameDepth = depthDiff === 0;

  if( sameDepth ){

    if( aIsNode && bIsEdge ){
      return 1; // 'a' is a node, it should be drawn later

    } else if( aIsEdge && bIsNode ){
      return -1; // 'a' is an edge, it should be drawn first

    } else { // both nodes or both edges
      if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)
        return a_p.index - b_p.index;
      } else {
        return zDiff;
      }
    }

  // elements on different level
  } else {
    return depthDiff; // deeper element should be drawn later
  }

};

module.exports = zIndexSort;

},{}],30:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var util = _dereq_('../util');
var Collection = _dereq_('../collection');
var Element = _dereq_('../collection/element');
var window = _dereq_('../window');
var document = window ? window.document : null;
var NullRenderer = _dereq_('../extensions/renderer/null');

var corefn = {
  add: function(opts){

    var elements;
    var cy = this;

    // add the elements
    if( is.elementOrCollection(opts) ){
      var eles = opts;

      if( eles._private.cy === cy ){ // same instance => just restore
        elements = eles.restore();

      } else { // otherwise, copy from json
        var jsons = [];

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];
          jsons.push( ele.json() );
        }

        elements = new Collection( cy, jsons );
      }
    }

    // specify an array of options
    else if( is.array(opts) ){
      var jsons = opts;

      elements = new Collection(cy, jsons);
    }

    // specify via opts.nodes and opts.edges
    else if( is.plainObject(opts) && (is.array(opts.nodes) || is.array(opts.edges)) ){
      var elesByGroup = opts;
      var jsons = [];

      var grs = ['nodes', 'edges'];
      for( var i = 0, il = grs.length; i < il; i++ ){
        var group = grs[i];
        var elesArray = elesByGroup[group];

        if( is.array(elesArray) ){

          for( var j = 0, jl = elesArray.length; j < jl; j++ ){
            var json = util.extend( { group: group }, elesArray[j] );

            jsons.push( json );
          }
        }
      }

      elements = new Collection(cy, jsons);
    }

    // specify options for one element
    else {
      var json = opts;
      elements = (new Element( cy, json )).collection();
    }

    return elements;
  },

  remove: function(collection){
    if( is.elementOrCollection(collection) ){
      collection = collection;
    } else if( is.string(collection) ){
      var selector = collection;
      collection = this.$( selector );
    }

    return collection.remove();
  },

  load: function(elements, onload, ondone){
    var cy = this;

    cy.notifications(false);

    // remove old elements
    var oldEles = cy.elements();
    if( oldEles.length > 0 ){
      oldEles.remove();
    }

    if( elements != null ){
      if( is.plainObject(elements) || is.array(elements) ){
        cy.add( elements );
      }
    }

    cy.one('layoutready', function(e){
      cy.notifications(true);
      cy.trigger(e); // we missed this event by turning notifications off, so pass it on

      cy.notify({
        type: 'load',
        collection: cy.elements()
      });

      cy.one('load', onload);
      cy.trigger('load');
    }).one('layoutstop', function(){
      cy.one('done', ondone);
      cy.trigger('done');
    });

    var layoutOpts = util.extend({}, cy._private.options.layout);
    layoutOpts.eles = cy.$();

    cy.layout( layoutOpts );

    return this;
  }
};

module.exports = corefn;

},{"../collection":23,"../collection/element":19,"../extensions/renderer/null":73,"../is":77,"../util":94,"../window":100}],31:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');
var util = _dereq_('../util');
var is = _dereq_('../is');

var corefn = ({

  // pull in animation functions
  animate: define.animate(),
  animation: define.animation(),
  animated: define.animated(),
  clearQueue: define.clearQueue(),
  delay: define.delay(),
  delayAnimation: define.delayAnimation(),
  stop: define.stop(),

  addToAnimationPool: function( eles ){
    var cy = this;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    cy._private.aniEles.merge( eles );
  },

  stopAnimationLoop: function(){
    this._private.animationsRunning = false;
  },

  startAnimationLoop: function(){
    var cy = this;

    cy._private.animationsRunning = true;

    if( !cy.styleEnabled() ){ return; } // save cycles when no style used

    // NB the animation loop will exec in headless environments if style enabled
    // and explicit cy.destroy() is necessary to stop the loop

    function globalAnimationStep(){
      if( !cy._private.animationsRunning ){ return; }

      util.requestAnimationFrame(function(now){
        handleElements(now);
        globalAnimationStep();
      });
    }

    globalAnimationStep(); // first call

    function handleElements( now ){
      var eles = cy._private.aniEles;
      var doneEles = [];

      function handleElement( ele, isCore ){
        var _p = ele._private;
        var current = _p.animation.current;
        var queue = _p.animation.queue;
        var ranAnis = false;

        // if nothing currently animating, get something from the queue
        if( current.length === 0 ){
          var next = queue.shift();

          if( next ){
            current.push( next );
          }
        }

        var callbacks = function( callbacks ){
          for( var j = callbacks.length - 1; j >= 0; j-- ){
            var cb = callbacks[j];

            cb();
          }

          callbacks.splice( 0, callbacks.length );
        };

        // step and remove if done
        for( var i = current.length - 1; i >= 0; i-- ){
          var ani = current[i];
          var ani_p = ani._private;

          if( ani_p.stopped ){
            current.splice( i, 1 );

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.frames );

            continue;
          }

          if( !ani_p.playing && !ani_p.applying ){ continue; }

          // an apply() while playing shouldn't do anything
          if( ani_p.playing && ani_p.applying ){
            ani_p.applying = false;
          }

          if( !ani_p.started ){
            startAnimation( ele, ani, now );
          }

          step( ele, ani, now, isCore );

          if( ani_p.applying ){
            ani_p.applying = false;
          }

          callbacks( ani_p.frames );

          if( ani.completed() ){
            current.splice(i, 1);

            ani_p.hooked = false;
            ani_p.playing = false;
            ani_p.started = false;

            callbacks( ani_p.completes );
          }

          ranAnis = true;
        }

        if( !isCore && current.length === 0 && queue.length === 0 ){
          doneEles.push( ele );
        }

        return ranAnis;
      } // handleElement

      // handle all eles
      var ranEleAni = false;
      for( var e = 0; e < eles.length; e++ ){
        var ele = eles[e];
        var handledThisEle = handleElement( ele );

        ranEleAni = ranEleAni || handledThisEle;
      } // each element

      var ranCoreAni = handleElement( cy, true );

      // notify renderer
      if( ranEleAni || ranCoreAni ){
        var toNotify;

        if( eles.length > 0 ){
          var updatedEles = eles.updateCompoundBounds();
          toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;
        }

        cy.notify({
          type: 'draw',
          collection: toNotify
        });
      }

      // remove elements from list of currently animating if its queues are empty
      eles.unmerge( doneEles );

    } // handleElements

    function startAnimation( self, ani, now ){
      var isCore = is.core( self );
      var isEles = !isCore;
      var ele = self;
      var style = cy._private.style;
      var ani_p = ani._private;

      if( isEles ){
        var pos = ele._private.position;

        ani_p.startPosition = ani_p.startPosition || {
          x: pos.x,
          y: pos.y
        };

        ani_p.startStyle = ani_p.startStyle || style.getValueStyle( ele );
      }

      if( isCore ){
        var pan = cy._private.pan;

        ani_p.startPan = ani_p.startPan || {
          x: pan.x,
          y: pan.y
        };

        ani_p.startZoom = ani_p.startZoom != null ? ani_p.startZoom : cy._private.zoom;
      }

      ani_p.started = true;
      ani_p.startTime = now - ani_p.progress * ani_p.duration;
    }

    function step( self, ani, now, isCore ){
      var style = cy._private.style;
      var isEles = !isCore;
      var _p = self._private;
      var ani_p = ani._private;
      var pEasing = ani_p.easing;
      var startTime = ani_p.startTime;

      if( !ani_p.easingImpl ){

        if( pEasing == null ){ // use default
          ani_p.easingImpl = easings['linear'];

        } else { // then define w/ name
          var easingVals;

          if( is.string( pEasing ) ){
            var easingProp = style.parse('transition-timing-function', pEasing);

            easingVals = easingProp.value;

          } else { // then assume preparsed array
            easingVals = pEasing;
          }

          var name, args;

          if( is.string( easingVals ) ){
            name = easingVals;
            args = [];
          } else {
            name = easingVals[1];
            args = easingVals.slice(2).map(function(n){ return +n; });
          }

          if( args.length > 0 ){ // create with args
            if( name === 'spring' ){
              args.push( ani_p.duration ); // need duration to generate spring
            }

            ani_p.easingImpl = easings[ name ].apply( null, args );
          } else { // static impl by name
            ani_p.easingImpl = easings[ name ];
          }
        }

      }

      var easing = ani_p.easingImpl;
      var percent;

      if( ani_p.duration === 0 ){
        percent = 1;
      } else {
        percent = (now - startTime) / ani_p.duration;
      }

      if( ani_p.applying ){
        percent = ani_p.progress;
      }

      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( ani_p.delay == null ){ // then update

        var startPos = ani_p.startPosition;
        var endPos = ani_p.position;
        var pos = _p.position;
        if( endPos && isEles ){
          if( valid( startPos.x, endPos.x ) ){
            pos.x = ease( startPos.x, endPos.x, percent, easing );
          }

          if( valid( startPos.y, endPos.y ) ){
            pos.y = ease( startPos.y, endPos.y, percent, easing );
          }
        }

        var startPan = ani_p.startPan;
        var endPan = ani_p.pan;
        var pan = _p.pan;
        var animatingPan = endPan != null && isCore;
        if( animatingPan ){
          if( valid( startPan.x, endPan.x ) ){
            pan.x = ease( startPan.x, endPan.x, percent, easing );
          }

          if( valid( startPan.y, endPan.y ) ){
            pan.y = ease( startPan.y, endPan.y, percent, easing );
          }

          self.trigger('pan');
        }

        var startZoom = ani_p.startZoom;
        var endZoom = ani_p.zoom;
        var animatingZoom = endZoom != null && isCore;
        if( animatingZoom ){
          if( valid( startZoom, endZoom ) ){
            _p.zoom = ease( startZoom, endZoom, percent, easing );
          }

          self.trigger('zoom');
        }

        if( animatingPan || animatingZoom ){
          self.trigger('viewport');
        }

        var props = ani_p.style;
        if( props && isEles ){

          for( var i = 0; i < props.length; i++ ){
            var prop = props[i];
            var name = prop.name;
            var end = prop;

            var start = ani_p.startStyle[ name ];
            var easedVal = ease( start, end, percent, easing );

            style.overrideBypass( self, name, easedVal );
          } // for props

        } // if

      }

      if( is.fn(ani_p.step) ){
        ani_p.step.apply( self, [ now ] );
      }

      ani_p.progress = percent;

      return percent;
    }

    function valid(start, end){
      if( start == null || end == null ){
        return false;
      }

      if( is.number(start) && is.number(end) ){
        return true;
      } else if( (start) && (end) ){
        return true;
      }

      return false;
    }

    // assumes p0 = 0, p3 = 1
    function evalCubicBezier( p1, p2, t ){
      var one_t = 1 - t;
      var tsq = t*t;

      return ( 3 * one_t * one_t * t * p1 ) + ( 3 * one_t * tsq * p2 ) + tsq * t;
    }

    function cubicBezier( p1, p2 ){
      return function( start, end, percent ){
        return start + (end - start) * evalCubicBezier( p1, p2, percent );
      };
    }

    /* Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */
    /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass
       then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */
    var generateSpringRK4 = (function () {
        function springAccelerationForState (state) {
            return (-state.tension * state.x) - (state.friction * state.v);
        }

        function springEvaluateStateWithDerivative (initialState, dt, derivative) {
            var state = {
                x: initialState.x + derivative.dx * dt,
                v: initialState.v + derivative.dv * dt,
                tension: initialState.tension,
                friction: initialState.friction
            };

            return { dx: state.v, dv: springAccelerationForState(state) };
        }

        function springIntegrateState (state, dt) {
            var a = {
                    dx: state.v,
                    dv: springAccelerationForState(state)
                },
                b = springEvaluateStateWithDerivative(state, dt * 0.5, a),
                c = springEvaluateStateWithDerivative(state, dt * 0.5, b),
                d = springEvaluateStateWithDerivative(state, dt, c),
                dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx),
                dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);

            state.x = state.x + dxdt * dt;
            state.v = state.v + dvdt * dt;

            return state;
        }

        return function springRK4Factory (tension, friction, duration) {

            var initState = {
                    x: -1,
                    v: 0,
                    tension: null,
                    friction: null
                },
                path = [0],
                time_lapsed = 0,
                tolerance = 1 / 10000,
                DT = 16 / 1000,
                have_duration, dt, last_state;

            tension = parseFloat(tension) || 500;
            friction = parseFloat(friction) || 20;
            duration = duration || null;

            initState.tension = tension;
            initState.friction = friction;

            have_duration = duration !== null;

            /* Calculate the actual time it takes for this animation to complete with the provided conditions. */
            if (have_duration) {
                /* Run the simulation without a duration. */
                time_lapsed = springRK4Factory(tension, friction);
                /* Compute the adjusted time delta. */
                dt = time_lapsed / duration * DT;
            } else {
                dt = DT;
            }

            while (true) {
                /* Next/step function .*/
                last_state = springIntegrateState(last_state || initState, dt);
                /* Store the position. */
                path.push(1 + last_state.x);
                time_lapsed += 16;
                /* If the change threshold is reached, break. */
                if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {
                    break;
                }
            }

            /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the
               computed path and returns a snapshot of the position according to a given percentComplete. */
            return !have_duration ? time_lapsed : function(percentComplete) { return path[ (percentComplete * (path.length - 1)) | 0 ]; };
        };
    }());

    var easings = {
      'linear': function( start, end, percent ){
        return start + (end - start) * percent;
      },

      // default easings
      'ease': cubicBezier( 0.25, 0.1, 0.25, 1 ),
      'ease-in': cubicBezier( 0.42, 0, 1, 1 ),
      'ease-out': cubicBezier( 0, 0, 0.58, 1 ),
      'ease-in-out': cubicBezier( 0.42, 0, 0.58, 1 ),

      // sine
      'ease-in-sine': cubicBezier( 0.47, 0, 0.745, 0.715 ),
      'ease-out-sine': cubicBezier( 0.39, 0.575, 0.565, 1 ),
      'ease-in-out-sine': cubicBezier( 0.445, 0.05, 0.55, 0.95 ),

      // quad
      'ease-in-quad': cubicBezier( 0.55, 0.085, 0.68, 0.53 ),
      'ease-out-quad': cubicBezier( 0.25, 0.46, 0.45, 0.94 ),
      'ease-in-out-quad': cubicBezier( 0.455, 0.03, 0.515, 0.955 ),

      // cubic
      'ease-in-cubic': cubicBezier( 0.55, 0.055, 0.675, 0.19 ),
      'ease-out-cubic': cubicBezier( 0.215, 0.61, 0.355, 1 ),
      'ease-in-out-cubic': cubicBezier( 0.645, 0.045, 0.355, 1 ),

      // quart
      'ease-in-quart': cubicBezier( 0.895, 0.03, 0.685, 0.22 ),
      'ease-out-quart': cubicBezier( 0.165, 0.84, 0.44, 1 ),
      'ease-in-out-quart': cubicBezier( 0.77, 0, 0.175, 1 ),

      // quint
      'ease-in-quint': cubicBezier( 0.755, 0.05, 0.855, 0.06 ),
      'ease-out-quint': cubicBezier( 0.23, 1, 0.32, 1 ),
      'ease-in-out-quint': cubicBezier( 0.86, 0, 0.07, 1 ),

      // expo
      'ease-in-expo': cubicBezier( 0.95, 0.05, 0.795, 0.035 ),
      'ease-out-expo': cubicBezier( 0.19, 1, 0.22, 1 ),
      'ease-in-out-expo': cubicBezier( 1, 0, 0, 1 ),

      // circ
      'ease-in-circ': cubicBezier( 0.6, 0.04, 0.98, 0.335 ),
      'ease-out-circ': cubicBezier( 0.075, 0.82, 0.165, 1 ),
      'ease-in-out-circ': cubicBezier( 0.785, 0.135, 0.15, 0.86 ),


      // user param easings...

      'spring': function( tension, friction, duration ){
        var spring = generateSpringRK4( tension, friction, duration );

        return function( start, end, percent ){
          return start + (end - start) * spring( percent );
        };
      },

      'cubic-bezier': function( x1, y1, x2, y2 ){
        return cubicBezier( x1, y1, x2, y2 );
      }
    };

    function ease( startProp, endProp, percent, easingFn ){
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      var start, end;

      if( startProp.pfValue != null || startProp.value != null ){
        start = startProp.pfValue != null ? startProp.pfValue : startProp.value;
      } else {
        start = startProp;
      }

      if( endProp.pfValue != null || endProp.value != null ){
        end = endProp.pfValue != null ? endProp.pfValue : endProp.value;
      } else {
        end = endProp;
      }

      if( is.number(start) && is.number(end) ){
        return easingFn( start, end, percent );

      } else if( is.array(start) && is.array(end) ){
        var easedArr = [];

        for( var i = 0; i < end.length; i++ ){
          var si = start[i];
          var ei = end[i];

          if( si != null && ei != null ){
            var val = easingFn(si, ei, percent);

            if( startProp.roundValue ){ val = Math.round( val ); }

            easedArr.push( val );
          } else {
            easedArr.push( ei );
          }
        }

        return easedArr;
      }

      return undefined;
    }

  }

});

module.exports = corefn;

},{"../define":41,"../is":77,"../util":94}],32:[function(_dereq_,module,exports){
'use strict';

var define = _dereq_('../define');

var corefn = ({
  on: define.on(), // .on( events [, selector] [, data], handler)
  one: define.on({ unbindSelfOnTrigger: true }),
  once: define.on({ unbindAllBindersOnTrigger: true }),
  off: define.off(), // .off( events [, selector] [, handler] )
  trigger: define.trigger() // .trigger( events [, extraParams] )
});

define.eventAliasesOn( corefn );

module.exports = corefn;

},{"../define":41}],33:[function(_dereq_,module,exports){
'use strict';

var corefn = ({

  png: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    return renderer.png( options );
  },

  jpg: function( options ){
    var renderer = this._private.renderer;
    options = options || {};

    options.bg = options.bg || '#fff';

    return renderer.jpg( options );
  }

});

corefn.jpeg = corefn.jpg;

module.exports = corefn;

},{}],34:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('../window');
var util = _dereq_('../util');
var Collection = _dereq_('../collection');
var is = _dereq_('../is');
var Promise = _dereq_('../promise');
var define = _dereq_('../define');

var Core = function( opts ){
  if( !(this instanceof Core) ){
    return new Core(opts);
  }
  var cy = this;

  opts = util.extend({}, opts);

  var container = opts.container;

  // allow for passing a wrapped jquery object
  // e.g. cytoscape({ container: $('#cy') })
  if( container && !is.htmlElement( container ) && is.htmlElement( container[0] ) ){
    container = container[0];
  }

  var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
  reg = reg || {};

  if( reg && reg.cy ){
    reg.cy.destroy();

    reg = {}; // old instance => replace reg completely
  }

  var readies = reg.readies = reg.readies || [];

  if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
  reg.cy = cy;

  var head = window !== undefined && container !== undefined && !opts.headless;
  var options = opts;
  options.layout = util.extend( { name: head ? 'grid' : 'null' }, options.layout );
  options.renderer = util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );

  var defVal = function( def, val, altVal ){
    if( val !== undefined ){
      return val;
    } else if( altVal !== undefined ){
      return altVal;
    } else {
      return def;
    }
  };

  var _p = this._private = {
    container: container, // html dom ele container
    ready: false, // whether ready has been triggered
    initrender: false, // has initrender has been triggered
    options: options, // cached options
    elements: [], // array of elements
    id2index: {}, // element id => index in elements array
    listeners: [], // list of listeners
    onRenders: [], // rendering listeners
    aniEles: Collection(this), // elements being animated
    scratch: {}, // scratch object for core
    layout: null,
    renderer: null,
    notificationsEnabled: true, // whether notifications are sent to the renderer
    minZoom: 1e-50,
    maxZoom: 1e50,
    zoomingEnabled: defVal(true, options.zoomingEnabled),
    userZoomingEnabled: defVal(true, options.userZoomingEnabled),
    panningEnabled: defVal(true, options.panningEnabled),
    userPanningEnabled: defVal(true, options.userPanningEnabled),
    boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),
    autolock: defVal(false, options.autolock, options.autolockNodes),
    autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
    autounselectify: defVal(false, options.autounselectify),
    styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
    zoom: is.number(options.zoom) ? options.zoom : 1,
    pan: {
      x: is.plainObject(options.pan) && is.number(options.pan.x) ? options.pan.x : 0,
      y: is.plainObject(options.pan) && is.number(options.pan.y) ? options.pan.y : 0
    },
    animation: { // object for currently-running animations
      current: [],
      queue: []
    },
    hasCompoundNodes: false,
    deferredExecQueue: []
  };

  // set selection type
  var selType = options.selectionType;
  if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
    // then set default

    _p.selectionType = 'single';
  } else {
    _p.selectionType = selType;
  }

  // init zoom bounds
  if( is.number(options.minZoom) && is.number(options.maxZoom) && options.minZoom < options.maxZoom ){
    _p.minZoom = options.minZoom;
    _p.maxZoom = options.maxZoom;
  } else if( is.number(options.minZoom) && options.maxZoom === undefined ){
    _p.minZoom = options.minZoom;
  } else if( is.number(options.maxZoom) && options.minZoom === undefined ){
    _p.maxZoom = options.maxZoom;
  }

  var loadExtData = function( next ){
    var anyIsPromise = false;

    for( var i = 0; i < extData.length; i++ ){
      var datum = extData[i];

      if( is.promise(datum) ){
        anyIsPromise = true;
        break;
      }
    }

    if( anyIsPromise ){
      return Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
    } else {
      next( extData ); // exec synchronously for convenience
    }
  };

  // create the renderer
  cy.initRenderer( util.extend({
    hideEdgesOnViewport: options.hideEdgesOnViewport,
    hideLabelsOnViewport: options.hideLabelsOnViewport,
    textureOnViewport: options.textureOnViewport,
    wheelSensitivity: is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
    motionBlur: options.motionBlur === undefined ? true : options.motionBlur, // on by default
    motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
    pixelRatio: is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : undefined,
    desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
    touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
  }, options.renderer) );

  var extData = [ options.style, options.elements ];
  loadExtData(function( thens ){
    var initStyle = thens[0];
    var initEles = thens[1];

    // init style
    if( _p.styleEnabled ){
      cy.setStyle( initStyle );
    }

    // trigger the passed function for the `initrender` event
    if( options.initrender ){
      cy.on('initrender', options.initrender);
      cy.on('initrender', function(){
        _p.initrender = true;
      });
    }

    // initial load
    cy.load(initEles, function(){ // onready
      cy.startAnimationLoop();
      _p.ready = true;

      // if a ready callback is specified as an option, the bind it
      if( is.fn( options.ready ) ){
        cy.on('ready', options.ready);
      }

      // bind all the ready handlers registered before creating this instance
      for( var i = 0; i < readies.length; i++ ){
        var fn = readies[i];
        cy.on('ready', fn);
      }
      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc

      cy.trigger('ready');
    }, options.done);

  });
};

var corefn = Core.prototype; // short alias

util.extend(corefn, {
  instanceString: function(){
    return 'core';
  },

  isReady: function(){
    return this._private.ready;
  },

  ready: function( fn ){
    if( this.isReady() ){
      this.trigger('ready', [], fn); // just calls fn as though triggered via ready event
    } else {
      this.on('ready', fn);
    }

    return this;
  },

  initrender: function(){
    return this._private.initrender;
  },

  destroy: function(){
    var cy = this;

    cy.stopAnimationLoop();

    cy.notify({ type: 'destroy' }); // destroy the renderer

    var domEle = cy.container();
    if( domEle ){
      domEle._cyreg = null;

      while( domEle.childNodes.length > 0 ){
        domEle.removeChild( domEle.childNodes[0] );
      }
    }

    return cy;
  },

  getElementById: function( id ){
    var index = this._private.id2index[ id ];
    if( index !== undefined ){
      return this._private.elements[ index ];
    }

    // worst case, return an empty collection
    return Collection( this );
  },

  selectionType: function(){
    return this._private.selectionType;
  },

  hasCompoundNodes: function(){
    return this._private.hasCompoundNodes;
  },

  styleEnabled: function(){
    return this._private.styleEnabled;
  },

  addToPool: function( eles ){
    var elements = this._private.elements;
    var id2index = this._private.id2index;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];

      var id = ele._private.data.id;
      var index = id2index[ id ];
      var alreadyInPool = index !== undefined;

      if( !alreadyInPool ){
        index = elements.length;
        elements.push( ele );
        id2index[ id ] = index;
        ele._private.index = index;
      }
    }

    return this; // chaining
  },

  removeFromPool: function( eles ){
    var elements = this._private.elements;
    var id2index = this._private.id2index;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];

      var id = ele._private.data.id;
      var index = id2index[ id ];
      var inPool = index !== undefined;

      if( inPool ){
        this._private.id2index[ id ] = undefined;
        elements.splice(index, 1);

        // adjust the index of all elements past this index
        for( var j = index; j < elements.length; j++ ){
          var jid = elements[j]._private.data.id;
          id2index[ jid ]--;
          elements[j]._private.index--;
        }
      }
    }
  },

  container: function(){
    return this._private.container;
  },

  options: function(){
    return util.copy( this._private.options );
  },

  json: function( obj ){
    var cy = this;
    var _p = cy._private;

    if( is.plainObject(obj) ){ // set

      cy.startBatch();

      if( obj.elements ){
        var idInJson = {};

        var updateEles = function( jsons, gr ){
          for( var i = 0; i < jsons.length; i++ ){
            var json = jsons[i];
            var id = json.data.id;
            var ele = cy.getElementById( id );

            idInJson[ id ] = true;

            if( ele.length !== 0 ){ // existing element should be updated
              ele.json( json );
            } else { // otherwise should be added
              if( gr ){
                cy.add( util.extend({ group: gr }, json) );
              } else {
                cy.add( json );
              }
            }
          }
        };

        if( is.array(obj.elements) ){ // elements: []
          updateEles( obj.elements );

        } else { // elements: { nodes: [], edges: [] }
          var grs = ['nodes', 'edges'];
          for( var i = 0; i < grs.length; i++ ){
            var gr = grs[i];
            var elements = obj.elements[ gr ];

            if( is.array(elements) ){
              updateEles( elements, gr );
            }
          }
        }

        // elements not specified in json should be removed
        cy.elements().stdFilter(function( ele ){
          return !idInJson[ ele.id() ];
        }).remove();
      }

      if( obj.style ){
        cy.style( obj.style );
      }

      if( obj.zoom != null && obj.zoom !== _p.zoom ){
        cy.zoom( obj.zoom );
      }

      if( obj.pan ){
        if( obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y ){
          cy.pan( obj.pan );
        }
      }

      var fields = [
        'minZoom', 'maxZoom', 'zoomingEnabled', 'userZoomingEnabled',
        'panningEnabled', 'userPanningEnabled',
        'boxSelectionEnabled',
        'autolock', 'autoungrabify', 'autounselectify'
      ];

      for( var i = 0; i < fields.length; i++ ){
        var f = fields[i];

        if( obj[f] != null ){
          cy[f]( obj[f] );
        }
      }

      cy.endBatch();

      return this; // chaining
    } else if( obj === undefined ){ // get
      var json = {};

      json.elements = {};
      cy.elements().each(function(i, ele){
        var group = ele.group();

        if( !json.elements[group] ){
          json.elements[group] = [];
        }

        json.elements[group].push( ele.json() );
      });

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = util.copy( cy._private.pan );
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.renderer = util.copy( cy._private.options.renderer );
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;

      return json;
    }
  },

  scratch: define.data({
    field: 'scratch',
    bindingEvent: 'scratch',
    allowBinding: true,
    allowSetting: true,
    settingEvent: 'scratch',
    settingTriggersEvent: true,
    triggerFnName: 'trigger',
    allowGetting: true
  }),

  removeScratch: define.removeData({
    field: 'scratch',
    event: 'scratch',
    triggerFnName: 'trigger',
    triggerEvent: true
  })

});

[
  _dereq_('./add-remove'),
  _dereq_('./animation'),
  _dereq_('./events'),
  _dereq_('./export'),
  _dereq_('./layout'),
  _dereq_('./notification'),
  _dereq_('./renderer'),
  _dereq_('./search'),
  _dereq_('./style'),
  _dereq_('./viewport')
].forEach(function( props ){
  util.extend( corefn, props );
});

module.exports = Core;

},{"../collection":23,"../define":41,"../is":77,"../promise":80,"../util":94,"../window":100,"./add-remove":30,"./animation":31,"./events":32,"./export":33,"./layout":35,"./notification":36,"./renderer":37,"./search":38,"./style":39,"./viewport":40}],35:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var corefn = ({

  layout: function( params ){
    var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.makeLayout( params ) );

    layout.run();

    return this; // chaining
  },

  makeLayout: function( options ){
    var cy = this;

    if( options == null ){
      util.error('Layout options must be specified to make a layout');
      return;
    }

    if( options.name == null ){
      util.error('A `name` must be specified to make a layout');
      return;
    }

    var name = options.name;
    var Layout = cy.extension('layout', name);

    if( Layout == null ){
      util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
      return;
    }

    var eles;
    if( is.string( options.eles ) ){
      eles = cy.$( options.eles );
    } else {
      eles = options.eles != null ? options.eles : cy.$();
    }

    var layout = new Layout( util.extend({}, options, {
      cy: cy,
      eles: eles
    }) );

    return layout;
  }

});

corefn.createLayout = corefn.makeLayout;

module.exports = corefn;

},{"../is":77,"../util":94}],36:[function(_dereq_,module,exports){
'use strict';

var corefn = ({
  notify: function( params ){
    var _p = this._private;

    if( _p.batchingNotify ){
      var bEles = _p.batchNotifyEles;
      var bTypes = _p.batchNotifyTypes;

      if( params.collection ){
        bEles.merge( params.collection );
      }

      if( !bTypes.ids[ params.type ] ){
        bTypes.push( params.type );
      }

      return; // notifications are disabled during batching
    }

    if( !_p.notificationsEnabled ){ return; } // exit on disabled

    var renderer = this.renderer();

    renderer.notify(params);
  },

  notifications: function( bool ){
    var p = this._private;

    if( bool === undefined ){
      return p.notificationsEnabled;
    } else {
      p.notificationsEnabled = bool ? true : false;
    }
  },

  noNotifications: function( callback ){
    this.notifications(false);
    callback();
    this.notifications(true);
  },

  startBatch: function(){
    var _p = this._private;

    if( _p.batchCount == null ){
      _p.batchCount = 0;
    }

    if( _p.batchCount === 0 ){
      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = this.collection();
      _p.batchNotifyEles = this.collection();
      _p.batchNotifyTypes = [];

      _p.batchNotifyTypes.ids = {};
    }

    _p.batchCount++;

    return this;
  },

  endBatch: function(){
    var _p = this._private;

    _p.batchCount--;

    if( _p.batchCount === 0 ){
      // update style for dirty eles
      _p.batchingStyle = false;
      _p.batchStyleEles.updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        collection: _p.batchNotifyEles
      });
    }

    return this;
  },

  batch: function( callback ){
    this.startBatch();
    callback();
    this.endBatch();

    return this;
  },

  // for backwards compatibility
  batchData: function( map ){
    var cy = this;

    return this.batch(function(){
      for( var id in map ){
        var data = map[id];
        var ele = cy.getElementById( id );

        ele.data( data );
      }
    });
  }
});

module.exports = corefn;

},{}],37:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');

var corefn = ({

  renderTo: function( context, zoom, pan, pxRatio ){
    var r = this._private.renderer;

    r.renderTo( context, zoom, pan, pxRatio );
    return this;
  },

  renderer: function(){
    return this._private.renderer;
  },

  forceRender: function(){
    this.notify({
      type: 'draw'
    });

    return this;
  },

  resize: function(){
    this.notify({
      type: 'resize'
    });

    this.trigger('resize');

    return this;
  },

  initRenderer: function( options ){
    var cy = this;

    var RendererProto = cy.extension('renderer', options.name);
    if( RendererProto == null ){
      util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
      return;
    }

    var rOpts = util.extend({}, options, {
      cy: cy
    });
    var renderer = cy._private.renderer = new RendererProto( rOpts );

    renderer.init( rOpts );

  },

  triggerOnRender: function(){
    var cbs = this._private.onRenders;

    for( var i = 0; i < cbs.length; i++ ){
      var cb = cbs[i];

      cb();
    }

    return this;
  },

  onRender: function( cb ){
    this._private.onRenders.push( cb );

    return this;
  },

  offRender: function( fn ){
    var cbs = this._private.onRenders;

    if( fn == null ){ // unbind all
      this._private.onRenders = [];
      return this;
    }

    for( var i = 0; i < cbs.length; i++ ){ // unbind specified
      var cb = cbs[i];

      if( fn === cb ){
        cbs.splice( i, 1 );
        break;
      }
    }

    return this;
  }

});

corefn.invalidateDimensions = corefn.resize;

module.exports = corefn;

},{"../util":94}],38:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var Collection = _dereq_('../collection');

var corefn = ({

  // get a collection
  // - empty collection on no args
  // - collection of elements in the graph on selector arg
  // - guarantee a returned collection when elements or collection specified
  collection: function( eles, opts ){

    if( is.string( eles ) ){
      return this.$( eles );

    } else if( is.elementOrCollection( eles ) ){
      return eles.collection();

    } else if( is.array( eles ) ){
      return Collection( this, eles, opts );
    }

    return Collection( this );
  },

  nodes: function( selector ){
    var nodes = this.$(function(){
      return this.isNode();
    });

    if( selector ){
      return nodes.filter( selector );
    }

    return nodes;
  },

  edges: function( selector ){
    var edges = this.$(function(){
      return this.isEdge();
    });

    if( selector ){
      return edges.filter( selector );
    }

    return edges;
  },

  // search the graph like jQuery
  $: function( selector ){
    var eles = new Collection( this, this._private.elements );

    if( selector ){
      return eles.filter( selector );
    }

    return eles;
  }

});

// aliases
corefn.elements = corefn.filter = corefn.$;

module.exports = corefn;

},{"../collection":23,"../is":77}],39:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var Style = _dereq_('../style');

var corefn = ({

  style: function( newStyle ){
    if( newStyle ){
      var s = this.setStyle( newStyle );

      s.update();
    }

    return this._private.style;
  },

  setStyle: function( style ){
    var _p = this._private;

    if( is.stylesheet(style) ){
      _p.style = style.generateStyle(this);

    } else if( is.array(style) ) {
      _p.style = Style.fromJson(this, style);

    } else if( is.string(style) ){
      _p.style = Style.fromString(this, style);

    } else {
      _p.style = Style( this );
    }

    return _p.style;
  }
});

module.exports = corefn;

},{"../is":77,"../style":86}],40:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');

var corefn = ({

  autolock: function(bool){
    if( bool !== undefined ){
      this._private.autolock = bool ? true : false;
    } else {
      return this._private.autolock;
    }

    return this; // chaining
  },

  autoungrabify: function(bool){
    if( bool !== undefined ){
      this._private.autoungrabify = bool ? true : false;
    } else {
      return this._private.autoungrabify;
    }

    return this; // chaining
  },

  autounselectify: function(bool){
    if( bool !== undefined ){
      this._private.autounselectify = bool ? true : false;
    } else {
      return this._private.autounselectify;
    }

    return this; // chaining
  },

  panningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.panningEnabled = bool ? true : false;
    } else {
      return this._private.panningEnabled;
    }

    return this; // chaining
  },

  userPanningEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userPanningEnabled = bool ? true : false;
    } else {
      return this._private.userPanningEnabled;
    }

    return this; // chaining
  },

  zoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.zoomingEnabled = bool ? true : false;
    } else {
      return this._private.zoomingEnabled;
    }

    return this; // chaining
  },

  userZoomingEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.userZoomingEnabled = bool ? true : false;
    } else {
      return this._private.userZoomingEnabled;
    }

    return this; // chaining
  },

  boxSelectionEnabled: function( bool ){
    if( bool !== undefined ){
      this._private.boxSelectionEnabled = bool ? true : false;
    } else {
      return this._private.boxSelectionEnabled;
    }

    return this; // chaining
  },

  pan: function(){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    switch( args.length ){
    case 0: // .pan()
      return pan;

    case 1:

      if( is.string( args[0] ) ){ // .pan('x')
        dim = args[0];
        return pan[ dim ];

      } else if( is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })
        if( !this._private.panningEnabled ){
          return this;
        }

        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number(x) ){
          pan.x = x;
        }

        if( is.number(y) ){
          pan.y = y;
        }

        this.trigger('pan viewport');
      }
      break;

    case 2: // .pan('x', 100)
      if( !this._private.panningEnabled ){
        return this;
      }

      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number(val) ){
        pan[dim] = val;
      }

      this.trigger('pan viewport');
      break;

    default:
      break; // invalid
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  panBy: function(params){
    var args = arguments;
    var pan = this._private.pan;
    var dim, val, dims, x, y;

    if( !this._private.panningEnabled ){
      return this;
    }

    switch( args.length ){
    case 1:

      if( is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })
        dims = args[0];
        x = dims.x;
        y = dims.y;

        if( is.number(x) ){
          pan.x += x;
        }

        if( is.number(y) ){
          pan.y += y;
        }

        this.trigger('pan viewport');
      }
      break;

    case 2: // .panBy('x', 100)
      dim = args[0];
      val = args[1];

      if( (dim === 'x' || dim === 'y') && is.number(val) ){
        pan[dim] += val;
      }

      this.trigger('pan viewport');
      break;

    default:
      break; // invalid
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  fit: function( elements, padding ){
    var viewportState = this.getFitViewport( elements, padding );

    if( viewportState ){
      var _p = this._private;
      _p.zoom = viewportState.zoom;
      _p.pan = viewportState.pan;

      this.trigger('pan zoom viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  getFitViewport: function( elements, padding ){
    if( is.number(elements) && padding === undefined ){ // elements is optional
      padding = elements;
      elements = undefined;
    }

    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return;
    }

    var bb;

    if( is.string(elements) ){
      var sel = elements;
      elements = this.$( sel );

    } else if( is.boundingBox(elements) ){ // assume bb
      var bbe = elements;
      bb = {
        x1: bbe.x1,
        y1: bbe.y1,
        x2: bbe.x2,
        y2: bbe.y2
      };

      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;

    } else if( !is.elementOrCollection(elements) ){
      elements = this.elements();
    }

    bb = bb || elements.boundingBox();

    var w = this.width();
    var h = this.height();
    var zoom;
    padding = is.number(padding) ? padding : 0;

    if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){
      zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      var pan = { // now pan to middle
        x: (w - zoom*( bb.x1 + bb.x2 ))/2,
        y: (h - zoom*( bb.y1 + bb.y2 ))/2
      };

      return {
        zoom: zoom,
        pan: pan
      };
    }

    return;
  },

  minZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.minZoom;
    } else if( is.number(zoom) ){
      this._private.minZoom = zoom;
    }

    return this;
  },

  maxZoom: function( zoom ){
    if( zoom === undefined ){
      return this._private.maxZoom;
    } else if( is.number(zoom) ){
      this._private.maxZoom = zoom;
    }

    return this;
  },

  zoom: function( params ){
    var pos; // in rendered px
    var zoom;

    if( params === undefined ){ // then get the zoom
      return this._private.zoom;

    } else if( is.number(params) ){ // then set the zoom
      zoom = params;

    } else if( is.plainObject(params) ){ // then zoom about a point
      zoom = params.level;

      if( params.position ){
        var p = params.position;
        var pan = this._private.pan;
        var z = this._private.zoom;

        pos = { // convert to rendered px
          x: p.x * z + pan.x,
          y: p.y * z + pan.y
        };
      } else if( params.renderedPosition ){
        pos = params.renderedPosition;
      }

      if( pos && !this._private.panningEnabled ){
        return this; // panning disabled
      }
    }

    if( !this._private.zoomingEnabled ){
      return this; // zooming disabled
    }

    if( !is.number(zoom) || ( pos && (!is.number(pos.x) || !is.number(pos.y)) ) ){
      return this; // can't zoom with invalid params
    }

    // crop zoom
    zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
    zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

    if( pos ){ // set zoom about position
      var pan1 = this._private.pan;
      var zoom1 = this._private.zoom;
      var zoom2 = zoom;

      var pan2 = {
        x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,
        y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y
      };

      this._private.zoom = zoom;
      this._private.pan = pan2;

      var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
      this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );

    } else { // just set the zoom
      this._private.zoom = zoom;
      this.trigger('zoom viewport');
    }

    this.notify({ // notify the renderer that the viewport changed
      type: 'viewport'
    });

    return this; // chaining
  },

  viewport: function( opts ){
    var _p = this._private;
    var zoomDefd = true;
    var panDefd = true;
    var events = []; // to trigger
    var zoomFailed = false;
    var panFailed = false;

    if( !opts ){ return this; }
    if( !is.number(opts.zoom) ){ zoomDefd = false; }
    if( !is.plainObject(opts.pan) ){ panDefd = false; }
    if( !zoomDefd && !panDefd ){ return this; }

    if( zoomDefd ){
      var z = opts.zoom;

      if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
        zoomFailed = true;

      } else {
        _p.zoom = z;

        events.push('zoom');
      }
    }

    if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
      var p = opts.pan;

      if( is.number(p.x) ){
        _p.pan.x = p.x;
        panFailed = false;
      }

      if( is.number(p.y) ){
        _p.pan.y = p.y;
        panFailed = false;
      }

      if( !panFailed ){
        events.push('pan');
      }
    }

    if( events.length > 0 ){
      events.push('viewport');
      this.trigger( events.join(' ') );

      this.notify({
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  center: function( elements ){
    var pan = this.getCenterPan( elements );

    if( pan ){
      this._private.pan = pan;

      this.trigger('pan viewport');

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });
    }

    return this; // chaining
  },

  getCenterPan: function( elements, zoom ){
    if( !this._private.panningEnabled ){
      return;
    }

    if( is.string(elements) ){
      var selector = elements;
      elements = this.elements( selector );
    } else if( !is.elementOrCollection(elements) ){
      elements = this.elements();
    }

    var bb = elements.boundingBox();
    var w = this.width();
    var h = this.height();
    zoom = zoom === undefined ? this._private.zoom : zoom;

    var pan = { // middle
      x: (w - zoom*( bb.x1 + bb.x2 ))/2,
      y: (h - zoom*( bb.y1 + bb.y2 ))/2
    };

    return pan;
  },

  reset: function(){
    if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
      return this;
    }

    this.viewport({
      pan: { x: 0, y: 0 },
      zoom: 1
    });

    return this; // chaining
  },

  width: function(){
    var container = this._private.container;

    if( container ){
      return container.clientWidth;
    }

    return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
  },

  height: function(){
    var container = this._private.container;

    if( container ){
      return container.clientHeight;
    }

    return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
  },

  extent: function(){
    var pan = this._private.pan;
    var zoom = this._private.zoom;
    var rb = this.renderedExtent();

    var b = {
      x1: ( rb.x1 - pan.x )/zoom,
      x2: ( rb.x2 - pan.x )/zoom,
      y1: ( rb.y1 - pan.y )/zoom,
      y2: ( rb.y2 - pan.y )/zoom
    };

    b.w = b.x2 - b.x1;
    b.h = b.y2 - b.y1;

    return b;
  },

  renderedExtent: function(){
    var width = this.width();
    var height = this.height();

    return {
      x1: 0,
      y1: 0,
      x2: width,
      y2: height,
      w: width,
      h: height
    };
  }
});

// aliases
corefn.centre = corefn.center;

// backwards compatibility
corefn.autolockNodes = corefn.autolock;
corefn.autoungrabifyNodes = corefn.autoungrabify;

module.exports = corefn;

},{"../is":77}],41:[function(_dereq_,module,exports){
'use strict';

// use this module to cherry pick functions into your prototype
// (useful for functions shared between the core and collections, for example)

// e.g.
// var foo = define.foo({ /* params... */ })

var util = _dereq_('./util');
var is = _dereq_('./is');
var Selector = _dereq_('./selector');
var Promise = _dereq_('./promise');
var Event = _dereq_('./event');
var Animation = _dereq_('./animation');

var define = {

  // access data field
  data: function( params ){
    var defaults = {
      field: 'data',
      bindingEvent: 'data',
      allowBinding: false,
      allowSetting: false,
      allowGetting: false,
      settingEvent: 'data',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      immutableKeys: {}, // key => true if immutable
      updateStyle: false,
      onSet: function( self ){},
      canSet: function( self ){ return true; }
    };
    params = util.extend({}, defaults, params);

    return function dataImpl( name, value ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var single = selfIsArrayLike ? self[0] : self;

      // .data('foo', ...)
      if( is.string(name) ){ // set or get property

        // .data('foo')
        if( p.allowGetting && value === undefined ){ // get

          var ret;
          if( single ){
            ret = single._private[ p.field ][ name ];
          }
          return ret;

        // .data('foo', 'bar')
        } else if( p.allowSetting && value !== undefined ) { // set
          var valid = !p.immutableKeys[name];
          if( valid ){
            for( var i = 0, l = all.length; i < l; i++ ){
              if( p.canSet( all[i] ) ){
                all[i]._private[ p.field ][ name ] = value;
              }
            }

            // update mappers if asked
            if( p.updateStyle ){ self.updateStyle(); }

            // call onSet callback
            p.onSet( self );

            if( p.settingTriggersEvent ){
              self[ p.triggerFnName ]( p.settingEvent );
            }
          }
        }

      // .data({ 'foo': 'bar' })
      } else if( p.allowSetting && is.plainObject(name) ){ // extend
        var obj = name;
        var k, v;

        for( k in obj ){
          v = obj[ k ];

          var valid = !p.immutableKeys[k];
          if( valid ){
            for( var i = 0, l = all.length; i < l; i++ ){
              if( p.canSet( all[i] ) ){
                all[i]._private[ p.field ][ k ] = v;
              }
            }
          }
        }

        // update mappers if asked
        if( p.updateStyle ){ self.updateStyle(); }

        // call onSet callback
        p.onSet( self );

        if( p.settingTriggersEvent ){
          self[ p.triggerFnName ]( p.settingEvent );
        }

      // .data(function(){ ... })
      } else if( p.allowBinding && is.fn(name) ){ // bind to event
        var fn = name;
        self.bind( p.bindingEvent, fn );

      // .data()
      } else if( p.allowGetting && name === undefined ){ // get whole object
        var ret;
        if( single ){
          ret = single._private[ p.field ];
        }
        return ret;
      }

      return self; // maintain chainability
    }; // function
  }, // data

  // remove data field
  removeData: function( params ){
    var defaults = {
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: false,
      immutableKeys: {} // key => true if immutable
    };
    params = util.extend({}, defaults, params);

    return function removeDataImpl( names ){
      var p = params;
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like

      // .removeData('foo bar')
      if( is.string(names) ){ // then get the list of keys, and delete them
        var keys = names.split(/\s+/);
        var l = keys.length;

        for( var i = 0; i < l; i++ ){ // delete each non-empty key
          var key = keys[i];
          if( is.emptyString(key) ){ continue; }

          var valid = !p.immutableKeys[ key ]; // not valid if immutable
          if( valid ){
            for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
              all[ i_a ]._private[ p.field ][ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }

      // .removeData()
      } else if( names === undefined ){ // then delete all keys

        for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
          var _privateFields = all[ i_a ]._private[ p.field ];

          for( var key in _privateFields ){
            var validKeyToDelete = !p.immutableKeys[ key ];

            if( validKeyToDelete ){
              _privateFields[ key ] = undefined;
            }
          }
        }

        if( p.triggerEvent ){
          self[ p.triggerFnName ]( p.event );
        }
      }

      return self; // maintain chaining
    }; // function
  }, // removeData

  // event function reusable stuff
  event: {
    regex: /(\w+)(\.\w+)?/, // regex for matching event strings (e.g. "click.namespace")
    optionalTypeRegex: /(\w+)?(\.\w+)?/,
    falseCallback: function(){ return false; }
  },

  // event binding
  on: function( params ){
    var defaults = {
      unbindSelfOnTrigger: false,
      unbindAllBindersOnTrigger: false
    };
    params = util.extend({}, defaults, params);

    return function onImpl(events, selector, data, callback){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var eventsIsString = is.string(events);
      var p = params;

      if( is.plainObject(selector) ){ // selector is actually data
        callback = data;
        data = selector;
        selector = undefined;
      } else if( is.fn(selector) || selector === false ){ // selector is actually callback
        callback = selector;
        data = undefined;
        selector = undefined;
      }

      if( is.fn(data) || data === false ){ // data is actually callback
        callback = data;
        data = undefined;
      }

      // if there isn't a callback, we can't really do anything
      // (can't speak for mapped events arg version)
      if( !(is.fn(callback) || callback === false) && eventsIsString ){
        return self; // maintain chaining
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      for( var evts in events ){
        callback = events[evts];
        if( callback === false ){
          callback = define.event.falseCallback;
        }

        if( !is.fn(callback) ){ continue; }

        evts = evts.split(/\s+/);
        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[i];
          if( is.emptyString(evt) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]

          if( match ){
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            var listener = {
              callback: callback, // callback to run
              data: data, // extra data in eventObj.data
              delegated: selector ? true : false, // whether the evt is delegated
              selector: selector, // the selector to match for delegated events
              selObj: new Selector(selector), // cached selector object to save rebuilding
              type: type, // the event type (e.g. 'click')
              namespace: namespace, // the event namespace (e.g. ".foo")
              unbindSelfOnTrigger: p.unbindSelfOnTrigger,
              unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
              binders: all // who bound together
            };

            for( var j = 0; j < all.length; j++ ){
              var _p = all[j]._private;

              _p.listeners = _p.listeners || [];
              _p.listeners.push( listener );
            }
          }
        } // for events array
      } // for events map

      return self; // maintain chaining
    }; // function
  }, // on

  eventAliasesOn: function( proto ){
    var p = proto;

    p.addListener = p.listen = p.bind = p.on;
    p.removeListener = p.unlisten = p.unbind = p.off;
    p.emit = p.trigger;

    // this is just a wrapper alias of .on()
    p.pon = p.promiseOn = function( events, selector ){
      var self = this;
      var args = Array.prototype.slice.call( arguments, 0 );

      return new Promise(function( resolve, reject ){
        var callback = function( e ){
          self.off.apply( self, offArgs );

          resolve( e );
        };

        var onArgs = args.concat([ callback ]);
        var offArgs = onArgs.concat([]);

        self.on.apply( self, onArgs );
      });
    };
  },

  off: function offImpl( params ){
    var defaults = {
    };
    params = util.extend({}, defaults, params);

    return function(events, selector, callback){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var eventsIsString = is.string(events);

      if( arguments.length === 0 ){ // then unbind all

        for( var i = 0; i < all.length; i++ ){
          all[i]._private.listeners = [];
        }

        return self; // maintain chaining
      }

      if( is.fn(selector) || selector === false ){ // selector is actually callback
        callback = selector;
        selector = undefined;
      }

      if( eventsIsString ){ // then convert to map
        var map = {};
        map[ events ] = callback;
        events = map;
      }

      for( var evts in events ){
        callback = events[evts];

        if( callback === false ){
          callback = define.event.falseCallback;
        }

        evts = evts.split(/\s+/);
        for( var h = 0; h < evts.length; h++ ){
          var evt = evts[h];
          if( is.emptyString(evt) ){ continue; }

          var match = evt.match( define.event.optionalTypeRegex ); // [type][.namespace]
          if( match ){
            var type = match[1] ? match[1] : undefined;
            var namespace = match[2] ? match[2] : undefined;

            for( var i = 0; i < all.length; i++ ){ //
              var listeners = all[i]._private.listeners = all[i]._private.listeners || [];

              for( var j = 0; j < listeners.length; j++ ){
                var listener = listeners[j];
                var nsMatches = !namespace || namespace === listener.namespace;
                var typeMatches = !type || listener.type === type;
                var cbMatches = !callback || callback === listener.callback;
                var listenerMatches = nsMatches && typeMatches && cbMatches;

                // delete listener if it matches
                if( listenerMatches ){
                  listeners.splice(j, 1);
                  j--;
                }
              } // for listeners
            } // for all
          } // if match
        } // for events array

      } // for events map

      return self; // maintain chaining
    }; // function
  }, // off

  trigger: function( params ){
    var defaults = {};
    params = util.extend({}, defaults, params);

    return function triggerImpl(events, extraParams, fnToTrigger){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var eventsIsString = is.string(events);
      var eventsIsObject = is.plainObject(events);
      var eventsIsEvent = is.event(events);
      var cy = this._private.cy || ( is.core(this) ? this : null );
      var hasCompounds = cy ? cy.hasCompoundNodes() : false;

      if( eventsIsString ){ // then make a plain event object for each event name
        var evts = events.split(/\s+/);
        events = [];

        for( var i = 0; i < evts.length; i++ ){
          var evt = evts[i];
          if( is.emptyString(evt) ){ continue; }

          var match = evt.match( define.event.regex ); // type[.namespace]
          var type = match[1];
          var namespace = match[2] ? match[2] : undefined;

          events.push( {
            type: type,
            namespace: namespace
          } );
        }
      } else if( eventsIsObject ){ // put in length 1 array
        var eventArgObj = events;

        events = [ eventArgObj ];
      }

      if( extraParams ){
        if( !is.array(extraParams) ){ // make sure extra params are in an array if specified
          extraParams = [ extraParams ];
        }
      } else { // otherwise, we've got nothing
        extraParams = [];
      }

      for( var i = 0; i < events.length; i++ ){ // trigger each event in order
        var evtObj = events[i];

        for( var j = 0; j < all.length; j++ ){ // for each
          var triggerer = all[j];
          var listeners = triggerer._private.listeners = triggerer._private.listeners || [];
          var triggererIsElement = is.element(triggerer);
          var bubbleUp = triggererIsElement || params.layout;

          // create the event for this element from the event object
          var evt;

          if( eventsIsEvent ){ // then just get the object
            evt = evtObj;

            evt.cyTarget = evt.cyTarget || triggerer;
            evt.cy = evt.cy || cy;

          } else { // then we have to make one
            evt = new Event( evtObj, {
              cyTarget: triggerer,
              cy: cy,
              namespace: evtObj.namespace
            } );
          }

          // if a layout was specified, then put it in the typed event
          if( evtObj.layout ){
            evt.layout = evtObj.layout;
          }

          // if triggered by layout, put in event
          if( params.layout ){
            evt.layout = triggerer;
          }

          // create a rendered position based on the passed position
          if( evt.cyPosition ){
            var pos = evt.cyPosition;
            var zoom = cy.zoom();
            var pan = cy.pan();

            evt.cyRenderedPosition = {
              x: pos.x * zoom + pan.x,
              y: pos.y * zoom + pan.y
            };
          }

          if( fnToTrigger ){ // then override the listeners list with just the one we specified
            listeners = [{
              namespace: evt.namespace,
              type: evt.type,
              callback: fnToTrigger
            }];
          }

          for( var k = 0; k < listeners.length; k++ ){ // check each listener
            var lis = listeners[k];
            var nsMatches = !lis.namespace || lis.namespace === evt.namespace;
            var typeMatches = lis.type === evt.type;
            var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive
            var listenerMatches = nsMatches && typeMatches && targetMatches;

            if( listenerMatches ){ // then trigger it
              var args = [ evt ];
              args = args.concat( extraParams ); // add extra params to args list

              if( lis.data ){ // add on data plugged into binding
                evt.data = lis.data;
              } else { // or clear it in case the event obj is reused
                evt.data = undefined;
              }

              if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                listeners.splice(k, 1);
                k--;
              }

              if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                var binders = lis.binders;
                for( var l = 0; l < binders.length; l++ ){
                  var binder = binders[l];
                  if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                  var binderListeners = binder._private.listeners;
                  for( var m = 0; m < binderListeners.length; m++ ){
                    var binderListener = binderListeners[m];

                    if( binderListener === lis ){ // delete listener from list
                      binderListeners.splice(m, 1);
                      m--;
                    }
                  }
                }
              }

              // run the callback
              var context = lis.delegated ? evt.cyTarget : triggerer;
              var ret = lis.callback.apply( context, args );

              if( ret === false || evt.isPropagationStopped() ){
                // then don't bubble
                bubbleUp = false;

                if( ret === false ){
                  // returning false is a shorthand for stopping propagation and preventing the def. action
                  evt.stopPropagation();
                  evt.preventDefault();
                }
              }
            } // if listener matches
          } // for each listener

          // bubble up event for elements
          if( bubbleUp ){
            var parent = hasCompounds ? triggerer._private.parent : null;
            var hasParent = parent != null && parent.length !== 0;

            if( hasParent ){ // then bubble up to parent
              parent = parent[0];
              parent.trigger(evt);
            } else { // otherwise, bubble up to the core
              cy.trigger(evt);
            }
          }

        } // for each of all
      } // for each event

      return self; // maintain chaining
    }; // function
  }, // trigger

  animated: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function animatedImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return false; }

      var ele = all[0];

      if( ele ){
        return ele._private.animation.current.length > 0;
      }
    };
  }, // animated

  clearQueue: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function clearQueueImpl(){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[i];
        ele._private.animation.queue = [];
      }

      return this;
    };
  }, // clearQueue

  delay: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function delayImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animate({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  }, // delay

  delayAnimation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function delayAnimationImpl( time, complete ){
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      return this.animation({
        delay: time,
        duration: time,
        complete: complete
      });
    };
  }, // delay

  animation: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function animationImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;
      var isCore = !selfIsArrayLike;
      var isEles = !isCore;

      if( !cy.styleEnabled() ){ return this; }

      var style = cy.style();

      properties = util.extend( {}, properties, params );

      if( properties.duration === undefined ){
        properties.duration = 400;
      }

      switch( properties.duration ){
      case 'slow':
        properties.duration = 600;
        break;
      case 'fast':
        properties.duration = 200;
        break;
      }

      var propertiesEmpty = true;
      if( properties ){ for( var i in properties ){ // jshint ignore:line
        propertiesEmpty = false;
        break;
      } }

      if( propertiesEmpty ){
        return new Animation( all[0], properties ); // nothing to animate
      }

      if( isEles ){
        properties.style = style.getPropsList( properties.style || properties.css );

        properties.css = undefined;
      }

      if( properties.renderedPosition && isEles ){
        var rpos = properties.renderedPosition;
        var pan = cy.pan();
        var zoom = cy.zoom();

        properties.position = {
          x: ( rpos.x - pan.x ) /zoom,
          y: ( rpos.y - pan.y ) /zoom
        };
      }

      // override pan w/ panBy if set
      if( properties.panBy && isCore ){
        var panBy = properties.panBy;
        var cyPan = cy.pan();

        properties.pan = {
          x: cyPan.x + panBy.x,
          y: cyPan.y + panBy.y
        };
      }

      // override pan w/ center if set
      var center = properties.center || properties.centre;
      if( center && isCore ){
        var centerPan = cy.getCenterPan( center.eles, properties.zoom );

        if( centerPan ){
          properties.pan = centerPan;
        }
      }

      // override pan & zoom w/ fit if set
      if( properties.fit && isCore ){
        var fit = properties.fit;
        var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

        if( fitVp ){
          properties.pan = fitVp.pan;
          properties.zoom = fitVp.zoom;
        }
      }

      return new Animation( all[0], properties );
    };
  }, // animate

  animate: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function animateImpl( properties, params ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      if( params ){
        properties = util.extend( {}, properties, params );
      }

      // manually hook and run the animation
      for( var i = 0; i < all.length; i++ ){
        var ele = all[i];
        var queue = ele.animated() && (properties.queue === undefined || properties.queue);

        var ani = ele.animation( properties, (queue ? { queue: true } : undefined) );

        ani.play();
      }

      return this; // chaining
    };
  }, // animate

  stop: function( fnParams ){
    var defaults = {};
    fnParams = util.extend({}, defaults, fnParams);

    return function stopImpl( clearQueue, jumpToEnd ){
      var self = this;
      var selfIsArrayLike = self.length !== undefined;
      var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
      var cy = this._private.cy || this;

      if( !cy.styleEnabled() ){ return this; }

      for( var i = 0; i < all.length; i++ ){
        var ele = all[i];
        var _p = ele._private;
        var anis = _p.animation.current;

        for( var j = 0; j < anis.length; j++ ){
          var ani = anis[j];
          var ani_p = ani._private;

          if( jumpToEnd ){
            // next iteration of the animation loop, the animation
            // will go straight to the end and be removed
            ani_p.duration = 0;
          }
        }

        // clear the queue of future animations
        if( clearQueue ){
          _p.animation.queue = [];
        }

        if( !jumpToEnd ){
          _p.animation.current = [];
        }
      }

      // we have to notify (the animation loop doesn't do it for us on `stop`)
      cy.notify({
        collection: this,
        type: 'draw'
      });

      return this;
    };
  } // stop

}; // define

module.exports = define;

},{"./animation":1,"./event":42,"./is":77,"./promise":80,"./selector":81,"./util":94}],42:[function(_dereq_,module,exports){
'use strict';

// ref
// https://github.com/jquery/jquery/blob/master/src/event.js

var Event = function( src, props ) {
  // Allow instantiation without the 'new' keyword
  if ( !(this instanceof Event) ) {
    return new Event( src, props );
  }

  // Event object
  if ( src && src.type ) {
    this.originalEvent = src;
    this.type = src.type;

    // Events bubbling up the document may have been marked as prevented
    // by a handler lower down the tree; reflect the correct value.
    this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

  // Event type
  } else {
    this.type = src;
  }

  // Put explicitly provided properties onto the event object
  if ( props ) {
    // util.extend( this, props );

    // more efficient to manually copy fields we use
    this.type = props.type !== undefined ? props.type : this.type;
    this.cy = props.cy;
    this.cyTarget = props.cyTarget;
    this.cyPosition = props.cyPosition;
    this.cyRenderedPosition = props.cyRenderedPosition;
    this.namespace = props.namespace;
    this.layout = props.layout;
    this.data = props.data;
    this.message = props.message;
  }

  // Create a timestamp if incoming event doesn't have one
  this.timeStamp = src && src.timeStamp || Date.now();
};

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
Event.prototype = {
  instanceString: function(){
    return 'event';
  },

  preventDefault: function() {
    this.isDefaultPrevented = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }

    // if preventDefault exists run it on the original event
    if ( e.preventDefault ) {
      e.preventDefault();
    }
  },

  stopPropagation: function() {
    this.isPropagationStopped = returnTrue;

    var e = this.originalEvent;
    if ( !e ) {
      return;
    }

    // if stopPropagation exists run it on the original event
    if ( e.stopPropagation ) {
      e.stopPropagation();
    }
  },

  stopImmediatePropagation: function() {
    this.isImmediatePropagationStopped = returnTrue;
    this.stopPropagation();
  },

  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse
};

module.exports = Event;

},{}],43:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('./util');
var define = _dereq_('./define');
var Collection = _dereq_('./collection');
var Core = _dereq_('./core');
var incExts = _dereq_('./extensions');
var is = _dereq_('./is');

// registered extensions to cytoscape, indexed by name
var extensions = {};

// registered modules for extensions, indexed by name
var modules = {};

function setExtension( type, name, registrant ){

  var ext = registrant;

  if( type === 'core' ){
    Core.prototype[ name ] = registrant;

  } else if( type === 'collection' ){
    Collection.prototype[ name ] = registrant;

  } else if( type === 'layout' ){
    // fill in missing layout functions in the prototype

    var Layout = function( options ){
      this.options = options;

      registrant.call( this, options );

      // make sure layout has _private for use w/ std apis like .on()
      if( !is.plainObject(this._private) ){
        this._private = {};
      }

      this._private.cy = options.cy;
      this._private.listeners = [];
    };

    var layoutProto = Layout.prototype = Object.create( registrant.prototype );

    var optLayoutFns = [];

    for( var i = 0; i < optLayoutFns.length; i++ ){
      var fnName = optLayoutFns[i];

      layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };
    }

    // either .start() or .run() is defined, so autogen the other
    if( layoutProto.start && !layoutProto.run ){
      layoutProto.run = function(){ this.start(); return this; };
    } else if( !layoutProto.start && layoutProto.run ){
      layoutProto.start = function(){ this.run(); return this; };
    }

    if( !layoutProto.stop ){
      layoutProto.stop = function(){
        var opts = this.options;

        if( opts && opts.animate ){
          var anis = this.animations;
          for( var i = 0; i < anis.length; i++ ){
            anis[i].stop();
          }
        }

        this.trigger('layoutstop');

        return this;
      };
    }

    if( !layoutProto.destroy ){
      layoutProto.destroy = function(){
        return this;
      };
    }

    layoutProto.on = define.on({ layout: true });
    layoutProto.one = define.on({ layout: true, unbindSelfOnTrigger: true });
    layoutProto.once = define.on({ layout: true, unbindAllBindersOnTrigger: true });
    layoutProto.off = define.off({ layout: true });
    layoutProto.trigger = define.trigger({ layout: true });

    define.eventAliasesOn( layoutProto );

    ext = Layout; // replace with our wrapped layout

  } else if( type === 'renderer' && name !== 'null' && name !== 'base' ){
    // user registered renderers inherit from base

    var bProto = getExtension( 'renderer', 'base' ).prototype;
    var rProto = registrant.prototype;

    for( var pName in bProto ){
      var pVal = bProto[ pName ];
      var existsInR = rProto[ pName ] != null;

      if( existsInR ){
        util.error('Can not register renderer `' + name + '` since it overrides `' + pName + '` in its prototype');
        return;
      }

      rProto[ pName ] = pVal; // take impl from base
    }

    bProto.clientFunctions.forEach(function( name ){
      rProto[ name ] = rProto[ name ] || function(){
        util.error('Renderer does not implement `renderer.' + name + '()` on its prototype');
      };
    });

  }

  return util.setMap({
    map: extensions,
    keys: [ type, name ],
    value: ext
  });
}

function getExtension(type, name){
  return util.getMap({
    map: extensions,
    keys: [ type, name ]
  });
}

function setModule(type, name, moduleType, moduleName, registrant){
  return util.setMap({
    map: modules,
    keys: [ type, name, moduleType, moduleName ],
    value: registrant
  });
}

function getModule(type, name, moduleType, moduleName){
  return util.getMap({
    map: modules,
    keys: [ type, name, moduleType, moduleName ]
  });
}

var extension = function(){
  // e.g. extension('renderer', 'svg')
  if( arguments.length === 2 ){
    return getExtension.apply(null, arguments);
  }

  // e.g. extension('renderer', 'svg', { ... })
  else if( arguments.length === 3 ){
    return setExtension.apply(null, arguments);
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse')
  else if( arguments.length === 4 ){
    return getModule.apply(null, arguments);
  }

  // e.g. extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
  else if( arguments.length === 5 ){
    return setModule.apply(null, arguments);
  }

  else {
    util.error('Invalid extension access syntax');
  }

};

// allows a core instance to access extensions internally
Core.prototype.extension = extension;

// included extensions
incExts.forEach(function( group ){
  group.extensions.forEach(function( ext ){
    setExtension( group.type, ext.name, ext.impl );
  });
});

module.exports = extension;

},{"./collection":23,"./core":34,"./define":41,"./extensions":44,"./is":77,"./util":94}],44:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  {
    type: 'layout',
    extensions: _dereq_('./layout')
  },

  {
    type: 'renderer',
    extensions: _dereq_('./renderer')
  }
];

},{"./layout":50,"./renderer":72}],45:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');
var is = _dereq_('../../is');

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
  padding: 30, // padding on fit
  circle: false, // put depths in concentric circles if true, put depths top down if false
  spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  roots: undefined, // the roots of the trees
  maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function BreadthFirstLayout( options ){
  this.options = util.extend({}, defaults, options);
}

BreadthFirstLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');
  var graph = eles;

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var roots;
  if( is.elementOrCollection(options.roots) ){
    roots = options.roots;
  } else if( is.array(options.roots) ){
    var rootsArray = [];

    for( var i = 0; i < options.roots.length; i++ ){
      var id = options.roots[i];
      var ele = cy.getElementById( id );
      rootsArray.push( ele );
    }

    roots = cy.collection( rootsArray );
  } else if( is.string(options.roots) ){
    roots = cy.$( options.roots );

  } else {
    if( options.directed ){
      roots = nodes.roots();
    } else {
      var components = [];
      var unhandledNodes = nodes;

      while( unhandledNodes.length > 0 ){
        var currComp = cy.collection();

        eles.bfs({
          roots: unhandledNodes[0],
          visit: function(i, depth, node, edge, pNode){
            currComp = currComp.add( node );
          },
          directed: false
        });

        unhandledNodes = unhandledNodes.not( currComp );
        components.push( currComp );
      }

      roots = cy.collection();
      for( var i = 0; i < components.length; i++ ){
        var comp = components[i];
        var maxDegree = comp.maxDegree( false );
        var compRoots = comp.filter(function(){
          return this.degree(false) === maxDegree;
        });

        roots = roots.add( compRoots );
      }

    }
  }


  var depths = [];
  var foundByBfs = {};
  var id2depth = {};
  var prevNode = {};
  var prevEdge = {};
  var successors = {};

  // find the depths of the nodes
  graph.bfs({
    roots: roots,
    directed: options.directed,
    visit: function(i, depth, node, edge, pNode){
      var ele = this[0];
      var id = ele.id();

      if( !depths[depth] ){
        depths[depth] = [];
      }

      depths[depth].push( ele );
      foundByBfs[ id ] = true;
      id2depth[ id ] = depth;
      prevNode[ id ] = pNode;
      prevEdge[ id ] = edge;

      if( pNode ){
        var prevId = pNode.id();
        var succ = successors[ prevId ] = successors[ prevId ] || [];

        succ.push( node );
      }
    }
  });

  // check for nodes not found by bfs
  var orphanNodes = [];
  for( var i = 0; i < nodes.length; i++ ){
    var ele = nodes[i];

    if( foundByBfs[ ele.id() ] ){
      continue;
    } else {
      orphanNodes.push( ele );
    }
  }

  // assign orphan nodes a depth from their neighborhood
  var maxChecks = orphanNodes.length * 3;
  var checks = 0;
  while( orphanNodes.length !== 0 && checks < maxChecks ){
    var node = orphanNodes.shift();
    var neighbors = node.neighborhood().nodes();
    var assignedDepth = false;

    for( var i = 0; i < neighbors.length; i++ ){
      var depth = id2depth[ neighbors[i].id() ];

      if( depth !== undefined ){
        depths[depth].push( node );
        assignedDepth = true;
        break;
      }
    }

    if( !assignedDepth ){
      orphanNodes.push( node );
    }

    checks++;
  }

  // assign orphan nodes that are still left to the depth of their subgraph
  while( orphanNodes.length !== 0 ){
    var node = orphanNodes.shift();
    //var subgraph = graph.bfs( node ).path;
    var assignedDepth = false;

    // for( var i = 0; i < subgraph.length; i++ ){
    //   var depth = id2depth[ subgraph[i].id() ];

    //   if( depth !== undefined ){
    //     depths[depth].push( node );
    //     assignedDepth = true;
    //     break;
    //   }
    // }

    if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
      if( depths.length === 0 ){
        depths.push([]);
      }

      depths[0].push( node );
    }
  }

  // assign the nodes a depth and index
  var assignDepthsToEles = function(){
    for( var i = 0; i < depths.length; i++ ){
      var eles = depths[i];

      for( var j = 0; j < eles.length; j++ ){
        var ele = eles[j];

        ele._private.scratch.breadthfirst = {
          depth: i,
          index: j
        };
      }
    }
  };
  assignDepthsToEles();


  var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
    var edges = node.connectedEdges(function(){
      return this.data('target') === node.id();
    });
    var thisInfo = node._private.scratch.breadthfirst;
    var highestDepthOfOther = 0;
    var highestOther;
    for( var i = 0; i < edges.length; i++ ){
      var edge = edges[i];
      var otherNode = edge.source()[0];
      var otherInfo = otherNode._private.scratch.breadthfirst;

      if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
        highestDepthOfOther = otherInfo.depth;
        highestOther = otherNode;
      }
    }

    return highestOther;
  };

   // make maximal if so set by adjusting depths
  for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

    var nDepths = depths.length;
    var elesToMove = [];
    for( var i = 0; i < nDepths; i++ ){
      var depth = depths[i];

      var nDepth = depth.length;
      for( var j = 0; j < nDepth; j++ ){
        var ele = depth[j];
        var info = ele._private.scratch.breadthfirst;
        var intEle = intersectsDepth(ele);

        if( intEle ){
          info.intEle = intEle;
          elesToMove.push( ele );
        }
      }
    }

    for( var i = 0; i < elesToMove.length; i++ ){
      var ele = elesToMove[i];
      var info = ele._private.scratch.breadthfirst;
      var intEle = info.intEle;
      var intInfo = intEle._private.scratch.breadthfirst;

      depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

      // add to end of new depth
      var newDepth = intInfo.depth + 1;
      while( newDepth > depths.length - 1 ){
        depths.push([]);
      }
      depths[ newDepth ].push( ele );

      info.depth = newDepth;
      info.index = depths[newDepth].length - 1;
    }

    assignDepthsToEles();
  }

  // find min distance we need to leave between nodes
  var minDistance = 0;
  if( options.avoidOverlap ){
    for( var i = 0; i < nodes.length; i++ ){
      var n = nodes[i];
      var nbb = n.boundingBox();
      var w = nbb.w;
      var h = nbb.h;

      minDistance = Math.max(minDistance, w, h);
    }
    minDistance *= options.spacingFactor; // just to have some nice spacing
  }

  // get the weighted percent for an element based on its connectivity to other levels
  var cachedWeightedPercent = {};
  var getWeightedPercent = function( ele ){
    if( cachedWeightedPercent[ ele.id() ] ){
      return cachedWeightedPercent[ ele.id() ];
    }

    var eleDepth = ele._private.scratch.breadthfirst.depth;
    var neighbors = ele.neighborhood().nodes().not(':parent');
    var percent = 0;
    var samples = 0;

    for( var i = 0; i < neighbors.length; i++ ){
      var neighbor = neighbors[i];
      var bf = neighbor._private.scratch.breadthfirst;
      var index = bf.index;
      var depth = bf.depth;
      var nDepth = depths[depth].length;

      if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
        percent += index / nDepth;
        samples++;
      }
    }

    samples = Math.max(1, samples);
    percent = percent / samples;

    if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
      percent = undefined;
    }

    cachedWeightedPercent[ ele.id() ] = percent;
    return percent;
  };


  // rearrange the indices in each depth level based on connectivity

  var sortFn = function(a, b){
    var apct = getWeightedPercent( a );
    var bpct = getWeightedPercent( b );

    return apct - bpct;
  };

  for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

    for( var i = 0; i < depths.length; i++ ){
      depths[i] = depths[i].sort( sortFn );
    }
    assignDepthsToEles(); // and update

  }

  var biggestDepthSize = 0;
  for( var i = 0; i < depths.length; i++ ){
    biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );
  }

  var center = {
    x: bb.x1 + bb.w/2,
    y: bb.x1 + bb.h/2
  };

  var getPosition = function( ele, isBottomDepth ){
    var info = ele._private.scratch.breadthfirst;
    var depth = info.depth;
    var index = info.index;
    var depthSize = depths[depth].length;

    var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
    var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
    var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
    radiusStepSize = Math.max( radiusStepSize, minDistance );

    if( !options.circle ){

      var epos = {
        x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
        y: (depth + 1) * distanceY
      };

      if( isBottomDepth ){
        return epos;
      }

      // var succs = successors[ ele.id() ];
      // if( succs ){
      //   epos.x = 0;
      //
      //   for( var i = 0 ; i < succs.length; i++ ){
      //     var spos = pos[ succs[i].id() ];
      //
      //     epos.x += spos.x;
      //   }
      //
      //   epos.x /= succs.length;
      // } else {
      //   //debugger;
      // }

      return epos;

    } else {
      if( options.circle ){
        var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
        var theta = 2 * Math.PI / depths[depth].length * index;

        if( depth === 0 && depths[0].length === 1 ){
          radius = 1;
        }

        return {
          x: center.x + radius * Math.cos(theta),
          y: center.y + radius * Math.sin(theta)
        };

      } else {
        return {
          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
          y: (depth + 1) * distanceY
        };
      }
    }

  };

  // get positions in reverse depth order
  var pos = {};
  for( var i = depths.length - 1; i >=0; i-- ){
    var depth = depths[i];

    for( var j = 0; j < depth.length; j++ ){
      var node = depth[j];

      pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
    }
  }

  nodes.layoutPositions(this, options, function(){
    return pos[ this.id() ];
  });

  return this; // chaining
};

module.exports = BreadthFirstLayout;

},{"../../is":77,"../../math":79,"../../util":94}],46:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');
var is = _dereq_('../../is');

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
  radius: undefined, // the radius of the circle
  startAngle: 3/2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function CircleLayout( options ){
  this.options = util.extend({}, defaults, options);
}

CircleLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var nodes = eles.nodes().not(':parent');

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w/2,
    y: bb.y1 + bb.h/2
  };

  var sweep = options.sweep === undefined ? 2*Math.PI - 2*Math.PI/nodes.length : options.sweep;

  var dTheta = sweep / ( Math.max(1, nodes.length - 1) );
  var r;

  var minDistance = 0;
  for( var i = 0; i < nodes.length; i++ ){
    var n = nodes[i];
    var nbb = n.boundingBox();
    var w = nbb.w;
    var h = nbb.h;

    minDistance = Math.max(minDistance, w, h);
  }

  if( is.number(options.radius) ){
    r = options.radius;
  } else if( nodes.length <= 1 ){
    r = 0;
  } else {
    r = Math.min( bb.h, bb.w )/2 - minDistance;
  }

  // calculate the radius
  if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
    minDistance *= 1.75; // just to have some nice spacing

    var dcos = Math.cos(dTheta) - Math.cos(0);
    var dsin = Math.sin(dTheta) - Math.sin(0);
    var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
    r = Math.max( rMin, r );
  }

  var getPos = function( i, ele ){
    var theta = options.startAngle + i * dTheta * ( clockwise ? 1 : -1 );

    var rx = r * Math.cos( theta );
    var ry = r * Math.sin( theta );
    var pos = {
      x: center.x + rx,
      y: center.y + ry
    };

    return pos;
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = CircleLayout;

},{"../../is":77,"../../math":79,"../../util":94}],47:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // the padding on fit
  startAngle: 3/2 * Math.PI, // where nodes start in radians
  sweep: undefined, // how many radians should be between the first and last node (defaults to full circle)
  clockwise: true, // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)
  equidistant: false, // whether levels have an equal radial distance betwen them, may cause bounding box overflow
  minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  height: undefined, // height of layout area (overrides container height)
  width: undefined, // width of layout area (overrides container width)
  concentric: function(node){ // returns numeric value for each node, placing higher nodes in levels towards the centre
    return node.degree();
  },
  levelWidth: function(nodes){ // the variation of concentric values in each level
    return nodes.maxDegree() / 4;
  },
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function ConcentricLayout( options ){
  this.options = util.extend({}, defaults, options);
}

ConcentricLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;

  var cy = params.cy;

  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var center = {
    x: bb.x1 + bb.w/2,
    y: bb.y1 + bb.h/2
  };

  var nodeValues = []; // { node, value }
  var theta = options.startAngle;
  var maxNodeSize = 0;

  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[i];
    var value;

    // calculate the node value
    value = options.concentric.apply(node, [ node ]);
    nodeValues.push({
      value: value,
      node: node
    });

    // for style mapping
    node._private.scratch.concentric = value;
  }

  // in case we used the `concentric` in style
  nodes.updateStyle();

  // calculate max size now based on potentially updated mappers
  for( var i = 0; i < nodes.length; i++ ){
    var node = nodes[i];
    var nbb = node.boundingBox();

    maxNodeSize = Math.max( maxNodeSize, nbb.w, nbb.h );
  }

  // sort node values in descreasing order
  nodeValues.sort(function(a, b){
    return b.value - a.value;
  });

  var levelWidth = options.levelWidth( nodes );

  // put the values into levels
  var levels = [ [] ];
  var currentLevel = levels[0];
  for( var i = 0; i < nodeValues.length; i++ ){
    var val = nodeValues[i];

    if( currentLevel.length > 0 ){
      var diff = Math.abs( currentLevel[0].value - val.value );

      if( diff >= levelWidth ){
        currentLevel = [];
        levels.push( currentLevel );
      }
    }

    currentLevel.push( val );
  }

  // create positions from levels

  var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

  if( !options.avoidOverlap ){ // then strictly constrain to bb
    var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
    var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );
    var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

    minDist = Math.min( minDist, rStep );
  }

  // find the metrics for each level
  var r = 0;
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[i];
    var sweep = options.sweep === undefined ? 2*Math.PI - 2*Math.PI/level.length : options.sweep;
    var dTheta = level.dTheta = sweep / ( Math.max(1, level.length - 1) );

    // calculate the radius
    if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping

      r = Math.max( rMin, r );
    }

    level.r = r;

    r += minDist;
  }

  if( options.equidistant ){
    var rDeltaMax = 0;
    var r = 0;

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];
      var rDelta = level.r - r;

      rDeltaMax = Math.max( rDeltaMax, rDelta );
    }

    r = 0;
    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];

      if( i === 0 ){
        r = level.r;
      }

      level.r = r;

      r += rDeltaMax;
    }
  }

  // calculate the node positions
  var pos = {}; // id => position
  for( var i = 0; i < levels.length; i++ ){
    var level = levels[i];
    var dTheta = level.dTheta;
    var r = level.r;

    for( var j = 0; j < level.length; j++ ){
      var val = level[j];
      var theta = options.startAngle + (clockwise ? 1 : -1) * dTheta * j;

      var p = {
        x: center.x + r * Math.cos(theta),
        y: center.y + r * Math.sin(theta)
      };

      pos[ val.node.id() ] = p;
    }
  }

  // position the nodes
  nodes.layoutPositions(this, options, function(){
    var id = this.id();

    return pos[id];
  });

  return this; // chaining
};

module.exports = ConcentricLayout;

},{"../../math":79,"../../util":94}],48:[function(_dereq_,module,exports){
'use strict';

/*
The CoSE layout was written by Gerardo Huck.
https://www.linkedin.com/in/gerardohuck/

Based on the following article:
http://dl.acm.org/citation.cfm?id=1498047

Modifications tracked on Github.
*/

var util = _dereq_('../../util');
var math = _dereq_('../../math');
var Thread = _dereq_('../../thread');
var is = _dereq_('../../is');

var DEBUG;

/**
 * @brief :  default layout options
 */
var defaults = {
  // Called on `layoutready`
  ready               : function() {},

  // Called on `layoutstop`
  stop                : function() {},

  // Whether to animate while running the layout
  animate             : true,

  // The layout animates only after this many milliseconds
  // (prevents flashing on fast runs)
  animationThreshold  : 250,

  // Number of iterations between consecutive screen positions update
  // (0 -> only updated on the end)
  refresh             : 20,

  // Whether to fit the network view after when done
  fit                 : true,

  // Padding on fit
  padding             : 30,

  // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  boundingBox         : undefined,

  // Extra spacing between components in non-compound graphs
  componentSpacing    : 100,

  // Node repulsion (non overlapping) multiplier
  nodeRepulsion       : function( node ){ return 400000; },

  // Node repulsion (overlapping) multiplier
  nodeOverlap         : 10,

  // Ideal edge (non nested) length
  idealEdgeLength     : function( edge ){ return 10; },

  // Divisor to compute edge forces
  edgeElasticity      : function( edge ){ return 100; },

  // Nesting factor (multiplier) to compute ideal edge length for nested edges
  nestingFactor       : 5,

  // Gravity force (constant)
  gravity             : 80,

  // Maximum number of iterations to perform
  numIter             : 1000,

  // Initial temperature (maximum node displacement)
  initialTemp         : 200,

  // Cooling factor (how the temperature is reduced between consecutive iterations
  coolingFactor       : 0.95,

  // Lower temperature threshold (below this point the layout will end)
  minTemp             : 1.0,

  // Whether to use threading to speed up the layout
  useMultitasking     : true
};


/**
 * @brief       : constructor
 * @arg options : object containing layout options
 */
function CoseLayout(options) {
  this.options = util.extend({}, defaults, options);

  this.options.layout = this;
}


/**
 * @brief : runs the layout
 */
CoseLayout.prototype.run = function() {
  var options = this.options;
  var cy      = options.cy;
  var layout  = this;
  var thread  = this.thread;

  if( !thread || thread.stopped() ){
    thread = this.thread = Thread({ disabled: !options.useMultitasking });
  }

  layout.stopped = false;

  layout.trigger({ type: 'layoutstart', layout: layout });

  // Set DEBUG - Global variable
  if (true === options.debug) {
    DEBUG = true;
  } else {
    DEBUG = false;
  }

  // Initialize layout info
  var layoutInfo = createLayoutInfo(cy, layout, options);

  // Show LayoutInfo contents if debugging
  if (DEBUG) {
    printLayoutInfo(layoutInfo);
  }

  // If required, randomize node positions
  // if (true === options.randomize) {
    randomizePositions(layoutInfo, cy);
  // }

  var startTime = Date.now();
  var refreshRequested = false;
  var refresh = function( rOpts ){
    rOpts = rOpts || {};

    if( refreshRequested ){
      return;
    }

    if( !rOpts.force && Date.now() - startTime < options.animationThreshold ){
      return;
    }

    refreshRequested = true;

    util.requestAnimationFrame(function(){
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit( options.padding );
      }

      refreshRequested = false;

      if( rOpts.next ){ rOpts.next(); }
    });
  };

  thread.on('message', function( e ){
    var layoutNodes = e.message;

    layoutInfo.layoutNodes = layoutNodes;
    refresh();
  });

  thread.pass({
    layoutInfo: layoutInfo,
    options: {
      animate: options.animate,
      refresh: options.refresh,
      componentSpacing: options.componentSpacing,
      nodeOverlap: options.nodeOverlap,
      nestingFactor: options.nestingFactor,
      gravity: options.gravity,
      numIter: options.numIter,
      initialTemp: options.initialTemp,
      coolingFactor: options.coolingFactor,
      minTemp: options.minTemp
    }
  }).run(function( pass ){
    var layoutInfo = pass.layoutInfo;
    var options = pass.options;
    var stopped = false;

    /**
     * @brief          : Performs one iteration of the physical simulation
     * @arg layoutInfo : LayoutInfo object already initialized
     * @arg cy         : Cytoscape object
     * @arg options    : Layout options
     */
    var step = function(layoutInfo, options, step) {
      // var s = "\n\n###############################";
      // s += "\nSTEP: " + step;
      // s += "\n###############################\n";
      // logDebug(s);

      // Calculate node repulsions
      calculateNodeForces(layoutInfo, options);
      // Calculate edge forces
      calculateEdgeForces(layoutInfo, options);
      // Calculate gravity forces
      calculateGravityForces(layoutInfo, options);
      // Propagate forces from parent to child
      propagateForces(layoutInfo, options);
      // Update positions based on calculated forces
      updatePositions(layoutInfo, options);
    };

    /**
     * @brief : Computes the node repulsion forces
     */
    var calculateNodeForces = function(layoutInfo, options) {
      // Go through each of the graphs in graphSet
      // Nodes only repel each other if they belong to the same graph
      // var s = 'calculateNodeForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
        var graph    = layoutInfo.graphSet[i];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Now get all the pairs of nodes
        // Only get each pair once, (A, B) = (B, A)
        for (var j = 0; j < numNodes; j++) {
          var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];

          for (var k = j + 1; k < numNodes; k++) {
            var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];

            nodeRepulsion(node1, node2, layoutInfo, options);
          }
        }
      }
    };

    /**
     * @brief : Compute the node repulsion forces between a pair of nodes
     */
    var nodeRepulsion = function(node1, node2, layoutInfo, options) {
      // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

      var cmptId1 = node1.cmptId;
      var cmptId2 = node2.cmptId;

      if( cmptId1 !== cmptId2 && !layoutInfo.isCompound ){ return; }

      // Get direction of line connecting both node centers
      var directionX = node2.positionX - node1.positionX;
      var directionY = node2.positionY - node1.positionY;
      // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

      // If both centers are the same, apply a random force
      if (0 === directionX && 0 === directionY) {
        // s += "\nNodes have the same position.";
        return; // TODO could be improved with random force
      }

      var overlap = nodesOverlap(node1, node2, directionX, directionY);

      if (overlap > 0) {
        // s += "\nNodes DO overlap.";
        // s += "\nOverlap: " + overlap;
        // If nodes overlap, repulsion force is proportional
        // to the overlap
        var force    = options.nodeOverlap * overlap;

        // Compute the module and components of the force vector
        var distance = Math.sqrt(directionX * directionX + directionY * directionY);
        // s += "\nDistance: " + distance;
        var forceX   = force * directionX / distance;
        var forceY   = force * directionY / distance;

      } else {
        // s += "\nNodes do NOT overlap.";
        // If there's no overlap, force is inversely proportional
        // to squared distance

        // Get clipping points for both nodes
        var point1 = findClippingPoint(node1, directionX, directionY);
        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

        // Use clipping points to compute distance
        var distanceX   = point2.x - point1.x;
        var distanceY   = point2.y - point1.y;
        var distanceSqr = distanceX * distanceX + distanceY * distanceY;
        var distance    = Math.sqrt(distanceSqr);
        // s += "\nDistance: " + distance;

        // Compute the module and components of the force vector
        var force  = ( node1.nodeRepulsion + node2.nodeRepulsion ) / distanceSqr;
        var forceX = force * distanceX / distance;
        var forceY = force * distanceY / distance;
      }

      // Apply force
      if( !node1.isLocked ){
        node1.offsetX -= forceX;
        node1.offsetY -= forceY;
      }

      if( !node2.isLocked ){
        node2.offsetX += forceX;
        node2.offsetY += forceY;
      }

      // s += "\nForceX: " + forceX + " ForceY: " + forceY;
      // logDebug(s);

      return;
    };

    /**
     * @brief  : Determines whether two nodes overlap or not
     * @return : Amount of overlapping (0 => no overlap)
     */
    var nodesOverlap = function(node1, node2, dX, dY) {

      if (dX > 0) {
        var overlapX = node1.maxX - node2.minX;
      } else {
        var overlapX = node2.maxX - node1.minX;
      }

      if (dY > 0) {
        var overlapY = node1.maxY - node2.minY;
      } else {
        var overlapY = node2.maxY - node1.minY;
      }

      if (overlapX >= 0 && overlapY >= 0) {
        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
      } else {
        return 0;
      }
    };

    /**
     * @brief : Finds the point in which an edge (direction dX, dY) intersects
     *          the rectangular bounding box of it's source/target node
     */
    var findClippingPoint = function(node, dX, dY) {

      // Shorcuts
      var X = node.positionX;
      var Y = node.positionY;
      var H = node.height || 1;
      var W = node.width || 1;
      var dirSlope     = dY / dX;
      var nodeSlope    = H / W;

      // var s = 'Computing clipping point of node ' + node.id +
      //   " . Height:  " + H + ", Width: " + W +
      //   "\nDirection " + dX + ", " + dY;
      //
      // Compute intersection
      var res = {};
      do {
        // Case: Vertical direction (up)
        if (0 === dX && 0 < dY) {
          res.x = X;
          // s += "\nUp direction";
          res.y = Y + H / 2;
          break;
        }

        // Case: Vertical direction (down)
        if (0 === dX && 0 > dY) {
          res.x = X;
          res.y = Y + H / 2;
          // s += "\nDown direction";
          break;
        }

        // Case: Intersects the right border
        if (0 < dX &&
        -1 * nodeSlope <= dirSlope &&
        dirSlope <= nodeSlope) {
          res.x = X + W / 2;
          res.y = Y + (W * dY / 2 / dX);
          // s += "\nRightborder";
          break;
        }

        // Case: Intersects the left border
        if (0 > dX &&
        -1 * nodeSlope <= dirSlope &&
        dirSlope <= nodeSlope) {
          res.x = X - W / 2;
          res.y = Y - (W * dY / 2 / dX);
          // s += "\nLeftborder";
          break;
        }

        // Case: Intersects the top border
        if (0 < dY &&
        ( dirSlope <= -1 * nodeSlope ||
          dirSlope >= nodeSlope )) {
          res.x = X + (H * dX / 2 / dY);
          res.y = Y + H / 2;
          // s += "\nTop border";
          break;
        }

        // Case: Intersects the bottom border
        if (0 > dY &&
        ( dirSlope <= -1 * nodeSlope ||
          dirSlope >= nodeSlope )) {
          res.x = X - (H * dX / 2 / dY);
          res.y = Y - H / 2;
          // s += "\nBottom border";
          break;
        }

      } while (false);

      // s += "\nClipping point found at " + res.x + ", " + res.y;
      // logDebug(s);
      return res;
    };

    /**
     * @brief : Calculates all edge forces
     */
    var calculateEdgeForces = function(layoutInfo, options) {
      // Iterate over all edges
      for (var i = 0; i < layoutInfo.edgeSize; i++) {
        // Get edge, source & target nodes
        var edge     = layoutInfo.layoutEdges[i];
        var sourceIx = layoutInfo.idToIndex[edge.sourceId];
        var source   = layoutInfo.layoutNodes[sourceIx];
        var targetIx = layoutInfo.idToIndex[edge.targetId];
        var target   = layoutInfo.layoutNodes[targetIx];

        // Get direction of line connecting both node centers
        var directionX = target.positionX - source.positionX;
        var directionY = target.positionY - source.positionY;

        // If both centers are the same, do nothing.
        // A random force has already been applied as node repulsion
        if (0 === directionX && 0 === directionY) {
        return;
        }

        // Get clipping points for both nodes
        var point1 = findClippingPoint(source, directionX, directionY);
        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);


        var lx = point2.x - point1.x;
        var ly = point2.y - point1.y;
        var l  = Math.sqrt(lx * lx + ly * ly);

        var force  = Math.pow(edge.idealLength - l, 2) / edge.elasticity;

        if (0 !== l) {
          var forceX = force * lx / l;
          var forceY = force * ly / l;
        } else {
          var forceX = 0;
          var forceY = 0;
        }

        // Add this force to target and source nodes
        if( !source.isLocked ){
          source.offsetX += forceX;
          source.offsetY += forceY;
        }

        if( !target.isLocked ){
          target.offsetX -= forceX;
          target.offsetY -= forceY;
        }

        // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
        // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
        // logDebug(s);
      }
    };

    /**
     * @brief : Computes gravity forces for all nodes
     */
    var calculateGravityForces = function(layoutInfo, options) {
      var distThreshold = 1;

      // var s = 'calculateGravityForces';
      // logDebug(s);
      for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
        var graph    = layoutInfo.graphSet[i];
        var numNodes = graph.length;

        // s = "Set: " + graph.toString();
        // logDebug(s);

        // Compute graph center
        if (0 === i) {
          var centerX   = layoutInfo.clientHeight / 2;
          var centerY   = layoutInfo.clientWidth  / 2;
        } else {
          // Get Parent node for this graph, and use its position as center
          var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
          var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
          var centerX = parent.positionX;
          var centerY = parent.positionY;
        }
        // s = "Center found at: " + centerX + ", " + centerY;
        // logDebug(s);

        // Apply force to all nodes in graph
        for (var j = 0; j < numNodes; j++) {
          var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
          // s = "Node: " + node.id;

          if( node.isLocked ){ continue; }

          var dx = centerX - node.positionX;
          var dy = centerY - node.positionY;
          var d  = Math.sqrt(dx * dx + dy * dy);
          if (d > distThreshold) {
            var fx = options.gravity * dx / d;
            var fy = options.gravity * dy / d;
            node.offsetX += fx;
            node.offsetY += fy;
            // s += ": Applied force: " + fx + ", " + fy;
          } else {
            // s += ": skypped since it's too close to center";
          }
          // logDebug(s);
        }
      }
    };

    /**
     * @brief          : This function propagates the existing offsets from
     *                   parent nodes to its descendents.
     * @arg layoutInfo : layoutInfo Object
     * @arg cy         : cytoscape Object
     * @arg options    : Layout options
     */
    var propagateForces = function(layoutInfo, options) {
      // Inline implementation of a queue, used for traversing the graph in BFS order
      var queue = [];
      var start = 0;   // Points to the start the queue
      var end   = -1;  // Points to the end of the queue

      // logDebug('propagateForces');

      // Start by visiting the nodes in the root graph
      queue.push.apply(queue, layoutInfo.graphSet[0]);
      end += layoutInfo.graphSet[0].length;

      // Traverse the graph, level by level,
      while (start <= end) {
        // Get the node to visit and remove it from queue
        var nodeId    = queue[start++];
        var nodeIndex = layoutInfo.idToIndex[nodeId];
        var node      = layoutInfo.layoutNodes[nodeIndex];
        var children  = node.children;

        // We only need to process the node if it's compound
        if (0 < children.length && !node.isLocked) {
          var offX = node.offsetX;
          var offY = node.offsetY;

          // var s = "Propagating offset from parent node : " + node.id +
          //   ". OffsetX: " + offX + ". OffsetY: " + offY;
          // s += "\n Children: " + children.toString();
          // logDebug(s);

          for (var i = 0; i < children.length; i++) {
            var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
            // Propagate offset
            childNode.offsetX += offX;
            childNode.offsetY += offY;
            // Add children to queue to be visited
            queue[++end] = children[i];
          }

          // Reset parent offsets
          node.offsetX = 0;
          node.offsetY = 0;
        }

      }
    };

    /**
     * @brief : Updates the layout model positions, based on
     *          the accumulated forces
     */
    var updatePositions = function(layoutInfo, options) {
      // var s = 'Updating positions';
      // logDebug(s);

      // Reset boundaries for compound nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length) {
          // logDebug("Resetting boundaries of compound node: " + n.id);
          n.maxX = undefined;
          n.minX = undefined;
          n.maxY = undefined;
          n.minY = undefined;
        }
      }

      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if (0 < n.children.length || n.isLocked) {
          // No need to set compound or locked node position
          // logDebug("Skipping position update of node: " + n.id);
          continue;
        }
        // s = "Node: " + n.id + " Previous position: (" +
        // n.positionX + ", " + n.positionY + ").";

        // Limit displacement in order to improve stability
        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
        n.positionX += tempForce.x;
        n.positionY += tempForce.y;
        n.offsetX = 0;
        n.offsetY = 0;
        n.minX    = n.positionX - n.width;
        n.maxX    = n.positionX + n.width;
        n.minY    = n.positionY - n.height;
        n.maxY    = n.positionY + n.height;
        // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
        // logDebug(s);

        // Update ancestry boudaries
        updateAncestryBoundaries(n, layoutInfo);
      }

      // Update size, position of compund nodes
      for (var i = 0; i < layoutInfo.nodeSize; i++) {
        var n = layoutInfo.layoutNodes[i];
        if ( 0 < n.children.length && !n.isLocked ) {
          n.positionX = (n.maxX + n.minX) / 2;
          n.positionY = (n.maxY + n.minY) / 2;
          n.width     = n.maxX - n.minX;
          n.height    = n.maxY - n.minY;
          // s = "Updating position, size of compound node " + n.id;
          // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
          // s += "\nWidth: " + n.width + ", Height: " + n.height;
          // logDebug(s);
        }
      }
    };

    /**
     * @brief : Limits a force (forceX, forceY) to be not
     *          greater (in modulo) than max.
     8          Preserves force direction.
     */
    var limitForce = function(forceX, forceY, max) {
      // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
      var force = Math.sqrt(forceX * forceX + forceY * forceY);

      if (force > max) {
        var res = {
        x : max * forceX / force,
        y : max * forceY / force
        };

      } else {
        var res = {
        x : forceX,
        y : forceY
        };
      }

      // s += ".\nResult: (" + res.x + ", " + res.y + ")";
      // logDebug(s);

      return res;
    };

    /**
     * @brief : Function used for keeping track of compound node
     *          sizes, since they should bound all their subnodes.
     */
    var updateAncestryBoundaries = function(node, layoutInfo) {
      // var s = "Propagating new position/size of node " + node.id;
      var parentId = node.parentId;
      if (null == parentId) {
        // If there's no parent, we are done
        // s += ". No parent node.";
        // logDebug(s);
        return;
      }

      // Get Parent Node
      var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
      var flag = false;

      // MaxX
      if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
        p.maxX = node.maxX + p.padRight;
        flag = true;
        // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
      }

      // MinX
      if (null == p.minX || node.minX - p.padLeft < p.minX) {
        p.minX = node.minX - p.padLeft;
        flag = true;
        // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
      }

      // MaxY
      if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
        p.maxY = node.maxY + p.padBottom;
        flag = true;
        // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
      }

      // MinY
      if (null == p.minY || node.minY - p.padTop < p.minY) {
        p.minY = node.minY - p.padTop;
        flag = true;
        // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
      }

      // If updated boundaries, propagate changes upward
      if (flag) {
        // logDebug(s);
        return updateAncestryBoundaries(p, layoutInfo);
      }

      // s += ". No changes in boundaries/position of parent node " + p.id;
      // logDebug(s);
      return;
    };

    var separateComponents = function(layutInfo, options){
      var nodes = layoutInfo.layoutNodes;
      var components = [];

      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var cid = node.cmptId;
        var component = components[ cid ] = components[ cid ] || [];

        component.push( node );
      }

      var totalA = 0;

      for( var i = 0; i < components.length; i++ ){
        var c = components[i];
        c.x1 = Infinity;
        c.x2 = -Infinity;
        c.y1 = Infinity;
        c.y2 = -Infinity;

        for( var j = 0; j < c.length; j++ ){
          var n = c[j];

          c.x1 = Math.min( c.x1, n.positionX - n.width/2 );
          c.x2 = Math.max( c.x2, n.positionX + n.width/2 );
          c.y1 = Math.min( c.y1, n.positionY - n.height/2 );
          c.y2 = Math.max( c.y2, n.positionY + n.height/2 );
        }

        c.w = c.x2 - c.x1;
        c.h = c.y2 - c.y1;

        totalA += c.w * c.h;
      }

      components.sort(function( c1, c2 ){
        return c2.w*c2.h - c1.w*c1.h;
      });

      var x = 0;
      var y = 0;
      var usedW = 0;
      var rowH = 0;
      var maxRowW = Math.sqrt( totalA ) * layoutInfo.clientWidth / layoutInfo.clientHeight;

      for( var i = 0; i < components.length; i++ ){
        var c = components[i];

        for( var j = 0; j < c.length; j++ ){
          var n = c[j];

          if( !n.isLocked ){
            n.positionX += x;
            n.positionY += y;
          }
        }

        x += c.w + options.componentSpacing;
        usedW += c.w + options.componentSpacing;
        rowH = Math.max( rowH, c.h );

        if( usedW > maxRowW ){
          y += rowH + options.componentSpacing;
          x = 0;
          usedW = 0;
          rowH = 0;
        }
      }
    };

    var mainLoop = function(i){
      if( stopped ){
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, options, i);

      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var i = 0;
    var loopRet;

    do {
      var f = 0;

      while( f < options.refresh && i < options.numIter ){
        var loopRet = mainLoop(i);
        if( !loopRet ){ break; }

        f++;
        i++;
      }

      if( options.animate ){
        broadcast( layoutInfo.layoutNodes ); // jshint ignore:line
      }

    } while ( loopRet && i + 1 < options.numIter );

    separateComponents( layoutInfo, options );

    return layoutInfo;
  }).then(function( layoutInfoUpdated ){
    layoutInfo.layoutNodes = layoutInfoUpdated.layoutNodes; // get the positions

    thread.stop();
    done();
  });

  var done = function(){
    refresh({ 
      force: true,
      next: function(){
        // Layout has finished
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }
    });
  };

  return this; // chaining
};


/**
 * @brief : called on continuous layouts to stop them before they finish
 */
CoseLayout.prototype.stop = function(){
  this.stopped = true;

  if( this.thread ){
    this.thread.stop();
  }

  this.trigger('layoutstop');

  return this; // chaining
};

CoseLayout.prototype.destroy = function(){
  if( this.thread ){
    this.thread.stop();
  }

  return this; // chaining
};


/**
 * @brief     : Creates an object which is contains all the data
 *              used in the layout process
 * @arg cy    : cytoscape.js object
 * @return    : layoutInfo object initialized
 */
var createLayoutInfo = function(cy, layout, options) {
  // Shortcut
  var edges = options.eles.edges();
  var nodes = options.eles.nodes();

  var layoutInfo   = {
    isCompound   : cy.hasCompoundNodes(),
    layoutNodes  : [],
    idToIndex    : {},
    nodeSize     : nodes.size(),
    graphSet     : [],
    indexToGraph : [],
    layoutEdges  : [],
    edgeSize     : edges.size(),
    temperature  : options.initialTemp,
    clientWidth  : cy.width(),
    clientHeight : cy.width(),
    boundingBox  : math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                     x1: 0, y1: 0, w: cy.width(), h: cy.height()
                   } )
  };

  var components = options.eles.components();
  var id2cmptId = {};

  for( var i = 0; i < components.length; i++ ){
    var component = components[i];

    for( var j = 0; j < component.length; j++ ){
      var node = component[j];

      id2cmptId[ node.id() ] = i;
    }
  }

  // Iterate over all nodes, creating layout nodes
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = nodes[i];
    var nbb = n.boundingBox();

    var tempNode        = {};
    tempNode.isLocked   = n.locked();
    tempNode.id         = n.data('id');
    tempNode.parentId   = n.data('parent');
    tempNode.cmptId     = id2cmptId[ n.id() ];
    tempNode.children   = [];
    tempNode.positionX  = n.position('x');
    tempNode.positionY  = n.position('y');
    tempNode.offsetX    = 0;
    tempNode.offsetY    = 0;
    tempNode.height     = nbb.w;
    tempNode.width      = nbb.h;
    tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
    tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
    tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
    tempNode.minY       = tempNode.positionY - tempNode.height / 2;
    tempNode.padLeft    = parseFloat( n.style('padding-left') );
    tempNode.padRight   = parseFloat( n.style('padding-right') );
    tempNode.padTop     = parseFloat( n.style('padding-top') );
    tempNode.padBottom  = parseFloat( n.style('padding-bottom') );

    // forces
    tempNode.nodeRepulsion = is.fn( options.nodeRepulsion ) ? options.nodeRepulsion.call( n, n ) : options.nodeRepulsion;

    // Add new node
    layoutInfo.layoutNodes.push(tempNode);
    // Add entry to id-index map
    layoutInfo.idToIndex[tempNode.id] = i;
  }

  // Inline implementation of a queue, used for traversing the graph in BFS order
  var queue = [];
  var start = 0;   // Points to the start the queue
  var end   = -1;  // Points to the end of the queue

  var tempGraph = [];

  // Second pass to add child information and
  // initialize queue for hierarchical traversal
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var p_id = n.parentId;
    // Check if node n has a parent node
    if (null != p_id) {
    // Add node Id to parent's list of children
    layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
    } else {
    // If a node doesn't have a parent, then it's in the root graph
    queue[++end] = n.id;
    tempGraph.push(n.id);
    }
  }

  // Add root graph to graphSet
  layoutInfo.graphSet.push(tempGraph);

  // Traverse the graph, level by level,
  while (start <= end) {
    // Get the node to visit and remove it from queue
    var node_id  = queue[start++];
    var node_ix  = layoutInfo.idToIndex[node_id];
    var node     = layoutInfo.layoutNodes[node_ix];
    var children = node.children;
    if (children.length > 0) {
    // Add children nodes as a new graph to graph set
    layoutInfo.graphSet.push(children);
    // Add children to que queue to be visited
    for (var i = 0; i < children.length; i++) {
      queue[++end] = children[i];
    }
    }
  }

  // Create indexToGraph map
  for (var i = 0; i < layoutInfo.graphSet.length; i++) {
    var graph = layoutInfo.graphSet[i];
    for (var j = 0; j < graph.length; j++) {
    var index = layoutInfo.idToIndex[graph[j]];
    layoutInfo.indexToGraph[index] = i;
    }
  }

  // Iterate over all edges, creating Layout Edges
  for (var i = 0; i < layoutInfo.edgeSize; i++) {
    var e = edges[i];
    var tempEdge = {};
    tempEdge.id       = e.data('id');
    tempEdge.sourceId = e.data('source');
    tempEdge.targetId = e.data('target');

    // Compute ideal length
    var idealLength = is.fn( options.idealEdgeLength ) ? options.idealEdgeLength.call( e, e ) : options.idealEdgeLength;
    var elasticity = is.fn( options.edgeElasticity ) ? options.edgeElasticity.call( e, e ) : options.edgeElasticity;

    // Check if it's an inter graph edge
    var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];
    var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];
    var sourceGraph = layoutInfo.indexToGraph[sourceIx];
    var targetGraph = layoutInfo.indexToGraph[targetIx];

    if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while ( -1 === lcaGraph.indexOf(tempNode.id) ) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while ( -1 === lcaGraph.indexOf(tempNode.id) ) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +
        //  ". Index: " + lca + " Contents: " + lcaGraph.toString() +
        //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
    }

    tempEdge.idealLength = idealLength;
    tempEdge.elasticity = elasticity;

    layoutInfo.layoutEdges.push(tempEdge);
  }

  // Finally, return layoutInfo object
  return layoutInfo;
};


/**
 * @brief : This function finds the index of the lowest common
 *          graph ancestor between 2 nodes in the subtree
 *          (from the graph hierarchy induced tree) whose
 *          root is graphIx
 *
 * @arg node1: node1's ID
 * @arg node2: node2's ID
 * @arg layoutInfo: layoutInfo object
 *
 */
var findLCA = function(node1, node2, layoutInfo) {
  // Find their common ancester, starting from the root graph
  var res = findLCA_aux(node1, node2, 0, layoutInfo);
  if (2 > res.count) {
    // If aux function couldn't find the common ancester,
    // then it is the root graph
    return 0;
  } else {
    return res.graph;
  }
};


/**
 * @brief          : Auxiliary function used for LCA computation
 *
 * @arg node1      : node1's ID
 * @arg node2      : node2's ID
 * @arg graphIx    : subgraph index
 * @arg layoutInfo : layoutInfo object
 *
 * @return         : object of the form {count: X, graph: Y}, where:
 *                   X is the number of ancesters (max: 2) found in
 *                   graphIx (and it's subgraphs),
 *                   Y is the graph index of the lowest graph containing
 *                   all X nodes
 */
var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {
  var graph = layoutInfo.graphSet[graphIx];
  // If both nodes belongs to graphIx
  if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {
    return {count:2, graph:graphIx};
  }

  // Make recursive calls for all subgraphs
  var c = 0;
  for (var i = 0; i < graph.length; i++) {
    var nodeId   = graph[i];
    var nodeIx   = layoutInfo.idToIndex[nodeId];
    var children = layoutInfo.layoutNodes[nodeIx].children;

    // If the node has no child, skip it
    if (0 === children.length) {
    continue;
    }

    var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
    var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
    if (0 === result.count) {
    // Neither node1 nor node2 are present in this subgraph
    continue;
    } else if (1 === result.count) {
    // One of (node1, node2) is present in this subgraph
    c++;
    if (2 === c) {
      // We've already found both nodes, no need to keep searching
      break;
    }
    } else {
    // Both nodes are present in this subgraph
    return result;
    }
  }

  return {count:c, graph:graphIx};
};


/**
 * @brief: printsLayoutInfo into js console
 *         Only used for debbuging
 */
var printLayoutInfo = function(layoutInfo) {
  /* jshint ignore:start */

  if (!DEBUG) {
    return;
  }
  console.debug("layoutNodes:");
  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];
    var s =
    "\nindex: "     + i +
    "\nId: "        + n.id +
    "\nChildren: "  + n.children.toString() +
    "\nparentId: "  + n.parentId  +
    "\npositionX: " + n.positionX +
    "\npositionY: " + n.positionY +
    "\nOffsetX: " + n.offsetX +
    "\nOffsetY: " + n.offsetY +
    "\npadLeft: " + n.padLeft +
    "\npadRight: " + n.padRight +
    "\npadTop: " + n.padTop +
    "\npadBottom: " + n.padBottom;

    console.debug(s);
  }

  console.debug('idToIndex');
  for (var i in layoutInfo.idToIndex) {
    console.debug("Id: " + i + "\nIndex: " + layoutInfo.idToIndex[i]);
  }

  console.debug('Graph Set');
  var set = layoutInfo.graphSet;
  for (var i = 0; i < set.length; i ++) {
    console.debug("Set : " + i + ": " + set[i].toString());
  }

  var s = 'IndexToGraph';
  for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {
    s += "\nIndex : " + i + " Graph: "+ layoutInfo.indexToGraph[i];
  }
  console.debug(s);

  s = 'Layout Edges';
  for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
    var e = layoutInfo.layoutEdges[i];
    s += "\nEdge Index: " + i + " ID: " + e.id +
    " SouceID: " + e.sourceId + " TargetId: " + e.targetId +
    " Ideal Length: " + e.idealLength;
  }
  console.debug(s);

  s =  "nodeSize: " + layoutInfo.nodeSize;
  s += "\nedgeSize: " + layoutInfo.edgeSize;
  s += "\ntemperature: " + layoutInfo.temperature;
  console.debug(s);

  return;
  /* jshint ignore:end */
};


/**
 * @brief : Randomizes the position of all nodes
 */
var randomizePositions = function(layoutInfo, cy) {
  var width     = layoutInfo.clientWidth;
  var height    = layoutInfo.clientHeight;

  for (var i = 0; i < layoutInfo.nodeSize; i++) {
    var n = layoutInfo.layoutNodes[i];

    // No need to randomize compound nodes or locked nodes
    if ( 0 === n.children.length && !n.isLocked ) {
      n.positionX = Math.random() * width;
      n.positionY = Math.random() * height;
    }
  }
};


/**
 * @brief          : Updates the positions of nodes in the network
 * @arg layoutInfo : LayoutInfo object
 * @arg cy         : Cytoscape object
 * @arg options    : Layout options
 */
var refreshPositions = function(layoutInfo, cy, options) {
  // var s = 'Refreshing positions';
  // logDebug(s);

  var layout = options.layout;
  var nodes = options.eles.nodes();
  var bb = layoutInfo.boundingBox;
  var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };

  if( options.boundingBox ){
    nodes.forEach(function( node ){
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

      coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
      coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

      coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
      coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
    });

    coseBB.w = coseBB.x2 - coseBB.x1;
    coseBB.h = coseBB.y2 - coseBB.y1;
  }

  nodes.positions(function(i, ele) {
    var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
    // s = "Node: " + lnode.id + ". Refreshed position: (" +
    // lnode.positionX + ", " + lnode.positionY + ").";
    // logDebug(s);

    if( options.boundingBox ){ // then add extra bounding box constraint
      var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
      var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

      return {
        x: bb.x1 + pctX * bb.w,
        y: bb.y1 + pctY * bb.h
      };
    } else {
      return {
        x: lnode.positionX,
        y: lnode.positionY
      };
    }
  });

  // Trigger layoutReady only on first call
  if (true !== layoutInfo.ready) {
    // s = 'Triggering layoutready';
    // logDebug(s);
    layoutInfo.ready = true;
    layout.one('layoutready', options.ready);
    layout.trigger({ type: 'layoutready', layout: this });
  }
};

/**
 * @brief : Logs a debug message in JS console, if DEBUG is ON
 */
// var logDebug = function(text) {
//   if (DEBUG) {
//     console.debug(text);
//   }
// };

module.exports = CoseLayout;

},{"../../is":77,"../../math":79,"../../thread":92,"../../util":94}],49:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');

var defaults = {
  fit: true, // whether to fit the viewport to the graph
  padding: 30, // padding used on fit
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
  avoidOverlapPadding: 10, // extra spacing around nodes when avoidOverlap: true
  condense: false, // uses all available space on false, uses minimal space on true
  rows: undefined, // force num of rows in the grid
  cols: undefined, // force num of columns in the grid
  position: function( node ){}, // returns { row, col } for element
  sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function GridLayout( options ){
  this.options = util.extend({}, defaults, options);
}

GridLayout.prototype.run = function(){
  var params = this.options;
  var options = params;

  var cy = params.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  if( options.sort ){
    nodes = nodes.sort( options.sort );
  }

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  if( bb.h === 0 || bb.w === 0){
    nodes.layoutPositions(this, options, function(){
      return { x: bb.x1, y: bb.y1 };
    });

  } else {

    // width/height * splits^2 = cells where splits is number of times to split width
    var cells = nodes.size();
    var splits = Math.sqrt( cells * bb.h/bb.w );
    var rows = Math.round( splits );
    var cols = Math.round( bb.w/bb.h * splits );

    var small = function(val){
      if( val == null ){
        return Math.min(rows, cols);
      } else {
        var min = Math.min(rows, cols);
        if( min == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var large = function(val){
      if( val == null ){
        return Math.max(rows, cols);
      } else {
        var max = Math.max(rows, cols);
        if( max == rows ){
          rows = val;
        } else {
          cols = val;
        }
      }
    };

    var oRows = options.rows;
    var oCols = options.cols != null ? options.cols : options.columns;

    // if rows or columns were set in options, use those values
    if( oRows != null && oCols != null ){
      rows = oRows;
      cols = oCols;
    } else if( oRows != null && oCols == null ){
      rows = oRows;
      cols = Math.ceil( cells / rows );
    } else if( oRows == null && oCols != null ){
      cols = oCols;
      rows = Math.ceil( cells / cols );
    }

    // otherwise use the automatic values and adjust accordingly

    // if rounding was up, see if we can reduce rows or columns
    else if( cols * rows > cells ){
      var sm = small();
      var lg = large();

      // reducing the small side takes away the most cells, so try it first
      if( (sm - 1) * lg >= cells ){
        small(sm - 1);
      } else if( (lg - 1) * sm >= cells ){
        large(lg - 1);
      }
    } else {

      // if rounding was too low, add rows or columns
      while( cols * rows < cells ){
        var sm = small();
        var lg = large();

        // try to add to larger side first (adds less in multiplication)
        if( (lg + 1) * sm >= cells ){
          large(lg + 1);
        } else {
          small(sm + 1);
        }
      }
    }

    var cellWidth = bb.w / cols;
    var cellHeight = bb.h / rows;

    if( options.condense ){
      cellWidth = 0;
      cellHeight = 0;
    }

    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var pos = node._private.position;

        if( pos.x == null || pos.y == null ){ // for bb
          pos.x = 0;
          pos.y = 0;
        }

        var nbb = node.boundingBox();
        var p = options.avoidOverlapPadding;

        var w = nbb.w + p;
        var h = nbb.h + p;

        cellWidth = Math.max( cellWidth, w );
        cellHeight = Math.max( cellHeight, h );
      }
    }

    var cellUsed = {}; // e.g. 'c-0-2' => true

    var used = function(row, col){
      return cellUsed['c-' + row + '-' + col] ? true : false;
    };

    var use = function(row, col){
      cellUsed['c-' + row + '-' + col] = true;
    };

    // to keep track of current cell position
    var row = 0;
    var col = 0;
    var moveToNextCell = function(){
      col++;
      if( col >= cols ){
        col = 0;
        row++;
      }
    };

    // get a cache of all the manual positions
    var id2manPos = {};
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];
      var rcPos = options.position( node );

      if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
        var pos = {
          row: rcPos.row,
          col: rcPos.col
        };

        if( pos.col === undefined ){ // find unused col
          pos.col = 0;

          while( used(pos.row, pos.col) ){
            pos.col++;
          }
        } else if( pos.row === undefined ){ // find unused row
          pos.row = 0;

          while( used(pos.row, pos.col) ){
            pos.row++;
          }
        }

        id2manPos[ node.id() ] = pos;
        use( pos.row, pos.col );
      }
    }

    var getPos = function(i, element){
      var x, y;

      if( element.locked() || element.isFullAutoParent() ){
        return false;
      }

      // see if we have a manual position set
      var rcPos = id2manPos[ element.id() ];
      if( rcPos ){
        x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;
        y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;

      } else { // otherwise set automatically

        while( used(row, col) ){
          moveToNextCell();
        }

        x = col * cellWidth + cellWidth/2 + bb.x1;
        y = row * cellHeight + cellHeight/2 + bb.y1;
        use( row, col );

        moveToNextCell();
      }

      return { x: x, y: y };

    };

    nodes.layoutPositions( this, options, getPos );
  }

  return this; // chaining

};

module.exports = GridLayout;

},{"../../math":79,"../../util":94}],50:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  { name: 'breadthfirst', impl: _dereq_('./breadthfirst') },
  { name: 'circle', impl: _dereq_('./circle') },
  { name: 'concentric',impl: _dereq_('./concentric') },
  { name: 'cose', impl: _dereq_('./cose') },
  { name: 'grid', impl: _dereq_('./grid') },
  { name: 'null', impl: _dereq_('./null') },
  { name: 'preset', impl: _dereq_('./preset') },
  { name: 'random', impl: _dereq_('./random') }
];

},{"./breadthfirst":45,"./circle":46,"./concentric":47,"./cose":48,"./grid":49,"./null":51,"./preset":52,"./random":53}],51:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');

// default layout options
var defaults = {
  ready: function(){}, // on layoutready
  stop: function(){} // on layoutstop
};

// constructor
// options : object containing layout options
function NullLayout( options ){
  this.options = util.extend({}, defaults, options);
}

// runs the layout
NullLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles; // elements to consider in the layout
  var layout = this;

  // cy is automatically populated for us in the constructor
  var cy = options.cy; // jshint ignore:line

  layout.trigger('layoutstart');

  // puts all nodes at (0, 0)
  eles.nodes().positions(function(){
    return {
      x: 0,
      y: 0
    };
  });

  // trigger layoutready when each node has had its position set at least once
  layout.one('layoutready', options.ready);
  layout.trigger('layoutready');

  // trigger layoutstop when the layout stops (e.g. finishes)
  layout.one('layoutstop', options.stop);
  layout.trigger('layoutstop');

  return this; // chaining
};

// called on continuous layouts to stop them before they finish
NullLayout.prototype.stop = function(){
  return this; // chaining
};

module.exports = NullLayout;

},{"../../util":94}],52:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var is = _dereq_('../../is');

var defaults = {
  positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
  zoom: undefined, // the zoom level to set (prob want fit = false if set)
  pan: undefined, // the pan level to set (prob want fit = false if set)
  fit: true, // whether to fit to viewport
  padding: 30, // padding on fit
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function PresetLayout( options ){
  this.options = util.extend({}, defaults, options);
}

PresetLayout.prototype.run = function(){
  var options = this.options;
  var eles = options.eles;

  var nodes = eles.nodes();
  var posIsFn = is.fn( options.positions );

  function getPosition(node){
    if( options.positions == null ){
      return null;
    }

    if( posIsFn ){
      return options.positions.apply( node, [ node ] );
    }

    var pos = options.positions[node._private.data.id];

    if( pos == null ){
      return null;
    }

    return pos;
  }

  nodes.layoutPositions(this, options, function(i, node){
    var position = getPosition(node);

    if( node.locked() || position == null ){
      return false;
    }

    return position;
  });

  return this; // chaining
};

module.exports = PresetLayout;

},{"../../is":77,"../../util":94}],53:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../util');
var math = _dereq_('../../math');

var defaults = {
  fit: true, // whether to fit to viewport
  padding: 30, // fit padding
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  animate: false, // whether to transition the node positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  ready: undefined, // callback on layoutready
  stop: undefined // callback on layoutstop
};

function RandomLayout( options ){
  this.options = util.extend({}, defaults, options);
}

RandomLayout.prototype.run = function(){
  var options = this.options;
  var cy = options.cy;
  var eles = options.eles;
  var nodes = eles.nodes().not(':parent');

  var bb = math.makeBoundingBox( options.boundingBox ? options.boundingBox : {
    x1: 0, y1: 0, w: cy.width(), h: cy.height()
  } );

  var getPos = function( i, node ){
    return {
      x: bb.x1 + Math.round( Math.random() * bb.w ),
      y: bb.y1 + Math.round( Math.random() * bb.h )
    };
  };

  nodes.layoutPositions( this, options, getPos );

  return this; // chaining
};

module.exports = RandomLayout;

},{"../../math":79,"../../util":94}],54:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_('../../../math');
var is = _dereq_('../../../is');
var util = _dereq_('../../../util');

var BRp = {};

BRp.arrowShapeHeight = 0.3;

BRp.registerArrowShapes = function(){
  var arrowShapes = this.arrowShapes = {};
  var renderer = this;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function( x, y, size, angle, translation, padding ){
    var x1 = translation.x - size/2 - padding;
    var x2 = translation.x + size/2 + padding;
    var y1 = translation.y - size/2 - padding;
    var y2 = translation.y + size/2 + padding;

    var inside = (x1 <= x && x <= x2) && (y1 <= y && y <= y2);

    return inside;
  };

  var transform = function( x, y, size, angle, translation ){
    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);

    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;

    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  var transformPoints = function( pts, size, angle, translation ){
    var retPts = [];

    for( var i = 0; i < pts.length; i += 2 ){
      var x = pts[i];
      var y = pts[i + 1];

      retPts.push( transform(x, y, size, angle, translation) );
    }

    return retPts;
  };

  var pointsToArr = function( pts ){
    var ret = [];

    for( var i = 0; i < pts.length; i++ ){
      var p = pts[i];

      ret.push( p.x, p.y );
    }

    return ret;
  };

  var defineArrowShape = function( name, defn ){
    if( is.string(defn) ){
      defn = arrowShapes[ defn ];
    }

    arrowShapes[ name ] = util.extend( {
      name: name,

      points: [
        -0.15, -0.3,
        0.15, -0.3,
        0.15, 0.3,
        -0.15, 0.3
      ],

      collide: function( x, y, size, angle, translation, padding ){
        var points = pointsToArr( transformPoints( this.points, size + 2*padding, angle, translation ) );
        var inside = math.pointInsidePolygonPoints( x, y, points );

        return inside;
      },

      roughCollide: bbCollide,

      draw: function( context, size, angle, translation ){
        var points = transformPoints( this.points, size, angle, translation );

        renderer.arrowShapeImpl('polygon')( context, points );
      },

      spacing: function( edge ){
        return 0;
      },

      gap: function( edge ){
        return edge._private.style['width'].pfValue * 2;
      }
    }, defn );
  };

  defineArrowShape( 'none', {
    collide: util.falsify,

    roughCollide: util.falsify,

    draw: util.noop,

    spacing: util.zeroify,

    gap: util.zeroify
  } );

  defineArrowShape( 'triangle', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ]
  } );

  defineArrowShape( 'arrow', 'triangle' );

  defineArrowShape( 'triangle-backcurve', {
    points: arrowShapes['triangle'].points,

    controlPoint: [ 0, -0.15 ],

    roughCollide: bbCollide,

    draw: function( context, size, angle, translation ){
      var ptsTrans = transformPoints( this.points, size, angle, translation );
      var ctrlPt = this.controlPoint;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, ptsTrans, ctrlPtTrans );
    },

    gap: function( edge ){
      return edge._private.style['width'].pfValue;
    }
  } );


  defineArrowShape( 'triangle-tee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],

    collide: function( x, y, size, angle, translation, padding ){
      var triPts = pointsToArr( transformPoints( this.points, size + 2*padding, angle, translation ) );
      var teePts = pointsToArr( transformPoints( this.pointsTee, size + 2*padding, angle, translation ) );

      var inside = math.pointInsidePolygonPoints( x, y, triPts ) || math.pointInsidePolygonPoints( x, y, teePts );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      var triPts = transformPoints( this.points, size, angle, translation );
      var teePts = transformPoints( this.pointsTee, size, angle, translation );

      renderer.arrowShapeImpl( this.name )( context, triPts, teePts );
    }
  } );

  defineArrowShape( 'vee', {
    points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      0, -0.15
    ],

    gap: function( edge ){
      return edge._private.style['width'].pfValue;
    }
  } );

  defineArrowShape( 'half-triangle-overshot', {
    points: [
      0, -0.25,
      -0.5, -0.25,
      0.5, 0.25
    ],

    leavePathOpen: true,

    matchEdgeWidth: true
  } );

  defineArrowShape( 'circle', {
    radius: 0.15,

    collide: function( x, y, size, angle, translation, padding ){
      var t = translation;
      var inside = ( Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2*padding) * this.radius, 2) );

      return inside;
    },

    draw: function( context, size, angle, translation ){
      renderer.arrowShapeImpl( this.name )( context, translation.x, translation.y, this.radius * size );
    },

    spacing: function( edge ){
      return renderer.getArrowWidth(edge._private.style['width'].pfValue)
        * this.radius;
    }
  } );

  defineArrowShape( 'inhibitor', {
    points: [
      -0.25, 0,
      -0.25, -0.1,
      0.25, -0.1,
      0.25, 0
    ],

    spacing: function( edge ){
      return 1;
    },

    gap: function( edge ){
      return 1;
    }
  } );

  defineArrowShape( 'tee', 'inhibitor' );

  defineArrowShape( 'square', {
    points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ]
  } );

  defineArrowShape( 'diamond', {
    points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    gap: function( edge ){
      return edge._private.style['width'].pfValue;
    }
  } );

};

module.exports = BRp;

},{"../../../is":77,"../../../math":79,"../../../util":94}],55:[function(_dereq_,module,exports){
'use strict';

var BRp = {};

var delEleCache = function( r ){
  r.eleEache = null;
};

var getEleCache = function( r ){
  if( !r.eleEache ){
    r.eleEache = {
      nodes: r.cy.nodes(),
      edges: r.cy.edges()
    };
  }

  return r.eleEache;
};

BRp.getCachedElements = function(){
  return getEleCache( this );
};

BRp.getCachedNodes = function(){
  return getEleCache( this ).nodes;
};

BRp.getCachedEdges = function(){
  return getEleCache( this ).edges;
};

BRp.updateElementsCache = function(){
  var r = this;

  delEleCache( r );

  return getEleCache( r );
};

module.exports = BRp;

},{}],56:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_('../../../math');
var is = _dereq_('../../../is');
var zIndexSort = _dereq_('../../../collection/zsort');

var BRp = {};

// Project mouse
BRp.projectIntoViewport = function(clientX, clientY) {
  var offsets = this.findContainerClientCoords();
  var offsetLeft = offsets[0];
  var offsetTop = offsets[1];

  var x = clientX - offsetLeft;
  var y = clientY - offsetTop;

  x -= this.cy.pan().x; y -= this.cy.pan().y; x /= this.cy.zoom(); y /= this.cy.zoom();
  return [x, y];
};

BRp.findContainerClientCoords = function() {
  var container = this.container;

  var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();

  return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];
};

BRp.invalidateContainerClientCoordsCache = function(){
  this.containerBB = null;
};

// Find nearest element
BRp.findNearestElement = function(x, y, visibleElementsOnly, isTouch){
  var self = this;
  var r = this;
  var eles = r.getCachedZSortedEles();
  var near = [];
  var zoom = r.cy.zoom();
  var hasCompounds = r.cy.hasCompoundNodes();
  var edgeThreshold = (isTouch ? 24 : 8) / zoom;
  var nodeThreshold = (isTouch ? 8 : 2) / zoom;
  var labelThreshold = (isTouch ? 8 : 2) / zoom;

  function checkNode(node){
    var _p = node._private;

    if( _p.style['events'].strValue === 'no' ){ return; }

    var width = node.outerWidth() + 2*nodeThreshold;
    var height = node.outerHeight() + 2*nodeThreshold;
    var hw = width/2;
    var hh = height/2;
    var pos = _p.position;

    if(
      pos.x - hw <= x && x <= pos.x + hw // bb check x
        &&
      pos.y - hh <= y && y <= pos.y + hh // bb check y
    ){
      var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );

      // exit early if invisible edge and must be visible
      if( visibleElementsOnly && !visible ){
        return;
      }

      var shape = r.nodeShapes[ self.getNodeShape(node) ];

      if(
        shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)
      ){
        near.push( node );
      }

    }
  }

  function checkEdge(edge){
    var _p = edge._private;

    if( _p.style['events'].strValue === 'no' ){ return; }

    var rs = _p.rscratch;
    var style = _p.style;
    var width = style['width'].pfValue/2 + edgeThreshold; // more like a distance radius from centre
    var widthSq = width * width;
    var width2 = width * 2;
    var src = _p.source;
    var tgt = _p.target;
    var inEdgeBB = false;
    var sqDist;

    // exit early if invisible edge and must be visible
    var passedVisibilityCheck;
    var passesVisibilityCheck = function(){
      if( passedVisibilityCheck !== undefined ){
        return passedVisibilityCheck;
      }

      if( !visibleElementsOnly ){
        passedVisibilityCheck = true;
        return true;
      }

      var visible = edge.visible() && !edge.transparent();
      if( visible ){
        passedVisibilityCheck = true;
        return true;
      }

      passedVisibilityCheck = false;
      return false;
    };

    if( rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack' ){
      var pts = rs.allpts;

      for( var i = 0; i + 3 < pts.length; i += 2 ){
        if(
          (inEdgeBB = math.inLineVicinity(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], width2))
            && passesVisibilityCheck() &&
          widthSq > ( sqDist = math.sqDistanceToFiniteLine(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3]) )
        ){
          near.push( edge );
        }
      }

    } else if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
      var pts = rs.allpts;
      for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
        if(
          (inEdgeBB = math.inBezierVicinity(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], pts[i+4], pts[i+5], width2))
            && passesVisibilityCheck() &&
          (widthSq > (sqDist = math.sqDistanceToQuadraticBezier(x, y, pts[i], pts[i+1], pts[i+2], pts[i+3], pts[i+4], pts[i+5])) )
        ){
          near.push( edge );
        }
      }
    }

    // if we're close to the edge but didn't hit it, maybe we hit its arrows
    if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){
      var src = src || _p.source;
      var tgt = tgt || _p.target;

      var eWidth = style['width'].pfValue;
      var arSize = self.getArrowWidth( eWidth );

      var arrows = [
        { name: 'source', x: rs.arrowStartX, y: rs.arrowStartY, angle: rs.srcArrowAngle },
        { name: 'target', x: rs.arrowEndX, y: rs.arrowEndY, angle: rs.tgtArrowAngle },
        { name: 'mid-source', x: rs.midX, y: rs.midY, angle: rs.midsrcArrowAngle },
        { name: 'mid-target', x: rs.midX, y: rs.midY, angle: rs.midtgtArrowAngle }
      ];

      for( var i = 0; i < arrows.length; i++ ){
        var ar = arrows[i];
        var shape = r.arrowShapes[ style[ar.name+'-arrow-shape'].value ];

        if(
          shape.roughCollide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold)
           &&
          shape.collide(x, y, arSize, ar.angle, { x: ar.x, y: ar.y }, edgeThreshold)
        ){
          near.push( edge );
          break;
        }
      }
    }

    // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
    if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){
      checkNode( src );
      checkNode( tgt );
    }
  }

  function checkLabel(ele){
    var _p = ele._private;
    var th = labelThreshold;

    if( _p.style['text-events'].strValue === 'no' ){ return; }

    // adjust bb w/ angle
    if( _p.group === 'edges' && _p.style['edge-text-rotation'].strValue === 'autorotate' ){

      var rstyle = _p.rstyle;
      var lw = rstyle.labelWidth + 2*th;
      var lh = rstyle.labelHeight + 2*th;
      var lx = rstyle.labelX;
      var ly = rstyle.labelY;

      var theta = _p.rscratch.labelAngle;
      var cos = Math.cos( theta );
      var sin = Math.sin( theta );

      var rotate = function( x, y ){
        x = x - lx;
        y = y - ly;

        return {
          x: x*cos - y*sin + lx,
          y: x*sin + y*cos + ly
        };
      };

      var lx1 = lx - lw/2;
      var lx2 = lx + lw/2;
      var ly1 = ly - lh/2;
      var ly2 = ly + lh/2;

      var px1y1 = rotate( lx1, ly1 );
      var px1y2 = rotate( lx1, ly2 );
      var px2y1 = rotate( lx2, ly1 );
      var px2y2 = rotate( lx2, ly2 );

      var points = [
        px1y1.x, px1y1.y,
        px2y1.x, px2y1.y,
        px2y2.x, px2y2.y,
        px1y2.x, px1y2.y
      ];

      if( math.pointInsidePolygonPoints( x, y, points ) ){
        near.push( ele );
      }

    } else {
      var bb = ele.boundingBox({
        includeLabels: true,
        includeNodes: false,
        includeEdges: false
      });

      // adjust bb w/ threshold
      bb.x1 -= th;
      bb.y1 -= th;
      bb.x2 += th;
      bb.y2 += th;
      bb.w = bb.x2 - bb.x1;
      bb.h = bb.y2 - bb.y1;

      if( math.inBoundingBox( bb, x, y ) ){
        near.push( ele );
      }
    }

  }

  for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
    var ele = eles[i];
    var _p = ele._private;

    if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early

    if( _p.group === 'nodes' ){
      checkNode( ele );

    } else  { // then edge
      checkEdge( ele );
    }

    checkLabel( ele );

  }


  if( near.length > 0 ){
    return near[ near.length - 1 ];
  } else {
    return null;
  }
};

// 'Give me everything from this box'
BRp.getAllInBox = function(x1, y1, x2, y2) {
  var nodes = this.getCachedNodes();
  var edges = this.getCachedEdges();
  var box = [];

  var x1c = Math.min(x1, x2);
  var x2c = Math.max(x1, x2);
  var y1c = Math.min(y1, y2);
  var y2c = Math.max(y1, y2);

  x1 = x1c;
  x2 = x2c;
  y1 = y1c;
  y2 = y2c;

  var boxBb = math.makeBoundingBox({
    x1: x1, y1: y1,
    x2: x2, y2: y2
  });

  for ( var i = 0; i < nodes.length; i++ ){
    var node = nodes[i];
    var nodeBb = node.boundingBox({
      includeNodes: true,
      includeEdges: false,
      includeLabels: false
    });

    if( math.boundingBoxesIntersect(boxBb, nodeBb) ){
      box.push(nodes[i]);
    }
  }

  for( var e = 0; e < edges.length; e++ ){
    var edge = edges[e];
    var _p = edge._private;
    var rs = _p.rscratch;

    if( rs.startX != null && rs.startY != null && !math.inBoundingBox( boxBb, rs.startX, rs.startY ) ){ continue; }
    if( rs.endX != null && rs.endY != null && !math.inBoundingBox( boxBb, rs.endX, rs.endY ) ){ continue; }

    if( rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack' ){

      var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;
      var allInside = true;

      for( var i = 0; i < pts.length; i++ ){
        if( !math.pointInBoundingBox( boxBb, pts[i] ) ){
          allInside = false;
          break;
        }
      }

      if( allInside ){
        box.push( edge );
      }

    } else if( rs.edgeType === 'haystack' || rs.edgeType === 'straight' ){
      box.push( edge );
    }

  }

  return box;
};


/**
 * Returns the shape of the given node. If the height or width of the given node
 * is set to auto, the node is considered to be a compound.
 *
 * @param node          a node
 * @return {String}     shape of the node
 */
BRp.getNodeShape = function( node ){
  var r = this;
  var style = node._private.style;
  var shape = style['shape'].value;

  if( node.isParent() ){
    if( shape === 'rectangle' || shape === 'roundrectangle' ){
      return shape;
    } else {
      return 'rectangle';
    }
  }

  if( shape === 'polygon' ){
    var points = style['shape-polygon-points'].value;

    return r.nodeShapes.makePolygon( points ).name;
  }

  return shape;
};

BRp.updateCachedZSortedEles = function(){
  this.getCachedZSortedEles( true );
};

BRp.getCachedZSortedEles = function( forceRecalc ){
  var lastNodes = this.lastZOrderCachedNodes;
  var lastEdges = this.lastZOrderCachedEdges;
  var nodes = this.getCachedNodes();
  var edges = this.getCachedEdges();
  var eles = [];

  if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){
    //console.time('cachezorder')

    for( var i = 0; i < nodes.length; i++ ){
      var n = nodes[i];

      if( n.animated() || (n.visible() && !n.transparent()) ){
        eles.push( n );
      }
    }

    for( var i = 0; i < edges.length; i++ ){
      var e = edges[i];

      if( e.animated() || (e.visible() && !e.transparent()) ){
        eles.push( e );
      }
    }

    eles.sort( zIndexSort );
    this.cachedZSortedEles = eles;
    //console.log('make cache')

    //console.timeEnd('cachezorder')
  } else {
    eles = this.cachedZSortedEles;
    //console.log('read cache')
  }

  this.lastZOrderCachedNodes = nodes;
  this.lastZOrderCachedEdges = edges;

  return eles;
};

function pushBezierPts(edge, pts){
  var qbezierAt = function( p1, p2, p3, t ){ return math.qbezierAt(p1, p2, p3, t); };
  var _p = edge._private;
  var bpts = _p.rstyle.bezierPts;

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )
  });

  bpts.push({
    x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),
    y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )
  });
}

BRp.projectLines = function( edge ){
  var _p = edge._private;
  var rs = _p.rscratch;
  var et = rs.edgeType;

  if( et === 'multibezier' ||  et === 'bezier' ||  et === 'self' ||  et === 'compound' ){
    var bpts = _p.rstyle.bezierPts = []; // jshint ignore:line

    for( var i = 0; i + 5 < rs.allpts.length; i += 4 ){
      pushBezierPts( edge, rs.allpts.slice(i, i+6) );
    }
  } else if(  et === 'segments' ){
    var lpts = _p.rstyle.linePts = [];

    for( var i = 0; i + 1 < rs.allpts.length; i += 2 ){
      lpts.push({
        x: rs.allpts[i],
        y: rs.allpts[i+1]
      });
    }
  } else if( et === 'haystack' ){
    var hpts = rs.haystackPts;

    _p.rstyle.haystackPts = [
      { x: hpts[0], y: hpts[1] },
      { x: hpts[2], y: hpts[3] }
    ];
  }
};

BRp.projectBezier = BRp.projectLines;

BRp.recalculateNodeLabelProjection = function( node ){
  var content = node._private.style['label'].strValue;
  if( !content || content.match(/^\s+$/) ){ return; }

  var textX, textY;
  var nodeWidth = node.outerWidth();
  var nodeHeight = node.outerHeight();
  var nodePos = node._private.position;
  var textHalign = node._private.style['text-halign'].strValue;
  var textValign = node._private.style['text-valign'].strValue;
  var rs = node._private.rscratch;
  var rstyle = node._private.rstyle;

  switch( textHalign ){
    case 'left':
      textX = nodePos.x - nodeWidth / 2;
      break;

    case 'right':
      textX = nodePos.x + nodeWidth / 2;
      break;

    default: // e.g. center
      textX = nodePos.x;
  }

  switch( textValign ){
    case 'top':
      textY = nodePos.y - nodeHeight / 2;
      break;

    case 'bottom':
      textY = nodePos.y + nodeHeight / 2;
      break;

    default: // e.g. middle
      textY = nodePos.y;
  }

  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions( node );
};

BRp.recalculateEdgeLabelProjection = function( edge ){
  var content = edge._private.style['label'].strValue;
  if( !content || content.match(/^\s+$/) ){ return; }

  var textX, textY;
  var _p = edge._private;
  var rs = _p.rscratch;
  //var style = _p.style;
  var rstyle = _p.rstyle;

  textX = rs.midX;
  textY = rs.midY;

  // add center point to style so bounding box calculations can use it
  rs.labelX = textX;
  rs.labelY = textY;
  rstyle.labelX = textX;
  rstyle.labelY = textY;

  this.applyLabelDimensions( edge );
};

BRp.applyLabelDimensions = function( ele ){
  var rs = ele._private.rscratch;
  var rstyle = ele._private.rstyle;

  var text = this.getLabelText( ele );
  var labelDims = this.calculateLabelDimensions( ele, text );

  rstyle.labelWidth = labelDims.width;
  rs.labelWidth = labelDims.width;

  rstyle.labelHeight = labelDims.height;
  rs.labelHeight = labelDims.height;
};

BRp.getLabelText = function( ele ){
  var style = ele._private.style;
  var text = ele._private.style['label'].strValue;
  var textTransform = style['text-transform'].value;
  var rscratch = ele._private.rscratch;

  if (textTransform == 'none') {
  } else if (textTransform == 'uppercase') {
    text = text.toUpperCase();
  } else if (textTransform == 'lowercase') {
    text = text.toLowerCase();
  }

  if( style['text-wrap'].value === 'wrap' ){
    //console.log('wrap');

    // save recalc if the label is the same as before
    if( rscratch.labelWrapKey === rscratch.labelKey ){
      // console.log('wrap cache hit');
      return rscratch.labelWrapCachedText;
    }
    // console.log('wrap cache miss');

    var lines = text.split('\n');
    var maxW = style['text-max-width'].pfValue;
    var wrappedLines = [];

    for( var l = 0; l < lines.length; l++ ){
      var line = lines[l];
      var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
      var lineW = lineDims.width;

      if( lineW > maxW ){ // line is too long
        var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
        var subline = '';

        for( var w = 0; w < words.length; w++ ){
          var word = words[w];
          var testLine = subline.length === 0 ? word : subline + ' ' + word;
          var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
          var testW = testDims.width;

          if( testW <= maxW ){ // word fits on current line
            subline += word + ' ';
          } else { // word starts new line
            wrappedLines.push( subline );
            subline = word + ' ';
          }
        }

        // if there's remaining text, put it in a wrapped line
        if( !subline.match(/^\s+$/) ){
          wrappedLines.push( subline );
        }
      } else { // line is already short enough
        wrappedLines.push( line );
      }
    } // for

    rscratch.labelWrapCachedLines = wrappedLines;
    rscratch.labelWrapCachedText = text = wrappedLines.join('\n');
    rscratch.labelWrapKey = rscratch.labelKey;

    // console.log(text)
  } // if wrap

  return text;
};

BRp.calculateLabelDimensions = function( ele, text, extraKey ){
  var r = this;
  var style = ele._private.style;
  var fStyle = style['font-style'].strValue;
  var size = style['font-size'].pfValue + 'px';
  var family = style['font-family'].strValue;
  // var variant = style['font-variant'].strValue;
  var weight = style['font-weight'].strValue;

  var cacheKey = ele._private.labelKey;

  if( extraKey ){
    cacheKey += '$@$' + extraKey;
  }

  var cache = r.labelDimCache || (r.labelDimCache = {});

  if( cache[cacheKey] ){
    return cache[cacheKey];
  }

  var div = this.labelCalcDiv;

  if( !div ){
    div = this.labelCalcDiv = document.createElement('div');
    document.body.appendChild( div );
  }

  var ds = div.style;

  // from ele style
  ds.fontFamily = family;
  ds.fontStyle = fStyle;
  ds.fontSize = size;
  // ds.fontVariant = variant;
  ds.fontWeight = weight;

  // forced style
  ds.position = 'absolute';
  ds.left = '-9999px';
  ds.top = '-9999px';
  ds.zIndex = '-1';
  ds.visibility = 'hidden';
  ds.pointerEvents = 'none';
  ds.padding = '0';
  ds.lineHeight = '1';

  if( style['text-wrap'].value === 'wrap' ){
    ds.whiteSpace = 'pre'; // so newlines are taken into account
  } else {
    ds.whiteSpace = 'normal';
  }

  // put label content in div
  div.textContent = text;

  cache[cacheKey] = {
    width: div.clientWidth,
    height: div.clientHeight
  };

  return cache[cacheKey];
};

BRp.recalculateRenderedStyle = function( eles ){
  var edges = [];
  var nodes = [];
  var handledEdge = {};

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var _p = ele._private;
    var style = _p.style;
    var rs = _p.rscratch;
    var rstyle = _p.rstyle;
    var id = _p.data.id;
    var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;
    var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;
    var styleSame = bbStyleSame && labelStyleSame;

    if( _p.group === 'nodes' ){
      var pos = _p.position;
      var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;
      var wSame = rstyle.nodeW != null && rstyle.nodeW === style['width'].pfValue;
      var hSame = rstyle.nodeH != null && rstyle.nodeH === style['height'].pfValue;

      if( !posSame || !styleSame || !wSame || !hSame ){
        nodes.push( ele );
      }

      rstyle.nodeX = pos.x;
      rstyle.nodeY = pos.y;
      rstyle.nodeW = style['width'].pfValue;
      rstyle.nodeH = style['height'].pfValue;
    } else { // edges

      var srcPos = _p.source._private.position;
      var tgtPos = _p.target._private.position;
      var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;
      var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;
      var positionsSame = srcSame && tgtSame;

      if( !positionsSame || !styleSame ){
        if( rs.edgeType === 'bezier' || rs.edgeType === 'straight' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
          if( !handledEdge[ id ] ){
            edges.push( ele );
            handledEdge[ id ] = true;

            var parallelEdges = ele.parallelEdges();
            for( var i = 0; i < parallelEdges.length; i++ ){
              var pEdge = parallelEdges[i];
              var pId = pEdge._private.data.id;

              if( !handledEdge[ pId ] ){
                edges.push( pEdge );
                handledEdge[ pId ] = true;
              }

            }
          }
        } else {
          edges.push( ele );
        }
      } // if positions diff

      // update rstyle positions
      rstyle.srcX = srcPos.x;
      rstyle.srcY = srcPos.y;
      rstyle.tgtX = tgtPos.x;
      rstyle.tgtY = tgtPos.y;

    } // if edges

    rs.boundingBoxKey = _p.boundingBoxKey;
    rs.labelKey = _p.labelKey;
  }

  this.recalculateEdgeProjections( edges );
  this.recalculateLabelProjections( nodes, edges );
};

BRp.recalculateLabelProjections = function( nodes, edges ){
  for( var i = 0; i < nodes.length; i++ ){
    this.recalculateNodeLabelProjection( nodes[i] );
  }

  for( var i = 0; i < edges.length; i++ ){
    this.recalculateEdgeLabelProjection( edges[i] );
  }
};

BRp.recalculateEdgeProjections = function( edges ){
  this.findEdgeControlPoints( edges );
};


// Find edge control points
BRp.findEdgeControlPoints = function(edges) {
  if( !edges || edges.length === 0 ){ return; }

  var r = this;
  var cy = r.cy;
  var hasCompounds = cy.hasCompoundNodes();
  var hashTable = {};
  var pairIds = [];
  var haystackEdges = [];
  var autorotateEdges = [];

  // create a table of edge (src, tgt) => list of edges between them
  var pairId;
  for (var i = 0; i < edges.length; i++){
    var edge = edges[i];
    var _p = edge._private;
    var data = _p.data;
    var style = _p.style;
    var curveStyle = style['curve-style'].value;
    var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

    // ignore edges who are not to be displayed
    // they shouldn't take up space
    if( style.display.value === 'none' ){
      continue;
    }

    if( style['edge-text-rotation'].strValue === 'autorotate' ){
      autorotateEdges.push( edge );
    }

    if( curveStyle === 'haystack' ){
      haystackEdges.push( edge );
      continue;
    }

    var srcId = data.source;
    var tgtId = data.target;

    pairId = srcId > tgtId ?
      tgtId + '$-$' + srcId :
      srcId + '$-$' + tgtId ;

    if( edgeIsUnbundled ){
      pairId = 'unbundled' + '$-$' + data.id;
    }

    if( hashTable[pairId] == null ){
      hashTable[pairId] = [];
      pairIds.push( pairId );
    }

    hashTable[pairId].push( edge );

    if( edgeIsUnbundled ){
      hashTable[pairId].hasUnbundled = true;
    }
  }

  var src, tgt, src_p, tgt_p, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape;
  var vectorNormInverse;
  var badBezier;

  // for each pair (src, tgt), create the ctrl pts
  // Nested for loop is OK; total number of iterations for both loops = edgeCount
  for (var p = 0; p < pairIds.length; p++) {
    pairId = pairIds[p];
    var pairEdges = hashTable[pairId];

    // for each pair id, the edges should be sorted by index
    pairEdges.sort(function(edge1, edge2){
      return edge1._private.index - edge2._private.index;
    });

    src = pairEdges[0]._private.source;
    tgt = pairEdges[0]._private.target;

    src_p = src._private;
    tgt_p = tgt._private;

    // make sure src/tgt distinction is consistent
    // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)
    if( src_p.data.id > tgt_p.data.id ){
      var temp = src;
      src = tgt;
      tgt = temp;
    }

    srcPos = src_p.position;
    tgtPos = tgt_p.position;

    srcW = src.outerWidth();
    srcH = src.outerHeight();

    tgtW = tgt.outerWidth();
    tgtH = tgt.outerHeight();

    srcShape = r.nodeShapes[ this.getNodeShape(src) ];
    tgtShape = r.nodeShapes[ this.getNodeShape(tgt) ];

    badBezier = false;


    if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

      // pt outside src shape to calc distance/displacement from src to tgt
      var srcOutside = srcShape.intersectLine(
        srcPos.x,
        srcPos.y,
        srcW,
        srcH,
        tgtPos.x,
        tgtPos.y,
        0
      );

      // pt outside tgt shape to calc distance/displacement from src to tgt
      var tgtOutside = tgtShape.intersectLine(
        tgtPos.x,
        tgtPos.y,
        tgtW,
        tgtH,
        srcPos.x,
        srcPos.y,
        0
      );

      var midptSrcPts = {
        x1: srcOutside[0],
        x2: tgtOutside[0],
        y1: srcOutside[1],
        y2: tgtOutside[1]
      };

      var dy = ( tgtOutside[1] - srcOutside[1] );
      var dx = ( tgtOutside[0] - srcOutside[0] );
      var l = Math.sqrt( dx*dx + dy*dy );

      var vector = {
        x: dx,
        y: dy
      };

      var vectorNorm = {
        x: vector.x/l,
        y: vector.y/l
      };
      vectorNormInverse = {
        x: -vectorNorm.y,
        y: vectorNorm.x
      };


      // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw
      if(
        tgtShape.checkPoint( srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||
        srcShape.checkPoint( tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y )
      ){
        vectorNormInverse = {};
        badBezier = true;
      }

    }

    var edge;
    var edge_p;
    var rs;

    for (var i = 0; i < pairEdges.length; i++) {
      edge = pairEdges[i];
      edge_p = edge._private;
      rs = edge_p.rscratch;

      var edgeIndex1 = rs.lastEdgeIndex;
      var edgeIndex2 = i;

      var numEdges1 = rs.lastNumEdges;
      var numEdges2 = pairEdges.length;

      var eStyle = edge_p.style;
      var style = eStyle;
      var curveStyle = eStyle['curve-style'].value;
      var ctrlptDists = eStyle['control-point-distances'];
      var ctrlptWs = eStyle['control-point-weights'];
      var bezierN = ctrlptDists && ctrlptWs ? Math.min( ctrlptDists.value.length, ctrlptWs.value.length ) : 1;
      var stepSize = eStyle['control-point-step-size'].pfValue;
      var ctrlptDist = ctrlptDists !== undefined ? ctrlptDists.pfValue[0] : undefined;
      var ctrlptWeight = ctrlptWs.value[0];
      var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || curveStyle === 'segments';

      var swappedDirection = edge_p.source !== src;

      if( swappedDirection && edgeIsUnbundled ){
        ctrlptDist *= -1;
      }

      var srcX1 = rs.lastSrcCtlPtX;
      var srcX2 = srcPos.x;
      var srcY1 = rs.lastSrcCtlPtY;
      var srcY2 = srcPos.y;
      var srcW1 = rs.lastSrcCtlPtW;
      var srcW2 = src.outerWidth();
      var srcH1 = rs.lastSrcCtlPtH;
      var srcH2 = src.outerHeight();

      var tgtX1 = rs.lastTgtCtlPtX;
      var tgtX2 = tgtPos.x;
      var tgtY1 = rs.lastTgtCtlPtY;
      var tgtY2 = tgtPos.y;
      var tgtW1 = rs.lastTgtCtlPtW;
      var tgtW2 = tgt.outerWidth();
      var tgtH1 = rs.lastTgtCtlPtH;
      var tgtH2 = tgt.outerHeight();

      var width1 = rs.lastW;
      var width2 = eStyle['control-point-step-size'].pfValue;

      if( badBezier ){
        rs.badBezier = true;
      } else {
        rs.badBezier = false;
      }

      if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
      &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
      &&  width1 === width2
      &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
        // console.log('edge ctrl pt cache HIT')
        continue; // then the control points haven't changed and we can skip calculating them
      } else {
        rs.lastSrcCtlPtX = srcX2;
        rs.lastSrcCtlPtY = srcY2;
        rs.lastSrcCtlPtW = srcW2;
        rs.lastSrcCtlPtH = srcH2;
        rs.lastTgtCtlPtX = tgtX2;
        rs.lastTgtCtlPtY = tgtY2;
        rs.lastTgtCtlPtW = tgtW2;
        rs.lastTgtCtlPtH = tgtH2;
        rs.lastEdgeIndex = edgeIndex2;
        rs.lastNumEdges = numEdges2;
        rs.lastWidth = width2;
        // console.log('edge ctrl pt cache MISS')
      }

      if( src === tgt ){
        // Self-edge

        rs.edgeType = 'self';

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        rs.ctrlpts = [
          srcPos.x,
          srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1),

          srcPos.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1),
          srcPos.y
        ];

      } else if(
        hasCompounds &&
        ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
        ( src.parents().anySame(tgt) || tgt.parents().anySame(src) )
      ){
        // Compound edge

        rs.edgeType = 'compound';

        // because the line approximation doesn't apply for compound beziers
        // (loop/self edges are already elided b/c of cheap src==tgt check)
        rs.badBezier = false;

        var j = i;
        var loopDist = stepSize;

        if( edgeIsUnbundled ){
          j = 0;
          loopDist = ctrlptDist;
        }

        var loopW = 50;

        var loopaPos = {
          x: srcPos.x - srcW/2,
          y: srcPos.y - srcH/2
        };

        var loopbPos = {
          x: tgtPos.x - tgtW/2,
          y: tgtPos.y - tgtH/2
        };

        var loopPos = {
          x: Math.min( loopaPos.x, loopbPos.x ),
          y: Math.min( loopaPos.y, loopbPos.y )
        };

        // avoids cases with impossible beziers
        var minCompoundStretch = 0.5;
        var compoundStretchA = Math.max( minCompoundStretch, Math.log(srcW * 0.01) );
        var compoundStretchB = Math.max( minCompoundStretch, Math.log(tgtW * 0.01) );

        rs.ctrlpts = [
          loopPos.x,
          loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,

          loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,
          loopPos.y
        ];

      } else if( curveStyle === 'segments' ){
        // Segments (multiple straight lines)

        rs.edgeType = 'segments';
        rs.segpts = [];

        var segmentWs = eStyle['segment-weights'].pfValue;
        var segmentDs = eStyle['segment-distances'].pfValue;
        var segmentsN = Math.min( segmentWs.length, segmentDs.length );

        for( var s = 0; s < segmentsN; s++ ){
          var w = segmentWs[s];
          var d = segmentDs[s];

          // d = swappedDirection ? -d : d;
          //
          // d = Math.abs(d);

          // var w1 = !swappedDirection ? (1 - w) : w;
          // var w2 = !swappedDirection ? w : (1 - w);

          var w1 = (1 - w);
          var w2 = w;

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.segpts.push(
            adjustedMidpt.x + vectorNormInverse.x * d,
            adjustedMidpt.y + vectorNormInverse.y * d
          );
        }

      // Straight edge
      } else if (
        pairEdges.length % 2 === 1
        && i === Math.floor(pairEdges.length / 2)
        && !edgeIsUnbundled
      ){

        rs.edgeType = 'straight';

      } else {
        // (Multi)bezier

        var multi = edgeIsUnbundled;

        rs.edgeType = multi ? 'multibezier' : 'bezier';
        rs.ctrlpts = [];

        for( var b = 0; b < bezierN; b++ ){
          var normctrlptDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manctrlptDist;
          var sign = math.signum( normctrlptDist );

          if( multi ){
            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size
            ctrlptWeight = ctrlptWs.value[b];
          }

          if( edgeIsUnbundled ){ // multi or single unbundled
            manctrlptDist = ctrlptDist;
          } else {
            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;
          }

          var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;

          var w1 = !swappedDirection || edgeIsUnbundled ? (1 - ctrlptWeight) : ctrlptWeight;
          var w2 = !swappedDirection || edgeIsUnbundled ? ctrlptWeight : (1 - ctrlptWeight);

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.ctrlpts.push(
            adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint,
            adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint
          );
        }

      }

      // find endpts for edge
      this.findEndpoints( edge );

      var badStart = !is.number( rs.startX ) || !is.number( rs.startY );
      var badAStart = !is.number( rs.arrowStartX ) || !is.number( rs.arrowStartY );
      var badEnd = !is.number( rs.endX ) || !is.number( rs.endY );
      var badAEnd = !is.number( rs.arrowEndX ) || !is.number( rs.arrowEndY );

      var minCpADistFactor = 3;
      var arrowW = this.getArrowWidth( eStyle['width'].pfValue ) * this.arrowShapeHeight;
      var minCpADist = minCpADistFactor * arrowW;

      if( rs.edgeType === 'bezier' ){
        var startACpDist = math.distance( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = math.distance( { x: rs.ctrlpts[0], y: rs.ctrlpts[1] }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        var overlapping = false;

        if( badStart || badAStart || closeStartACp ){
          overlapping = true;

          // project control point along line from src centre to outside the src shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - srcPos.x,
            y: rs.ctrlpts[1] - srcPos.y
          };
          var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max(srcW, srcH);
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var srcCtrlPtIntn = srcShape.intersectLine(
            srcPos.x,
            srcPos.y,
            srcW,
            srcH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeStartACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);
          } else {
            rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;
          }
        }

        if( badEnd || badAEnd || closeEndACp ){
          overlapping = true;

          // project control point along line from tgt centre to outside the tgt shape
          // (otherwise intersection will yield nothing)
          var cpD = { // delta
            x: rs.ctrlpts[0] - tgtPos.x,
            y: rs.ctrlpts[1] - tgtPos.y
          };
          var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
          var cpM = { // normalised delta
            x: cpD.x / cpL,
            y: cpD.y / cpL
          };
          var radius = Math.max(srcW, srcH);
          var cpProj = { // *2 radius guarantees outside shape
            x: rs.ctrlpts[0] + cpM.x * 2 * radius,
            y: rs.ctrlpts[1] + cpM.y * 2 * radius
          };

          var tgtCtrlPtIntn = tgtShape.intersectLine(
            tgtPos.x,
            tgtPos.y,
            tgtW,
            tgtH,
            cpProj.x,
            cpProj.y,
            0
          );

          if( closeEndACp ){
            rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - endACpDist);
            rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - endACpDist);
          } else {
            rs.ctrlpts[0] = tgtCtrlPtIntn[0] + cpM.x * minCpADist;
            rs.ctrlpts[1] = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
          }

        }

        if( overlapping ){
          // recalc endpts
          this.findEndpoints( edge );
        }

      }

      if( rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' ){
        rs.allpts = [];

        rs.allpts.push( rs.startX, rs.startY );

        for( var b = 0; b+1 < rs.ctrlpts.length; b += 2 ){
          // ctrl pt itself
          rs.allpts.push( rs.ctrlpts[b], rs.ctrlpts[b+1] );

          // the midpt between ctrlpts as intermediate destination pts
          if( b + 3 < rs.ctrlpts.length ){
            rs.allpts.push( (rs.ctrlpts[b] + rs.ctrlpts[b+2])/2, (rs.ctrlpts[b+1] + rs.ctrlpts[b+3])/2 );
          }
        }

        rs.allpts.push( rs.endX, rs.endY );

        var m, mt;
        if( rs.edgeType === 'bezier' ){
          rs.midX = math.qbezierAt( rs.arrowStartX, rs.ctrlpts[0], rs.arrowEndX, 0.5 );
          rs.midY = math.qbezierAt( rs.arrowStartY, rs.ctrlpts[1], rs.arrowEndY, 0.5 );
        } else if( rs.ctrlpts.length/2 % 2 === 0 ){
          m = rs.allpts.length/2 - 1;

          rs.midX = rs.allpts[m];
          rs.midY = rs.allpts[m+1];
        } else {
          m = rs.allpts.length/2 - 3;
          mt = 0.5;

          rs.midX = math.qbezierAt( rs.allpts[m], rs.allpts[m+2], rs.allpts[m+4], mt );
          rs.midY = math.qbezierAt( rs.allpts[m+1], rs.allpts[m+3], rs.allpts[m+5], mt );
        }

      } else if( rs.edgeType === 'straight' ){
        // need to calc these after endpts
        rs.allpts = [ rs.startX, rs.startY, rs.endX, rs.endY ];

        // default midpt for labels etc
        rs.midX = ( rs.arrowStartX + rs.arrowEndX )/2;
        rs.midY = ( rs.arrowStartY + rs.arrowEndY )/2;

      } else if( rs.edgeType === 'segments' ){
        rs.allpts = [];
        rs.allpts.push( rs.startX, rs.startY );
        rs.allpts.push.apply( rs.allpts, rs.segpts );
        rs.allpts.push( rs.endX, rs.endY );

        if( rs.segpts.length % 4 === 0 ){
          var i2 = rs.segpts.length / 2;
          var i1 = i2 - 2;

          rs.midX = ( rs.segpts[i1] + rs.segpts[i2] ) / 2;
          rs.midY = ( rs.segpts[i1+1] + rs.segpts[i2+1] ) / 2;
        } else {
          var i1 = rs.segpts.length / 2 - 1;

          rs.midX = rs.segpts[i1];
          rs.midY = rs.segpts[i1+1];
        }


      }

      this.projectLines( edge );
      this.calculateArrowAngles( edge );
      this.recalculateEdgeLabelProjection( edge );

    }
  }

  for( var i = 0; i < haystackEdges.length; i++ ){
    var edge = haystackEdges[i];
    var _p = edge._private;
    var style = _p.style;
    var rscratch = _p.rscratch;
    var rs = rscratch;

    if( !rscratch.haystack ){
      var angle = Math.random() * 2 * Math.PI;

      rscratch.source = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };

      var angle = Math.random() * 2 * Math.PI;

      rscratch.target = {
        x: Math.cos(angle),
        y: Math.sin(angle)
      };

    }

    var src = _p.source;
    var tgt = _p.target;
    var srcPos = src._private.position;
    var tgtPos = tgt._private.position;
    var srcW = src.width();
    var tgtW = tgt.width();
    var srcH = src.height();
    var tgtH = tgt.height();
    var radius = style['haystack-radius'].value;
    var halfRadius = radius/2; // b/c have to half width/height

    rs.haystackPts = rs.allpts = [
      rs.source.x * srcW * halfRadius + srcPos.x,
      rs.source.y * srcH * halfRadius + srcPos.y,
      rs.target.x * tgtW * halfRadius + tgtPos.x,
      rs.target.y * tgtH * halfRadius + tgtPos.y
    ];

    rs.midX = (rs.allpts[0] + rs.allpts[2])/2;
    rs.midY = (rs.allpts[1] + rs.allpts[3])/2;

    // always override as haystack in case set to different type previously
    rscratch.edgeType = 'haystack';
    rscratch.haystack = true;

    this.projectLines( edge );
    this.calculateArrowAngles( edge );
    this.recalculateEdgeLabelProjection( edge );
  }

  for( var i = 0 ; i < autorotateEdges.length; i++ ){
    var edge = autorotateEdges[i];
    var rs = edge._private.rscratch;

    rs.labelAngle = Math.atan( rs.midDispY / rs.midDispX );
  }

  return hashTable;
};

var getAngleFromDisp = function( dispX, dispY ){
  return Math.atan2( dispY, dispX ) - Math.PI/2;
};

BRp.calculateArrowAngles = function( edge ){
  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';
  var isMultibezier = rs.edgeType === 'multibezier';
  var isSegments = rs.edgeType === 'segments';
  var isCompound = rs.edgeType === 'compound';
  var isSelf = rs.edgeType === 'self';

  // Displacement gives direction for arrowhead orientation
  var dispX, dispY;
  var startX, startY, endX, endY;

  var srcPos = edge.source().position();
  var tgtPos = edge.target().position();

  if( isHaystack ){
    startX = rs.haystackPts[0];
    startY = rs.haystackPts[1];
    endX = rs.haystackPts[2];
    endY = rs.haystackPts[3];
  } else {
    startX = rs.arrowStartX;
    startY = rs.arrowStartY;
    endX = rs.arrowEndX;
    endY = rs.arrowEndY;
  }

  // source
  //

  dispX = srcPos.x - startX;
  dispY = srcPos.y - startY;

  rs.srcArrowAngle = getAngleFromDisp( dispX, dispY );

  // mid target
  //

  var midX = rs.midX;
  var midY = rs.midY;

  if( isHaystack ){
    midX = ( startX + endX )/2;
    midY = ( startY + endY )/2;
  }

  dispX = endX - startX;
  dispY = endY - startY;

  if( isSelf ){
    dispX = -1;
    dispY = 1;
  } else if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      var i2 = pts.length / 2;
      var i1 = i2 - 2;

      dispX = ( pts[i2] - pts[i1] );
      dispY = ( pts[i2+1] - pts[i1+1] );
    } else {
      var i2 = pts.length / 2 - 1;
      var i1 = i2 - 2;
      var i3 = i2 + 2;

      dispX = ( pts[i2] - pts[i1] );
      dispY = ( pts[i2+1] - pts[i1+1] );
    }
  } else if( isMultibezier || isCompound ){
    var pts = rs.allpts;
    var cpts = rs.ctrlpts;
    var bp0x, bp0y;
    var bp1x, bp1y;

    if( cpts.length / 2 % 2 === 0 ){
      var p0 = pts.length / 2 - 1; // startpt
      var ic = p0 + 2;
      var p1 = ic + 2;

      bp0x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.0 );
      bp0y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.0 );

      bp1x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.0001 );
      bp1y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.0001 );
    } else {
      var ic = pts.length / 2 - 1; // ctrpt
      var p0 = ic - 2; // startpt
      var p1 = ic + 2; // endpt

      bp0x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.4999 );
      bp0y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.4999 );

      bp1x = math.qbezierAt( pts[p0], pts[ic], pts[p1], 0.5 );
      bp1y = math.qbezierAt( pts[p0+1], pts[ic+1], pts[p1+1], 0.5 );
    }

    dispX = ( bp1x - bp0x );
    dispY = ( bp1y - bp0y );
  }

  rs.midtgtArrowAngle = getAngleFromDisp( dispX, dispY );

  rs.midDispX = dispX;
  rs.midDispY = dispY;

  // mid source
  //

  dispX *= -1;
  dispY *= -1;

  if( isSegments ){
    var pts = rs.allpts;

    if( pts.length / 2 % 2 === 0 ){
      // already ok
    } else {
      var i2 = pts.length / 2 - 1;
      var i3 = i2 + 2;

      dispX = -( pts[i3] - pts[i2] );
      dispY = -( pts[i3+1] - pts[i2+1] );
    }
  }

  rs.midsrcArrowAngle = getAngleFromDisp( dispX, dispY );

  // target
  //

  dispX = tgtPos.x - endX;
  dispY = tgtPos.y - endY;

  rs.tgtArrowAngle = getAngleFromDisp( dispX, dispY );
};


BRp.findEndpoints = function( edge ){
  var r = this;
  var intersect;

  var source = edge.source()[0];
  var target = edge.target()[0];

  var src_p = source._private;
  var tgt_p = target._private;

  var srcPos = src_p.position;
  var tgtPos = tgt_p.position;

  var tgtArShape = edge._private.style['target-arrow-shape'].value;
  var srcArShape = edge._private.style['source-arrow-shape'].value;

  var rs = edge._private.rscratch;

  var et = rs.edgeType;
  var bezier = et === 'bezier' || et === 'multibezier' || et === 'self' || et === 'compound';
  var multi = et !== 'bezier';
  var lines = et === 'straight' || et === 'segments';
  var segments = et === 'segments';

  var p1, p2;

  if( bezier ){
    var cpStart = [ rs.ctrlpts[0], rs.ctrlpts[1] ];
    var cpEnd = multi ? [ rs.ctrlpts[rs.ctrlpts.length - 2], rs.ctrlpts[rs.ctrlpts.length - 1] ] : cpStart;

    p1 = cpEnd;
    p2 = cpStart;
  } else if( lines ){
    var srcArrowFromPt = !segments ? [ tgtPos.x, tgtPos.y ] : rs.segpts.slice( 0, 2 );
    var tgtArrowFromPt = !segments ? [ srcPos.x, srcPos.y ] : rs.segpts.slice( rs.segpts.length - 2 );

    p1 = tgtArrowFromPt;
    p2 = srcArrowFromPt;
  }

  intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(
    tgtPos.x,
    tgtPos.y,
    target.outerWidth(),
    target.outerHeight(),
    p1[0],
    p1[1],
    0
  );

  var arrowEnd = math.shortenIntersection(intersect, p1,
    r.arrowShapes[tgtArShape].spacing(edge));
  var edgeEnd = math.shortenIntersection(intersect, p1,
    r.arrowShapes[tgtArShape].gap(edge));

  rs.endX = edgeEnd[0];
  rs.endY = edgeEnd[1];

  rs.arrowEndX = arrowEnd[0];
  rs.arrowEndY = arrowEnd[1];

  intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(
    srcPos.x,
    srcPos.y,
    source.outerWidth(),
    source.outerHeight(),
    p2[0],
    p2[1],
    0
  );

  var arrowStart = math.shortenIntersection(
    intersect, p2,
    r.arrowShapes[srcArShape].spacing(edge)
  );
  var edgeStart = math.shortenIntersection(
    intersect, p2,
    r.arrowShapes[srcArShape].gap(edge)
  );

  rs.startX = edgeStart[0];
  rs.startY = edgeStart[1];

  rs.arrowStartX = arrowStart[0];
  rs.arrowStartY = arrowStart[1];

  if( lines ){
    if( !is.number(rs.startX) || !is.number(rs.startY) || !is.number(rs.endX) || !is.number(rs.endY) ){
      rs.badLine = true;
    } else {
      rs.badLine = false;
    }
  }
};

BRp.getArrowWidth = BRp.getArrowHeight = function(edgeWidth) {
  var cache = this.arrowWidthCache = this.arrowWidthCache || {};

  var cachedVal = cache[edgeWidth];
  if( cachedVal ){
    return cachedVal;
  }

  cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);
  cache[edgeWidth] = cachedVal;

  return cachedVal;
};

module.exports = BRp;

},{"../../../collection/zsort":29,"../../../is":77,"../../../math":79}],57:[function(_dereq_,module,exports){
'use strict';

var BRp = {};

BRp.getCachedImage = function(url, onLoad) {
  var r = this;
  var imageCache = r.imageCache = r.imageCache || {};

  if( imageCache[url] && imageCache[url].image ){
    return imageCache[url].image;
  }

  var cache = imageCache[url] = imageCache[url] || {};

  var image = cache.image = new Image();
  image.addEventListener('load', onLoad);
  image.src = url;

  return image;
};

module.exports = BRp;

},{}],58:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');
var util = _dereq_('../../../util');

var BaseRenderer = function(){};
var BR = BaseRenderer;
var BRp = BR.prototype;

BRp.clientFunctions = [ 'redrawHint', 'render', 'renderTo', 'matchCanvasSize', 'nodeShapeImpl', 'arrowShapeImpl' ];

BRp.init = function( options ){
  var r = this;

  r.options = options;

  r.cy = options.cy;

  r.container = options.cy.container();

  r.selection = [undefined, undefined, undefined, undefined, 0]; // Coordinates for selection box, plus enabled flag

  //--Pointer-related data
  r.hoverData = {down: null, last: null,
      downTime: null, triggerMode: null,
      dragging: false,
      initialPan: [null, null], capture: false};

  r.dragData = {possibleDragElements: []};

  r.touchData = {
      start: null, capture: false,

      // These 3 fields related to tap, taphold events
      startPosition: [null, null, null, null, null, null],
      singleTouchStartTime: null,
      singleTouchMoved: true,

      now: [null, null, null, null, null, null],
      earlier: [null, null, null, null, null, null]
  };

  r.redraws = 0;
  r.showFps = options.showFps;

  r.hideEdgesOnViewport = options.hideEdgesOnViewport;
  r.hideLabelsOnViewport = options.hideLabelsOnViewport;
  r.textureOnViewport = options.textureOnViewport;
  r.wheelSensitivity = options.wheelSensitivity;
  r.motionBlurEnabled = options.motionBlur; // on by default
  r.forcedPixelRatio = options.pixelRatio;
  r.motionBlur = true; // for initial kick off
  r.motionBlurOpacity = options.motionBlurOpacity;
  r.motionBlurTransparency = 1 - r.motionBlurOpacity;
  r.motionBlurPxRatio = 1;
  r.mbPxRBlurry = 1; //0.8;
  r.minMbLowQualFrames = 4;
  r.fullQualityMb = false;
  r.clearedForMotionBlur = [];
  r.desktopTapThreshold = options.desktopTapThreshold;
  r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
  r.touchTapThreshold = options.touchTapThreshold;
  r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
  r.tapholdDuration = 500;

  r.bindings = [];

  r.registerNodeShapes();
  r.registerArrowShapes();
  r.load();
};

BRp.notify = function(params) {
  var types;
  var r = this;

  if( is.array( params.type ) ){
    types = params.type;

  } else {
    types = [ params.type ];
  }

  for( var i = 0; i < types.length; i++ ){
    var type = types[i];

    switch( type ){
      case 'destroy':
        r.destroy();
        return;

      case 'add':
      case 'remove':
      case 'load':
        r.updateElementsCache();
        break;

      case 'viewport':
        r.redrawHint('select', true);
        break;

      case 'style':
        r.updateCachedZSortedEles();
        break;
    }

    if( type === 'load' || type === 'resize' ){
      r.invalidateContainerClientCoordsCache();
      r.matchCanvasSize(r.container);
    }
  } // for

  r.redrawHint('eles', true);
  r.redrawHint('drag', true);

  this.startRenderLoop();

  this.redraw();
};

BRp.destroy = function(){
  this.destroyed = true;

  this.cy.stopAnimationLoop();

  for( var i = 0; i < this.bindings.length; i++ ){
    var binding = this.bindings[i];
    var b = binding;

    b.target.removeEventListener(b.event, b.handler, b.useCapture);
  }

  if( this.removeObserver ){
    this.removeObserver.disconnect();
  }

  if( this.labelCalcDiv ){
    try{
      document.body.removeChild(this.labelCalcDiv);
    } catch(e){
      // ie10 issue #1014
    }
  }
};

[
  _dereq_('./arrow-shapes'),
  _dereq_('./cached-eles'),
  _dereq_('./coord-ele-math'),
  _dereq_('./images'),
  _dereq_('./load-listeners'),
  _dereq_('./node-shapes'),
  _dereq_('./redraw')
].forEach(function( props ){
  util.extend( BRp, props );
});

module.exports = BR;

},{"../../../is":77,"../../../util":94,"./arrow-shapes":54,"./cached-eles":55,"./coord-ele-math":56,"./images":57,"./load-listeners":59,"./node-shapes":60,"./redraw":61}],59:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');
var util = _dereq_('../../../util');
var Event = _dereq_('../../../event');
var Collection = _dereq_('../../../collection');

var BRp = {};

BRp.registerBinding = function(target, event, handler, useCapture){
  this.bindings.push({
    target: target,
    event: event,
    handler: handler,
    useCapture: useCapture
  });

  target.addEventListener(event, handler, useCapture);
};

BRp.nodeIsDraggable = function(node) {
  if (node._private.style['opacity'].value !== 0
    && node._private.style['visibility'].value == 'visible'
    && node._private.style['display'].value == 'element'
    && !node.locked()
    && node.grabbable() ) {

    return true;
  }

  return false;
};

BRp.load = function() {
  var r = this;

  var triggerEvents = function( target, names, e, props ){
    if( target == null ){
      target = r.cy;
    }

    for( var i = 0; i < names.length; i++ ){
      var name = names[i];

      var event = Event( e, util.extend({ type: name }, props) );
      target.trigger( event );
    }
  };

  var isMultSelKeyDown = function( e ){
    return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey
  };

  var getDragListIds = function(opts){
    var listHasId;

    if( opts.addToList && r.cy.hasCompoundNodes() ){ // only needed for compound graphs
      if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
        opts.addToList.hasId = {};

        for( var i = 0; i < opts.addToList.length; i++ ){
          var ele = opts.addToList[i];

          opts.addToList.hasId[ ele.id() ] = true;
        }
      }

      listHasId = opts.addToList.hasId;
    }

    return listHasId || {};
  };

  // helper function to determine which child nodes and inner edges
  // of a compound node to be dragged as well as the grabbed and selected nodes
  var addDescendantsToDrag = function(node, opts){
    if( !node._private.cy.hasCompoundNodes() ){
      return;
    }

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    var listHasId = getDragListIds( opts );

    var innerNodes = node.descendants();

    for( var i = 0; i < innerNodes.size(); i++ ){
      var iNode = innerNodes[i];
      var _p = iNode._private;

      if( opts.inDragLayer ){
        _p.rscratch.inDragLayer = true;
      }

      if( opts.addToList && !listHasId[ iNode.id() ] ){
        opts.addToList.push( iNode );
        listHasId[ iNode.id() ] = true;

        _p.grabbed = true;
      }

      var edges = _p.edges;
      for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){
        edges[j]._private.rscratch.inDragLayer = true;
      }
    }
  };

  // adds the given nodes, and its edges to the drag layer
  var addNodeToDrag = function(node, opts){

    var _p = node._private;
    var listHasId = getDragListIds( opts );

    if( opts.inDragLayer ){
      _p.rscratch.inDragLayer = true;
    }

    if( opts.addToList && !listHasId[ node.id() ] ){
      opts.addToList.push( node );
      listHasId[ node.id() ] = true;

      _p.grabbed = true;
    }

    var edges = _p.edges;
    for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){
      edges[i]._private.rscratch.inDragLayer = true;
    }

    addDescendantsToDrag( node, opts ); // always add to drag

    // also add nodes and edges related to the topmost ancestor
    updateAncestorsInDragLayer( node, {
      inDragLayer: opts.inDragLayer
    } );
  };

  var freeDraggedElements = function( draggedElements ){
    if( !draggedElements ){ return; }

    for (var i=0; i < draggedElements.length; i++) {

      var dEi_p = draggedElements[i]._private;

      if(dEi_p.group === 'nodes') {
        dEi_p.rscratch.inDragLayer = false;
        dEi_p.grabbed = false;

        var sEdges = dEi_p.edges;
        for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }

        // for compound nodes, also remove related nodes and edges from the drag layer
        updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });

      } else if( dEi_p.group === 'edges' ){
        dEi_p.rscratch.inDragLayer = false;
      }

    }
  };

  // helper function to determine which ancestor nodes and edges should go
  // to the drag layer (or should be removed from drag layer).
  var updateAncestorsInDragLayer = function(node, opts) {

    if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

    // find top-level parent
    var parent = node;

    if( !node._private.cy.hasCompoundNodes() ){
      return;
    }

    while( parent.parent().nonempty() ){
      parent = parent.parent()[0];
    }

    // no parent node: no nodes to add to the drag layer
    if( parent == node ){
      return;
    }

    var nodes = parent.descendants()
      .merge( parent )
      .unmerge( node )
      .unmerge( node.descendants() )
    ;

    var edges = nodes.connectedEdges();

    var listHasId = getDragListIds( opts );

    for( var i = 0; i < nodes.size(); i++ ){
      if( opts.inDragLayer !== undefined ){
        nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;
      }

      if( opts.addToList && !listHasId[ nodes[i].id() ] ){
        opts.addToList.push( nodes[i] );
        listHasId[ nodes[i].id() ] = true;

        nodes[i]._private.grabbed = true;
      }
    }

    for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {
      edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;
    }
  };

  if( typeof MutationObserver !== 'undefined' ){
    r.removeObserver = new MutationObserver(function( mutns ){
      for( var i = 0; i < mutns.length; i++ ){
        var mutn = mutns[i];
        var rNodes = mutn.removedNodes;

        if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
          var rNode = rNodes[j];

          if( rNode === r.container ){
            r.destroy();
            break;
          }
        } }
      }
    });

    if( r.container.parentNode ){
      r.removeObserver.observe( r.container.parentNode, { childList: true } );
    }
  } else {
    r.registerBinding(r.container, 'DOMNodeRemoved', function(e){
      r.destroy();
    });
  }



  // auto resize
  r.registerBinding(window, 'resize', util.debounce( function(e) {
    r.invalidateContainerClientCoordsCache();

    r.matchCanvasSize(r.container);
    r.redrawHint('eles', true);
    r.redraw();
  }, 100 ) );

  var invalCtnrBBOnScroll = function(domEle){
    r.registerBinding(domEle, 'scroll', function(e){
      r.invalidateContainerClientCoordsCache();
    } );
  };

  var bbCtnr = r.cy.container();

  for( ;; ){

    invalCtnrBBOnScroll( bbCtnr );

    if( bbCtnr.parentNode ){
      bbCtnr = bbCtnr.parentNode;
    } else {
      break;
    }

  }

  // stop right click menu from appearing on cy
  r.registerBinding(r.container, 'contextmenu', function(e){
    e.preventDefault();
  });

  var inBoxSelection = function(){
    return r.selection[4] !== 0;
  };

  // Primary key
  r.registerBinding(r.container, 'mousedown', function(e) {
    e.preventDefault();
    r.hoverData.capture = true;
    r.hoverData.which = e.which;

    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements;

    r.hoverData.mdownPos = pos;

    var checkForTaphold = function(){
      r.hoverData.tapholdCancelled = false;

      clearTimeout( r.hoverData.tapholdTimeout );

      r.hoverData.tapholdTimeout = setTimeout(function(){

        if( r.hoverData.tapholdCancelled ){
          return;
        } else {
          var ele = r.hoverData.down;

          if( ele ){
            ele.trigger( Event(e, {
              type: 'taphold',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          } else {
            cy.trigger( Event(e, {
              type: 'taphold',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          }
        }

      }, r.tapholdDuration);
    };

    // Right click button
    if( e.which == 3 ){

      r.hoverData.cxtStarted = true;

      var cxtEvt = Event(e, {
        type: 'cxttapstart',
        cyPosition: { x: pos[0], y: pos[1] }
      });

      if( near ){
        near.activate();
        near.trigger( cxtEvt );

        r.hoverData.down = near;
      } else {
        cy.trigger( cxtEvt );
      }

      r.hoverData.downTime = (new Date()).getTime();
      r.hoverData.cxtDragged = false;

    // Primary button
    } else if (e.which == 1) {

      if( near ){
        near.activate();
      }

      // Element dragging
      {
        // If something is under the cursor and it is draggable, prepare to grab it
        if (near != null) {

          if( r.nodeIsDraggable(near) ){

            var grabEvent = Event(e, {
              type: 'grab',
              cyPosition: { x: pos[0], y: pos[1] }
            });

            if ( near.isNode() && !near.selected() ){

              draggedElements = r.dragData.possibleDragElements = [];
              addNodeToDrag( near, { addToList: draggedElements } );

              near.trigger(grabEvent);

            } else if ( near.isNode() && near.selected() ){
              draggedElements = r.dragData.possibleDragElements = [  ];

              var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });

              for( var i = 0; i < selectedNodes.length; i++ ){

                // Only add this selected node to drag if it is draggable, eg. has nonzero opacity
                if( r.nodeIsDraggable( selectedNodes[i] ) ){
                  addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );
                }
              }

              near.trigger( grabEvent );
            }

            r.redrawHint('eles', true);
            r.redrawHint('drag', true);

          }

        }

        r.hoverData.down = near;
        r.hoverData.downTime = (new Date()).getTime();
      }

      triggerEvents( near, ['mousedown', 'tapstart', 'vmousedown'], e, {
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if ( near == null ) {
        select[4] = 1;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);

        r.redraw();
      } else if( near.isEdge() ){
        select[4] = 1; // for future pan
      }

      checkForTaphold();

    }

    // Initialize selection box coordinates
    select[0] = select[2] = pos[0];
    select[1] = select[3] = pos[1];

  }, false);

  r.registerBinding(window, 'mousemove', function(e) {
    var preventDefault = false;
    var capture = r.hoverData.capture;

    // save cycles if mouse events aren't to be captured
    if ( !capture ){
      var containerPageCoords = r.findContainerClientCoords();

      if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth
        && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight
      ) {
        // inside container bounds so OK
      } else {
        return;
      }

      var cyContainer = r.container;
      var target = e.target;
      var tParent = target.parentNode;
      var containerIsTarget = false;

      while( tParent ){
        if( tParent === cyContainer ){
          containerIsTarget = true;
          break;
        }

        tParent = tParent.parentNode;
      }

      if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us
    }

    var cy = r.cy;
    var zoom = cy.zoom();
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var select = r.selection;

    var near = null;
    if( !r.hoverData.draggingEles ){
      near = r.findNearestElement(pos[0], pos[1], true, false);
    }
    var last = r.hoverData.last;
    var down = r.hoverData.down;

    var disp = [pos[0] - select[2], pos[1] - select[3]];

    var draggedElements = r.dragData.possibleDragElements;

    var dx = select[2] - select[0];
    var dx2 = dx * dx;
    var dy = select[3] - select[1];
    var dy2 = dy * dy;
    var dist2 = dx2 + dy2;
    var rdist2 = dist2 * zoom * zoom;

    var multSelKeyDown = isMultSelKeyDown( e );

    r.hoverData.tapholdCancelled = true;

    var updateDragDelta = function(){
      var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

      if( dragDelta.length === 0 ){
        dragDelta.push( disp[0] );
        dragDelta.push( disp[1] );
      } else {
        dragDelta[0] += disp[0];
        dragDelta[1] += disp[1];
      }
    };


    preventDefault = true;

    triggerEvents( near, ['mousemove', 'vmousemove', 'tapdrag'], e, {
      cyPosition: { x: pos[0], y: pos[1] }
    } );

    // trigger context drag if rmouse down
    if( r.hoverData.which === 3 ){
      var cxtEvt = Event(e, {
        type: 'cxtdrag',
        cyPosition: { x: pos[0], y: pos[1] }
      });

      if( down ){
        down.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      r.hoverData.cxtDragged = true;

      if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

        if( r.hoverData.cxtOver ){
          r.hoverData.cxtOver.trigger( Event(e, {
            type: 'cxtdragout',
            cyPosition: { x: pos[0], y: pos[1] }
          }) );
        }

        r.hoverData.cxtOver = near;

        if( near ){
          near.trigger( Event(e, {
            type: 'cxtdragover',
            cyPosition: { x: pos[0], y: pos[1] }
          }) );
        }

      }

    // Check if we are drag panning the entire graph
    } else if (r.hoverData.dragging) {
      preventDefault = true;

      if( cy.panningEnabled() && cy.userPanningEnabled() ){
        var deltaP;

        if( r.hoverData.justStartedPan ){
          var mdPos = r.hoverData.mdownPos;

          deltaP = {
            x: ( pos[0] - mdPos[0] ) * zoom,
            y: ( pos[1] - mdPos[1] ) * zoom
          };

          r.hoverData.justStartedPan = false;

        } else {
          deltaP = {
            x: disp[0] * zoom,
            y: disp[1] * zoom
          };

        }

        cy.panBy( deltaP );

        r.hoverData.dragged = true;
      }

      // Needs reproject due to pan changing viewport
      pos = r.projectIntoViewport(e.clientX, e.clientY);

    // Checks primary button down & out of time & mouse not moved much
    } else if(
        select[4] == 1 && (down == null || down.isEdge())
    ){

      if( !r.hoverData.dragging && cy.boxSelectionEnabled() && ( multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled() ) ){
        r.data.bgActivePosistion = undefined;
        r.hoverData.selecting = true;

        r.redrawHint('select', true);
        r.redraw();

      } else if( !r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled() ){
        r.hoverData.dragging = true;
        r.hoverData.justStartedPan = true;
        select[4] = 0;

        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);
        r.redraw();
      }

      if( down && down.isEdge() && down.active() ){ down.unactivate(); }

    } else {
      if( down && down.isEdge() && down.active() ){ down.unactivate(); }

      if (near != last) {

        if (last) {
          triggerEvents( last, ['mouseout', 'tapdragout'], e, {
            cyPosition: { x: pos[0], y: pos[1] }
          } );
        }

        if (near) {
          triggerEvents( near, ['mouseover', 'tapdragover'], e, {
            cyPosition: { x: pos[0], y: pos[1] }
          } );
        }

        r.hoverData.last = near;
      }

      if( down && down.isNode() && r.nodeIsDraggable(down) ){

        if( rdist2 >= r.desktopTapThreshold2 ){ // then drag

          var justStartedDrag = !r.dragData.didDrag;

          if( justStartedDrag ) {
            r.redrawHint('eles', true);
          }

          r.dragData.didDrag = true; // indicate that we actually did drag the node

          var toTrigger = [];

          for( var i = 0; i < draggedElements.length; i++ ){
            var dEle = draggedElements[i];

            // now, add the elements to the drag layer if not done already
            if( !r.hoverData.draggingEles ){
              addNodeToDrag( dEle, { inDragLayer: true } );
            }

            // Locked nodes not draggable, as well as non-visible nodes
            if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){
              var dPos = dEle._private.position;

              toTrigger.push( dEle );

              if( is.number(disp[0]) && is.number(disp[1]) ){
                var updatePos = !dEle.isParent();

                if( updatePos ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];
                }

                if( justStartedDrag ){
                  var dragDelta = r.hoverData.dragDelta;

                  if( updatePos && is.number(dragDelta[0]) && is.number(dragDelta[1]) ){
                    dPos.x += dragDelta[0];
                    dPos.y += dragDelta[1];
                  }
                }
              }

            }
          }

          r.hoverData.draggingEles = true;

          var tcol = (Collection(cy, toTrigger));

          tcol.updateCompoundBounds();
          tcol.trigger('position drag');

          r.redrawHint('drag', true);
          r.redraw();

        } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
          updateDragDelta();
        }
      }

      // prevent the dragging from triggering text selection on the page
      preventDefault = true;
    }

    select[2] = pos[0]; select[3] = pos[1];

    if( preventDefault ){
      if(e.stopPropagation) e.stopPropagation();
        if(e.preventDefault) e.preventDefault();
        return false;
      }
  }, false);

  r.registerBinding(window, 'mouseup', function(e) {
    var capture = r.hoverData.capture;
    if (!capture) { return; }
    r.hoverData.capture = false;

    var cy = r.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.selection;
    var near = r.findNearestElement(pos[0], pos[1], true, false);
    var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
    var multSelKeyDown = isMultSelKeyDown( e );

    if( r.data.bgActivePosistion ){
      r.redrawHint('select', true);
      r.redraw();
    }

    r.hoverData.tapholdCancelled = true;

    r.data.bgActivePosistion = undefined; // not active bg now

    if( down ){
      down.unactivate();
    }

    if( r.hoverData.which === 3 ){
      var cxtEvt = Event(e, {
        type: 'cxttapend',
        cyPosition: { x: pos[0], y: pos[1] }
      });

      if( down ){
        down.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( !r.hoverData.cxtDragged ){
        var cxtTap = Event(e, {
          type: 'cxttap',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtTap );
        } else {
          cy.trigger( cxtTap );
        }
      }

      r.hoverData.cxtDragged = false;
      r.hoverData.which = null;

    } else if( r.hoverData.which === 1 ) {

      // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
      if ( (down == null) // not mousedown on node
        && !r.dragData.didDrag // didn't move the node around
        && !r.hoverData.selecting // not box selection
        && !r.hoverData.dragged // didn't pan
        && !isMultSelKeyDown( e )
      ) {

        cy.$(function(){
          return this.selected();
        }).unselect();

        if (draggedElements.length > 0) {
          r.redrawHint('eles', true);
        }

        r.dragData.possibleDragElements = draggedElements = [];
      }

      triggerEvents( near, ['mouseup', 'tapend', 'vmouseup'], e, {
        cyPosition: { x: pos[0], y: pos[1] }
      } );

      if(
        !r.dragData.didDrag // didn't move a node around
        && !r.hoverData.dragged // didn't pan
      ){
        triggerEvents( near, ['click', 'tap', 'vclick'], e, {
          cyPosition: { x: pos[0], y: pos[1] }
        } );
      }

      // Single selection
      if( near == down && !r.dragData.didDrag && !r.hoverData.selecting ){
        if( near != null && near._private.selectable ){

          if( r.hoverData.dragging ){
            // if panning, don't change selection state
          } else if( cy.selectionType() === 'additive' || multSelKeyDown ){
            if( near.selected() ){
              near.unselect();
            } else {
              near.select();
            }
          } else {
            if( !multSelKeyDown ){
              cy.$(':selected').unmerge( near ).unselect();
              near.select();
            }
          }

          r.redrawHint('eles', true);
        }
      }

      if ( r.hoverData.selecting ) {
        var newlySelected = [];
        var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

        r.redrawHint('select', true);

        if( box.length > 0 ) {
          r.redrawHint('eles', true);
        }

        for( var i = 0; i < box.length; i++ ){
          if( box[i]._private.selectable ){
            newlySelected.push( box[i] );
          }
        }

        var newlySelCol = Collection( cy, newlySelected );

        if( cy.selectionType() === 'additive' ){
          newlySelCol.select();
        } else {
          if( !multSelKeyDown ){
            cy.$(':selected').unmerge( newlySelCol ).unselect();
          }

          newlySelCol.select();
        }

        // always need redraw in case eles unselectable
        r.redraw();

      }

      // Cancel drag pan
      if( r.hoverData.dragging ){
        r.hoverData.dragging = false;

        r.redrawHint('select', true);
        r.redrawHint('eles', true);

        r.redraw();
      }

      if (!select[4]) {


        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        freeDraggedElements( draggedElements );

        if( down ){ down.trigger('free'); }
      }

    } // else not right mouse

    select[4] = 0; r.hoverData.down = null;

    r.hoverData.cxtStarted = false;
    r.hoverData.draggingEles = false;
    r.hoverData.selecting = false;
    r.dragData.didDrag = false;
    r.hoverData.dragged = false;
    r.hoverData.dragDelta = [];

  }, false);

  var wheelHandler = function(e) {


    if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

    var cy = r.cy;
    var pos = r.projectIntoViewport(e.clientX, e.clientY);
    var rpos = [pos[0] * cy.zoom() + cy.pan().x,
                  pos[1] * cy.zoom() + cy.pan().y];

    if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
      e.preventDefault();
      return;
    }

    if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
      e.preventDefault();

      r.data.wheelZooming = true;
      clearTimeout( r.data.wheelTimeout );
      r.data.wheelTimeout = setTimeout(function(){
        r.data.wheelZooming = false;

        r.redrawHint('eles', true);
        r.redraw();
      }, 150);

      var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;
      diff = diff * r.wheelSensitivity;

      var needsWheelFix = e.deltaMode === 1;
      if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
        diff *= 33;
      }

      cy.zoom({
        level: cy.zoom() * Math.pow(10, diff),
        renderedPosition: { x: rpos[0], y: rpos[1] }
      });
    }

  };

  // Functions to help with whether mouse wheel should trigger zooming
  // --
  r.registerBinding(r.container, 'wheel', wheelHandler, true);

  // disable nonstandard wheel events
  // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);
  // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);
  // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

  r.registerBinding(window, 'scroll', function(e){
    r.scrollingPage = true;

    clearTimeout( r.scrollingPageTimeout );
    r.scrollingPageTimeout = setTimeout(function(){
      r.scrollingPage = false;
    }, 250);
  }, true);

  // Functions to help with handling mouseout/mouseover on the Cytoscape container
        // Handle mouseout on Cytoscape container
  r.registerBinding(r.container, 'mouseout', function(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);

    r.cy.trigger(Event(e, {
      type: 'mouseout',
      cyPosition: { x: pos[0], y: pos[1] }
    }));
  }, false);

  r.registerBinding(r.container, 'mouseover', function(e) {
    var pos = r.projectIntoViewport(e.clientX, e.clientY);

    r.cy.trigger(Event(e, {
      type: 'mouseover',
      cyPosition: { x: pos[0], y: pos[1] }
    }));
  }, false);

  var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
  var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
  var center1, modelCenter1; // center point on start pinch to zoom
  var offsetLeft, offsetTop;
  var containerWidth, containerHeight;
  var twoFingersStartInside;

  var distance = function(x1, y1, x2, y2){
    return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
  };

  var distanceSq = function(x1, y1, x2, y2){
    return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
  };

  var touchstartHandler;
  r.registerBinding(r.container, 'touchstart', touchstartHandler = function(e) {
    r.touchData.capture = true;
    r.data.bgActivePosistion = undefined;

    var cy = r.cy;
    var nodes = r.getCachedNodes();
    var edges = r.getCachedEdges();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }


    // record starting points for pinch-to-zoom
    if( e.touches[1] ){

      // anything in the set of dragged eles should be released
      var release = function( eles ){
        for( var i = 0; i < eles.length; i++ ){
          eles[i]._private.grabbed = false;
          eles[i]._private.rscratch.inDragLayer = false;
          if( eles[i].active() ){ eles[i].unactivate(); }
        }
      };
      release(nodes);
      release(edges);

      var offsets = r.findContainerClientCoords();
      offsetLeft = offsets[0];
      offsetTop = offsets[1];
      containerWidth = offsets[2];
      containerHeight = offsets[3];

      f1x1 = e.touches[0].clientX - offsetLeft;
      f1y1 = e.touches[0].clientY - offsetTop;

      f2x1 = e.touches[1].clientX - offsetLeft;
      f2y1 = e.touches[1].clientY - offsetTop;

      twoFingersStartInside =
           0 <= f1x1 && f1x1 <= containerWidth
        && 0 <= f2x1 && f2x1 <= containerWidth
        && 0 <= f1y1 && f1y1 <= containerHeight
        && 0 <= f2y1 && f2y1 <= containerHeight
      ;

      var pan = cy.pan();
      var zoom = cy.zoom();

      distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
      distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
      center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];
      modelCenter1 = [
        (center1[0] - pan.x) / zoom,
        (center1[1] - pan.y) / zoom
      ];

      // consider context tap
      var cxtDistThreshold = 200;
      var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
      if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

        var near1 = r.findNearestElement(now[0], now[1], true, true);
        var near2 = r.findNearestElement(now[2], now[3], true, true);

        if( near1 && near1.isNode() ){
          near1.activate().trigger( Event(e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          }) );
          r.touchData.start = near1;

        } else if( near2 && near2.isNode() ){
          near2.activate().trigger( Event(e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          }) );
          r.touchData.start = near2;

        } else {
          cy.trigger( Event(e, {
            type: 'cxttapstart',
            cyPosition: { x: now[0], y: now[1] }
          }) );
          r.touchData.start = null;
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = true;
        r.touchData.cxtDragged = false;
        r.data.bgActivePosistion = undefined;

        r.redraw();
        return;

      }

    }

    if (e.touches[2]) {

    } else if (e.touches[1]) {

    } else if (e.touches[0]) {
      var near = r.findNearestElement(now[0], now[1], true, true);

      if (near != null) {
        near.activate();

        r.touchData.start = near;

        if( near.isNode() && r.nodeIsDraggable(near) ){

          var draggedEles = r.dragData.touchDragEles = [];

          r.redrawHint('eles', true);
          r.redrawHint('drag', true);

          if( near.selected() ){
            // reset drag elements, since near will be added again

            var selectedNodes = cy.$(function(){
              return this.isNode() && this.selected();
            });

            for( var k = 0; k < selectedNodes.length; k++ ){
              var selectedNode = selectedNodes[k];

              if( r.nodeIsDraggable(selectedNode) ){
                addNodeToDrag( selectedNode, { addToList: draggedEles } );
              }
            }
          } else {
            addNodeToDrag( near, { addToList: draggedEles } );
          }

          near.trigger( Event(e, {
            type: 'grab',
            cyPosition: { x: now[0], y: now[1] }
          }) );
        }
      }

      triggerEvents( near, ['touchstart', 'tapstart', 'vmousedown'], e, {
        cyPosition: { x: now[0], y: now[1] }
      } );

      if (near == null) {
        r.data.bgActivePosistion = {
          x: pos[0],
          y: pos[1]
        };

        r.redrawHint('select', true);
        r.redraw();
      }


      // Tap, taphold
      // -----

      for (var i=0; i<now.length; i++) {
        earlier[i] = now[i];
        r.touchData.startPosition[i] = now[i];
      }

      r.touchData.singleTouchMoved = false;
      r.touchData.singleTouchStartTime = +new Date();

      clearTimeout( r.touchData.tapholdTimeout );
      r.touchData.tapholdTimeout = setTimeout(function() {
        if(
            r.touchData.singleTouchMoved === false
            && !r.pinching // if pinching, then taphold unselect shouldn't take effect
        ){
          triggerEvents( r.touchData.start, ['taphold'], e, {
            cyPosition: { x: now[0], y: now[1] }
          } );

          if (!r.touchData.start) {
            cy.$(':selected').unselect();
          }

        }
      }, r.tapholdDuration);
    }

  }, false);

  var touchmoveHandler;
  r.registerBinding(window, 'touchmove', touchmoveHandler = function(e) {

    var select = r.selection;
    var capture = r.touchData.capture;
    var cy = r.cy;
    var now = r.touchData.now; var earlier = r.touchData.earlier;
    var zoom = cy.zoom();

    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

    var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }
    var startPos = r.touchData.startPosition;
    var dx = now[0] - startPos[0];
    var dx2 = dx * dx;
    var dy = now[1] - startPos[1];
    var dy2 = dy * dy;
    var dist2 = dx2 + dy2;
    var rdist2 = dist2 * zoom * zoom;

    // context swipe cancelling
    if( capture && r.touchData.cxt ){
      e.preventDefault();

      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
      // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      var factorSq = distance2Sq / distance1Sq;

      var distThreshold = 150;
      var distThresholdSq = distThreshold * distThreshold;
      var factorThreshold = 1.5;
      var factorThresholdSq = factorThreshold * factorThreshold;

      // cancel ctx gestures if the distance b/t the fingers increases
      if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
        r.touchData.cxt = false;
        if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }
        r.data.bgActivePosistion = undefined;
        r.redrawHint('select', true);

        var cxtEvt = Event(e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        });
        if( r.touchData.start ){
          r.touchData.start.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }
      }

    }

    // context swipe
    if( capture && r.touchData.cxt ){
      var cxtEvt = Event(e, {
        type: 'cxtdrag',
        cyPosition: { x: now[0], y: now[1] }
      });
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      if( r.touchData.start ){
        r.touchData.start.trigger( cxtEvt );
      } else {
        cy.trigger( cxtEvt );
      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxtDragged = true;

      var near = r.findNearestElement(now[0], now[1], true, true);

      if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

        if( r.touchData.cxtOver ){
          r.touchData.cxtOver.trigger( Event(e, {
            type: 'cxtdragout',
            cyPosition: { x: now[0], y: now[1] }
          }) );
        }

        r.touchData.cxtOver = near;

        if( near ){
          near.trigger( Event(e, {
            type: 'cxtdragover',
            cyPosition: { x: now[0], y: now[1] }
          }) );

        }

      }

    // box selection
    } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
      e.preventDefault();

      r.data.bgActivePosistion = undefined;

      this.lastThreeTouch = +new Date();
      r.touchData.selecting = true;

      r.redrawHint('select', true);

      if( !select || select.length === 0 || select[0] === undefined ){
        select[0] = (now[0] + now[2] + now[4])/3;
        select[1] = (now[1] + now[3] + now[5])/3;
        select[2] = (now[0] + now[2] + now[4])/3 + 1;
        select[3] = (now[1] + now[3] + now[5])/3 + 1;
      } else {
        select[2] = (now[0] + now[2] + now[4])/3;
        select[3] = (now[1] + now[3] + now[5])/3;
      }

      select[4] = 1;
      r.touchData.selecting = true;

      r.redraw();

    // pinch to zoom
    } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom
      e.preventDefault();

      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      var draggedEles = r.dragData.touchDragEles;
      if( draggedEles ){
        r.redrawHint('drag', true);

        for( var i = 0; i < draggedEles.length; i++ ){
          draggedEles[i]._private.grabbed = false;
          draggedEles[i]._private.rscratch.inDragLayer = false;
        }
      }

      // (x2, y2) for fingers 1 and 2
      var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
      var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;


      var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
      // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
      // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
      var factor = distance2 / distance1;

      if( factor != 1 && twoFingersStartInside){
        // delta finger1
        var df1x = f1x2 - f1x1;
        var df1y = f1y2 - f1y1;

        // delta finger 2
        var df2x = f2x2 - f2x1;
        var df2y = f2y2 - f2y1;

        // translation is the normalised vector of the two fingers movement
        // i.e. so pinching cancels out and moving together pans
        var tx = (df1x + df2x)/2;
        var ty = (df1y + df2y)/2;

        // adjust factor by the speed multiplier
        // var speed = 1.5;
        // if( factor > 1 ){
        //   factor = (factor - 1) * speed + 1;
        // } else {
        //   factor = 1 - (1 - factor) * speed;
        // }

        // now calculate the zoom
        var zoom1 = cy.zoom();
        var zoom2 = zoom1 * factor;
        var pan1 = cy.pan();

        // the model center point converted to the current rendered pos
        var ctrx = modelCenter1[0] * zoom1 + pan1.x;
        var ctry = modelCenter1[1] * zoom1 + pan1.y;

        var pan2 = {
          x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,
          y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry
        };

        // remove dragged eles
        if( r.touchData.start ){
          var draggedEles = r.dragData.touchDragEles;

          if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){
            var dEi_p = draggedEles[i]._private;

            dEi_p.grabbed = false;
            dEi_p.rscratch.inDragLayer = false;
          } }

          var start_p = r.touchData.start._private;
          start_p.active = false;
          start_p.grabbed = false;
          start_p.rscratch.inDragLayer = false;

          r.redrawHint('drag', true);

          r.touchData.start
            .trigger('free')
            .trigger('unactivate')
          ;
        }

        cy.viewport({
          zoom: zoom2,
          pan: pan2,
          cancelOnFailedZoom: true
        });

        distance1 = distance2;
        f1x1 = f1x2;
        f1y1 = f1y2;
        f2x1 = f2x2;
        f2y1 = f2y2;

        r.pinching = true;
      }

      // Re-project
      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

    } else if (e.touches[0]) {
      var start = r.touchData.start;
      var last = r.touchData.last;
      var near = near || r.findNearestElement(now[0], now[1], true, true);

      if( start != null ){
        e.preventDefault();
      }

      // dragging nodes
      if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){

        if( rdist2 >= r.touchTapThreshold2 ){ // then dragging can happen
          var draggedEles = r.dragData.touchDragEles;
          var justStartedDrag = !r.dragData.didDrag;

          for( var k = 0; k < draggedEles.length; k++ ){
            var draggedEle = draggedEles[k];

            if( justStartedDrag ){
              addNodeToDrag( draggedEle, { inDragLayer: true } );
            }

            if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){
              r.dragData.didDrag = true;
              var dPos = draggedEle._private.position;
              var updatePos = !draggedEle.isParent();

              if( updatePos && is.number(disp[0]) && is.number(disp[1]) ){
                dPos.x += disp[0];
                dPos.y += disp[1];
              }

              if( justStartedDrag ){
                r.redrawHint('eles', true);

                var dragDelta = r.touchData.dragDelta;

                if( updatePos && is.number(dragDelta[0]) && is.number(dragDelta[1]) ){
                  dPos.x += dragDelta[0];
                  dPos.y += dragDelta[1];
                }

              }
            }
          }

          var tcol = Collection(cy, draggedEles);

          tcol.updateCompoundBounds();
          tcol.trigger('position drag');

          r.hoverData.draggingEles = true;

          r.redrawHint('drag', true);

          if(
               r.touchData.startPosition[0] == earlier[0]
            && r.touchData.startPosition[1] == earlier[1]
          ){

            r.redrawHint('eles', true);
          }

          r.redraw();
        } else { // otherise keep track of drag delta for later
          var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

          if( dragDelta.length === 0 ){
            dragDelta.push( disp[0] );
            dragDelta.push( disp[1] );
          } else {
            dragDelta[0] += disp[0];
            dragDelta[1] += disp[1];
          }
        }
      }

      // touchmove
      {
        triggerEvents( (start || near), ['touchmove', 'tapdrag', 'vmousemove'], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

        if (near != last) {
          if (last) { last.trigger(Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }
          if (near) { near.trigger(Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }
        }

        r.touchData.last = near;
      }

      // check to cancel taphold
      for (var i=0;i<now.length;i++) {
        if( now[i]
          && r.touchData.startPosition[i]
          && rdist2 > r.touchTapThreshold2 ){

          r.touchData.singleTouchMoved = true;
        }
      }

      // panning
      if(
          capture
          && ( start == null || start.isEdge() )
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){

        e.preventDefault();

        if( r.swipePanning ){
          cy.panBy({
            x: disp[0] * zoom,
            y: disp[1] * zoom
          });

        } else if( rdist2 >= r.touchTapThreshold2 ){
          r.swipePanning = true;

          cy.panBy({
            x: dx * zoom,
            y: dy * zoom
          });

          if( start ){
            start.unactivate();

            if( !r.data.bgActivePosistion ){
              r.data.bgActivePosistion = {
                x: now[0],
                y: now[1]
              };
            }

            r.redrawHint('select', true);

            r.touchData.start = null;
          }
        }

        // Re-project
        var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
        now[0] = pos[0]; now[1] = pos[1];
      }
    }

    for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }
    //r.redraw();

  }, false);

  var touchcancelHandler;
  r.registerBinding(window, 'touchcancel', touchcancelHandler = function(e) {
    var start = r.touchData.start;

    r.touchData.capture = false;

    if( start ){
      start.unactivate();
    }
  });

  var touchendHandler;
  r.registerBinding(window, 'touchend', touchendHandler = function(e) {
    var start = r.touchData.start;

    var capture = r.touchData.capture;

    if( capture ){
      r.touchData.capture = false;

      e.preventDefault();
    } else {
      return;
    }

    var select = r.selection;

    r.swipePanning = false;
    r.hoverData.draggingEles = false;

    var cy = r.cy;
    var zoom = cy.zoom();
    var now = r.touchData.now;
    var earlier = r.touchData.earlier;

    if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
    if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
    if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

    if( start ){
      start.unactivate();
    }

    var ctxTapend;
    if( r.touchData.cxt ){
      ctxTapend = Event(e, {
        type: 'cxttapend',
        cyPosition: { x: now[0], y: now[1] }
      });

      if( start ){
        start.trigger( ctxTapend );
      } else {
        cy.trigger( ctxTapend );
      }

      if( !r.touchData.cxtDragged ){
        var ctxTap = Event(e, {
          type: 'cxttap',
          cyPosition: { x: now[0], y: now[1] }
        });

        if( start ){
          start.trigger( ctxTap );
        } else {
          cy.trigger( ctxTap );
        }

      }

      if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
      r.touchData.cxt = false;
      r.touchData.start = null;

      r.redraw();
      return;
    }

    // no more box selection if we don't have three fingers
    if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
      r.touchData.selecting = false;

      var newlySelected = [];
      var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

      select[0] = undefined;
      select[1] = undefined;
      select[2] = undefined;
      select[3] = undefined;
      select[4] = 0;

      r.redrawHint('select', true);

      for( var i = 0; i< box.length; i++ ) {
        if( box[i]._private.selectable ){
          newlySelected.push( box[i] );
        }
      }

      var newlySelCol = Collection( cy, newlySelected );

      newlySelCol.select();

      if( newlySelCol.length > 0 ) {
        r.redrawHint('eles', true);
      } else {
        r.redraw();
      }
    }

    var updateStartStyle = false;

    if( start != null ){
      start._private.active = false;
      updateStartStyle = true;
      start.unactivate();
    }

    if (e.touches[2]) {
      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);
    } else if (e.touches[1]) {

    } else if (e.touches[0]) {

    // Last touch released
    } else if (!e.touches[0]) {

      r.data.bgActivePosistion = undefined;
      r.redrawHint('select', true);

      var draggedEles = r.dragData.touchDragEles;

      if (start != null ) {

        var startWasGrabbed = start._private.grabbed;

        freeDraggedElements( draggedEles );

        r.redrawHint('drag', true);
        r.redrawHint('eles', true);

        if( startWasGrabbed ){
          start.trigger('free');
        }

        triggerEvents( start, ['touchend', 'tapend', 'vmouseup'], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

        start.unactivate();

        r.touchData.start = null;

      } else {
        var near = r.findNearestElement(now[0], now[1], true, true);

        triggerEvents( near, ['touchend', 'tapend', 'vmouseup'], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );

      }

      var dx = r.touchData.startPosition[0] - now[0];
      var dx2 = dx * dx;
      var dy = r.touchData.startPosition[1] - now[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
      if (start != null
          && !r.dragData.didDrag // didn't drag nodes around
          && start._private.selectable
          && rdist2 < r.touchTapThreshold2
          && !r.pinching // pinch to zoom should not affect selection
      ) {

        if( cy.selectionType() === 'single' ){
          cy.$(':selected').unmerge( start ).unselect();
          start.select();
        } else {
          if( start.selected() ){
            start.unselect();
          } else {
            start.select();
          }
        }

        updateStartStyle = true;


        r.redrawHint('eles', true);
      }

      // Tap event, roughly same as mouse click event for touch
      if( !r.touchData.singleTouchMoved ){
        triggerEvents( start, ['tap', 'vclick'], e, {
          cyPosition: { x: now[0], y: now[1] }
        } );
      }

      r.touchData.singleTouchMoved = true;
    }

    for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }

    r.dragData.didDrag = false; // reset for next mousedown

    if( e.touches.length === 0 ){
      r.touchData.dragDelta = [];
    }

    if( updateStartStyle && start ){
      start.updateStyle(false);
    }

    if( e.touches.length < 2 ){
      r.pinching = false;
      r.redrawHint('eles', true);
      r.redraw();
    }

    //r.redraw();

  }, false);

  // fallback compatibility layer for ms pointer events
  if( typeof TouchEvent === 'undefined' ){

    var pointers = [];

    var makeTouch = function( e ){
      return {
        clientX: e.clientX,
        clientY: e.clientY,
        force: 1,
        identifier: e.pointerId,
        pageX: e.pageX,
        pageY: e.pageY,
        radiusX: e.width/2,
        radiusY: e.height/2,
        screenX: e.screenX,
        screenY: e.screenY,
        target: e.target
      };
    };

    var makePointer = function( e ){
      return {
        event: e,
        touch: makeTouch(e)
      };
    };

    var addPointer = function( e ){
      pointers.push( makePointer(e) );
    };

    var removePointer = function( e ){
      for( var i = 0; i < pointers.length; i++ ){
        var p = pointers[i];

        if( p.event.pointerId === e.pointerId ){
          pointers.splice( i, 1 );
          return;
        }
      }
    };

    var updatePointer = function( e ){
      var p = pointers.filter(function( p ){
        return p.event.pointerId === e.pointerId;
      })[0];

      p.event = e;
      p.touch = makeTouch(e);
    };

    var addTouchesToEvent = function( e ){
      e.touches = pointers.map(function( p ){
        return p.touch;
      });
    };

    var pointerIsMouse = function( e ){
      return e.pointerType === 'mouse' || e.pointerType === 4;
    };

    r.registerBinding(r.container, 'pointerdown', function(e){
      if( pointerIsMouse(e) ){ return; } // mouse already handled

      e.preventDefault();

      addPointer( e );

      addTouchesToEvent( e );
      touchstartHandler( e );
    });

    r.registerBinding(r.container, 'pointerup', function(e){
      if( pointerIsMouse(e) ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchendHandler( e );
    });

    r.registerBinding(r.container, 'pointercancel', function(e){
      if( pointerIsMouse(e) ){ return; } // mouse already handled

      removePointer( e );

      addTouchesToEvent( e );
      touchcancelHandler( e );
    });

    r.registerBinding(r.container, 'pointermove', function(e){
      if( pointerIsMouse(e) ){ return; } // mouse already handled

      e.preventDefault();

      updatePointer( e );

      addTouchesToEvent( e );
      touchmoveHandler( e );
    });

  }
};

module.exports = BRp;

},{"../../../collection":23,"../../../event":42,"../../../is":77,"../../../util":94}],60:[function(_dereq_,module,exports){
'use strict';

var math = _dereq_('../../../math');

var BRp = {};

BRp.registerNodeShapes = function(){
  var nodeShapes = this.nodeShapes = {};
  var renderer = this;

  nodeShapes['ellipse'] = {
    name: 'ellipse',

    draw: function( context, centerX, centerY, width, height ){
      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding)
      ;
    },

    checkPoint: function( x, y, padding, width, height, centerX, centerY ){
      x -= centerX;
      y -= centerY;

      x /= (width / 2 + padding);
      y /= (height / 2 + padding);

      return x*x + y*y <= 1;
    }
  };

  function generatePolygon( name, points ){
    return ( nodeShapes[name] = {
      name: name,

      points: points,

      draw: function( context, centerX, centerY, width, height ){
        renderer.nodeShapeImpl('polygon')( context, centerX, centerY, width, height, this.points );
      },

      intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
        return math.polygonIntersectLine(
            x, y,
            this.points,
            nodeX,
            nodeY,
            width / 2, height / 2,
            padding)
          ;
      },

      checkPoint: function( x, y, padding, width, height, centerX, centerY ){
        return math.pointInsidePolygon(x, y, nodeShapes[name].points,
          centerX, centerY, width, height, [0, -1], padding)
        ;
      }
    } );
  }

  generatePolygon( 'triangle', math.generateUnitNgonPointsFitToSquare(3, 0) );

  generatePolygon( 'square', math.generateUnitNgonPointsFitToSquare(4, 0) );
  nodeShapes['rectangle'] = nodeShapes['square'];

  nodeShapes['roundrectangle'] = {
    name: 'roundrectangle',

    points: math.generateUnitNgonPointsFitToSquare(4, 0),

    draw: function( context, centerX, centerY, width, height ){
      renderer.nodeShapeImpl( this.name )( context, centerX, centerY, width, height );
    },

    intersectLine: function( nodeX, nodeY, width, height, x, y, padding ){
      return math.roundRectangleIntersectLine(
        x, y,
        nodeX,
        nodeY,
        width, height,
        padding)
      ;
    },

    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY ){

      var cornerRadius = math.getRoundRectangleRadius(width, height);

      // Check hBox
      if (math.pointInsidePolygon(x, y, this.points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding) ){
        return true;
      }

      // Check vBox
      if (math.pointInsidePolygon(x, y, this.points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding) ){
        return true;
      }

      var checkInEllipse = function( x, y, centerX, centerY, width, height, padding ){
        x -= centerX;
        y -= centerY;

        x /= (width / 2 + padding);
        y /= (height / 2 + padding);

        return (x*x + y*y <= 1);
      };


      // Check top left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding) ){

        return true;
      }

      // Check top right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding) ){

        return true;
      }

      // Check bottom right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding) ){

        return true;
      }

      // Check bottom left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding) ){

        return true;
      }

      return false;
    }
  };

  generatePolygon( 'diamond', [
    0, 1,
    1, 0,
    0, -1,
    -1, 0
  ] );

  generatePolygon( 'pentagon', math.generateUnitNgonPointsFitToSquare(5, 0) );

  generatePolygon( 'hexagon', math.generateUnitNgonPointsFitToSquare(6, 0) );

  generatePolygon( 'heptagon', math.generateUnitNgonPointsFitToSquare(7, 0) );

  generatePolygon( 'octagon', math.generateUnitNgonPointsFitToSquare(8, 0) );

  var star5Points = new Array(20);
  {
    var outerPoints = math.generateUnitNgonPoints(5, 0);
    var innerPoints = math.generateUnitNgonPoints(5, Math.PI / 5);

    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;

    for (var i=0;i<innerPoints.length/2;i++ ){
      innerPoints[i*2] *= innerRadius;
      innerPoints[i*2+1] *= innerRadius;
    }

    for (var i=0;i<20/4;i++ ){
      star5Points[i*4] = outerPoints[i*2];
      star5Points[i*4+1] = outerPoints[i*2+1];

      star5Points[i*4+2] = innerPoints[i*2];
      star5Points[i*4+3] = innerPoints[i*2+1];
    }
  }

  star5Points = math.fitPolygonToSquare( star5Points );

  generatePolygon( 'star', star5Points );

  generatePolygon( 'vee', [
    -1, -1,
    0, -0.333,
    1, -1,
    0, 1
  ] );

  generatePolygon( 'rhomboid', [
    -1, -1,
    0.333, -1,
    1, 1,
    -0.333, 1
  ] );

  nodeShapes.makePolygon = function( points ){

    // use caching on user-specified polygons so they are as fast as native shapes

    var key = points.join('$');
    var name = 'polygon-' + key;
    var shape;

    if( (shape = nodeShapes[name]) ){ // got cached shape
      return shape;
    }

    // create and cache new shape
    return generatePolygon( name, points );
  };

};

module.exports = BRp;

},{"../../../math":79}],61:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../../../util');

var BRp = {};

BRp.timeToRender = function(){
  return this.redrawTotalTime / this.redrawCount;
};

var minRedrawLimit = 1000/60; // people can't see much better than 60fps
var maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth

BRp.redraw = function( options ){
  options = options || util.staticEmptyObject();

  var r = this;
  var forcedContext = options.forcedContext;

  if( r.averageRedrawTime === undefined ){ r.averageRedrawTime = 0; }
  if( r.lastRedrawTime === undefined ){ r.lastRedrawTime = 0; }

  var redrawLimit = r.lastRedrawTime; // estimate the ideal redraw limit based on how fast we can draw
  redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;
  redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;

  if( r.lastDrawTime === undefined ){ r.lastDrawTime = 0; }

  var nowTime = Date.now();
  var timeElapsed = nowTime - r.lastDrawTime;
  var callAfterLimit = timeElapsed >= redrawLimit;

  if( !forcedContext ){
    if( !callAfterLimit || r.currentlyDrawing ){
      r.skipFrame = true;
      return;
    }
  }

  r.requestedFrame = true;
  r.currentlyDrawing = true;
  r.renderOptions = options;
};

BRp.startRenderLoop = function(){
  var r = this;

  var renderFn = function(){
    if( r.destroyed ){ return; }

    if( r.requestedFrame && !r.skipFrame ){
      var startTime = util.performanceNow();

      r.render( r.renderOptions );

      var endTime = r.lastRedrawTime = util.performanceNow();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      var duration = endTime - startTime;

      r.redrawTotalTime += duration;
      r.lastRedrawTime = duration;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime/2 + duration/2;

      r.requestedFrame = false;
    }

    r.skipFrame = false;

    util.requestAnimationFrame( renderFn );
  };

  util.requestAnimationFrame( renderFn );

};

module.exports = BRp;

},{"../../../util":94}],62:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

var impl;

CRp.arrowShapeImpl = function( name ){
  return ( impl || (impl = {
    'polygon': function( context, points ){
      for( var i = 0; i < points.length; i++ ){
        var pt = points[i];

        context.lineTo( pt.x, pt.y );
      }
    },

    'triangle-backcurve': function( context, points, controlPoint ){
      var firstPt;

      for( var i = 0; i < points.length; i++ ){
        var pt = points[i];

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo( pt.x, pt.y );
      }

      context.quadraticCurveTo( controlPoint.x, controlPoint.y, firstPt.x, firstPt.y );
    },

    'triangle-tee': function( context, trianglePoints, teePoints ){
      var triPts = trianglePoints;
      for( var i = 0; i < triPts.length; i++ ){
        var pt = triPts[i];

        context.lineTo( pt.x, pt.y );
      }

      var teePts = teePoints;
      var firstTeePt = teePoints[0];
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for( var i = 0; i < teePts.length; i++ ){
        var pt = teePts[i];

        context.lineTo( pt.x, pt.y );
      }
    },

    'circle': function( context, rx, ry, r ){
      context.arc(rx, ry, r, 0, Math.PI * 2, false);
    }
  }) )[ name ];
};

module.exports = CRp;

},{}],63:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

CRp.drawEdge = function(context, edge, drawOverlayInstead) {
  var rs = edge._private.rscratch;
  var usePaths = this.usePaths();

  // if bezier ctrl pts can not be calculated, then die
  if( rs.badBezier || rs.badLine || isNaN( rs.allpts[0] ) ){ // iNaN in case edge is impossible and browser bugs (e.g. safari)
    return;
  }

  var style = edge._private.style;

  // Edge line width
  if (style['width'].pfValue <= 0) {
    return;
  }

  var overlayPadding = style['overlay-padding'].pfValue;
  var overlayOpacity = style['overlay-opacity'].value;
  var overlayColor = style['overlay-color'].value;

  // Edge color & opacity
  if( drawOverlayInstead ){

    if( overlayOpacity === 0 ){ // exit early if no overlay
      return;
    }

    this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
    context.lineCap = 'round';

    if( rs.edgeType == 'self' && !usePaths ){
      context.lineCap = 'butt';
    }

  } else {
    var lineColor = style['line-color'].value;

    this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);

    context.lineCap = 'butt';
  }

  var edgeWidth = style['width'].pfValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
  var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;
  context.lineWidth = edgeWidth;

  var shadowBlur = style['shadow-blur'].pfValue;
  var shadowOpacity = style['shadow-opacity'].value;
  var shadowColor = style['shadow-color'].value;
  var shadowOffsetX = style['shadow-offset-x'].pfValue;
  var shadowOffsetY = style['shadow-offset-y'].pfValue;

  this.shadowStyle(context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

  this.drawEdgePath(
    edge,
    context,
    rs.allpts,
    lineStyle,
    edgeWidth
  );

  this.drawArrowheads(context, edge, drawOverlayInstead);

  this.shadowStyle(context, 'transparent', 0); // reset for next guy

};


CRp.drawEdgePath = function(edge, context, pts, type, width) {
  var rs = edge._private.rscratch;
  var canvasCxt = context;
  var path;
  var pathCacheHit = false;
  var usePaths = this.usePaths();

  if( usePaths ){
    var pathCacheKey = pts.join('$');
    var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;

    if( keyMatches ){
      path = context = rs.pathCache;
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      rs.pathCacheKey = pathCacheKey;
      rs.pathCache = path;
    }
  }

  if( canvasCxt.setLineDash ){ // for very outofdate browsers
    switch( type ){
      case 'dotted':
        canvasCxt.setLineDash([ 1, 1 ]);
        break;

      case 'dashed':
        canvasCxt.setLineDash([ 6, 3 ]);
        break;

      case 'solid':
        canvasCxt.setLineDash([ ]);
        break;
    }
  }

  if( !pathCacheHit ){
    if( context.beginPath ){ context.beginPath(); }
    context.moveTo( pts[0], pts[1] );

    switch( rs.edgeType ){
      case 'bezier':
      case 'self':
      case 'compound':
      case 'multibezier':
        if( !rs.badBezier ){
          for( var i = 2; i + 3 < pts.length; i += 4 ){
            context.quadraticCurveTo( pts[i], pts[i+1], pts[i+2], pts[i+3] );
          }
        }
        break;

      case 'straight':
      case 'segments':
      case 'haystack':
        if( !rs.badLine ){
          for( var i = 2; i + 1 < pts.length; i += 2 ){
            context.lineTo( pts[i], pts[i+1] );
          }
        }
        break;
    }
  }

  context = canvasCxt;
  if( usePaths ){
    context.stroke( path );
  } else {
    context.stroke();
  }

  // reset any line dashes
  if( context.setLineDash ){ // for very outofdate browsers
    context.setLineDash([ ]);
  }

};

CRp.drawArrowheads = function(context, edge, drawOverlayInstead) {
  if( drawOverlayInstead ){ return; } // don't do anything for overlays

  var rs = edge._private.rscratch;
  var isHaystack = rs.edgeType === 'haystack';

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle );
  }

  this.drawArrowhead( context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle );

  this.drawArrowhead( context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle );

  if( !isHaystack ){
    this.drawArrowhead( context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle );
  }
};

CRp.drawArrowhead = function( context, edge, prefix, x, y, angle ){
  if( isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null ){ return; }

  var self = this;
  var style = edge._private.style;
  var arrowShape = style[prefix + '-arrow-shape'].value;

  if( arrowShape === 'none' ){
    return;
  }

  var gco = context.globalCompositeOperation;

  var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';
  var arrowFill = style[prefix + '-arrow-fill'].value;

  if( arrowShape === 'half-triangle-overshot' ){
    arrowFill = 'hollow';
    arrowClearFill = 'hollow';
  }

  if( style.opacity.value !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
    context.globalCompositeOperation = 'destination-out';

    self.fillStyle(context, 255, 255, 255, 1);
    self.strokeStyle(context, 255, 255, 255, 1);

    self.drawArrowShape( edge, prefix, context,
      arrowClearFill, style['width'].pfValue, style[prefix + '-arrow-shape'].value,
      x, y, angle
    );

    context.globalCompositeOperation = gco;
  } // otherwise, the opaque arrow clears it for free :)

  var color = style[prefix + '-arrow-color'].value;
  self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);
  self.strokeStyle(context, color[0], color[1], color[2], style.opacity.value);

  self.drawArrowShape( edge, prefix, context,
    arrowFill, style['width'].pfValue, style[prefix + '-arrow-shape'].value,
    x, y, angle
  );
};

CRp.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, angle) {
  var r = this;
  var usePaths = this.usePaths();
  var rs = edge._private.rscratch;
  var pathCacheHit = false;
  var path;
  var canvasContext = context;
  var translation = { x: x, y: y };
  var size = this.getArrowWidth( edgeWidth );
  var shapeImpl = r.arrowShapes[shape];

  if( usePaths ){
    var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
    rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
    rs.arrowPathCache = rs.arrowPathCache || {};

    var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
    if( alreadyCached ){
      path = context = rs.arrowPathCache[arrowType];
      pathCacheHit = true;
    } else {
      path = context = new Path2D();
      rs.arrowPathCacheKey[arrowType] = pathCacheKey;
      rs.arrowPathCache[arrowType] = path;
    }
  }

  if( context.beginPath ){ context.beginPath(); }

  if( !pathCacheHit ){
    shapeImpl.draw(context, size, angle, translation);
  }

  if( !shapeImpl.leavePathOpen && context.closePath ){
    context.closePath();
  }

  context = canvasContext;

  if( fill === 'filled' || fill === 'both' ){
    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }
  }

  if( fill === 'hollow' || fill === 'both' ){
    context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
    context.lineJoin = 'miter';

    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }

  }
};

module.exports = CRp;

},{}],64:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
  var r = this;

  try {
    context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
  } catch(e){
    r.data.canvasNeedsRedraw[r.NODE] = true;
    r.data.canvasNeedsRedraw[r.DRAG] = true;

    r.drawingImage = true;

    r.redraw();
  }
};

CRp.drawInscribedImage = function(context, img, node) {
  var r = this;
  var nodeX = node._private.position.x;
  var nodeY = node._private.position.y;
  var style = node._private.style;
  var fit = style['background-fit'].value;
  var xPos = style['background-position-x'];
  var yPos = style['background-position-y'];
  var repeat = style['background-repeat'].value;
  var nodeW = node.width();
  var nodeH = node.height();
  var rs = node._private.rscratch;
  var clip = style['background-clip'].value;
  var shouldClip = clip === 'node';
  var imgOpacity = style['background-image-opacity'].value;

  var imgW = img.width || img.cachedW;
  var imgH = img.height || img.cachedH;

  // workaround for broken browsers like ie
  if( null == imgW || null == imgH ){
    document.body.appendChild( img );

    imgW = img.cachedW = img.width || img.offsetWidth;
    imgH = img.cachedH = img.height || img.offsetHeight;

    document.body.removeChild( img );
  }

  var w = imgW;
  var h = imgH;

  var bgW = style['background-width'];
  if( bgW.value !== 'auto' ){
    if( bgW.units === '%' ){
      w = bgW.value/100 * nodeW;
    } else {
      w = bgW.pfValue;
    }
  }

  var bgH = style['background-height'];
  if( bgH.value !== 'auto' ){
    if( bgH.units === '%' ){
      h = bgH.value/100 * nodeH;
    } else {
      h = bgH.pfValue;
    }
  }

  if( w === 0 || h === 0 ){
    return; // no point in drawing empty image (and chrome is broken in this case)
  }

  if( fit === 'contain' ){
    var scale = Math.min( nodeW/w, nodeH/h );

    w *= scale;
    h *= scale;

  } else if( fit === 'cover' ){
    var scale = Math.max( nodeW/w, nodeH/h );

    w *= scale;
    h *= scale;
  }

  var x = (nodeX - nodeW/2); // left
  if( xPos.units === '%' ){
    x += (nodeW - w) * xPos.value/100;
  } else {
    x += xPos.pfValue;
  }

  var y = (nodeY - nodeH/2); // top
  if( yPos.units === '%' ){
    y += (nodeH - h) * yPos.value/100;
  } else {
    y += yPos.pfValue;
  }

  if( rs.pathCache ){
    x -= nodeX;
    y -= nodeY;

    nodeX = 0;
    nodeY = 0;
  }

  var gAlpha = context.globalAlpha;

  context.globalAlpha = imgOpacity;

  if( repeat === 'no-repeat' ){

    if( shouldClip ){
      context.save();

      if( rs.pathCache ){
        context.clip( rs.pathCache );
      } else {
        r.nodeShapes[r.getNodeShape(node)].draw(
          context,
          nodeX, nodeY,
          nodeW, nodeH);

        context.clip();
      }
    }

    r.safeDrawImage( context, img, 0, 0, imgW, imgH, x, y, w, h );

    if( shouldClip ){
      context.restore();
    }
  } else {
    var pattern = context.createPattern( img, repeat );
    context.fillStyle = pattern;

    r.nodeShapes[r.getNodeShape(node)].draw(
        context,
        nodeX, nodeY,
        nodeW, nodeH);

      context.translate(x, y);
      context.fill();
      context.translate(-x, -y);
  }

  context.globalAlpha = gAlpha;

};

module.exports = CRp;

},{}],65:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');

var CRp = {};

// Draw edge text
CRp.drawEdgeText = function(context, edge) {
  var text = edge._private.style['label'].strValue;

  if( !text || text.match(/^\s+$/) ){
    return;
  }

  if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching

  var computedSize = edge._private.style['font-size'].pfValue * edge.cy().zoom();
  var minSize = edge._private.style['min-zoomed-font-size'].pfValue;

  if( computedSize < minSize ){
    return;
  }

  // Calculate text draw position

  context.textAlign = 'center';
  context.textBaseline = 'middle';

  var rs = edge._private.rscratch;
  if( !is.number( rs.labelX ) || !is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

  var style = edge._private.style;
  var autorotate = style['edge-text-rotation'].strValue === 'autorotate';
  var theta;

  if( autorotate ){
    theta = rs.labelAngle;

    context.translate(rs.labelX, rs.labelY);
    context.rotate(theta);

    this.drawText(context, edge, 0, 0);

    context.rotate(-theta);
    context.translate(-rs.labelX, -rs.labelY);
  } else {
    this.drawText(context, edge, rs.labelX, rs.labelY);
  }

};

// Draw node text
CRp.drawNodeText = function(context, node) {
  var text = node._private.style['label'].strValue;

  if ( !text || text.match(/^\s+$/) ) {
    return;
  }

  var computedSize = node._private.style['font-size'].pfValue * node.cy().zoom();
  var minSize = node._private.style['min-zoomed-font-size'].pfValue;

  if( computedSize < minSize ){
    return;
  }

  // this.recalculateNodeLabelProjection( node );

  var textHalign = node._private.style['text-halign'].strValue;
  var textValign = node._private.style['text-valign'].strValue;
  var rs = node._private.rscratch;
  if( !is.number( rs.labelX ) || !is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

  switch( textHalign ){
    case 'left':
      context.textAlign = 'right';
      break;

    case 'right':
      context.textAlign = 'left';
      break;

    default: // e.g. center
      context.textAlign = 'center';
  }

  switch( textValign ){
    case 'top':
      context.textBaseline = 'bottom';
      break;

    case 'bottom':
      context.textBaseline = 'top';
      break;

    default: // e.g. center
      context.textBaseline = 'middle';
  }

  this.drawText(context, node, rs.labelX, rs.labelY);
};

CRp.getFontCache = function(context){
  var cache;

  this.fontCaches = this.fontCaches || [];

  for( var i = 0; i < this.fontCaches.length; i++ ){
    cache = this.fontCaches[i];

    if( cache.context === context ){
      return cache;
    }
  }

  cache = {
    context: context
  };
  this.fontCaches.push(cache);

  return cache;
};

// set up canvas context with font
// returns transformed text string
CRp.setupTextStyle = function( context, element ){
  // Font style
  var parentOpacity = element.effectiveOpacity();
  var style = element._private.style;
  var labelStyle = style['font-style'].strValue;
  var labelSize = style['font-size'].pfValue + 'px';
  var labelFamily = style['font-family'].strValue;
  var labelWeight = style['font-weight'].strValue;
  var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;
  var outlineOpacity = style['text-outline-opacity'].value * opacity;
  var color = style['color'].value;
  var outlineColor = style['text-outline-color'].value;
  var shadowBlur = style['text-shadow-blur'].pfValue;
  var shadowOpacity = style['text-shadow-opacity'].value;
  var shadowColor = style['text-shadow-color'].value;
  var shadowOffsetX = style['text-shadow-offset-x'].pfValue;
  var shadowOffsetY = style['text-shadow-offset-y'].pfValue;

  var fontCacheKey = element._private.fontKey;
  var cache = this.getFontCache(context);

  if( cache.key !== fontCacheKey ){
    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

    cache.key = fontCacheKey;
  }

  var text = this.getLabelText( element );

  // Calculate text draw position based on text alignment

  // so text outlines aren't jagged
  context.lineJoin = 'round';

  this.fillStyle(context, color[0], color[1], color[2], opacity);

  this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);

  this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

  return text;
};

function roundRect(ctx, x, y, width, height, radius) {
  var radius = radius || 5;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  ctx.fill();
}

// Draw text
CRp.drawText = function(context, element, textX, textY) {
  var _p = element._private;
  var style = _p.style;
  var rstyle = _p.rstyle;
  var rscratch = _p.rscratch;
  var parentOpacity = element.effectiveOpacity();
  if( parentOpacity === 0 || style['text-opacity'].value === 0){ return; }

  var text = this.setupTextStyle( context, element );
  var halign = style['text-halign'].value;
  var valign = style['text-valign'].value;

  if( element.isEdge() ){
    halign = 'center';
    valign = 'center';
  }

  if( element.isNode() ){
    var pLeft = style['padding-left'].pfValue;
    var pRight = style['padding-right'].pfValue;
    var pTop = style['padding-top'].pfValue;
    var pBottom = style['padding-bottom'].pfValue;

    textX += pLeft/2;
    textX -= pRight/2;

    textY += pTop/2;
    textY -= pBottom/2;
  }

  if ( text != null && !isNaN(textX) && !isNaN(textY)) {
    var backgroundOpacity = style['text-background-opacity'].value;
    var borderOpacity = style['text-border-opacity'].value;
    var textBorderWidth = style['text-border-width'].pfValue;

    if( backgroundOpacity > 0 || (textBorderWidth > 0 && borderOpacity > 0) ){
      var margin = 4 + textBorderWidth/2;

      if (element.isNode()) {
        //Move textX, textY to include the background margins
        if (valign === 'top') {
          textY -= margin;
        } else if (valign === 'bottom') {
          textY += margin;
        }
        if (halign === 'left') {
          textX -= margin;
        } else if (halign === 'right') {
          textX += margin;
        }
      }

      var bgWidth = rstyle.labelWidth;
      var bgHeight = rstyle.labelHeight;
      var bgX = textX;

      if (halign) {
        if (halign == 'center') {
          bgX = bgX - bgWidth / 2;
        } else if (halign == 'left') {
          bgX = bgX- bgWidth;
        }
      }

      var bgY = textY;

      if (element.isNode()) {
        if (valign == 'top') {
           bgY = bgY - bgHeight;
        } else if (valign == 'center') {
          bgY = bgY- bgHeight / 2;
        }
      } else {
        bgY = bgY - bgHeight / 2;
      }

      if (style['edge-text-rotation'].strValue === 'autorotate') {
        textY = 0;
        bgWidth += 4;
        bgX = textX - bgWidth / 2;
        bgY = textY - bgHeight / 2;
      } else {
        // Adjust with border width & margin
        bgX -= margin;
        bgY -= margin;
        bgHeight += margin*2;
        bgWidth += margin*2;
      }

      if( backgroundOpacity > 0 ){
        var textFill = context.fillStyle;
        var textBackgroundColor = style['text-background-color'].value;

        context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
        var styleShape = style['text-background-shape'].strValue;
        if (styleShape == 'roundrectangle') {
          roundRect(context, bgX, bgY, bgWidth, bgHeight, 2);
        } else {
          context.fillRect(bgX,bgY,bgWidth,bgHeight);
        }
        context.fillStyle = textFill;
      }

      if( textBorderWidth > 0 && borderOpacity > 0 ){
        var textStroke = context.strokeStyle;
        var textLineWidth = context.lineWidth;
        var textBorderColor = style['text-border-color'].value;
        var textBorderStyle = style['text-border-style'].value;

        context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
        context.lineWidth = textBorderWidth;

        if( context.setLineDash ){ // for very outofdate browsers
          switch( textBorderStyle ){
            case 'dotted':
              context.setLineDash([ 1, 1 ]);
              break;
            case 'dashed':
              context.setLineDash([ 4, 2 ]);
              break;
            case 'double':
              context.lineWidth = textBorderWidth/4; // 50% reserved for white between the two borders
              context.setLineDash([ ]);
              break;
            case 'solid':
              context.setLineDash([ ]);
              break;
          }
        }

        context.strokeRect(bgX,bgY,bgWidth,bgHeight);

        if( textBorderStyle === 'double' ){
          var whiteWidth = textBorderWidth/2;

          context.strokeRect(bgX+whiteWidth,bgY+whiteWidth,bgWidth-whiteWidth*2,bgHeight-whiteWidth*2);
        }

        if( context.setLineDash ){ // for very outofdate browsers
          context.setLineDash([ ]);
        }
        context.lineWidth = textLineWidth;
        context.strokeStyle = textStroke;
      }

    }

    var lineWidth = 2  * style['text-outline-width'].pfValue; // *2 b/c the stroke is drawn centred on the middle

    if( lineWidth > 0 ){
      context.lineWidth = lineWidth;
    }

    if( style['text-wrap'].value === 'wrap' ){
      var lines = rscratch.labelWrapCachedLines;
      var lineHeight = rstyle.labelHeight / lines.length;

      switch( valign ){
        case 'top':
          textY -= (lines.length - 1) * lineHeight;
          break;

        case 'bottom':
          // nothing required
          break;

        default:
        case 'center':
          textY -= (lines.length - 1) * lineHeight / 2;
      }

      for( var l = 0; l < lines.length; l++ ){
        if( lineWidth > 0 ){
          context.strokeText( lines[l], textX, textY );
        }

        context.fillText( lines[l], textX, textY );

        textY += lineHeight;
      }

    } else {
      if( lineWidth > 0 ){
        context.strokeText( text, textX, textY );
      }

      context.fillText( text, textX, textY );
    }


    this.shadowStyle(context, 'transparent', 0); // reset for next guy
  }
};


module.exports = CRp;

},{"../../../is":77}],66:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');

var CRp = {};

// Draw node
CRp.drawNode = function(context, node, drawOverlayInstead) {

  var r = this;
  var nodeWidth, nodeHeight;
  var style = node._private.style;
  var rs = node._private.rscratch;
  var _p = node._private;
  var pos = _p.position;

  if( !is.number(pos.x) || !is.number(pos.y) ){
    return; // can't draw node with undefined position
  }

  var usePaths = this.usePaths();
  var canvasContext = context;
  var path;
  var pathCacheHit = false;

  var overlayPadding = style['overlay-padding'].pfValue;
  var overlayOpacity = style['overlay-opacity'].value;
  var overlayColor = style['overlay-color'].value;

  if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw
    return;
  }

  var parentOpacity = node.effectiveOpacity();
  if( parentOpacity === 0 ){ return; }

  nodeWidth = node.width() + style['padding-left'].pfValue + style['padding-right'].pfValue;
  nodeHeight = node.height() + style['padding-top'].pfValue + style['padding-bottom'].pfValue;

  context.lineWidth = style['border-width'].pfValue;

  if( drawOverlayInstead === undefined || !drawOverlayInstead ){

    var url = style['background-image'].value[2] ||
      style['background-image'].value[1];
    var image;

    if (url !== undefined) {

      // get image, and if not loaded then ask to redraw when later loaded
      image = this.getCachedImage(url, function(){
        r.data.canvasNeedsRedraw[r.NODE] = true;
        r.data.canvasNeedsRedraw[r.DRAG] = true;

        r.drawingImage = true;

        r.redraw();
      });

      var prevBging = _p.backgrounding;
      _p.backgrounding = !image.complete;

      if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
        node.updateStyle( false );
      }
    }

    // Node color & opacity

    var bgColor = style['background-color'].value;
    var borderColor = style['border-color'].value;
    var borderStyle = style['border-style'].value;

    this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * parentOpacity);

    this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * parentOpacity);

    var shadowBlur = style['shadow-blur'].pfValue;
    var shadowOpacity = style['shadow-opacity'].value;
    var shadowColor = style['shadow-color'].value;
    var shadowOffsetX = style['shadow-offset-x'].pfValue;
    var shadowOffsetY = style['shadow-offset-y'].pfValue;

    this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

    context.lineJoin = 'miter'; // so borders are square with the node shape

    if( context.setLineDash ){ // for very outofdate browsers
      switch( borderStyle ){
        case 'dotted':
          context.setLineDash([ 1, 1 ]);
          break;

        case 'dashed':
          context.setLineDash([ 4, 2 ]);
          break;

        case 'solid':
        case 'double':
          context.setLineDash([ ]);
          break;
      }
    }


    var styleShape = style['shape'].strValue;

    if( usePaths ){
      var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;

      context.translate( pos.x, pos.y );

      if( rs.pathCacheKey === pathCacheKey ){
        path = context = rs.pathCache;
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.pathCacheKey = pathCacheKey;
        rs.pathCache = path;
      }
    }

    if( !pathCacheHit ){

      var npos = pos;

      if( usePaths ){
        npos = {
          x: 0,
          y: 0
        };
      }

      r.nodeShapes[this.getNodeShape(node)].draw(
            context,
            npos.x,
            npos.y,
            nodeWidth,
            nodeHeight);
    }

    context = canvasContext;

    if( usePaths ){
      context.fill( path );
    } else {
      context.fill();
    }

    this.shadowStyle(context, 'transparent', 0); // reset for next guy

    if (url !== undefined) {
      if( image.complete ){
        this.drawInscribedImage(context, image, node);
      }
    }

    var darkness = style['background-blacken'].value;
    var borderWidth = style['border-width'].pfValue;

    if( this.hasPie(node) ){
      this.drawPie( context, node, parentOpacity );

      // redraw path for blacken and border
      if( darkness !== 0 || borderWidth !== 0 ){

        if( !usePaths ){
          r.nodeShapes[this.getNodeShape(node)].draw(
              context,
              pos.x,
              pos.y,
              nodeWidth,
              nodeHeight);
        }
      }
    }

    if( darkness > 0 ){
      this.fillStyle(context, 0, 0, 0, darkness);

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }

    } else if( darkness < 0 ){
      this.fillStyle(context, 255, 255, 255, -darkness);

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }
    }

    // Border width, draw border
    if (borderWidth > 0) {

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }

      if( borderStyle === 'double' ){
        context.lineWidth = style['border-width'].pfValue/3;

        var gco = context.globalCompositeOperation;
        context.globalCompositeOperation = 'destination-out';

        if( usePaths ){
          context.stroke( path );
        } else {
          context.stroke();
        }

        context.globalCompositeOperation = gco;
      }

    }

    if( usePaths ){
      context.translate( -pos.x, -pos.y );
    }

    // reset in case we changed the border style
    if( context.setLineDash ){ // for very outofdate browsers
      context.setLineDash([ ]);
    }

  // draw the overlay
  } else {

    if( overlayOpacity > 0 ){
      this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

      r.nodeShapes['roundrectangle'].draw(
        context,
        node._private.position.x,
        node._private.position.y,
        nodeWidth + overlayPadding * 2,
        nodeHeight + overlayPadding * 2
      );

      context.fill();
    }
  }

};

// does the node have at least one pie piece?
CRp.hasPie = function(node){
  node = node[0]; // ensure ele ref

  return node._private.hasPie;
};

CRp.drawPie = function( context, node, nodeOpacity ){
  node = node[0]; // ensure ele ref

  var _p = node._private;
  var cyStyle = node.cy().style();
  var style = _p.style;
  var pieSize = style['pie-size'];
  var nodeW = node.width();
  var nodeH = node.height();
  var x = _p.position.x;
  var y = _p.position.y;
  var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
  var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
  var usePaths = this.usePaths();

  if( usePaths ){
    x = 0;
    y = 0;
  }

  if( pieSize.units === '%' ){
    radius = radius * pieSize.value / 100;
  } else if( pieSize.pfValue !== undefined ){
    radius = pieSize.pfValue / 2;
  }

  for( var i = 1; i <= cyStyle.pieBackgroundN; i++ ){ // 1..N
    var size = style['pie-' + i + '-background-size'].value;
    var color = style['pie-' + i + '-background-color'].value;
    var opacity = style['pie-' + i + '-background-opacity'].value * nodeOpacity;
    var percent = size / 100; // map integer range [0, 100] to [0, 1]

    // percent can't push beyond 1
    if( percent + lastPercent > 1 ){
      percent = 1 - lastPercent;
    }

    var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
    var angleDelta = 2 * Math.PI * percent;
    var angleEnd = angleStart + angleDelta;

    // ignore if
    // - zero size
    // - we're already beyond the full circle
    // - adding the current slice would go beyond the full circle
    if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
      continue;
    }

    context.beginPath();
    context.moveTo(x, y);
    context.arc( x, y, radius, angleStart, angleEnd );
    context.closePath();

    this.fillStyle(context, color[0], color[1], color[2], opacity);

    context.fill();

    lastPercent += percent;
  }

};


module.exports = CRp;

},{"../../../is":77}],67:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

var util = _dereq_('../../../util');
var math = _dereq_('../../../math');

var motionBlurDelay = 100;

// var isFirefox = typeof InstallTrigger !== 'undefined';

CRp.getPixelRatio = function(){
  var context = this.data.contexts[0];

  if( this.forcedPixelRatio != null ){
    return this.forcedPixelRatio;
  }

  var backingStore = context.backingStorePixelRatio ||
    context.webkitBackingStorePixelRatio ||
    context.mozBackingStorePixelRatio ||
    context.msBackingStorePixelRatio ||
    context.oBackingStorePixelRatio ||
    context.backingStorePixelRatio || 1;

  return (window.devicePixelRatio || 1) / backingStore;
};

CRp.paintCache = function(context){
  var caches = this.paintCaches = this.paintCaches || [];
  var needToCreateCache = true;
  var cache;

  for(var i = 0; i < caches.length; i++ ){
    cache = caches[i];

    if( cache.context === context ){
      needToCreateCache = false;
      break;
    }
  }

  if( needToCreateCache ){
    cache = {
      context: context
    };
    caches.push( cache );
  }

  return cache;
};

CRp.fillStyle = function(context, r, g, b, a){
  context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.fillStyle !== fillStyle ){
  //   context.fillStyle = cache.fillStyle = fillStyle;
  // }
};

CRp.strokeStyle = function(context, r, g, b, a){
  context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // turn off for now, seems context does its own caching

  // var cache = this.paintCache(context);

  // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

  // if( cache.strokeStyle !== strokeStyle ){
  //   context.strokeStyle = cache.strokeStyle = strokeStyle;
  // }
};

CRp.shadowStyle = function(context, color, opacity, blur, offsetX, offsetY){
  var zoom = this.cy.zoom();

  var cache = this.paintCache(context);

  // don't make expensive changes to the shadow style if it's not used
  if( cache.shadowOpacity === 0 && opacity === 0 ){
    return;
  }

  cache.shadowOpacity = opacity;

  if (opacity > 0) {
    context.shadowBlur = blur * zoom;
    context.shadowColor = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + opacity + ")";
    context.shadowOffsetX = offsetX * zoom;
    context.shadowOffsetY = offsetY * zoom;
  } else {
    context.shadowBlur = 0;
    context.shadowColor = "transparent";
  }
};

// Resize canvas
CRp.matchCanvasSize = function(container) {
  var r = this;
  var data = r.data;
  var width = container.clientWidth;
  var height = container.clientHeight;
  var pixelRatio = r.getPixelRatio();
  var mbPxRatio = r.motionBlurPxRatio;

  if(
    container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] ||
    container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]
  ){
    pixelRatio = mbPxRatio;
  }

  var canvasWidth = width * pixelRatio;
  var canvasHeight = height * pixelRatio;
  var canvas;

  if( canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight ){
    return; // save cycles if same
  }

  r.fontCaches = null; // resizing resets the style

  var canvasContainer = data.canvasContainer;
  canvasContainer.style.width = width + 'px';
  canvasContainer.style.height = height + 'px';

  for (var i = 0; i < r.CANVAS_LAYERS; i++) {

    canvas = data.canvases[i];

    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }

  for (var i = 0; i < r.BUFFER_COUNT; i++) {

    canvas = data.bufferCanvases[i];

    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {

      canvas.width = canvasWidth;
      canvas.height = canvasHeight;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }
  }

  r.textureMult = 1;
  if( pixelRatio <= 1 ){
    canvas = data.bufferCanvases[ r.TEXTURE_BUFFER ];

    r.textureMult = 2;
    canvas.width = canvasWidth * r.textureMult;
    canvas.height = canvasHeight * r.textureMult;
  }

  r.canvasWidth = canvasWidth;
  r.canvasHeight = canvasHeight;

};

CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
  this.render({
    forcedContext: cxt,
    forcedZoom: zoom,
    forcedPan: pan,
    drawAllLayers: true,
    forcedPxRatio: pxRatio
  });
};

CRp.render = function( options ) {
  options = options || util.staticEmptyObject();

  var forcedContext = options.forcedContext;
  var drawAllLayers = options.drawAllLayers;
  var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
  var forcedZoom = options.forcedZoom;
  var forcedPan = options.forcedPan;
  var r = this;
  var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
  var cy = r.cy; var data = r.data;
  var needDraw = data.canvasNeedsRedraw;
  var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
  var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
  var mbPxRatio = r.motionBlurPxRatio;
  var hasCompoundNodes = cy.hasCompoundNodes();
  var inNodeDragGesture = r.hoverData.draggingEles;
  var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
  motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
  var motionBlurFadeEffect = motionBlur;

  if( !forcedContext && r.motionBlurTimeout ){
    clearTimeout( r.motionBlurTimeout );
  }

  if( motionBlur ){
    if( r.mbFrames == null ){
      r.mbFrames = 0;
    }

    if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames
      r.mbFrames++;
    }

    if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
      motionBlurFadeEffect = false;
    }

    // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
    if( r.mbFrames > r.minMbLowQualFrames ){
      //r.fullQualityMb = false;
      r.motionBlurPxRatio = r.mbPxRBlurry;
    }
  }

  if( r.clearingMotionBlur ){
    r.motionBlurPxRatio = 1;
  }

  // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
  // because a rogue async texture frame would clear needDraw
  if( r.textureDrawLastFrame && !textureDraw ){
    needDraw[r.NODE] = true;
    needDraw[r.SELECT_BOX] = true;
  }

  var edges = r.getCachedEdges();
  var coreStyle = cy.style()._private.coreStyle;

  var zoom = cy.zoom();
  var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
  var pan = cy.pan();
  var effectivePan = {
    x: pan.x,
    y: pan.y
  };

  var vp = {
    zoom: zoom,
    pan: {
      x: pan.x,
      y: pan.y
    }
  };
  var prevVp = r.prevViewport;
  var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

  // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
  if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
    r.motionBlurPxRatio = 1;
  }

  if( forcedPan ){
    effectivePan = forcedPan;
  }

  // apply pixel ratio

  effectiveZoom *= pixelRatio;
  effectivePan.x *= pixelRatio;
  effectivePan.y *= pixelRatio;

  var eles = {
    drag: {
      nodes: [],
      edges: [],
      eles: []
    },
    nondrag: {
      nodes: [],
      edges: [],
      eles: []
    }
  };

  function mbclear( context, x, y, w, h ){
    var gco = context.globalCompositeOperation;

    context.globalCompositeOperation = 'destination-out';
    r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
    context.fillRect(x, y, w, h);

    context.globalCompositeOperation = gco;
  }

  function setContextTransform(context, clear){
    var ePan, eZoom, w, h;

    if( !r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG]) ){
      ePan = {
        x: pan.x * mbPxRatio,
        y: pan.y * mbPxRatio
      };

      eZoom = zoom * mbPxRatio;

      w = r.canvasWidth * mbPxRatio;
      h = r.canvasHeight * mbPxRatio;
    } else {
      ePan = effectivePan;
      eZoom = effectiveZoom;

      w = r.canvasWidth;
      h = r.canvasHeight;
    }

    context.setTransform(1, 0, 0, 1, 0, 0);

    if( clear === 'motionBlur' ){
      mbclear(context, 0, 0, w, h);
    } else if( !forcedContext && (clear === undefined || clear) ){
      context.clearRect(0, 0, w, h);
    }

    if( !drawAllLayers ){
      context.translate( ePan.x, ePan.y );
      context.scale( eZoom, eZoom );
    }
    if( forcedPan ){
      context.translate( forcedPan.x, forcedPan.y );
    }
    if( forcedZoom ){
      context.scale( forcedZoom, forcedZoom );
    }
  }

  if( !textureDraw ){
    r.textureDrawLastFrame = false;
  }

  if( textureDraw ){
    r.textureDrawLastFrame = true;

    var bb;

    if( !r.textureCache ){
      r.textureCache = {};

      bb = r.textureCache.bb = cy.elements().boundingBox();

      r.textureCache.texture = r.data.bufferCanvases[ r.TEXTURE_BUFFER ];

      var cxt = r.data.bufferContexts[ r.TEXTURE_BUFFER ];

      cxt.setTransform(1, 0, 0, 1, 0, 0);
      cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);

      r.render({
        forcedContext: cxt,
        drawOnlyNodeLayer: true,
        forcedPxRatio: pixelRatio * r.textureMult
      });

      var vp = r.textureCache.viewport = {
        zoom: cy.zoom(),
        pan: cy.pan(),
        width: r.canvasWidth,
        height: r.canvasHeight
      };

      vp.mpan = {
        x: (0 - vp.pan.x)/vp.zoom,
        y: (0 - vp.pan.y)/vp.zoom
      };
    }

    needDraw[r.DRAG] = false;
    needDraw[r.NODE] = false;

    var context = data.contexts[r.NODE];

    var texture = r.textureCache.texture;
    var vp = r.textureCache.viewport;
    bb = r.textureCache.bb;

    context.setTransform(1, 0, 0, 1, 0, 0);

    if( motionBlur ){
      mbclear(context, 0, 0, vp.width, vp.height);
    } else {
      context.clearRect(0, 0, vp.width, vp.height);
    }

    var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
    var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
    r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
    context.fillRect( 0, 0, vp.width, vp.height );

    var zoom = cy.zoom();

    setContextTransform( context, false );

    context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
    context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );

  } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
    r.textureCache = null;
  }

  var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
  var hideEdges = r.hideEdgesOnViewport && vpManip;
  var hideLabels = r.hideLabelsOnViewport && vpManip;

  if (needDraw[r.DRAG] || needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer) {
    if( hideEdges ){
    } else {
      r.findEdgeControlPoints(edges);
    }

    var zEles = r.getCachedZSortedEles();
    var extent = cy.extent();

    for (var i = 0; i < zEles.length; i++) {
      var ele = zEles[i];
      var list;
      var bb = forcedContext ? null : ele.boundingBox();
      var insideExtent = forcedContext ? true : math.boundingBoxesIntersect( extent, bb );

      if( !insideExtent ){ continue; } // no need to render

      if ( ele._private.rscratch.inDragLayer ) {
        list = eles.drag;
      } else {
        list = eles.nondrag;
      }

      list.eles.push( ele );
    }

  }


  function drawElements( list, context ){
    var eles = list.eles;

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];

      if( ele.isNode() ){
        r.drawNode(context, ele);

        if( !hideLabels ){
          r.drawNodeText(context, ele);
        }

        r.drawNode(context, ele, true);
      } else if( !hideEdges ) {
        r.drawEdge(context, ele);

        if( !hideLabels ){
          r.drawEdgeText(context, ele);
        }

        r.drawEdge(context, ele, true);
      }


    }

  }

  var needMbClear = [];

  needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;
  if( needMbClear[r.NODE] ){ r.clearedForMotionBlur[r.NODE] = true; }

  needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;
  if( needMbClear[r.DRAG] ){ r.clearedForMotionBlur[r.DRAG] = true; }

  if( needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE] ){
    var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_NODE ] : data.contexts[r.NODE] );
    var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

    setContextTransform( context, clear );
    drawElements(eles.nondrag, context);

    if( !drawAllLayers && !motionBlur ){
      needDraw[r.NODE] = false;
    }
  }

  if ( !drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG]) ) {
    var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;
    var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ r.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[r.DRAG] );

    setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );
    drawElements(eles.drag, context);

    if( !drawAllLayers && !motionBlur ){
      needDraw[r.DRAG] = false;
    }
  }

  if( r.showFps || (!drawOnlyNodeLayer && (needDraw[r.SELECT_BOX] && !drawAllLayers)) ) {
    var context = forcedContext || data.contexts[r.SELECT_BOX];

    setContextTransform( context );

    if( r.selection[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
      var zoom = r.cy.zoom();
      var borderWidth = coreStyle['selection-box-border-width'].value / zoom;

      context.lineWidth = borderWidth;
      context.fillStyle = "rgba("
        + coreStyle['selection-box-color'].value[0] + ","
        + coreStyle['selection-box-color'].value[1] + ","
        + coreStyle['selection-box-color'].value[2] + ","
        + coreStyle['selection-box-opacity'].value + ")";

      context.fillRect(
        r.selection[0],
        r.selection[1],
        r.selection[2] - r.selection[0],
        r.selection[3] - r.selection[1]);

      if (borderWidth > 0) {
        context.strokeStyle = "rgba("
          + coreStyle['selection-box-border-color'].value[0] + ","
          + coreStyle['selection-box-border-color'].value[1] + ","
          + coreStyle['selection-box-border-color'].value[2] + ","
          + coreStyle['selection-box-opacity'].value + ")";

        context.strokeRect(
          r.selection[0],
          r.selection[1],
          r.selection[2] - r.selection[0],
          r.selection[3] - r.selection[1]);
      }
    }

    if( data.bgActivePosistion && !r.hoverData.selecting ){
      var zoom = r.cy.zoom();
      var pos = data.bgActivePosistion;

      context.fillStyle = "rgba("
        + coreStyle['active-bg-color'].value[0] + ","
        + coreStyle['active-bg-color'].value[1] + ","
        + coreStyle['active-bg-color'].value[2] + ","
        + coreStyle['active-bg-opacity'].value + ")";

      context.beginPath();
      context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pfValue / zoom, 0, 2 * Math.PI);
      context.fill();
    }

    var timeToRender = r.lastRedrawTime;
    if( r.showFps && timeToRender ){
      timeToRender = Math.round( timeToRender );
      var fps = Math.round(1000/timeToRender);

      context.setTransform(1, 0, 0, 1, 0, 0);

      context.fillStyle = 'rgba(255, 0, 0, 0.75)';
      context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
      context.lineWidth = 1;
      context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

      var maxFps = 60;
      context.strokeRect(0, 30, 250, 20);
      context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);
    }

    if( !drawAllLayers ){
      needDraw[r.SELECT_BOX] = false;
    }
  }

  // motionblur: blit rendered blurry frames
  if( motionBlur && mbPxRatio !== 1 ){
    var cxtNode = data.contexts[r.NODE];
    var txtNode = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_NODE ];

    var cxtDrag = data.contexts[r.DRAG];
    var txtDrag = r.data.bufferCanvases[ r.MOTIONBLUR_BUFFER_DRAG ];

    var drawMotionBlur = function( cxt, txt, needClear ){
      cxt.setTransform(1, 0, 0, 1, 0, 0);

      if( needClear || !motionBlurFadeEffect ){
        cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
      } else {
        mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
      }

      var pxr = mbPxRatio;

      cxt.drawImage(
        txt, // img
        0, 0, // sx, sy
        r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
        0, 0, // x, y
        r.canvasWidth, r.canvasHeight // w, h
      );
    };

    if( needDraw[r.NODE] || needMbClear[r.NODE] ){
      drawMotionBlur( cxtNode, txtNode, needMbClear[r.NODE] );
      needDraw[r.NODE] = false;
    }

    if( needDraw[r.DRAG] || needMbClear[r.DRAG] ){
      drawMotionBlur( cxtDrag, txtDrag, needMbClear[r.DRAG] );
      needDraw[r.DRAG] = false;
    }
  }

  r.currentlyDrawing = false;

  r.prevViewport = vp;

  if( r.clearingMotionBlur ){
    r.clearingMotionBlur = false;
    r.motionBlurCleared = true;
    r.motionBlur = true;
  }

  if( motionBlur ){
    r.motionBlurTimeout = setTimeout(function(){
      r.motionBlurTimeout = null;

      r.clearedForMotionBlur[r.NODE] = false;
      r.clearedForMotionBlur[r.DRAG] = false;
      r.motionBlur = false;
      r.clearingMotionBlur = !textureDraw;
      r.mbFrames = 0;

      needDraw[r.NODE] = true;
      needDraw[r.DRAG] = true;

      r.redraw();
    }, motionBlurDelay);
  }

  r.drawingImage = false;


  if( !forcedContext && !r.initrender ){
    r.initrender = true;
    cy.trigger('initrender');
  }

  if( !forcedContext ){
    cy.triggerOnRender();
  }

};

module.exports = CRp;

},{"../../../math":79,"../../../util":94}],68:[function(_dereq_,module,exports){
'use strict';

  var math = _dereq_('../../../math');

  var CRp = {};

  // @O Polygon drawing
  CRp.drawPolygonPath = function(
    context, x, y, width, height, points) {

    var halfW = width / 2;
    var halfH = height / 2;

    if( context.beginPath ){ context.beginPath(); }

    context.moveTo( x + halfW * points[0], y + halfH * points[1] );

    for (var i = 1; i < points.length / 2; i++) {
      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );
    }

    context.closePath();
  };

  // Round rectangle drawing
  CRp.drawRoundRectanglePath = function(
    context, x, y, width, height, radius) {

    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = math.getRoundRectangleRadius(width, height);

    if( context.beginPath ){ context.beginPath(); }

    // Start at top middle
    context.moveTo(x, y - halfHeight);
    // Arc from middle top to right side
    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
    // Arc from right side to bottom
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
    // Arc from bottom to left side
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
    // Arc from left side to topBorder
    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
    // Join line
    context.lineTo(x, y - halfHeight);


    context.closePath();
  };

  var sin0 = Math.sin(0);
  var cos0 = Math.cos(0);

  var sin = {};
  var cos = {};

  var ellipseStepSize = Math.PI / 40;

  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
    sin[i] = Math.sin(i);
    cos[i] = Math.cos(i);
  }

  CRp.drawEllipsePath = function(context, centerX, centerY, width, height){
    if( context.beginPath ){ context.beginPath(); }

    if( context.ellipse ){
      context.ellipse( centerX, centerY, width/2, height/2, 0, 0, 2*Math.PI );
    } else {
      var xPos, yPos;
      var rw = width/2;
      var rh = height/2;
      for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
        xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;
        yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;

        if (i === 0) {
          context.moveTo(xPos, yPos);
        } else {
          context.lineTo(xPos, yPos);
        }
      }
    }

    context.closePath();
  };

module.exports = CRp;

},{"../../../math":79}],69:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../../../is');

var CRp = {};

CRp.createBuffer = function(w, h) {
  var buffer = document.createElement('canvas');
  buffer.width = w;
  buffer.height = h;

  return [buffer, buffer.getContext('2d')];
};

CRp.bufferCanvasImage = function( options ){
  var cy = this.cy;
  var bb = cy.elements().boundingBox();
  var width = options.full ? Math.ceil(bb.w) : this.container.clientWidth;
  var height = options.full ? Math.ceil(bb.h) : this.container.clientHeight;
  var scale = 1;

  if( options.scale !== undefined ){
    width *= options.scale;
    height *= options.scale;

    scale = options.scale;
  } else if( is.number(options.maxWidth) || is.number(options.maxHeight) ){
    var maxScaleW = Infinity;
    var maxScaleH = Infinity;

    if( is.number(options.maxWidth) ){
      maxScaleW = scale * options.maxWidth / width;
    }

    if( is.number(options.maxHeight) ){
      maxScaleH = scale * options.maxHeight / height;
    }

    scale = Math.min( maxScaleW, maxScaleH );

    width *= scale;
    height *= scale;
  }

  var buffCanvas = document.createElement('canvas');

  buffCanvas.width = width;
  buffCanvas.height = height;

  buffCanvas.style.width = width + 'px';
  buffCanvas.style.height = height + 'px';

  var buffCxt = buffCanvas.getContext('2d');

  // Rasterize the layers, but only if container has nonzero size
  if (width > 0 && height > 0) {

    buffCxt.clearRect( 0, 0, width, height );

    if( options.bg ){
      buffCxt.fillStyle = options.bg;
      buffCxt.rect( 0, 0, width, height );
      buffCxt.fill();
    }

    buffCxt.globalCompositeOperation = 'source-over';

    if( options.full ){ // draw the full bounds of the graph
      this.render({
        forcedContext: buffCxt,
        drawAllLayers: true,
        forcedZoom: scale,
        forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },
        forcedPxRatio: 1
      });
    } else { // draw the current view
      var cyPan = cy.pan();
      var pan = {
        x: cyPan.x * scale,
        y: cyPan.y * scale
      };
      var zoom = cy.zoom() * scale;

      this.render({
        forcedContext: buffCxt,
        drawAllLayers: true,
        forcedZoom: zoom,
        forcedPan: pan,
        forcedPxRatio: 1
      });
    }
  }

  return buffCanvas;
};

CRp.png = function( options ){
  return this.bufferCanvasImage( options ).toDataURL('image/png');
};

CRp.jpg = function( options ){
  return this.bufferCanvasImage( options ).toDataURL('image/jpeg');
};

module.exports = CRp;

},{"../../../is":77}],70:[function(_dereq_,module,exports){
/*
The canvas renderer was written by Yue Dong.

Modifications tracked on Github.
*/

'use strict';

var util = _dereq_('../../../util');
var is = _dereq_('../../../is');

var CR = CanvasRenderer;
var CRp = CanvasRenderer.prototype;

CRp.CANVAS_LAYERS = 3;
//
CRp.SELECT_BOX = 0;
CRp.DRAG = 1;
CRp.NODE = 2;

CRp.BUFFER_COUNT = 3;
//
CRp.TEXTURE_BUFFER = 0;
CRp.MOTIONBLUR_BUFFER_NODE = 1;
CRp.MOTIONBLUR_BUFFER_DRAG = 2;

function CanvasRenderer(options) {
  var r = this;

  r.data = {
    canvases: new Array(CRp.CANVAS_LAYERS),
    contexts: new Array(CRp.CANVAS_LAYERS),
    canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),

    bufferCanvases: new Array(CRp.BUFFER_COUNT),
    bufferContexts: new Array(CRp.CANVAS_LAYERS)
  };

  r.data.canvasContainer = document.createElement('div');
  var containerStyle = r.data.canvasContainer.style;
  r.data.canvasContainer.setAttribute('style', '-webkit-tap-highlight-color: rgba(0,0,0,0);');
  containerStyle.position = 'relative';
  containerStyle.zIndex = '0';
  containerStyle.overflow = 'hidden';

  var container = options.cy.container();
  container.appendChild( r.data.canvasContainer );
  container.setAttribute('style', ( container.getAttribute('style') || '' ) + '-webkit-tap-highlight-color: rgba(0,0,0,0);');

  for (var i = 0; i < CRp.CANVAS_LAYERS; i++) {
    var canvas = r.data.canvases[i] = document.createElement('canvas');
    r.data.contexts[i] = canvas.getContext('2d');
    canvas.setAttribute( 'style', '-webkit-user-select: none; -moz-user-select: -moz-none; user-select: none; -webkit-tap-highlight-color: rgba(0,0,0,0); outline-style: none;' + ( is.ms() ? ' -ms-touch-action: none; touch-action: none; ' : '' ) );
    canvas.style.position = 'absolute';
    canvas.setAttribute('data-id', 'layer' + i);
    canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);
    r.data.canvasContainer.appendChild(canvas);

    r.data.canvasNeedsRedraw[i] = false;
  }
  r.data.topCanvas = r.data.canvases[0];

  r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');
  r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');
  r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');

  for (var i = 0; i < CRp.BUFFER_COUNT; i++) {
    r.data.bufferCanvases[i] = document.createElement('canvas');
    r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');
    r.data.bufferCanvases[i].style.position = 'absolute';
    r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
    r.data.bufferCanvases[i].style.zIndex = String(-i - 1);
    r.data.bufferCanvases[i].style.visibility = 'hidden';
    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);
  }

  r.pathsEnabled = true;
}

CRp.redrawHint = function( group, bool ){
  var r = this;

  switch( group ){
    case 'eles':
      r.data.canvasNeedsRedraw[ CRp.NODE ] = bool;
      break;
    case 'drag':
      r.data.canvasNeedsRedraw[ CRp.DRAG ] = bool;
      break;
    case 'select':
      r.data.canvasNeedsRedraw[ CRp.SELECT_BOX ] = bool;
      break;
  }
};

// whether to use Path2D caching for drawing
var pathsImpld = typeof Path2D !== 'undefined';

CRp.path2dEnabled = function( on ){
  if( on === undefined ){
    return this.pathsEnabled;
  }

  this.pathsEnabled = on ? true : false;
};

CRp.usePaths = function(){
  return pathsImpld && this.pathsEnabled;
};

[
  _dereq_('./arrow-shapes'),
  _dereq_('./drawing-edges'),
  _dereq_('./drawing-images'),
  _dereq_('./drawing-label-text'),
  _dereq_('./drawing-nodes'),
  _dereq_('./drawing-redraw'),
  _dereq_('./drawing-shapes'),
  _dereq_('./export-image'),
  _dereq_('./node-shapes')
].forEach(function( props ){
  util.extend( CRp, props );
});

module.exports = CR;

},{"../../../is":77,"../../../util":94,"./arrow-shapes":62,"./drawing-edges":63,"./drawing-images":64,"./drawing-label-text":65,"./drawing-nodes":66,"./drawing-redraw":67,"./drawing-shapes":68,"./export-image":69,"./node-shapes":71}],71:[function(_dereq_,module,exports){
'use strict';

var CRp = {};

var impl;

CRp.nodeShapeImpl = function( name ){
  var self = this;

  return ( impl || (impl = {
    'ellipse': function( context, centerX, centerY, width, height ){
      self.drawEllipsePath( context, centerX, centerY, width, height );
    },

    'polygon': function( context, centerX, centerY, width, height, points ){
      self.drawPolygonPath( context, centerX, centerY, width, height, points );
    },

    'roundrectangle': function( context, centerX, centerY, width, height ){
      self.drawRoundRectanglePath( context, centerX, centerY, width, height, 10 );
    }
  }) )[ name ];
};

module.exports = CRp;

},{}],72:[function(_dereq_,module,exports){
'use strict';

module.exports = [
  { name: 'null', impl: _dereq_('./null') },
  { name: 'base', impl: _dereq_('./base') },
  { name: 'canvas', impl: _dereq_('./canvas') }
];

},{"./base":58,"./canvas":70,"./null":73}],73:[function(_dereq_,module,exports){
'use strict';

function NullRenderer(options){
  this.options = options;
  this.notifications = 0; // for testing
}

var noop = function(){};

NullRenderer.prototype = {
  recalculateRenderedStyle: noop,
  notify: function(){ this.notifications++; },
  init: noop
};

module.exports = NullRenderer;

},{}],74:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('./is');
var util = _dereq_('./util');
var Thread = _dereq_('./thread');
var Promise = _dereq_('./promise');
var define = _dereq_('./define');

var Fabric = function( N ){
  if( !(this instanceof Fabric) ){
    return new Fabric( N );
  }

  this._private = {
    pass: []
  };

  var defN = 4;

  if( is.number(N) ){
    // then use the specified number of threads
  } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){
    N = navigator.hardwareConcurrency;
  } else {
    try{
      N = _dereq_('os').cpus().length;
    } catch( err ){
      N = defN;
    }
  } // TODO could use an estimation here but would the additional expense be worth it?

  for( var i = 0; i < N; i++ ){
    this[i] = new Thread();
  }

  this.length = N;
};

var fabfn = Fabric.prototype; // short alias

util.extend(fabfn, {

  instanceString: function(){ return 'fabric'; },

  // require fn in all threads
  require: function( fn, as ){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.require( fn, as );
    }

    return this;
  },

  // get a random thread
  random: function(){
    var i = Math.round( (this.length - 1) * Math.random() );
    var thread = this[i];

    return thread;
  },

  // run on random thread
  run: function( fn ){
    var pass = this._private.pass.shift();

    return this.random().pass( pass ).run( fn );
  },

  // sends a random thread a message
  message: function( m ){
    return this.random().message( m );
  },

  // send all threads a message
  broadcast: function( m ){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.message( m );
    }

    return this; // chaining
  },

  // stop all threads
  stop: function(){
    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];

      thread.stop();
    }

    return this; // chaining
  },

  // pass data to be used with .spread() etc.
  pass: function( data ){
    var pass = this._private.pass;

    if( is.array(data) ){
      pass.push( data );
    } else {
      throw 'Only arrays may be used with fabric.pass()';
    }

    return this; // chaining
  },

  spreadSize: function(){
    var subsize =  Math.ceil( this._private.pass[0].length / this.length );

    subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread

    return subsize;
  },

  // split the data into slices to spread the data equally among threads
  spread: function( fn ){
    var self = this;
    var _p = self._private;
    var subsize = self.spreadSize(); // number of pass eles to handle in each thread
    var pass = _p.pass.shift().concat([]); // keep a copy
    var runPs = [];

    for( var i = 0; i < this.length; i++ ){
      var thread = this[i];
      var slice = pass.splice( 0, subsize );

      var runP = thread.pass( slice ).run( fn );

      runPs.push( runP );

      var doneEarly = pass.length === 0;
      if( doneEarly ){ break; }
    }

    return Promise.all( runPs ).then(function( thens ){
      var postpass = [];
      var p = 0;

      // fill postpass with the total result joined from all threads
      for( var i = 0; i < thens.length; i++ ){
        var then = thens[i]; // array result from thread i

        for( var j = 0; j < then.length; j++ ){
          var t = then[j]; // array element

          postpass[ p++ ] = t;
        }
      }

      return postpass;
    });
  },

  // parallel version of array.map()
  map: function( fn ){
    var self = this;

    self.require( fn, '_$_$_fabmap' );

    return self.spread(function( split ){
      var mapped = [];
      var origResolve = resolve; // jshint ignore:line

      resolve = function( val ){ // jshint ignore:line
        mapped.push( val );
      };

      for( var i = 0; i < split.length; i++ ){
        var oldLen = mapped.length;
        var ret = _$_$_fabmap( split[i] ); // jshint ignore:line
        var nothingInsdByResolve = oldLen === mapped.length;

        if( nothingInsdByResolve ){
          mapped.push( ret );
        }
      }

      resolve = origResolve; // jshint ignore:line

      return mapped;
    });

  },

  // parallel version of array.filter()
  filter: function( fn ){
    var _p = this._private;
    var pass = _p.pass[0];

    return this.map( fn ).then(function( include ){
      var ret = [];

      for( var i = 0; i < pass.length; i++ ){
        var datum = pass[i];
        var incDatum = include[i];

        if( incDatum ){
          ret.push( datum );
        }
      }

      return ret;
    });
  },

  // sorts the passed array using a divide and conquer strategy
  sort: function( cmp ){
    var self = this;
    var P = this._private.pass[0].length;
    var subsize = this.spreadSize();

    cmp = cmp || function( a, b ){ // default comparison function
      if( a < b ){
        return -1;
      } else if( a > b ){
        return 1;
      }

      return 0;
    };

    self.require( cmp, '_$_$_cmp' );

    return self.spread(function( split ){ // sort each split normally
      var sortedSplit = split.sort( _$_$_cmp ); // jshint ignore:line
      resolve( sortedSplit ); // jshint ignore:line

    }).then(function( joined ){
      // do all the merging in the main thread to minimise data transfer

      // TODO could do merging in separate threads but would incur add'l cost of data transfer
      // for each level of the merge

      var merge = function( i, j, max ){
        // don't overflow array
        j = Math.min( j, P );
        max = Math.min( max, P );

        // left and right sides of merge
        var l = i;
        var r = j;

        var sorted = [];

        for( var k = l; k < max; k++ ){

          var eleI = joined[i];
          var eleJ = joined[j];

          if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){
            sorted.push( eleI );
            i++;
          } else {
            sorted.push( eleJ );
            j++;
          }

        }

        // in the array proper, put the sorted values
        for( var k = 0; k < sorted.length; k++ ){ // kth sorted item
          var index = l + k;

          joined[ index ] = sorted[k];
        }
      };

      for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is "split" as 1

        for( var i = 0; i < P; i += 2*splitL ){
          merge( i, i + splitL, i + 2*splitL );
        }

      }

      return joined;
    });
  }


});

var defineRandomPasser = function( opts ){
  opts = opts || {};

  return function( fn, arg1 ){
    var pass = this._private.pass.shift();

    return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );
  };
};

util.extend(fabfn, {
  randomMap: defineRandomPasser({ threadFn: 'map' }),

  reduce: defineRandomPasser({ threadFn: 'reduce' }),

  reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })
});

// aliases
var fn = fabfn;
fn.promise = fn.run;
fn.terminate = fn.halt = fn.stop;
fn.include = fn.require;

// pull in event apis
util.extend(fabfn, {
  on: define.on(),
  one: define.on({ unbindSelfOnTrigger: true }),
  off: define.off(),
  trigger: define.trigger()
});

define.eventAliasesOn( fabfn );

module.exports = Fabric;

},{"./define":41,"./is":77,"./promise":80,"./thread":92,"./util":94,"os":undefined}],75:[function(_dereq_,module,exports){
'use strict';
/* jshint ignore:start */

// Generated by CoffeeScript 1.8.0
(function() {
  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;

  floor = Math.floor, min = Math.min;


  /*
  Default comparison function to be used
   */

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };


  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.

  If x is already in a, insert it to the right of the rightmost x.

  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */

  insort = function(a, x, lo, hi, cmp) {
    var mid;
    if (lo == null) {
      lo = 0;
    }
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
  };


  /*
  Push item onto heap, maintaining the heap invariant.
   */

  heappush = function(array, item, cmp) {
    if (cmp == null) {
      cmp = defaultCmp;
    }
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };


  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */

  heappop = function(array, cmp) {
    var lastelt, returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };


  /*
  Pop and return the current smallest value, and add the new item.

  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */

  heapreplace = function(array, item, cmp) {
    var returnitem;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };


  /*
  Fast version of a heappush followed by a heappop.
   */

  heappushpop = function(array, item, cmp) {
    var _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (array.length && cmp(array[0], item) < 0) {
      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
      _siftup(array, 0, cmp);
    }
    return item;
  };


  /*
  Transform list into a heap, in-place, in O(array.length) time.
   */

  heapify = function(array, cmp) {
    var i, _i, _j, _len, _ref, _ref1, _results, _results1;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    _ref1 = (function() {
      _results1 = [];
      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }
      return _results1;
    }).apply(this).reverse();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      _results.push(_siftup(array, i, cmp));
    }
    return _results;
  };


  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */

  updateItem = function(array, item, cmp) {
    var pos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };


  /*
  Find the n largest elements in a dataset.
   */

  nlargest = function(array, n, cmp) {
    var elem, result, _i, _len, _ref;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elem = _ref[_i];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };


  /*
  Find the n smallest elements in a dataset.
   */

  nsmallest = function(array, n, cmp) {
    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    _results = [];
    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(heappop(array, cmp));
    }
    return _results;
  };

  _siftdown = function(array, startpos, pos, cmp) {
    var newitem, parent, parentpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    if (cmp == null) {
      cmp = defaultCmp;
    }
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    function Heap(cmp) {
      this.cmp = cmp != null ? cmp : defaultCmp;
      this.nodes = [];
    }

    Heap.prototype.push = function(x) {
      return heappush(this.nodes, x, this.cmp);
    };

    Heap.prototype.pop = function() {
      return heappop(this.nodes, this.cmp);
    };

    Heap.prototype.peek = function() {
      return this.nodes[0];
    };

    Heap.prototype.contains = function(x) {
      return this.nodes.indexOf(x) !== -1;
    };

    Heap.prototype.replace = function(x) {
      return heapreplace(this.nodes, x, this.cmp);
    };

    Heap.prototype.pushpop = function(x) {
      return heappushpop(this.nodes, x, this.cmp);
    };

    Heap.prototype.heapify = function() {
      return heapify(this.nodes, this.cmp);
    };

    Heap.prototype.updateItem = function(x) {
      return updateItem(this.nodes, x, this.cmp);
    };

    Heap.prototype.clear = function() {
      return this.nodes = [];
    };

    Heap.prototype.empty = function() {
      return this.nodes.length === 0;
    };

    Heap.prototype.size = function() {
      return this.nodes.length;
    };

    Heap.prototype.clone = function() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    };

    Heap.prototype.toArray = function() {
      return this.nodes.slice(0);
    };

    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  })();

  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);

/* jshint ignore:end */

},{}],76:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('./window');
var is = _dereq_('./is');
var Core = _dereq_('./core');
var extension = _dereq_('./extension');
var registerJquery = _dereq_('./jquery-plugin');
var Stylesheet = _dereq_('./stylesheet');
var Thread = _dereq_('./thread');
var Fabric = _dereq_('./fabric');

var cytoscape = function( options ){ // jshint ignore:line
  // if no options specified, use default
  if( options === undefined ){
    options = {};
  }

  // create instance
  if( is.plainObject( options ) ){
    return new Core( options );
  }

  // allow for registration of extensions
  else if( is.string( options ) ) {
    return extension.apply(extension, arguments);
  }
};

// replaced by build system
cytoscape.version = '2.5.4';

// try to register w/ jquery
if( window && window.jQuery ){
  registerJquery( window.jQuery, cytoscape );
}

// expose register api
cytoscape.registerJquery = function( jQuery ){
  registerJquery( jQuery, cytoscape );
};

// expose public apis (mostly for extensions)
cytoscape.stylesheet = cytoscape.Stylesheet = Stylesheet;
cytoscape.thread = cytoscape.Thread = Thread;
cytoscape.fabric = cytoscape.Fabric = Fabric;

module.exports = cytoscape;

},{"./core":34,"./extension":43,"./fabric":74,"./is":77,"./jquery-plugin":78,"./stylesheet":91,"./thread":92,"./window":100}],77:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('./window');
var navigator = window ? window.navigator : null;

var typeofstr = typeof '';
var typeofobj = typeof {};
var typeoffn = typeof function(){};
var typeofhtmlele = typeof HTMLElement;

var instanceStr = function( obj ){
  return obj && obj.instanceString && is.fn( obj.instanceString ) ? obj.instanceString() : null;
};

var is = {
  defined: function(obj){
    return obj != null; // not undefined or null
  },

  string: function(obj){
    return obj != null && typeof obj == typeofstr;
  },

  fn: function(obj){
    return obj != null && typeof obj === typeoffn;
  },

  array: function(obj){
    return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
  },

  plainObject: function(obj){
    return obj != null && typeof obj === typeofobj && !is.array(obj) && obj.constructor === Object;
  },

  object: function(obj){
    return obj != null && typeof obj === typeofobj;
  },

  number: function(obj){
    return obj != null && typeof obj === typeof 1 && !isNaN(obj);
  },

  integer: function( obj ){
    return is.number(obj) && Math.floor(obj) === obj;
  },

  bool: function(obj){
    return obj != null && typeof obj === typeof true;
  },

  htmlElement: function(obj){
    if( 'undefined' === typeofhtmlele ){
      return undefined;
    } else {
      return null != obj && obj instanceof HTMLElement;
    }
  },

  elementOrCollection: function(obj){
    return is.element(obj) || is.collection(obj);
  },

  element: function(obj){
    return instanceStr(obj) === 'collection' && obj._private.single;
  },

  collection: function(obj){
    return instanceStr(obj) === 'collection' && !obj._private.single;
  },

  core: function(obj){
    return instanceStr(obj) === 'core';
  },

  style: function(obj){
    return instanceStr(obj) === 'style';
  },

  stylesheet: function(obj){
    return instanceStr(obj) === 'stylesheet';
  },

  event: function(obj){
    return instanceStr(obj) === 'event';
  },

  thread: function(obj){
    return instanceStr(obj) === 'thread';
  },

  fabric: function(obj){
    return instanceStr(obj) === 'fabric';
  },

  emptyString: function(obj){
    if( !obj ){ // null is empty
      return true;
    } else if( is.string(obj) ){
      if( obj === '' || obj.match(/^\s+$/) ){
        return true; // empty string is empty
      }
    }

    return false; // otherwise, we don't know what we've got
  },

  nonemptyString: function(obj){
    if( obj && is.string(obj) && obj !== '' && !obj.match(/^\s+$/) ){
      return true;
    }

    return false;
  },

  domElement: function(obj){
    if( typeof HTMLElement === 'undefined' ){
      return false; // we're not in a browser so it doesn't matter
    } else {
      return obj instanceof HTMLElement;
    }
  },

  boundingBox: function(obj){
    return is.plainObject(obj) &&
      is.number(obj.x1) && is.number(obj.x2) &&
      is.number(obj.y1) && is.number(obj.y2)
    ;
  },

  promise: function(obj){
    return is.object(obj) && is.fn(obj.then);
  },

  touch: function(){
    return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
  },

  gecko: function(){
    return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);
  },

  webkit: function(){
    return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);
  },

  chromium: function(){
    return typeof chrome !== 'undefined';
  },

  khtml: function(){
    return navigator && navigator.vendor.match(/kde/i); // probably a better way to detect this...
  },

  khtmlEtc: function(){
    return is.khtml() || is.webkit() || is.chromium();
  },

  ms: function(){
     return navigator && navigator.userAgent.match(/msie|trident|edge/i); // probably a better way to detect this...
  },

  windows: function(){
    return navigator && navigator.appVersion.match(/Win/i);
  },

  mac: function(){
    return navigator && navigator.appVersion.match(/Mac/i);
  },

  linux: function(){
    return navigator && navigator.appVersion.match(/Linux/i);
  },

  unix: function(){
    return navigator && navigator.appVersion.match(/X11/i);
  }
};

module.exports = is;

},{"./window":100}],78:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('./is');

var cyReg = function( $ele ){
  var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

  return d;
};

var registerJquery = function( $, cytoscape ){
  if( !$ ){ return; } // no jquery => don't need this

  if( $.fn.cytoscape ){ return; } // already registered

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function(opts){
    var $this = $(this);

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }

    // bind to ready
    else if( is.fn(opts) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;

      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger('ready', [], ready);

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      }

    }

    // proxy to create instance
    else if( is.plainObject(opts) ){
      return $this.each(function(){
        var options = $.extend({}, opts, {
          container: $(this)[0]
        });

        cytoscape(options);
      });
    }
  };

  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;

  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
};

module.exports = registerJquery;

},{"./is":77}],79:[function(_dereq_,module,exports){
'use strict';

var math = {};

math.signum = function(x){
  if( x > 0 ){
    return 1;
  } else if( x < 0 ){
    return -1;
  } else {
    return 0;
  }
};

math.distance = function( p1, p2 ){
  return Math.sqrt( math.sqDistance(p1, p2) );
};

math.sqDistance = function( p1, p2 ){
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;

  return dx*dx + dy*dy;
};

// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves
math.qbezierAt = function(p0, p1, p2, t){
  return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;
};

math.qbezierPtAt = function(p0, p1, p2, t){
  return {
    x: math.qbezierAt( p0.x, p1.x, p2.x, t ),
    y: math.qbezierAt( p0.y, p1.y, p2.y, t )
  };
};

// makes a full bb (x1, y1, x2, y2, w, h) from implicit params
math.makeBoundingBox = function( bb ){
  if( bb.x1 != null && bb.y1 != null ){
    if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x2,
        y2: bb.y2,
        w: bb.x2 - bb.x1,
        h: bb.y2 - bb.y1
      };
    } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
      return {
        x1: bb.x1,
        y1: bb.y1,
        x2: bb.x1 + bb.w,
        y2: bb.y1 + bb.h,
        w: bb.w,
        h: bb.h
      };
    }
  }
};

math.boundingBoxesIntersect = function( bb1, bb2 ){
  // case: one bb to right of other
  if( bb1.x1 > bb2.x2 ){ return false; }
  if( bb2.x1 > bb1.x2 ){ return false; }

  // case: one bb to left of other
  if( bb1.x2 < bb2.x1 ){ return false; }
  if( bb2.x2 < bb1.x1 ){ return false; }

  // case: one bb above other
  if( bb1.y2 < bb2.y1 ){ return false; }
  if( bb2.y2 < bb1.y1 ){ return false; }

  // case: one bb below other
  if( bb1.y1 > bb2.y2 ){ return false; }
  if( bb2.y1 > bb1.y2 ){ return false; }

  // otherwise, must have some overlap
  return true;
};

math.inBoundingBox = function( bb, x, y ){
  return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
};

math.pointInBoundingBox = function( bb, pt ){
  return this.inBoundingBox( bb, pt.x, pt.y );
};

math.roundRectangleIntersectLine = function(
  x, y, nodeX, nodeY, width, height, padding) {

  var cornerRadius = this.getRoundRectangleRadius(width, height);

  var halfWidth = width / 2;
  var halfHeight = height / 2;

  // Check intersections with straight line segments
  var straightLineIntersections;

  // Top segment, left to right
  {
    var topStartX = nodeX - halfWidth + cornerRadius - padding;
    var topStartY = nodeY - halfHeight - padding;
    var topEndX = nodeX + halfWidth - cornerRadius + padding;
    var topEndY = topStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Right segment, top to bottom
  {
    var rightStartX = nodeX + halfWidth + padding;
    var rightStartY = nodeY - halfHeight + cornerRadius - padding;
    var rightEndX = rightStartX;
    var rightEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Bottom segment, left to right
  {
    var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
    var bottomStartY = nodeY + halfHeight + padding;
    var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
    var bottomEndY = bottomStartY;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Left segment, top to bottom
  {
    var leftStartX = nodeX - halfWidth - padding;
    var leftStartY = nodeY - halfHeight + cornerRadius - padding;
    var leftEndX = leftStartX;
    var leftEndY = nodeY + halfHeight - cornerRadius + padding;

    straightLineIntersections = this.finiteLinesIntersect(
      x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);

    if (straightLineIntersections.length > 0) {
      return straightLineIntersections;
    }
  }

  // Check intersections with arc segments
  var arcIntersections;

  // Top Left
  {
    var topLeftCenterX = nodeX - halfWidth + cornerRadius;
    var topLeftCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topLeftCenterX, topLeftCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0
      && arcIntersections[0] <= topLeftCenterX
      && arcIntersections[1] <= topLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Top Right
  {
    var topRightCenterX = nodeX + halfWidth - cornerRadius;
    var topRightCenterY = nodeY - halfHeight + cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      topRightCenterX, topRightCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0
      && arcIntersections[0] >= topRightCenterX
      && arcIntersections[1] <= topRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Bottom Right
  {
    var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
    var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0
      && arcIntersections[0] >= bottomRightCenterX
      && arcIntersections[1] >= bottomRightCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  // Bottom Left
  {
    var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
    var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
    arcIntersections = this.intersectLineCircle(
      x, y, nodeX, nodeY,
      bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);

    // Ensure the intersection is on the desired quarter of the circle
    if (arcIntersections.length > 0
      && arcIntersections[0] <= bottomLeftCenterX
      && arcIntersections[1] >= bottomLeftCenterY) {
      return [arcIntersections[0], arcIntersections[1]];
    }
  }

  return []; // if nothing
};

math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){
  var t = tolerance;

  var x1 = Math.min(lx1, lx2);
  var x2 = Math.max(lx1, lx2);
  var y1 = Math.min(ly1, ly2);
  var y2 = Math.max(ly1, ly2);

  return x1 - t <= x && x <= x2 + t
    && y1 - t <= y && y <= y2 + t;
};

math.inBezierVicinity = function(
  x, y, x1, y1, x2, y2, x3, y3, tolerance) {

  var bb = {
    x1: Math.min( x1, x3, x2 ) - tolerance,
    x2: Math.max( x1, x3, x2 ) + tolerance,
    y1: Math.min( y1, y3, y2 ) - tolerance,
    y2: Math.max( y1, y3, y2 ) + tolerance
  };

  // if outside the rough bounding box for the bezier, then it can't be a hit
  if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
    // console.log('bezier out of rough bb')
    return false;
  } else {
    // console.log('do more expensive check');
    return true;
  }

};

math.solveCubic = function(a, b, c, d, result) {

  // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
  // r is the real component, i is the imaginary component

  // An implementation of the Cardano method from the year 1545
  // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

  b /= a;
  c /= a;
  d /= a;

  var discriminant, q, r, dum1, s, t, term1, r13;

  q = (3.0 * c - (b * b)) / 9.0;
  r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
  r /= 54.0;

  discriminant = q * q * q + r * r;
  result[1] = 0;
  term1 = (b / 3.0);

  if (discriminant > 0) {
    s = r + Math.sqrt(discriminant);
    s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));
    t = r - Math.sqrt(discriminant);
    t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));
    result[0] = -term1 + s + t;
    term1 += (s + t) / 2.0;
    result[4] = result[2] = -term1;
    term1 = Math.sqrt(3.0) * (-t + s) / 2;
    result[3] = term1;
    result[5] = -term1;
    return;
  }

  result[5] = result[3] = 0;

  if (discriminant === 0) {
    r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));
    result[0] = -term1 + 2.0 * r13;
    result[4] = result[2] = -(r13 + term1);
    return;
  }

  q = -q;
  dum1 = q * q * q;
  dum1 = Math.acos(r / Math.sqrt(dum1));
  r13 = 2.0 * Math.sqrt(q);
  result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
  result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
  result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);

  return;
};

math.sqDistanceToQuadraticBezier = function(
  x, y, x1, y1, x2, y2, x3, y3) {

  // Find minimum distance by using the minimum of the distance
  // function between the given point and the curve

  // This gives the coefficients of the resulting cubic equation
  // whose roots tell us where a possible minimum is
  // (Coefficients are divided by 4)

  var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3
    + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;

  var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3
    + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;

  var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x
    + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;

  var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x
    + y1*y2 - y1*y1 + y1*y - y2*y;

  // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);

  var roots = [];

  // Use the cubic solving algorithm
  this.solveCubic(a, b, c, d, roots);

  var zeroThreshold = 0.0000001;

  var params = [];

  for (var index = 0; index < 6; index += 2) {
    if (Math.abs(roots[index + 1]) < zeroThreshold
        && roots[index] >= 0
        && roots[index] <= 1.0) {
      params.push(roots[index]);
    }
  }

  params.push(1.0);
  params.push(0.0);

  var minDistanceSquared = -1;
  var closestParam;

  var curX, curY, distSquared;
  for (var i = 0; i < params.length; i++) {
    curX = Math.pow(1.0 - params[i], 2.0) * x1
      + 2.0 * (1 - params[i]) * params[i] * x2
      + params[i] * params[i] * x3;

    curY = Math.pow(1 - params[i], 2.0) * y1
      + 2 * (1.0 - params[i]) * params[i] * y2
      + params[i] * params[i] * y3;

    distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
    // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
    if (minDistanceSquared >= 0) {
      if (distSquared < minDistanceSquared) {
        minDistanceSquared = distSquared;
        closestParam = params[i];
      }
    } else {
      minDistanceSquared = distSquared;
      closestParam = params[i];
    }
  }

  return minDistanceSquared;
};

math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {
  var offset = [x - x1, y - y1];
  var line = [x2 - x1, y2 - y1];

  var lineSq = line[0] * line[0] + line[1] * line[1];
  var hypSq = offset[0] * offset[0] + offset[1] * offset[1];

  var dotProduct = offset[0] * line[0] + offset[1] * line[1];
  var adjSq = dotProduct * dotProduct / lineSq;

  if (dotProduct < 0) {
    return hypSq;
  }

  if (adjSq > lineSq) {
    return (x - x2) * (x - x2) + (y - y2) * (y - y2);
  }

  return hypSq - adjSq;
};

math.pointInsidePolygonPoints = function(x, y, points){
  var x1, y1, x2, y2;
  var y3;

  // Intersect with vertical line through (x, y)
  var up = 0;
  var down = 0;
  for (var i = 0; i < points.length / 2; i++) {

    x1 = points[i * 2];
    y1 = points[i * 2 + 1];

    if (i + 1 < points.length / 2) {
      x2 = points[(i + 1) * 2];
      y2 = points[(i + 1) * 2 + 1];
    } else {
      x2 = points[(i + 1 - points.length / 2) * 2];
      y2 = points[(i + 1 - points.length / 2) * 2 + 1];
    }

    if (x1 == x && x2 == x) {

    } else if ((x1 >= x && x >= x2)
      || (x1 <= x && x <= x2)) {

      y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;

      if (y3 > y) {
        up++;
      }

      if (y3 < y) {
        down++;
      }

    } else {
      continue;
    }

  }

  if (up % 2 === 0) {
    return false;
  } else {
    return true;
  }
};

math.pointInsidePolygon = function(
  x, y, basePoints, centerX, centerY, width, height, direction, padding) {

  //var direction = arguments[6];
  var transformedPoints = new Array(basePoints.length);

  // Gives negative angle
  var angle;

  if( direction[0] != null ){
    angle = Math.atan(direction[1] / direction[0]);

    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
  } else {
    angle = direction;
  }

  var cos = Math.cos(-angle);
  var sin = Math.sin(-angle);

  //    console.log("base: " + basePoints);
  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] =
      width / 2 * (basePoints[i * 2] * cos
        - basePoints[i * 2 + 1] * sin);

    transformedPoints[i * 2 + 1] =
      height / 2 * (basePoints[i * 2 + 1] * cos
        + basePoints[i * 2] * sin);

    transformedPoints[i * 2] += centerX;
    transformedPoints[i * 2 + 1] += centerY;
  }

  var points;

  if (padding > 0) {
    var expandedLineSet = this.expandPolygon(
      transformedPoints,
      -padding);

    points = this.joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }

  return math.pointInsidePolygonPoints( x, y, points );
};

math.joinLines = function(lineSet) {

  var vertices = new Array(lineSet.length / 2);

  var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
  var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;

  for (var i = 0; i < lineSet.length / 4; i++) {
    currentLineStartX = lineSet[i * 4];
    currentLineStartY = lineSet[i * 4 + 1];
    currentLineEndX = lineSet[i * 4 + 2];
    currentLineEndY = lineSet[i * 4 + 3];

    if (i < lineSet.length / 4 - 1) {
      nextLineStartX = lineSet[(i + 1) * 4];
      nextLineStartY = lineSet[(i + 1) * 4 + 1];
      nextLineEndX = lineSet[(i + 1) * 4 + 2];
      nextLineEndY = lineSet[(i + 1) * 4 + 3];
    } else {
      nextLineStartX = lineSet[0];
      nextLineStartY = lineSet[1];
      nextLineEndX = lineSet[2];
      nextLineEndY = lineSet[3];
    }

    var intersection = this.finiteLinesIntersect(
      currentLineStartX, currentLineStartY,
      currentLineEndX, currentLineEndY,
      nextLineStartX, nextLineStartY,
      nextLineEndX, nextLineEndY,
      true);

    vertices[i * 2] = intersection[0];
    vertices[i * 2 + 1] = intersection[1];
  }

  return vertices;
};

math.expandPolygon = function(points, pad) {

  var expandedLineSet = new Array(points.length * 2);

  var currentPointX, currentPointY, nextPointX, nextPointY;

  for (var i = 0; i < points.length / 2; i++) {
    currentPointX = points[i * 2];
    currentPointY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextPointX = points[(i + 1) * 2];
      nextPointY = points[(i + 1) * 2 + 1];
    } else {
      nextPointX = points[0];
      nextPointY = points[1];
    }

    // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]

    // Assume CCW polygon winding

    var offsetX = (nextPointY - currentPointY);
    var offsetY = -(nextPointX - currentPointX);

    // Normalize
    var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
    var normalizedOffsetX = offsetX / offsetLength;
    var normalizedOffsetY = offsetY / offsetLength;

    expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
    expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
    expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
  }

  return expandedLineSet;
};

math.intersectLineEllipse = function(
  x, y, centerX, centerY, ellipseWradius, ellipseHradius) {

  var dispX = centerX - x;
  var dispY = centerY - y;

  dispX /= ellipseWradius;
  dispY /= ellipseHradius;

  var len = Math.sqrt(dispX * dispX + dispY * dispY);

  var newLength = len - 1;

  if (newLength < 0) {
    return [];
  }

  var lenProportion = newLength / len;

  return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
};

// Returns intersections of increasing distance from line's start point
math.intersectLineCircle = function(
  x1, y1, x2, y2, centerX, centerY, radius) {

  // Calculate d, direction vector of line
  var d = [x2 - x1, y2 - y1]; // Direction vector of line
  var c = [centerX, centerY]; // Center of circle
  var f = [x1 - centerX, y1 - centerY];

  var a = d[0] * d[0] + d[1] * d[1];
  var b = 2 * (f[0] * d[0] + f[1] * d[1]);
  var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;

  var discriminant = b*b-4*a*c;

  if (discriminant < 0) {
    return [];
  }

  var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
  var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);

  var tMin = Math.min(t1, t2);
  var tMax = Math.max(t1, t2);
  var inRangeParams = [];

  if (tMin >= 0 && tMin <= 1) {
    inRangeParams.push(tMin);
  }

  if (tMax >= 0 && tMax <= 1) {
    inRangeParams.push(tMax);
  }

  if (inRangeParams.length === 0) {
    return [];
  }

  var nearIntersectionX = inRangeParams[0] * d[0] + x1;
  var nearIntersectionY = inRangeParams[0] * d[1] + y1;

  if (inRangeParams.length > 1) {

    if (inRangeParams[0] == inRangeParams[1]) {
      return [nearIntersectionX, nearIntersectionY];
    } else {

      var farIntersectionX = inRangeParams[1] * d[0] + x1;
      var farIntersectionY = inRangeParams[1] * d[1] + y1;

      return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
    }

  } else {
    return [nearIntersectionX, nearIntersectionY];
  }

};

math.findCircleNearPoint = function(centerX, centerY,
  radius, farX, farY) {

  var displacementX = farX - centerX;
  var displacementY = farY - centerY;
  var distance = Math.sqrt(displacementX * displacementX
    + displacementY * displacementY);

  var unitDisplacementX = displacementX / distance;
  var unitDisplacementY = displacementY / distance;

  return [centerX + unitDisplacementX * radius,
    centerY + unitDisplacementY * radius];
};

math.findMaxSqDistanceToOrigin = function(points) {
  var maxSqDistance = 0.000001;
  var sqDistance;

  for (var i = 0; i < points.length / 2; i++) {

    sqDistance = points[i * 2] * points[i * 2]
      + points[i * 2 + 1] * points[i * 2 + 1];

    if (sqDistance > maxSqDistance) {
      maxSqDistance = sqDistance;
    }
  }

  return maxSqDistance;
};

math.finiteLinesIntersect = function(
  x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {

  var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
  var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
  var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

  if (u_b !== 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
      return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];

    } else {
      if (!infiniteLines) {
        return [];
      } else {
        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
      }
    }
  } else {
    if (ua_t === 0 || ub_t === 0) {

      // Parallel, coincident lines. Check if overlap

      // Check endpoint of second line
      if ([x1, x2, x4].sort()[1] === x4) {
        return [x4, y4];
      }

      // Check start point of second line
      if ([x1, x2, x3].sort()[1] === x3) {
        return [x3, y3];
      }

      // Endpoint of first line
      if ([x3, x4, x2].sort()[1] === x2) {
        return [x2, y2];
      }

      return [];
    } else {

      // Parallel, non-coincident
      return [];
    }
  }
};

math.polygonIntersectLine = function(
  x, y, basePoints, centerX, centerY, width, height, padding) {

  var intersections = [];
  var intersection;

  var transformedPoints = new Array(basePoints.length);

  for (var i = 0; i < transformedPoints.length / 2; i++) {
    transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
    transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
  }

  var points;

  if (padding > 0) {
    var expandedLineSet = math.expandPolygon(
      transformedPoints,
      -padding);

    points = math.joinLines(expandedLineSet);
  } else {
    points = transformedPoints;
  }
  // var points = transformedPoints;

  var currentX, currentY, nextX, nextY;

  for (var i = 0; i < points.length / 2; i++) {

    currentX = points[i * 2];
    currentY = points[i * 2 + 1];

    if (i < points.length / 2 - 1) {
      nextX = points[(i + 1) * 2];
      nextY = points[(i + 1) * 2 + 1];
    } else {
      nextX = points[0];
      nextY = points[1];
    }

    intersection = this.finiteLinesIntersect(
      x, y, centerX, centerY,
      currentX, currentY,
      nextX, nextY);

    if (intersection.length !== 0) {
      intersections.push(intersection[0], intersection[1]);
    }
  }

  return intersections;
};

math.shortenIntersection = function(
  intersection, offset, amount) {

  var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];

  var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);

  var lenRatio = (length - amount) / length;

  if (lenRatio < 0) {
    lenRatio = 0.00001;
  }

  return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
};

math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {
  var points = math.generateUnitNgonPoints(sides, rotationRadians);
  points = math.fitPolygonToSquare(points);

  return points;
};

math.fitPolygonToSquare = function(points){
  var x, y;
  var sides = points.length/2;
  var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  for (var i = 0; i < sides; i++) {
    x = points[2 * i];
    y = points[2 * i + 1];

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  // stretch factors
  var sx = 2 / (maxX - minX);
  var sy = 2 / (maxY - minY);

  for (var i = 0; i < sides; i++){
    x = points[2 * i] = points[2 * i] * sx;
    y = points[2 * i + 1] = points[2 * i + 1] * sy;

    minX = Math.min( minX, x );
    maxX = Math.max( maxX, x );
    minY = Math.min( minY, y );
    maxY = Math.max( maxY, y );
  }

  if( minY < -1 ){
    for (var i = 0; i < sides; i++){
      y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);
    }
  }

  return points;
};

math.generateUnitNgonPoints = function(sides, rotationRadians) {

  var increment = 1.0 / sides * 2 * Math.PI;
  var startAngle = sides % 2 === 0 ?
    Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
    //    console.log(nodeShapes['square']);
  startAngle += rotationRadians;

  var points = new Array(sides * 2);

  var currentAngle, x, y;
  for (var i = 0; i < sides; i++) {
    currentAngle = i * increment + startAngle;

    x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);
    y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);
  }

  return points;
};

math.getRoundRectangleRadius = function(width, height) {

  // Set the default radius, unless half of width or height is smaller than default
  return Math.min(width / 4, height / 4, 8);
};

module.exports = math;

},{}],80:[function(_dereq_,module,exports){
// internal, minimal Promise impl s.t. apis can return promises in old envs
// based on thenable (http://github.com/rse/thenable)

'use strict';

/*  promise states [Promises/A+ 2.1]  */
var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

/*  promise object constructor  */
var api = function (executor) {
  /*  optionally support non-constructor/plain-function call  */
  if (!(this instanceof api))
    return new api(executor);

  /*  initialize object  */
  this.id           = "Thenable/1.0.7";
  this.state        = STATE_PENDING; /*  initial state  */
  this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
  this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
  this.onFulfilled  = [];            /*  initial handlers  */
  this.onRejected   = [];            /*  initial handlers  */

  /*  provide optional information-hiding proxy  */
  this.proxy = {
    then: this.then.bind(this)
  };

  /*  support optional executor function  */
  if (typeof executor === "function")
    executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
};

/*  promise API methods  */
api.prototype = {
  /*  promise resolving methods  */
  fulfill: function (value) { return deliver(this, STATE_FULFILLED, "fulfillValue", value); },
  reject:  function (value) { return deliver(this, STATE_REJECTED,  "rejectReason", value); },

  /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
  then: function (onFulfilled, onRejected) {
    var curr = this;
    var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
    curr.onFulfilled.push(
      resolver(onFulfilled, next, "fulfill"));             /*  [Promises/A+ 2.2.2/2.2.6]  */
    curr.onRejected.push(
      resolver(onRejected,  next, "reject" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
    execute(curr);
    return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
  }
};

/*  deliver an action  */
var deliver = function (curr, state, name, value) {
  if (curr.state === STATE_PENDING) {
    curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
    curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
    execute(curr);
  }
  return curr;
};

/*  execute all handlers  */
var execute = function (curr) {
  if (curr.state === STATE_FULFILLED)
    execute_handlers(curr, "onFulfilled", curr.fulfillValue);
  else if (curr.state === STATE_REJECTED)
    execute_handlers(curr, "onRejected",  curr.rejectReason);
};

/*  execute particular set of handlers  */
var execute_handlers = function (curr, name, value) {
  /* global setImmediate: true */
  /* global setTimeout: true */

  /*  short-circuit processing  */
  if (curr[name].length === 0)
    return;

  /*  iterate over all handlers, exactly once  */
  var handlers = curr[name];
  curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
  var func = function () {
    for (var i = 0; i < handlers.length; i++)
      handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
  };

  /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
  if (typeof setImmediate === "function")
    setImmediate(func);
  else
    setTimeout(func, 0);
};

/*  generate a resolver function  */
var resolver = function (cb, next, method) {
  return function (value) {
    if (typeof cb !== "function")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
      next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
    else {
      var result;
      try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
      catch (e) {
        next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
        return;
      }
      resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
    }
  };
};

/*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
var resolve = function (promise, x) {
  /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
  if (promise === x || promise.proxy === x) {
    promise.reject(new TypeError("cannot resolve promise with itself"));
    return;
  }

  /*  surgically check for a "then" method
    (mainly to just call the "getter" of "then" only once)  */
  var then;
  if ((typeof x === "object" && x !== null) || typeof x === "function") {
    try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
    catch (e) {
      promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
      return;
    }
  }

  /*  handle own Thenables    [Promises/A+ 2.3.2]
    and similar "thenables" [Promises/A+ 2.3.3]  */
  if (typeof then === "function") {
    var resolved = false;
    try {
      /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
      then.call(x,
        /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
        function (y) {
          if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          if (y === x)                                 /*  [Promises/A+ 3.6]  */
            promise.reject(new TypeError("circular thenable chain"));
          else
            resolve(promise, y);
        },

        /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
        function (r) {
          if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
          promise.reject(r);
        }
      );
    }
    catch (e) {
      if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
        promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
    }
    return;
  }

  /*  handle other values  */
  promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
};

// use native promises where possible
var Promise = typeof Promise === 'undefined' ? api : Promise;

// so we always have Promise.all()
Promise.all = Promise.all || function( ps ){
  return new Promise(function( resolveAll, rejectAll ){
    var vals = new Array( ps.length );
    var doneCount = 0;

    var fulfill = function( i, val ){
      vals[i] = val;
      doneCount++;

      if( doneCount === ps.length ){
        resolveAll( vals );
      }
    };

    for( var i = 0; i < ps.length; i++ ){
      (function( i ){
        var p = ps[i];
        var isPromise = p.then != null;

        if( isPromise ){
          p.then(function( val ){
            fulfill( i, val );
          }, function( err ){
            rejectAll( err );
          });
        } else {
          var val = p;
          fulfill( i, val );
        }
      })( i );
    }

  });
};

module.exports = Promise;

},{}],81:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('./is');
var util = _dereq_('./util');

var Selector = function( onlyThisGroup, selector ){

  if( !(this instanceof Selector) ){
    return new Selector(onlyThisGroup, selector);
  }

  if( selector === undefined && onlyThisGroup !== undefined ){
    selector = onlyThisGroup;
    onlyThisGroup = undefined;
  }

  var self = this;

  self._private = {
    selectorText: null,
    invalid: true
  };

  if( !selector || ( is.string(selector) && selector.match(/^\s*$/) ) ){

    if( onlyThisGroup == null ){
      // ignore
      self.length = 0;
    } else {
      self[0] = newQuery();
      self[0].group = onlyThisGroup;
      self.length = 1;
    }

  } else if( is.elementOrCollection( selector ) ){
    var collection = selector.collection();

    self[0] = newQuery();
    self[0].collection = collection;
    self.length = 1;

  } else if( is.fn( selector ) ) {
    self[0] = newQuery();
    self[0].filter = selector;
    self.length = 1;

  } else if( is.string( selector ) ){

    // the current subject in the query
    var currentSubject = null;

    // storage for parsed queries
    var newQuery = function(){
      return {
        classes: [],
        colonSelectors: [],
        data: [],
        group: null,
        ids: [],
        meta: [],

        // fake selectors
        collection: null, // a collection to match against
        filter: null, // filter function

        // these are defined in the upward direction rather than down (e.g. child)
        // because we need to go up in Selector.filter()
        parent: null, // parent query obj
        ancestor: null, // ancestor query obj
        subject: null, // defines subject in compound query (subject query obj; points to self if subject)

        // use these only when subject has been defined
        child: null,
        descendant: null
      };
    };

    // tokens in the query language
    var tokens = {
      metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
      comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
      boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
      string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
      number: util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
      meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from Collection)
      separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
      descendant: '\\s+',
      child: '\\s+>\\s+',
      subject: '\\$'
    };
    tokens.variable = '(?:[\\w-]|(?:\\\\'+ tokens.metaChar +'))+'; // a variable name
    tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
    tokens.className = tokens.variable; // a class name (follows variable conventions)
    tokens.id = tokens.variable; // an element id (follows variable conventions)

    // when a token like a variable has escaped meta characters, we need to clean the backslashes out
    // so that values get compared properly in Selector.filter()
    var cleanMetaChars = function(str){
      return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){
        return $1;
      });
    };

    // add @ variants to comparatorOp
    var ops = tokens.comparatorOp.split('|');
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[i];
      tokens.comparatorOp += '|@' + op;
    }

    // add ! variants to comparatorOp
    var ops = tokens.comparatorOp.split('|');
    for( var i = 0; i < ops.length; i++ ){
      var op = ops[i];

      if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !
      if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

      tokens.comparatorOp += '|\\!' + op;
    }

    // NOTE: add new expression syntax here to have it recognised by the parser;
    // - a query contains all adjacent (i.e. no separator in between) expressions;
    // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
    // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
    // - when you add something here, also add to Selector.toString()
    var exprs = [
      {
        name: 'group',
        query: true,
        regex: '(node|edge|\\*)',
        populate: function( group ){
          this.group = group == "*" ? group : group + 's';
        }
      },

      {
        name: 'state',
        query: true,
        // NB: if one colon selector is a substring of another from its start, place the longer one first
        // e.g. :foobar|:foo
        regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',
        populate: function( state ){
          this.colonSelectors.push( state );
        }
      },

      {
        name: 'id',
        query: true,
        regex: '\\#('+ tokens.id +')',
        populate: function( id ){
          this.ids.push( cleanMetaChars(id) );
        }
      },

      {
        name: 'className',
        query: true,
        regex: '\\.('+ tokens.className +')',
        populate: function( className ){
          this.classes.push( cleanMetaChars(className) );
        }
      },

      {
        name: 'dataExists',
        query: true,
        regex: '\\[\\s*('+ tokens.variable +')\\s*\\]',
        populate: function( variable ){
          this.data.push({
            field: cleanMetaChars(variable)
          });
        }
      },

      {
        name: 'dataCompare',
        query: true,
        regex: '\\[\\s*('+ tokens.variable +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.value +')\\s*\\]',
        populate: function( variable, comparatorOp, value ){
          var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

          if( valueIsString ){
            value = value.substring(1, value.length - 1);
          } else {
            value = parseFloat(value);
          }

          this.data.push({
            field: cleanMetaChars(variable),
            operator: comparatorOp,
            value: value
          });
        }
      },

      {
        name: 'dataBool',
        query: true,
        regex: '\\[\\s*('+ tokens.boolOp +')\\s*('+ tokens.variable +')\\s*\\]',
        populate: function( boolOp, variable ){
          this.data.push({
            field: cleanMetaChars(variable),
            operator: boolOp
          });
        }
      },

      {
        name: 'metaCompare',
        query: true,
        regex: '\\[\\[\\s*('+ tokens.meta +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.number +')\\s*\\]\\]',
        populate: function( meta, comparatorOp, number ){
          this.meta.push({
            field: cleanMetaChars(meta),
            operator: comparatorOp,
            value: parseFloat(number)
          });
        }
      },

      {
        name: 'nextQuery',
        separator: true,
        regex: tokens.separator,
        populate: function(){
          // go on to next query
          self[++i] = newQuery();
          currentSubject = null;
        }
      },

      {
        name: 'child',
        separator: true,
        regex: tokens.child,
        populate: function(){
          // this query is the parent of the following query
          var childQuery = newQuery();
          childQuery.parent = this;
          childQuery.subject = currentSubject;

          // we're now populating the child query with expressions that follow
          self[i] = childQuery;
        }
      },

      {
        name: 'descendant',
        separator: true,
        regex: tokens.descendant,
        populate: function(){
          // this query is the ancestor of the following query
          var descendantQuery = newQuery();
          descendantQuery.ancestor = this;
          descendantQuery.subject = currentSubject;

          // we're now populating the descendant query with expressions that follow
          self[i] = descendantQuery;
        }
      },

      {
        name: 'subject',
        modifier: true,
        regex: tokens.subject,
        populate: function(){
          if( currentSubject != null && this.subject != this ){
            util.error('Redefinition of subject in selector `' + selector + '`');
            return false;
          }

          currentSubject = this;
          this.subject = this;
        }

      }
    ];

    self._private.selectorText = selector;
    var remaining = selector;
    var i = 0;

    // of all the expressions, find the first match in the remaining text
    var consumeExpr = function( expectation ){
      var expr;
      var match;
      var name;

      for( var j = 0; j < exprs.length; j++ ){
        var e = exprs[j];
        var n = e.name;

        // ignore this expression if it doesn't meet the expectation function
        if( is.fn( expectation ) && !expectation(n, e) ){ continue; }

        var m = remaining.match(new RegExp( '^' + e.regex ));

        if( m != null ){
          match = m;
          expr = e;
          name = n;

          var consumed = m[0];
          remaining = remaining.substring( consumed.length );

          break; // we've consumed one expr, so we can return now
        }
      }

      return {
        expr: expr,
        match: match,
        name: name
      };
    };

    // consume all leading whitespace
    var consumeWhitespace = function(){
      var match = remaining.match(/^\s+/);

      if( match ){
        var consumed = match[0];
        remaining = remaining.substring( consumed.length );
      }
    };

    self[0] = newQuery(); // get started

    consumeWhitespace(); // get rid of leading whitespace
    for(;;){
      var check = consumeExpr();

      if( check.expr == null ){
        util.error('The selector `'+ selector +'`is invalid');
        return;
      } else {
        var args = [];
        for(var j = 1; j < check.match.length; j++){
          args.push( check.match[j] );
        }

        // let the token populate the selector object (i.e. in self[i])
        var ret = check.expr.populate.apply( self[i], args );

        if( ret === false ){ return; } // exit if population failed
      }

      // we're done when there's nothing left to parse
      if( remaining.match(/^\s*$/) ){
        break;
      }
    }

    self.length = i + 1;

    // adjust references for subject
    for(var j = 0; j < self.length; j++){
      var query = self[j];

      if( query.subject != null ){
        // go up the tree until we reach the subject
        for(;;){
          if( query.subject == query ){ break; } // done if subject is self

          if( query.parent != null ){ // swap parent/child reference
            var parent = query.parent;
            var child = query;

            child.parent = null;
            parent.child = child;

            query = parent; // go up the tree
          } else if( query.ancestor != null ){ // swap ancestor/descendant
            var ancestor = query.ancestor;
            var descendant = query;

            descendant.ancestor = null;
            ancestor.descendant = descendant;

            query = ancestor; // go up the tree
          } else {
            util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');
            break;
          }
        } // for

        self[j] = query.subject; // subject should be the root query
      } // if
    } // for

    // make sure for each query that the subject group matches the implicit group if any
    if( onlyThisGroup != null ){
      for(var j = 0; j < self.length; j++){
        if( self[j].group != null && self[j].group != onlyThisGroup ){
          util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');
          return;
        }

        self[j].group = onlyThisGroup; // set to implicit group
      }
    }

  } else {
    util.error('A selector must be created from a string; found ' + selector);
    return;
  }

  self._private.invalid = false;

};

var selfn = Selector.prototype;

selfn.size = function(){
  return this.length;
};

selfn.eq = function(i){
  return this[i];
};

var queryMatches = function(query, element){
  // check group
  if( query.group != null && query.group != '*' && query.group != element._private.group ){
    return false;
  }

  var cy = element.cy();

  // check colon selectors
  var allColonSelectorsMatch = true;
  for(var k = 0; k < query.colonSelectors.length; k++){
    var sel = query.colonSelectors[k];

    switch(sel){
    case ':selected':
      allColonSelectorsMatch = element.selected();
      break;
    case ':unselected':
      allColonSelectorsMatch = !element.selected();
      break;
    case ':selectable':
      allColonSelectorsMatch = element.selectable();
      break;
    case ':unselectable':
      allColonSelectorsMatch = !element.selectable();
      break;
    case ':locked':
      allColonSelectorsMatch = element.locked();
      break;
    case ':unlocked':
      allColonSelectorsMatch = !element.locked();
      break;
    case ':visible':
      allColonSelectorsMatch = element.visible();
      break;
    case ':hidden':
      allColonSelectorsMatch = !element.visible();
      break;
    case ':transparent':
      allColonSelectorsMatch = element.transparent();
      break;
    case ':grabbed':
      allColonSelectorsMatch = element.grabbed();
      break;
    case ':free':
      allColonSelectorsMatch = !element.grabbed();
      break;
    case ':removed':
      allColonSelectorsMatch = element.removed();
      break;
    case ':inside':
      allColonSelectorsMatch = !element.removed();
      break;
    case ':grabbable':
      allColonSelectorsMatch = element.grabbable();
      break;
    case ':ungrabbable':
      allColonSelectorsMatch = !element.grabbable();
      break;
    case ':animated':
      allColonSelectorsMatch = element.animated();
      break;
    case ':unanimated':
      allColonSelectorsMatch = !element.animated();
      break;
    case ':parent':
      allColonSelectorsMatch = element.isNode() && element.children().nonempty();
      break;
    case ':child':
    case ':nonorphan':
      allColonSelectorsMatch = element.isNode() && element.parent().nonempty();
      break;
    case ':orphan':
      allColonSelectorsMatch = element.isNode() && element.parent().empty();
      break;
    case ':loop':
      allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');
      break;
    case ':simple':
      allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');
      break;
    case ':active':
      allColonSelectorsMatch = element.active();
      break;
    case ':inactive':
      allColonSelectorsMatch = !element.active();
      break;
    case ':touch':
      allColonSelectorsMatch = is.touch();
      break;
    case ':backgrounding':
      allColonSelectorsMatch = element.backgrounding();
      break;
    case ':nonbackgrounding':
      allColonSelectorsMatch = !element.backgrounding();
      break;
    }

    if( !allColonSelectorsMatch ) break;
  }
  if( !allColonSelectorsMatch ) return false;

  // check id
  var allIdsMatch = true;
  for(var k = 0; k < query.ids.length; k++){
    var id = query.ids[k];
    var actualId = element._private.data.id;

    allIdsMatch = allIdsMatch && (id == actualId);

    if( !allIdsMatch ) break;
  }
  if( !allIdsMatch ) return false;

  // check classes
  var allClassesMatch = true;
  for(var k = 0; k < query.classes.length; k++){
    var cls = query.classes[k];

    allClassesMatch = allClassesMatch && element.hasClass(cls);

    if( !allClassesMatch ) break;
  }
  if( !allClassesMatch ) return false;

  // generic checking for data/metadata
  var operandsMatch = function(params){
    var allDataMatches = true;
    for(var k = 0; k < query[params.name].length; k++){
      var data = query[params.name][k];
      var operator = data.operator;
      var value = data.value;
      var field = data.field;
      var matches;

      if( operator != null && value != null ){

        var fieldVal = params.fieldValue(field);
        var fieldStr = !is.string(fieldVal) && !is.number(fieldVal) ? '' : '' + fieldVal;
        var valStr = '' + value;

        var caseInsensitive = false;
        if( operator.indexOf('@') >= 0 ){
          fieldStr = fieldStr.toLowerCase();
          valStr = valStr.toLowerCase();

          operator = operator.replace('@', '');
          caseInsensitive = true;
        }

        var notExpr = false;
        var handledNotExpr = false;
        if( operator.indexOf('!') >= 0 ){
          operator = operator.replace('!', '');
          notExpr = true;
        }

        // if we're doing a case insensitive comparison, then we're using a STRING comparison
        // even if we're comparing numbers
        if( caseInsensitive ){
          value = valStr.toLowerCase();
          fieldVal = fieldStr.toLowerCase();
        }

        switch(operator){
        case '*=':
          matches = fieldStr.search(valStr) >= 0;
          break;
        case '$=':
          matches = new RegExp(valStr + '$').exec(fieldStr) != null;
          break;
        case '^=':
          matches = new RegExp('^' + valStr).exec(fieldStr) != null;
          break;
        case '=':
          matches = fieldVal === value;
          break;
        case '!=':
          matches = fieldVal !== value;
          break;
        case '>':
          matches = !notExpr ? fieldVal > value : fieldVal <= value;
          handledNotExpr = true;
          break;
        case '>=':
          matches = !notExpr ? fieldVal >= value : fieldVal < value;
          handledNotExpr = true;
          break;
        case '<':
          matches = !notExpr ? fieldVal < value : fieldVal >= value;
          handledNotExpr = true;
          break;
        case '<=':
          matches = !notExpr ? fieldVal <= value : fieldVal > value;
          handledNotExpr = true;
          break;
        default:
          matches = false;
          break;

        }
      } else if( operator != null ){
        switch(operator){
        case '?':
          matches = params.fieldTruthy(field);
          break;
        case '!':
          matches = !params.fieldTruthy(field);
          break;
        case '^':
          matches = params.fieldUndefined(field);
          break;
        }
      } else {
        matches = !params.fieldUndefined(field);
      }

      if( notExpr && !handledNotExpr ){
        matches = !matches;
        handledNotExpr = true;
      }

      if( !matches ){
        allDataMatches = false;
        break;
      }
    } // for

    return allDataMatches;
  }; // operandsMatch

  // check data matches
  var allDataMatches = operandsMatch({
    name: 'data',
    fieldValue: function(field){
      return element._private.data[field];
    },
    fieldRef: function(field){
      return 'element._private.data.' + field;
    },
    fieldUndefined: function(field){
      return element._private.data[field] === undefined;
    },
    fieldTruthy: function(field){
      if( element._private.data[field] ){
        return true;
      }
      return false;
    }
  });

  if( !allDataMatches ){
    return false;
  }

  // check metadata matches
  var allMetaMatches = operandsMatch({
    name: 'meta',
    fieldValue: function(field){
      return element[field]();
    },
    fieldRef: function(field){
      return 'element.' + field + '()';
    },
    fieldUndefined: function(field){
      return element[field]() == null;
    },
    fieldTruthy: function(field){
      if( element[field]() ){
        return true;
      }
      return false;
    }
  });

  if( !allMetaMatches ){
    return false;
  }

  // check collection
  if( query.collection != null ){
    var matchesAny = query.collection._private.ids[ element.id() ] != null;

    if( !matchesAny ){
      return false;
    }
  }

  // check filter function
  if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){
    return false;
  }


  // check parent/child relations
  var confirmRelations = function( query, elements ){
    if( query != null ){
      var matches = false;

      if( !cy.hasCompoundNodes() ){
        return false;
      }

      elements = elements(); // make elements functional so we save cycles if query == null

      // query must match for at least one element (may be recursive)
      for(var i = 0; i < elements.length; i++){
        if( queryMatches( query, elements[i] ) ){
          matches = true;
          break;
        }
      }

      return matches;
    } else {
      return true;
    }
  };

  if (! confirmRelations(query.parent, function(){
    return element.parent();
  }) ){ return false; }

  if (! confirmRelations(query.ancestor, function(){
    return element.parents();
  }) ){ return false; }

  if (! confirmRelations(query.child, function(){
    return element.children();
  }) ){ return false; }

  if (! confirmRelations(query.descendant, function(){
    return element.descendants();
  }) ){ return false; }

  // we've reached the end, so we've matched everything for this query
  return true;
}; // queryMatches

// filter an existing collection
selfn.filter = function(collection){
  var self = this;
  var cy = collection.cy();

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return cy.collection();
  }

  var selectorFunction = function(i, element){
    for(var j = 0; j < self.length; j++){
      var query = self[j];

      if( queryMatches(query, element) ){
        return true;
      }
    }

    return false;
  };

  if( self._private.selectorText == null ){
    selectorFunction = function(){ return true; };
  }

  var filteredCollection = collection.filter( selectorFunction );

  return filteredCollection;
}; // filter

// does selector match a single element?
selfn.matches = function(ele){
  var self = this;

  // don't bother trying if it's invalid
  if( self._private.invalid ){
    return false;
  }

  for(var j = 0; j < self.length; j++){
    var query = self[j];

    if( queryMatches(query, ele) ){
      return true;
    }
  }

  return false;
}; // filter

// ith query to string
selfn.toString = selfn.selector = function(){

  var str = '';

  var clean = function(obj, isValue){
    if( is.string(obj) ){
      return isValue ? '"' + obj + '"' : obj;
    }
    return '';
  };

  var queryToString = function(query){
    var str = '';

    if( query.subject === query ){
      str += '$';
    }

    var group = clean(query.group);
    str += group.substring(0, group.length - 1);

    for(var j = 0; j < query.data.length; j++){
      var data = query.data[j];

      if( data.value ){
        str += '[' + data.field + clean(data.operator) + clean(data.value, true) + ']';
      } else {
        str += '[' + clean(data.operator) + data.field + ']';
      }
    }

    for(var j = 0; j < query.meta.length; j++){
      var meta = query.meta[j];
      str += '[[' + meta.field + clean(meta.operator) + clean(meta.value, true) + ']]';
    }

    for(var j = 0; j < query.colonSelectors.length; j++){
      var sel = query.colonSelectors[i];
      str += sel;
    }

    for(var j = 0; j < query.ids.length; j++){
      var sel = '#' + query.ids[i];
      str += sel;
    }

    for(var j = 0; j < query.classes.length; j++){
      var sel = '.' + query.classes[j];
      str += sel;
    }

    if( query.parent != null ){
      str = queryToString( query.parent ) + ' > ' + str;
    }

    if( query.ancestor != null ){
      str = queryToString( query.ancestor ) + ' ' + str;
    }

    if( query.child != null ){
      str += ' > ' + queryToString( query.child );
    }

    if( query.descendant != null ){
      str += ' ' + queryToString( query.descendant );
    }

    return str;
  };

  for(var i = 0; i < this.length; i++){
    var query = this[i];

    str += queryToString( query );

    if( this.length > 1 && i < this.length - 1 ){
      str += ', ';
    }
  }

  return str;
};

module.exports = Selector;

},{"./is":77,"./util":94}],82:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var styfn = {};

// (potentially expensive calculation)
// apply the style to the element based on
// - its bypass
// - what selectors match it
styfn.apply = function( eles ){
  var self = this;

  if( self._private.newStyle ){ // clear style caches
    this._private.contextStyles = {};
    this._private.propDiffs = {};
  }

  for( var ie = 0; ie < eles.length; ie++ ){
    var ele = eles[ie];
    var cxtMeta = self.getContextMeta( ele );
    var cxtStyle = self.getContextStyle( cxtMeta );
    var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

    self.updateTransitions( ele, app.diffProps );
    self.updateStyleHints( ele );

  } // for elements

  self._private.newStyle = false;
};

styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
  var self = this;
  var cache = self._private.propDiffs = self._private.propDiffs || {};
  var dualCxtKey = oldCxtKey + '-' + newCxtKey;
  var cachedVal = cache[dualCxtKey];

  if( cachedVal ){
    return cachedVal;
  }

  var diffProps = [];
  var addedProp = {};

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[i];
    var oldHasCxt = oldCxtKey[i] === 't';
    var newHasCxt = newCxtKey[i] === 't';
    var cxtHasDiffed = oldHasCxt !== newHasCxt;
    var cxtHasMappedProps = cxt.mappedProperties.length > 0;

    if( cxtHasDiffed || cxtHasMappedProps ){
      var props;

      if( cxtHasDiffed && cxtHasMappedProps ){
        props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
      } else if( cxtHasDiffed ){
        props = cxt.properties; // need to check them all
      } else if( cxtHasMappedProps ){
        props = cxt.mappedProperties; // only need to check mapped
      }

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        var name = prop.name;

        // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
        // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
        // is cached)
        var laterCxtOverrides = false;
        for( var k = i + 1; k < self.length; k++ ){
          var laterCxt = self[k];
          var hasLaterCxt = newCxtKey[k] === 't';

          if( !hasLaterCxt ){ continue; } // can't override unless the context is active

          laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

          if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
        }

        if( !addedProp[name] && !laterCxtOverrides ){
          addedProp[name] = true;
          diffProps.push( name );
        }
      } // for props
    } // if

  } // for contexts

  cache[ dualCxtKey ] = diffProps;
  return diffProps;
};

styfn.getContextMeta = function( ele ){
  var self = this;
  var cxtKey = '';
  var diffProps;
  var prevKey = ele._private.styleCxtKey || '';

  if( self._private.newStyle ){
    prevKey = ''; // since we need to apply all style if a fresh stylesheet
  }

  // get the cxt key
  for( var i = 0; i < self.length; i++ ){
    var context = self[i];
    var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

    if( contextSelectorMatches ){
      cxtKey += 't';
    } else {
      cxtKey += 'f';
    }
  } // for context

  diffProps = self.getPropertiesDiff( prevKey, cxtKey );

  ele._private.styleCxtKey = cxtKey;

  return {
    key: cxtKey,
    diffPropNames: diffProps
  };
};

// gets a computed ele style object based on matched contexts
styfn.getContextStyle = function( cxtMeta ){
  var cxtKey = cxtMeta.key;
  var self = this;
  var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

  // if already computed style, returned cached copy
  if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }

  var style = {
    _private: {
      key: cxtKey
    }
  };

  for( var i = 0; i < self.length; i++ ){
    var cxt = self[i];
    var hasCxt = cxtKey[i] === 't';

    if( !hasCxt ){ continue; }

    for( var j = 0; j < cxt.properties.length; j++ ){
      var prop = cxt.properties[j];
      var styProp = style[ prop.name ] = prop;

      styProp.context = cxt;
    }
  }

  cxtStyles[cxtKey] = style;
  return style;
};

styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
  var self = this;
  var diffProps = cxtMeta.diffPropNames;
  var retDiffProps = {};

  for( var i = 0; i < diffProps.length; i++ ){
    var diffPropName = diffProps[i];
    var cxtProp = cxtStyle[ diffPropName ];
    var eleProp = ele._private.style[ diffPropName ];

    // save cycles when the context prop doesn't need to be applied
    if( !cxtProp || eleProp === cxtProp ){ continue; }

    var retDiffProp = retDiffProps[ diffPropName ] = {
      prev: eleProp
    };

    self.applyParsedProperty( ele, cxtProp );

    retDiffProp.next = ele._private.style[ diffPropName ];

    if( retDiffProp.next && retDiffProp.next.bypass ){
      retDiffProp.next = retDiffProp.next.bypassed;
    }
  }

  return {
    diffProps: retDiffProps
  };
};

styfn.updateStyleHints = function(ele){
  var _p = ele._private;
  var self = this;
  var style = _p.style;

  if( ele.removed() ){ return; }

  // set whether has pie or not; for greater efficiency
  var hasPie = false;
  if( _p.group === 'nodes' && self._private.hasPie ){
    for( var i = 1; i <= self.pieBackgroundN; i++ ){ // 1..N
      var size = _p.style['pie-' + i + '-background-size'].value;

      if( size > 0 ){
        hasPie = true;
        break;
      }
    }
  }

  _p.hasPie = hasPie;

  var transform = style['text-transform'].strValue;
  var content = style['label'].strValue;
  var fStyle = style['font-style'].strValue;
  var size = style['font-size'].pfValue + 'px';
  var family = style['font-family'].strValue;
  // var variant = style['font-variant'].strValue;
  var weight = style['font-weight'].strValue;
  var valign = style['text-valign'].strValue;
  var halign = style['text-valign'].strValue;
  var oWidth = style['text-outline-width'].pfValue;
  var wrap = style['text-wrap'].strValue;
  var wrapW = style['text-max-width'].pfValue;
  _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth + '$' + wrap + '$' + wrapW;
  _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;

  var width = style['width'].pfValue;
  var height = style['height'].pfValue;
  var borderW = style['border-width'].pfValue;
  _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;

  if( ele._private.group === 'edges' ){
    var cpss = style['control-point-step-size'].pfValue;
    var cpd = style['control-point-distances'] ? style['control-point-distances'].pfValue.join('_') : undefined;
    var cpw = style['control-point-weights'].value.join('_');
    var curve = style['curve-style'].strValue;
    var sd = style['segment-distances'] ? style['segment-distances'].pfValue.join('_') : undefined;
    var sw = style['segment-weights'].value.join('_');

    _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ sd +'$'+ sw +'$'+ curve;
  }

  _p.styleKey = Date.now();
};

// apply a property to the style (for internal use)
// returns whether application was successful
//
// now, this function flattens the property, and here's how:
//
// for parsedProp:{ bypass: true, deleteBypass: true }
// no property is generated, instead the bypass property in the
// element's style is replaced by what's pointed to by the `bypassed`
// field in the bypass property (i.e. restoring the property the
// bypass was overriding)
//
// for parsedProp:{ mapped: truthy }
// the generated flattenedProp:{ mapping: prop }
//
// for parsedProp:{ bypass: true }
// the generated flattenedProp:{ bypassed: parsedProp }
styfn.applyParsedProperty = function( ele, parsedProp ){
  var self = this;
  var prop = parsedProp;
  var style = ele._private.style;
  var fieldVal, flatProp;
  var types = self.types;
  var type = self.properties[ prop.name ].type;
  var propIsBypass = prop.bypass;
  var origProp = style[ prop.name ];
  var origPropIsBypass = origProp && origProp.bypass;
  var _p = ele._private;

  // can't apply auto to width or height unless it's a parent node
  if( (parsedProp.name === 'height' || parsedProp.name === 'width') && ele.isNode() ){
    if( parsedProp.value === 'auto' && !ele.isParent() ){
      return false;
    } else if( parsedProp.value !== 'auto' && ele.isParent() ){
      prop = parsedProp = this.parse( parsedProp.name, 'auto', propIsBypass );
    }
  }

  // check if we need to delete the current bypass
  if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete
    var currentProp = style[ prop.name ];

    // can only delete if the current prop is a bypass and it points to the property it was overriding
    if( !currentProp ){
      return true; // property is already not defined
    } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original

      // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
      style[ prop.name ] = currentProp.bypassed;
      return true;

    } else {
      return false; // we're unsuccessful deleting the bypass
    }
  }

  var printMappingErr = function(){
    util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');
  };

  // put the property in the style objects
  switch( prop.mapped ){ // flatten the property if mapped
  case types.mapData:
  case types.mapLayoutData:
  case types.mapScratch:

    var isLayout = prop.mapped === types.mapLayoutData;
    var isScratch = prop.mapped === types.mapScratch;

    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split(".");
    var fieldVal;

    if( isScratch || isLayout ){
      fieldVal = _p.scratch;
    } else {
      fieldVal = _p.data;
    }

    for( var i = 0; i < fields.length && fieldVal; i++ ){
      var field = fields[i];
      fieldVal = fieldVal[ field ];
    }

    var percent;
    if( !is.number(fieldVal) ){ // then keep the mapping but assume 0% for now
      percent = 0;
    } else {
      percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
    }

    // make sure to bound percent value
    if( percent < 0 ){
      percent = 0;
    } else if( percent > 1 ){
      percent = 1;
    }

    if( type.color ){
      var r1 = prop.valueMin[0];
      var r2 = prop.valueMax[0];
      var g1 = prop.valueMin[1];
      var g2 = prop.valueMax[1];
      var b1 = prop.valueMin[2];
      var b2 = prop.valueMax[2];
      var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
      var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

      var clr = [
        Math.round( r1 + (r2 - r1)*percent ),
        Math.round( g1 + (g2 - g1)*percent ),
        Math.round( b1 + (b2 - b1)*percent ),
        Math.round( a1 + (a2 - a1)*percent )
      ];

      flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
        bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
        name: prop.name,
        value: clr,
        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
      };

    } else if( type.number ){
      var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
      flatProp = this.parse( prop.name, calcValue, prop.bypass, true );

    } else {
      return false; // can only map to colours and numbers
    }

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  // direct mapping
  case types.data:
  case types.layoutData:
  case types.scratch:
    var isLayout = prop.mapped === types.layoutData;
    var isScratch = prop.mapped === types.scratch;

    // flatten the field (e.g. data.foo.bar)
    var fields = prop.field.split(".");
    var fieldVal;

    if( isScratch || isLayout ){
      fieldVal = _p.scratch;
    } else {
      fieldVal = _p.data;
    }

    if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
      var field = fields[i];
      fieldVal = fieldVal[ field ];
    } }

    flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );

    if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
      var flatPropVal = origProp ? origProp.strValue : '';

      flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );
    }

    if( !flatProp ){ printMappingErr(); }
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case types.fn:
    var fn = prop.value;
    var fnRetVal = fn( ele );

    flatProp = this.parse( prop.name, fnRetVal, prop.bypass, true );
    flatProp.mapping = prop; // keep a reference to the mapping
    prop = flatProp; // the flattened (mapped) property is the one we want

    break;

  case undefined:
    break; // just set the property

  default:
    return false; // not a valid mapping
  }

  // if the property is a bypass property, then link the resultant property to the original one
  if( propIsBypass ){
    if( origPropIsBypass ){ // then this bypass overrides the existing one
      prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
    } else { // then link the orig prop to the new bypass
      prop.bypassed = origProp;
    }

    style[ prop.name ] = prop; // and set

  } else { // prop is not bypass
    if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
      origProp.bypassed = prop;
    } else { // then just replace the old prop with the new one
      style[ prop.name ] = prop;
    }
  }

  return true;
};

// updates the visual style for all elements (useful for manual style modification after init)
styfn.update = function(){
  var cy = this._private.cy;
  var eles = cy.elements();

  eles.updateStyle();
};

// just update the functional properties (i.e. mappings) in the elements'
// styles (less expensive than recalculation)
styfn.updateMappers = function( eles ){
  var self = this;

  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[i];
    var style = ele._private.style;

    for( var j = 0; j < self.properties.length; j++ ){ // for each prop
      var prop = self.properties[j];
      var propInStyle = style[ prop.name ];

      if( propInStyle && propInStyle.mapping ){
        var mapping = propInStyle.mapping;
        this.applyParsedProperty( ele, mapping ); // reapply the mapping property
      }
    }

    this.updateStyleHints( ele );
  }
};

// diffProps : { name => { prev, next } }
styfn.updateTransitions = function( ele, diffProps, isBypass ){
  var self = this;
  var _p = ele._private;
  var style = _p.style;
  var props = style['transition-property'].value;
  var duration = style['transition-duration'].pfValue;
  var delay = style['transition-delay'].pfValue;
  var css = {};

  if( props.length > 0 && duration > 0 ){

    // build up the style to animate towards
    var anyPrev = false;
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];
      var styProp = style[ prop ];
      var diffProp = diffProps[ prop ];

      if( !diffProp ){ continue; }

      var prevProp = diffProp.prev;
      var fromProp = prevProp;
      var toProp = diffProp.next != null ? diffProp.next : styProp;
      var diff = false;
      var initVal;
      var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)

      if( !fromProp ){ continue; }

      // consider px values
      if( is.number( fromProp.pfValue ) && is.number( toProp.pfValue ) ){
        diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy
        initVal = fromProp.pfValue + initDt * diff;

      // consider numerical values
      } else if( is.number( fromProp.value ) && is.number( toProp.value ) ){
        diff = toProp.value - fromProp.value; // nonzero is truthy
        initVal = fromProp.value + initDt * diff;

      // consider colour values
      } else if( is.array( fromProp.value ) && is.array( toProp.value ) ){
        diff = fromProp.value[0] !== toProp.value[0]
          || fromProp.value[1] !== toProp.value[1]
          || fromProp.value[2] !== toProp.value[2]
        ;

        initVal = fromProp.strValue;
      }

      // the previous value is good for an animation only if it's different
      if( diff ){
        css[ prop ] = toProp.strValue; // to val
        this.applyBypass( ele, prop, initVal ); // from val
        anyPrev = true;
      }

    } // end if props allow ani

    // can't transition if there's nothing previous to transition from
    if( !anyPrev ){ return; }

    _p.transitioning = true;

    ele.stop();

    if( delay > 0 ){
      ele.delay( delay );
    }

    ele.animate({
      css: css
    }, {
      duration: duration,
      easing: style['transition-timing-function'].value,
      queue: false,
      complete: function(){
        if( !isBypass ){
          self.removeBypasses( ele, props );
        }

        _p.transitioning = false;
      }
    });

  } else if( _p.transitioning ){
    ele.stop();

    this.removeBypasses( ele, props );

    _p.transitioning = false;
  }
};

module.exports = styfn;

},{"../is":77,"../util":94}],83:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var util = _dereq_('../util');

var styfn = {};

// bypasses are applied to an existing style on an element, and just tacked on temporarily
// returns true iff application was successful for at least 1 specified property
styfn.applyBypass = function( eles, name, value, updateTransitions ){
  var self = this;
  var props = [];
  var isBypass = true;

  // put all the properties (can specify one or many) in an array after parsing them
  if( name === "*" || name === "**" ){ // apply to all property names

    if( value !== undefined ){
      for( var i = 0; i < self.properties.length; i++ ){
        var prop = self.properties[i];
        var name = prop.name;

        var parsedProp = this.parse(name, value, true);

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }

  } else if( is.string(name) ){ // then parse the single property
    var parsedProp = this.parse(name, value, true);

    if( parsedProp ){
      props.push( parsedProp );
    }
  } else if( is.plainObject(name) ){ // then parse each property
    var specifiedProps = name;
    updateTransitions = value;

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[i];
      var name = prop.name;
      var value = specifiedProps[ name ];

      if( value === undefined ){ // try camel case name too
        value = specifiedProps[ util.dash2camel(name) ];
      }

      if( value !== undefined ){
        var parsedProp = this.parse(name, value, true);

        if( parsedProp ){
          props.push( parsedProp );
        }
      }
    }
  } else { // can't do anything without well defined properties
    return false;
  }

  // we've failed if there are no valid properties
  if( props.length === 0 ){ return false; }

  // now, apply the bypass properties on the elements
  var ret = false; // return true if at least one succesful bypass applied
  for( var i = 0; i < eles.length; i++ ){ // for each ele
    var ele = eles[i];
    var style = ele._private.style;
    var diffProps = {};
    var diffProp;

    for( var j = 0; j < props.length; j++ ){ // for each prop
      var prop = props[j];

      if( updateTransitions ){
        var prevProp = style[ prop.name ];
        diffProp = diffProps[ prop.name ] = { prev: prevProp };
      }

      ret = this.applyParsedProperty( ele, prop ) || ret;

      if( updateTransitions ){
        diffProp.next = style[ prop.name ];
      }

    } // for props

    if( ret ){
      this.updateStyleHints( ele );
    }

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles

  return ret;
};

// only useful in specific cases like animation
styfn.overrideBypass = function( eles, name, value ){
  name = util.camel2dash(name);

  for( var i = 0; i < eles.length; i++ ){
    var ele = eles[i];
    var prop = ele._private.style[ name ];
    var type = this.properties[ name ].type;
    var isColor = type.color;
    var isMulti = type.mutiple;

    if( !prop.bypass ){ // need a bypass if one doesn't exist
      this.applyBypass( ele, name, value );
      continue;
    }

    prop.value = value;

    if( prop.pfValue != null ){
      prop.pfValue = value;
    }

    if( isColor ){
      prop.strValue = 'rgb(' + value.join(',') + ')';
    } else if( isMulti ){
      prop.strValue = value.join(' ');
    } else {
      prop.strValue = '' + value;
    }
  }
};

styfn.removeAllBypasses = function( eles, updateTransitions ){
  return this.removeBypasses( eles, this.propertyNames, updateTransitions );
};

styfn.removeBypasses = function( eles, props, updateTransitions ){
  var isBypass = true;

  for( var j = 0; j < eles.length; j++ ){
    var ele = eles[j];
    var diffProps = {};
    var style = ele._private.style;

    for( var i = 0; i < props.length; i++ ){
      var name = props[i];
      var prop = this.properties[ name ];
      var value = ''; // empty => remove bypass
      var parsedProp = this.parse(name, value, true);
      var prevProp = style[ prop.name ];
      var diffProp = diffProps[ prop.name ] = { prev: prevProp };

      this.applyParsedProperty(ele, parsedProp);

      diffProp.next = style[ prop.name ];
    } // for props

    this.updateStyleHints( ele );

    if( updateTransitions ){
      this.updateTransitions( ele, diffProps, isBypass );
    }
  } // for eles
};

module.exports = styfn;

},{"../is":77,"../util":94}],84:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('../window');

var styfn = {};

// gets what an em size corresponds to in pixels relative to a dom element
styfn.getEmSizeInPixels = function(){
  var px = this.containerCss('font-size');

  if( px != null ){
    return parseFloat( px );
  } else {
    return 1; // for headless
  }
};

// gets css property from the core container
styfn.containerCss = function( propName ){
  var cy = this._private.cy;
  var domElement = cy.container();

  if( window && domElement && window.getComputedStyle ){
    return window.getComputedStyle(domElement).getPropertyValue( propName );
  }
};

module.exports = styfn;

},{"../window":100}],85:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var styfn = {};

// gets the rendered style for an element
styfn.getRenderedStyle = function( ele ){
  return this.getRawStyle( ele, true );
};

// gets the raw style for an element
styfn.getRawStyle = function( ele, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var rstyle = {};

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[i];
      var val = self.getStylePropertyValue( ele, prop.name, isRenderedVal );

      if( val ){
        rstyle[ prop.name ] = val;
        rstyle[ util.dash2camel(prop.name) ] = val;
      }
    }

    return rstyle;
  }
};

styfn.getStylePropertyValue = function( ele, propName, isRenderedVal ){
  var self = this;
  var ele = ele[0]; // insure it's an element

  if( ele ){
    var style = ele._private.style;
    var prop = self.properties[ propName ];
    var type = prop.type;
    var styleProp = style[ prop.name ];
    var zoom = ele.cy().zoom();

    if( styleProp ){
      var units = styleProp.units ? type.implicitUnits || 'px' : null;
      var val = units ? [].concat( styleProp.pfValue ).map(function( pfValue ){
        return ( pfValue * (isRenderedVal ? zoom : 1) ) + units;
      }).join(' ') : styleProp.strValue;

      return val;
    }
  }
};

// gets the value style for an element (useful for things like animations)
styfn.getValueStyle = function( ele ){
  var self = this;
  var rstyle = {};
  var style;
  var isEle = is.element(ele);

  if( isEle ){
    style = ele._private.style;
  } else {
    style = ele; // just passed the style itself
  }

  if( style ){
    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[i];
      var styleProp = style[ prop.name ] || style[ util.dash2camel(prop.name) ];

      if( styleProp !== undefined ){ // then make a prop of it
        if( is.plainObject( styleProp ) ){
          styleProp = this.parse( prop.name, styleProp.strValue );
        } else {
          styleProp = this.parse( prop.name, styleProp );
        }
      }

      if( styleProp ){
        rstyle[ prop.name ] = styleProp;
        rstyle[ util.dash2camel(prop.name) ] = styleProp;
      }
    }
  }

  return rstyle;
};

styfn.getPropsList = function( propsObj ){
  var self = this;
  var rstyle = [];
  var style = propsObj;
  var props = self.properties;

  if( style ){
    for( var name in style ){
      var val = style[name];
      var prop = props[name] || props[ util.camel2dash(name) ];
      var styleProp = this.parse( prop.name, val );

      rstyle.push( styleProp );
    }
  }

  return rstyle;
};

module.exports = styfn;

},{"../is":77,"../util":94}],86:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var util = _dereq_('../util');
var Selector = _dereq_('../selector');

var Style = function( cy ){

  if( !(this instanceof Style) ){
    return new Style(cy);
  }

  if( !is.core(cy) ){
    util.error('A style must have a core reference');
    return;
  }

  this._private = {
    cy: cy,
    coreStyle: {},
    newStyle: true
  };

  this.length = 0;

  this.addDefaultStylesheet();
};

var styfn = Style.prototype;

styfn.instanceString = function(){
  return 'style';
};

// remove all contexts
styfn.clear = function(){
  for( var i = 0; i < this.length; i++ ){
    this[i] = undefined;
  }
  this.length = 0;
  this._private.newStyle = true;

  return this; // chaining
};

styfn.resetToDefault = function(){
  this.clear();
  this.addDefaultStylesheet();

  return this;
};

// builds a style object for the 'core' selector
styfn.core = function(){
  return this._private.coreStyle;
};

// create a new context from the specified selector string and switch to that context
styfn.selector = function( selectorStr ){
  // 'core' is a special case and does not need a selector
  var selector = selectorStr === 'core' ? null : new Selector( selectorStr );

  var i = this.length++; // new context means new index
  this[i] = {
    selector: selector,
    properties: [],
    mappedProperties: [],
    index: i
  };

  return this; // chaining
};

// add one or many css rules to the current context
styfn.css = function(){
  var self = this;
  var args = arguments;

  switch( args.length ){
  case 1:
    var map = args[0];

    for( var i = 0; i < self.properties.length; i++ ){
      var prop = self.properties[i];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){
        mapVal = map[ util.dash2camel(prop.name) ];
      }

      if( mapVal !== undefined ){
        this.cssRule( prop.name, mapVal );
      }
    }

    break;

  case 2:
    this.cssRule( args[0], args[1] );
    break;

  default:
    break; // do nothing if args are invalid
  }

  return this; // chaining
};
styfn.style = styfn.css;

// add a single css rule to the current context
styfn.cssRule = function( name, value ){
  // name-value pair
  var property = this.parse( name, value );

  // add property to current context if valid
  if( property ){
    var i = this.length - 1;
    this[i].properties.push( property );
    this[i].properties[ property.name ] = property; // allow access by name as well

    if( property.name.match(/pie-(\d+)-background-size/) && property.value ){
      this._private.hasPie = true;
    }

    if( property.mapped ){
      this[i].mappedProperties.push( property );
    }

    // add to core style if necessary
    var currentSelectorIsCore = !this[i].selector;
    if( currentSelectorIsCore ){
      this._private.coreStyle[ property.name ] = property;
    }
  }

  return this; // chaining
};

// static function
Style.fromJson = function( cy, json ){
  var style = new Style( cy );

  style.fromJson( json );

  return style;
};

Style.fromString = function( cy, string ){
  return new Style( cy ).fromString( string );
};

[
  _dereq_('./apply'),
  _dereq_('./bypass'),
  _dereq_('./container'),
  _dereq_('./get-for-ele'),
  _dereq_('./json'),
  _dereq_('./string-sheet'),
  _dereq_('./properties'),
  _dereq_('./parse')
].forEach(function( props ){
  util.extend( styfn, props );
});


Style.types = styfn.types;
Style.properties = styfn.properties;

module.exports = Style;

},{"../is":77,"../selector":81,"../util":94,"./apply":82,"./bypass":83,"./container":84,"./get-for-ele":85,"./json":87,"./parse":88,"./properties":89,"./string-sheet":90}],87:[function(_dereq_,module,exports){
'use strict';

var styfn = {};

styfn.applyFromJson = function( json ){
  var style = this;

  for( var i = 0; i < json.length; i++ ){
    var context = json[i];
    var selector = context.selector;
    var props = context.style || context.css;

    style.selector( selector ); // apply selector

    for( var name in props ){
      var value = props[name];

      style.css( name, value ); // apply property
    }
  }

  return style;
};

// accessible cy.style() function
styfn.fromJson = function( json ){
  var style = this;

  style.resetToDefault();
  style.applyFromJson( json );

  return style;
};

// get json from cy.style() api
styfn.json = function(){
  var json = [];

  for( var i = this.defaultLength; i < this.length; i++ ){
    var cxt = this[i];
    var selector = cxt.selector;
    var props = cxt.properties;
    var css = {};

    for( var j = 0; j < props.length; j++ ){
      var prop = props[j];
      css[ prop.name ] = prop.strValue;
    }

    json.push({
      selector: !selector ? 'core' : selector.toString(),
      style: css
    });
  }

  return json;
};

module.exports = styfn;

},{}],88:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var is = _dereq_('../is');

var styfn = {};

// a caching layer for property parsing
styfn.parse = function( name, value, propIsBypass, propIsFlat ){
  var argHash = [ name, value, propIsBypass, propIsFlat ].join('$');
  var propCache = this.propCache = this.propCache || {};
  var ret;
  var impl = parseImpl.bind( this );

  if( !(ret = propCache[argHash]) ){
    ret = propCache[argHash] = impl( name, value, propIsBypass, propIsFlat );
  }

  // always need a copy since props are mutated later in their lifecycles
  ret = util.copy( ret );

  if( ret ){
    ret.value = util.copy( ret.value ); // because it could be an array, e.g. colour
  }

  return ret;
};

// parse a property; return null on invalid; return parsed property otherwise
// fields :
// - name : the name of the property
// - value : the parsed, native-typed value of the property
// - strValue : a string value that represents the property value in valid css
// - bypass : true iff the property is a bypass property
var parseImpl = function( name, value, propIsBypass, propIsFlat ){
  var self = this;

  name = util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')

  var property = self.properties[ name ];
  var passedValue = value;
  var types = self.types;

  if( !property ){ return null; } // return null on property of unknown name
  if( value === undefined || value === null ){ return null; } // can't assign null

  // the property may be an alias
  if( property.alias ){
    property = property.pointsTo;
    name = property.name;
  }

  var valueIsString = is.string(value);
  if( valueIsString ){ // trim the value to make parsing easier
    value = value.trim();
  }

  var type = property.type;
  if( !type ){ return null; } // no type, no luck

  // check if bypass is null or empty string (i.e. indication to delete bypass property)
  if( propIsBypass && (value === '' || value === null) ){
    return {
      name: name,
      value: value,
      bypass: true,
      deleteBypass: true
    };
  }

  // check if value is a function used as a mapper
  if( is.fn(value) ){
    return {
      name: name,
      value: value,
      strValue: 'fn',
      mapped: types.fn,
      bypass: propIsBypass
    };
  }

  // check if value is mapped
  var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;
  if( !valueIsString || propIsFlat ){
    // then don't bother to do the expensive regex checks

  } else if(
    ( data = new RegExp( types.data.regex ).exec( value ) ) ||
    ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||
    ( scratch = new RegExp( types.scratch.regex ).exec( value ) )
  ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass

    var mapped;
    if( data ){
      mapped = types.data;
    } else if( layoutData ){
      mapped = types.layoutData;
    } else {
      mapped = types.scratch;
    }

    data = data || layoutData || scratch;

    return {
      name: name,
      value: data,
      strValue: '' + value,
      mapped: mapped,
      field: data[1],
      bypass: propIsBypass
    };

  } else if(
    ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||
    ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||
    ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )
  ){
    if( propIsBypass ){ return false; } // mappers not allowed in bypass
    if( type.multiple ){ return false; } // impossible to map to num

    var mapped;
    if( mapData ){
      mapped = types.mapData;
    } else if( mapLayoutData ){
      mapped = types.mapLayoutData;
    } else {
      mapped = types.mapScratch;
    }

    mapData = mapData || mapLayoutData || mapScratch;

    // we can map only if the type is a colour or a number
    if( !(type.color || type.number) ){ return false; }

    var valueMin = this.parse( name, mapData[4] ); // parse to validate
    if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

    var valueMax = this.parse( name, mapData[5] ); // parse to validate
    if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

    // check if valueMin and valueMax are the same
    if( valueMin.value === valueMax.value ){
      return false; // can't make much of a mapper without a range

    } else if( type.color ){
      var c1 = valueMin.value;
      var c2 = valueMax.value;

      var same = c1[0] === c2[0] // red
        && c1[1] === c2[1] // green
        && c1[2] === c2[2] // blue
        && ( // optional alpha
          c1[3] === c2[3] // same alpha outright
          || (
            (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
            &&
            (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
          )
        )
      ;

      if( same ){ return false; } // can't make a mapper without a range
    }

    return {
      name: name,
      value: mapData,
      strValue: '' + value,
      mapped: mapped,
      field: mapData[1],
      fieldMin: parseFloat( mapData[2] ), // min & max are numeric
      fieldMax: parseFloat( mapData[3] ),
      valueMin: valueMin.value,
      valueMax: valueMax.value,
      bypass: propIsBypass
    };
  }

  if( type.multiple && propIsFlat !== 'multiple' ){
    var vals;

    if( valueIsString ){
      vals = value.split(/\s+/);
    } else if( is.array(value) ){
      vals = value;
    } else {
      vals = [ value ];
    }

    if( type.evenMultiple && vals.length % 2 !== 0 ){ return null; }

    var valArr = vals.map(function( v ){
      var p = self.parse( name, v, propIsBypass, 'multiple' );

      if( p.pfValue != null ){
        return p.pfValue;
      } else {
        return p.value;
      }
    });

    return {
      name: name,
      value: valArr,
      pfValue: valArr,
      strValue: valArr.join(' '),
      bypass: propIsBypass,
      units: type.number && !type.unitless ? type.implicitUnits || 'px' : undefined
    };
  }

  // several types also allow enums
  var checkEnums = function(){
    for( var i = 0; i < type.enums.length; i++ ){
      var en = type.enums[i];

      if( en === value ){
        return {
          name: name,
          value: value,
          strValue: '' + value,
          bypass: propIsBypass
        };
      }
    }

    return null;
  };

  // check the type and return the appropriate object
  if( type.number ){
    var units;
    var implicitUnits = 'px'; // not set => px

    if( type.units ){ // use specified units if set
      units = type.units;
    }

    if( type.implicitUnits ){
      implicitUnits = type.implicitUnits;
    }

    if( !type.unitless ){
      if( valueIsString ){
        var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
        if( units ){ unitsRegex = units; } // only allow explicit units if so set
        var match = value.match( '^(' + util.regex.number + ')(' + unitsRegex + ')?' + '$' );

        if( match ){
          value = match[1];
          units = match[2] || implicitUnits;
        }

      } else if( !units || type.implicitUnits ) {
        units = implicitUnits; // implicitly px if unspecified
      }
    }

    value = parseFloat( value );

    // if not a number and enums not allowed, then the value is invalid
    if( isNaN(value) && type.enums === undefined ){
      return null;
    }

    // check if this number type also accepts special keywords in place of numbers
    // (i.e. `left`, `auto`, etc)
    if( isNaN(value) && type.enums !== undefined ){
      value = passedValue;

      return checkEnums();
    }

    // check if value must be an integer
    if( type.integer && !is.integer(value) ){
      return null;
    }

    // check value is within range
    if( (type.min !== undefined && value < type.min)
    || (type.max !== undefined && value > type.max)
    ){
      return null;
    }

    var ret = {
      name: name,
      value: value,
      strValue: '' + value + (units ? units : ''),
      units: units,
      bypass: propIsBypass
    };

    // normalise value in pixels
    if( type.unitless || (units !== 'px' && units !== 'em') ){
      ret.pfValue = value;
    } else {
      ret.pfValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
    }

    // normalise value in ms
    if( units === 'ms' || units === 's' ){
      ret.pfValue = units === 'ms' ? value : 1000 * value;
    }

    // normalise value in rad
    if( units === 'deg' || units === 'rad' ){
      ret.pfValue = units === 'rad' ? value : value * Math.PI/180;
    }

    return ret;

  } else if( type.propList ) {

    var props = [];
    var propsStr = '' + value;

    if( propsStr === 'none' ){
      // leave empty

    } else { // go over each prop

      var propsSplit = propsStr.split(',');
      for( var i = 0; i < propsSplit.length; i++ ){
        var propName = propsSplit[i].trim();

        if( self.properties[propName] ){
          props.push( propName );
        }
      }

      if( props.length === 0 ){ return null; }
    }

    return {
      name: name,
      value: props,
      strValue: props.length === 0 ? 'none' : props.join(', '),
      bypass: propIsBypass
    };

  } else if( type.color ){
    var tuple = util.color2tuple( value );

    if( !tuple ){ return null; }

    return {
      name: name,
      value: tuple,
      strValue: '' + value,
      bypass: propIsBypass,
      roundValue: true
    };

  } else if( type.regex || type.regexes ){

    // first check enums
    if( type.enums ){
      var enumProp = checkEnums();

      if( enumProp ){ return enumProp; }
    }

    var regexes = type.regexes ? type.regexes : [ type.regex ];

    for( var i = 0; i < regexes.length; i++ ){
      var regex = new RegExp( regexes[i] ); // make a regex from the type string
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };

      }
    }

    return null; // didn't match any

  } else if( type.string ){
    // just return
    return {
      name: name,
      value: value,
      strValue: '' + value,
      bypass: propIsBypass
    };

  } else if( type.enums ){ // check enums last because it's a combo type in others
    return checkEnums();

  } else {
    return null; // not a type we can handle
  }

};

module.exports = styfn;

},{"../is":77,"../util":94}],89:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');

var styfn = {};

(function(){
  var number = util.regex.number;
  var rgba = util.regex.rgbaNoBackRefs;
  var hsla = util.regex.hslaNoBackRefs;
  var hex3 = util.regex.hex3;
  var hex6 = util.regex.hex6;
  var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
  var mapData = function( prefix ){
    var mapArg = number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6;
    return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + mapArg + ')\\s*\\,\\s*(' + mapArg + ')\\)$';
  };

  // each visual style property has a type and needs to be validated according to it
  styfn.types = {
    time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
    percent: { number: true, min: 0, max: 100, units: '%', implicitUnits: '%' },
    zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
    nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
    nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
    position: { enums: ['parent', 'origin'] },
    nodeSize: { number: true, min: 0, enums: ['auto', 'label'] },
    number: { number: true, unitless: true },
    numbers: { number: true, unitless: true, multiple: true },
    size: { number: true, min: 0 },
    bidirectionalSize: { number: true }, // allows negative
    bidirectionalSizes: { number: true, multiple: true }, // allows negative
    bgSize: { number: true, min: 0, allowPercent: true },
    bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'] },
    bgPos: { number: true, allowPercent: true },
    bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },
    bgFit: { enums: ['none', 'contain', 'cover'] },
    bgClip: { enums: ['none', 'node'] },
    color: { color: true },
    bool: { enums: ['yes', 'no'] },
    lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
    borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
    curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack', 'segments'] },
    fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
    fontVariant: { enums: ['small-caps', 'normal'] },
    fontStyle: { enums: ['italic', 'normal', 'oblique'] },
    fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
    textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
    textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
    textWrap: { enums: ['none', 'wrap'] },
    textBackgroundShape: { enums: ['rectangle', 'roundrectangle']},
    nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid', 'polygon'] },
    compoundIncludeLabels: { enums: ['include', 'exclude'] },
    arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'vee', 'square', 'circle', 'diamond', 'none'] },
    arrowFill: { enums: ['filled', 'hollow'] },
    display: { enums: ['element', 'none'] },
    visibility: { enums: ['hidden', 'visible'] },
    valign: { enums: ['top', 'center', 'bottom'] },
    halign: { enums: ['left', 'center', 'right'] },
    text: { string: true },
    data: { mapping: true, regex: data('data') },
    layoutData: { mapping: true, regex: data('layoutData') },
    scratch: { mapping: true, regex: data('scratch') },
    mapData: { mapping: true, regex: mapData('mapData') },
    mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
    mapScratch: { mapping: true, regex: mapData('mapScratch') },
    fn: { mapping: true, fn: true },
    url: { regex: '^url\\s*\\(\\s*([^\\s]+)\\s*\\s*\\)|none|(.+)$' },
    propList: { propList: true },
    angle: { number: true, units: 'deg|rad', implicitUnits: 'rad' },
    textRotation: { enums: ['none', 'autorotate'] },
    polygonPointList: { number: true, multiple: true, evenMultiple: true, min: -1, max: 1, unitless: true },
    easing: {
      regexes: [
        '^(spring)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$',
        '^(cubic-bezier)\\s*\\(\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*,\\s*(' + number + ')\\s*\\)$'
      ],
      enums: [
        'linear',
        'ease', 'ease-in', 'ease-out', 'ease-in-out',
        'ease-in-sine', 'ease-out-sine', 'ease-in-out-sine',
        'ease-in-quad', 'ease-out-quad', 'ease-in-out-quad',
        'ease-in-cubic', 'ease-out-cubic', 'ease-in-out-cubic',
        'ease-in-quart', 'ease-out-quart', 'ease-in-out-quart',
        'ease-in-quint', 'ease-out-quint', 'ease-in-out-quint',
        'ease-in-expo', 'ease-out-expo', 'ease-in-out-expo',
        'ease-in-circ', 'ease-out-circ', 'ease-in-out-circ'
      ]
    }
  };

  // define visual style properties
  var t = styfn.types;
  var props = styfn.properties = [
    // labels
    { name: 'text-valign', type: t.valign },
    { name: 'text-halign', type: t.halign },
    { name: 'color', type: t.color },
    { name: 'label', type: t.text },
    { name: 'text-outline-color', type: t.color },
    { name: 'text-outline-width', type: t.size },
    { name: 'text-outline-opacity', type: t.zeroOneNumber },
    { name: 'text-opacity', type: t.zeroOneNumber },
    { name: 'text-background-color', type: t.color },
    { name: 'text-background-opacity', type: t.zeroOneNumber },
    { name: 'text-border-opacity', type: t.zeroOneNumber },
    { name: 'text-border-color', type: t.color },
    { name: 'text-border-width', type: t.size },
    { name: 'text-border-style', type: t.borderStyle },
    { name: 'text-background-shape', type: t.textBackgroundShape},
    // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
    { name: 'text-transform', type: t.textTransform },
    { name: 'text-wrap', type: t.textWrap },
    { name: 'text-max-width', type: t.size },
    { name: 'text-events', type: t.bool },

    // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes
    { name: 'font-family', type: t.fontFamily },
    { name: 'font-style', type: t.fontStyle },
    // { name: 'font-variant', type: t.fontVariant }, // not useful
    { name: 'font-weight', type: t.fontWeight },
    { name: 'font-size', type: t.size },
    { name: 'min-zoomed-font-size', type: t.size },
    { name: 'edge-text-rotation', type: t.textRotation },

    // behaviour
    { name: 'events', type: t.bool },

    // visibility
    { name: 'display', type: t.display },
    { name: 'visibility', type: t.visibility },
    { name: 'opacity', type: t.zeroOneNumber },
    { name: 'z-index', type: t.nonNegativeInt },

    // overlays
    { name: 'overlay-padding', type: t.size },
    { name: 'overlay-color', type: t.color },
    { name: 'overlay-opacity', type: t.zeroOneNumber },

    // shadows
    { name: 'shadow-blur', type: t.size },
    { name: 'shadow-color', type: t.color },
    { name: 'shadow-opacity', type: t.zeroOneNumber },
    { name: 'shadow-offset-x', type: t.bidirectionalSize },
    { name: 'shadow-offset-y', type: t.bidirectionalSize },

    // label shadows
    { name: 'text-shadow-blur', type: t.size },
    { name: 'text-shadow-color', type: t.color },
    { name: 'text-shadow-opacity', type: t.zeroOneNumber },
    { name: 'text-shadow-offset-x', type: t.bidirectionalSize },
    { name: 'text-shadow-offset-y', type: t.bidirectionalSize },

    // transition anis
    { name: 'transition-property', type: t.propList },
    { name: 'transition-duration', type: t.time },
    { name: 'transition-delay', type: t.time },
    { name: 'transition-timing-function', type: t.easing },

    // node body
    { name: 'height', type: t.nodeSize },
    { name: 'width', type: t.nodeSize },
    { name: 'shape', type: t.nodeShape },
    { name: 'shape-polygon-points', type: t.polygonPointList },
    { name: 'background-color', type: t.color },
    { name: 'background-opacity', type: t.zeroOneNumber },
    { name: 'background-blacken', type: t.nOneOneNumber },
    { name: 'padding-left', type: t.size },
    { name: 'padding-right', type: t.size },
    { name: 'padding-top', type: t.size },
    { name: 'padding-bottom', type: t.size },

    // node border
    { name: 'border-color', type: t.color },
    { name: 'border-opacity', type: t.zeroOneNumber },
    { name: 'border-width', type: t.size },
    { name: 'border-style', type: t.borderStyle },

    // node background images
    { name: 'background-image', type: t.url },
    { name: 'background-image-opacity', type: t.zeroOneNumber },
    { name: 'background-position-x', type: t.bgPos },
    { name: 'background-position-y', type: t.bgPos },
    { name: 'background-repeat', type: t.bgRepeat },
    { name: 'background-fit', type: t.bgFit },
    { name: 'background-clip', type: t.bgClip },
    { name: 'background-width', type: t.bgWH },
    { name: 'background-height', type: t.bgWH },

    // compound props
    { name: 'position', type: t.position },
    { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },

    // edge line
    { name: 'line-style', type: t.lineStyle },
    { name: 'line-color', type: t.color },
    { name: 'curve-style', type: t.curveStyle },
    { name: 'haystack-radius', type: t.zeroOneNumber },
    { name: 'control-point-step-size', type: t.size },
    { name: 'control-point-distances', type: t.bidirectionalSizes },
    { name: 'control-point-weights', type: t.numbers },
    { name: 'segment-distances', type: t.bidirectionalSizes },
    { name: 'segment-weights', type: t.numbers },

    // these are just for the core
    { name: 'selection-box-color', type: t.color },
    { name: 'selection-box-opacity', type: t.zeroOneNumber },
    { name: 'selection-box-border-color', type: t.color },
    { name: 'selection-box-border-width', type: t.size },
    { name: 'active-bg-color', type: t.color },
    { name: 'active-bg-opacity', type: t.zeroOneNumber },
    { name: 'active-bg-size', type: t.size },
    { name: 'outside-texture-bg-color', type: t.color },
    { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
  ];

  // define aliases
  var aliases = styfn.aliases = [
    { name: 'content', pointsTo: 'label' },
    { name: 'control-point-distance', pointsTo: 'control-point-distances' },
    { name: 'control-point-weight', pointsTo: 'control-point-weights' }
  ];

  // pie backgrounds for nodes
  styfn.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
  props.push({ name: 'pie-size', type: t.bgSize });
  for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
    props.push({ name: 'pie-'+i+'-background-color', type: t.color });
    props.push({ name: 'pie-'+i+'-background-size', type: t.percent });
    props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });
  }

  // edge arrows
  var arrowPrefixes = styfn.arrowPrefixes = ['source', 'mid-source', 'target', 'mid-target'];
  [
    { name: 'arrow-shape', type: t.arrowShape },
    { name: 'arrow-color', type: t.color },
    { name: 'arrow-fill', type: t.arrowFill }
  ].forEach(function( prop ){
    arrowPrefixes.forEach(function( prefix ){
      var name = prefix + '-' + prop.name;
      var type = prop.type;

      props.push({ name: name, type: type });
    });
  }, {});

  // list of property names
  styfn.propertyNames = props.map(function(p){ return p.name; });

  // allow access of properties by name ( e.g. style.properties.height )
  for( var i = 0; i < props.length; i++ ){
    var prop = props[i];

    props[ prop.name ] = prop; // allow lookup by name
  }

  // map aliases
  for( var i = 0; i < aliases.length; i++ ){
    var alias = aliases[i];
    var pointsToProp = props[ alias.pointsTo ];
    var aliasProp = {
      name: alias.name,
      alias: true,
      pointsTo: pointsToProp
    };

    // add alias prop for parsing
    props.push( aliasProp );

    props[ alias.name ] = aliasProp; // allow lookup by name
  }
})();

// adds the default stylesheet to the current style
styfn.addDefaultStylesheet = function(){
  // fill the style with the default stylesheet
  this
    .selector('node, edge') // common properties
      .css( util.extend( {
        'events': 'yes',
        'text-events': 'no',
        'text-valign': 'top',
        'text-halign': 'center',
        'color': '#000',
        'text-outline-color': '#000',
        'text-outline-width': 0,
        'text-outline-opacity': 1,
        'text-opacity': 1,
        'text-decoration': 'none',
        'text-transform': 'none',
        'text-wrap': 'none',
        'text-max-width': 9999,
        'text-background-color': '#000',
        'text-background-opacity': 0,
        'text-border-opacity': 0,
        'text-border-width': 0,
        'text-border-style': 'solid',
        'text-border-color':'#000',
        'text-background-shape':'rectangle',
        'font-family': 'Helvetica Neue, Helvetica, sans-serif',
        'font-style': 'normal',
        // 'font-variant': fontVariant,
        'font-weight': 'normal',
        'font-size': 16,
        'min-zoomed-font-size': 0,
        'edge-text-rotation': 'none',
        'visibility': 'visible',
        'display': 'element',
        'opacity': 1,
        'z-index': 0,
        'label': '',
        'overlay-opacity': 0,
        'overlay-color': '#000',
        'overlay-padding': 10,
        'shadow-opacity': 0,
        'shadow-color': '#000',
        'shadow-blur': 10,
        'shadow-offset-x': 0,
        'shadow-offset-y': 0,
        'text-shadow-opacity': 0,
        'text-shadow-color': '#000',
        'text-shadow-blur': 5,
        'text-shadow-offset-x': 0,
        'text-shadow-offset-y': 0,
        'transition-property': 'none',
        'transition-duration': 0,
        'transition-delay': 0,
        'transition-timing-function': 'linear',

        // node props
        'background-blacken': 0,
        'background-color': '#888',
        'background-opacity': 1,
        'background-image': 'none',
        'background-image-opacity': 1,
        'background-position-x': '50%',
        'background-position-y': '50%',
        'background-repeat': 'no-repeat',
        'background-fit': 'none',
        'background-clip': 'node',
        'background-width': 'auto',
        'background-height': 'auto',
        'border-color': '#000',
        'border-opacity': 1,
        'border-width': 0,
        'border-style': 'solid',
        'height': 30,
        'width': 30,
        'shape': 'ellipse',
        'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',

        // compound props
        'padding-top': 0,
        'padding-bottom': 0,
        'padding-left': 0,
        'padding-right': 0,
        'position': 'origin',
        'compound-sizing-wrt-labels': 'include'
      }, {
        // node pie bg
        'pie-size': '100%'
      }, [
        { name: 'pie-{{i}}-background-color', value: 'black' },
        { name: 'pie-{{i}}-background-size', value: '0%' },
        { name: 'pie-{{i}}-background-opacity', value: 1 }
      ].reduce(function( css, prop ){
        for( var i = 1; i <= styfn.pieBackgroundN; i++ ){
          var name = prop.name.replace('{{i}}', i);
          var val = prop.value;

          css[ name ] = val;
        }

        return css;
      }, {}), {
        // edge props
        'line-style': 'solid',
        'line-color': '#ddd',
        'control-point-step-size': 40,
        'control-point-weights': 0.5,
        'segment-weights': 0.5,
        'segment-distances': 20,
        'curve-style': 'bezier',
        'haystack-radius': 0.8
      }, [
        { name: 'arrow-shape', value: 'none' },
        { name: 'arrow-color', value: '#ddd' },
        { name: 'arrow-fill', value: 'filled' }
      ].reduce(function( css, prop ){
        styfn.arrowPrefixes.forEach(function( prefix ){
          var name = prefix + '-' + prop.name;
          var val = prop.value;

          css[ name ] = val;
        });

        return css;
      }, {}) ) )
    .selector('$node > node') // compound (parent) node properties
      .css({
        'width': 'auto',
        'height': 'auto',
        'shape': 'rectangle',
        'padding-top': 10,
        'padding-right': 10,
        'padding-left': 10,
        'padding-bottom': 10
      })
    .selector('edge') // just edge properties
      .css({
        'width': 1
      })
    .selector(':active')
      .css({
        'overlay-color': 'black',
        'overlay-padding': 10,
        'overlay-opacity': 0.25
      })
    .selector('core') // just core properties
      .css({
        'selection-box-color': '#ddd',
        'selection-box-opacity': 0.65,
        'selection-box-border-color': '#aaa',
        'selection-box-border-width': 1,
        'active-bg-color': 'black',
        'active-bg-opacity': 0.15,
        'active-bg-size': 30,
        'outside-texture-bg-color': '#000',
        'outside-texture-bg-opacity': 0.125
      })
  ;

  this.defaultLength = this.length;
};

module.exports = styfn;

},{"../util":94}],90:[function(_dereq_,module,exports){
'use strict';

var util = _dereq_('../util');
var Selector = _dereq_('../selector');

var styfn = {};

styfn.applyFromString = function( string ){
  var self = this;
  var style = this;
  var remaining = '' + string;
  var selAndBlockStr;
  var blockRem;
  var propAndValStr;

  // remove comments from the style string
  remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

  function removeSelAndBlockFromRemaining(){
    // remove the parsed selector and block from the remaining text to parse
    if( remaining.length > selAndBlockStr.length ){
      remaining = remaining.substr( selAndBlockStr.length );
    } else {
      remaining = '';
    }
  }

  function removePropAndValFromRem(){
    // remove the parsed property and value from the remaining block text to parse
    if( blockRem.length > propAndValStr.length ){
      blockRem = blockRem.substr( propAndValStr.length );
    } else {
      blockRem = '';
    }
  }

  while(true){
    var nothingLeftToParse = remaining.match(/^\s*$/);
    if( nothingLeftToParse ){ break; }

    var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

    if( !selAndBlock ){
      util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
      break;
    }

    selAndBlockStr = selAndBlock[0];

    // parse the selector
    var selectorStr = selAndBlock[1];
    if( selectorStr !== 'core' ){
      var selector = new Selector( selectorStr );
      if( selector._private.invalid ){
        util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue;
      }
    }

    // parse the block of properties and values
    var blockStr = selAndBlock[2];
    var invalidBlock = false;
    blockRem = blockStr;
    var props = [];

    while(true){
      var nothingLeftToParse = blockRem.match(/^\s*$/);
      if( nothingLeftToParse ){ break; }

      var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

      if( !propAndVal ){
        util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
        invalidBlock = true;
        break;
      }

      propAndValStr = propAndVal[0];
      var propStr = propAndVal[1];
      var valStr = propAndVal[2];

      var prop = self.properties[ propStr ];
      if( !prop ){
        util.error('Skipping property: Invalid property name in: ' + propAndValStr);

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      var parsedProp = style.parse( propStr, valStr );

      if( !parsedProp ){
        util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

        // skip this property in the block
        removePropAndValFromRem();
        continue;
      }

      props.push({
        name: propStr,
        val: valStr
      });
      removePropAndValFromRem();
    }

    if( invalidBlock ){
      removeSelAndBlockFromRemaining();
      break;
    }

    // put the parsed block in the style
    style.selector( selectorStr );
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];
      style.css( prop.name, prop.val );
    }

    removeSelAndBlockFromRemaining();
  }

  return style;
};

styfn.fromString = function( string ){
  var style = this;

  style.resetToDefault();
  style.applyFromString( string );

  return style;
};

module.exports = styfn;

},{"../selector":81,"../util":94}],91:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('./is');
var util = _dereq_('./util');
var Style = _dereq_('./style');

// a dummy stylesheet object that doesn't need a reference to the core
// (useful for init)
var Stylesheet = function(){
  if( !(this instanceof Stylesheet) ){
    return new Stylesheet();
  }

  this.length = 0;
};

var sheetfn = Stylesheet.prototype;

sheetfn.instanceString = function(){
  return 'stylesheet';
};

// just store the selector to be parsed later
sheetfn.selector = function( selector ){
  var i = this.length++;

  this[i] = {
    selector: selector,
    properties: []
  };

  return this; // chaining
};

// just store the property to be parsed later
sheetfn.css = function( name, value ){
  var i = this.length - 1;

  if( is.string(name) ){
    this[i].properties.push({
      name: name,
      value: value
    });
  } else if( is.plainObject(name) ){
    var map = name;

    for( var j = 0; j < Style.properties.length; j++ ){
      var prop = Style.properties[j];
      var mapVal = map[ prop.name ];

      if( mapVal === undefined ){ // also try camel case name
        mapVal = map[ util.dash2camel(prop.name) ];
      }

      if( mapVal !== undefined ){
        var name = prop.name;
        var value = mapVal;

        this[i].properties.push({
          name: name,
          value: value
        });
      }
    }
  }

  return this; // chaining
};

sheetfn.style = sheetfn.css;

// generate a real style object from the dummy stylesheet
sheetfn.generateStyle = function( cy ){
  var style = new Style(cy);

  for( var i = 0; i < this.length; i++ ){
    var context = this[i];
    var selector = context.selector;
    var props = context.properties;

    style.selector(selector); // apply selector

    for( var j = 0; j < props.length; j++ ){
      var prop = props[j];

      style.css( prop.name, prop.value ); // apply property
    }
  }

  return style;
};

module.exports = Stylesheet;

},{"./is":77,"./style":86,"./util":94}],92:[function(_dereq_,module,exports){
// cross-env thread/worker
// NB : uses (heavyweight) processes on nodejs so best not to create too many threads

'use strict';

var window = _dereq_('./window');
var util = _dereq_('./util');
var Promise = _dereq_('./promise');
var Event = _dereq_('./event');
var define = _dereq_('./define');
var is = _dereq_('./is');

var Thread = function( opts ){
  if( !(this instanceof Thread) ){
    return new Thread( opts );
  }

  var _p = this._private = {
    requires: [],
    files: [],
    queue: null,
    pass: [],
    disabled: false
  };

  if( is.plainObject(opts) ){
    if( opts.disabled != null ){
      _p.disabled = !!opts.disabled;
    }
  }

};

var thdfn = Thread.prototype; // short alias

var stringifyFieldVal = function( val ){
  var valStr = is.fn( val ) ? val.toString() : "JSON.parse('" + JSON.stringify(val) + "')";

  return valStr;
};

// allows for requires with prototypes and subobjs etc
var fnAsRequire = function( fn ){
  var req;
  var fnName;

  if( is.object(fn) && fn.fn ){ // manual fn
    req = fnAs( fn.fn, fn.name );
    fnName = fn.name;
    fn = fn.fn;
  } else if( is.fn(fn) ){ // auto fn
    req = fn.toString();
    fnName = fn.name;
  } else if( is.string(fn) ){ // stringified fn
    req = fn;
  } else if( is.object(fn) ){ // plain object
    if( fn.proto ){
      req = '';
    } else {
      req = fn.name + ' = {};';
    }

    fnName = fn.name;
    fn = fn.obj;
  }

  req += '\n';

  var protoreq = function( val, subname ){
    if( val.prototype ){
      var protoNonempty = false;
      for( var prop in val.prototype ){ protoNonempty = true; break; } // jshint ignore:line

      if( protoNonempty ){
        req += fnAsRequire( {
          name: subname,
          obj: val,
          proto: true
        }, val );
      }
    }
  };

  // pull in prototype
  if( fn.prototype && fnName != null ){

    for( var name in fn.prototype ){
      var protoStr = '';

      var val = fn.prototype[ name ];
      var valStr = stringifyFieldVal( val );
      var subname = fnName + '.prototype.' + name;

      protoStr += subname + ' = ' + valStr + ';\n';

      if( protoStr ){
        req += protoStr;
      }

      protoreq( val, subname ); // subobject with prototype
    }

  }

  // pull in properties for obj/fns
  if( !is.string(fn) ){ for( var name in fn ){
    var propsStr = '';

    if( fn.hasOwnProperty(name) ){
      var val = fn[ name ];
      var valStr = stringifyFieldVal( val );
      var subname = fnName + '["' + name + '"]';

      propsStr += subname + ' = ' + valStr + ';\n';
    }

    if( propsStr ){
      req += propsStr;
    }

    protoreq( val, subname ); // subobject with prototype
  } }

  return req;
};

var isPathStr = function( str ){
  return is.string(str) && str.match(/\.js$/);
};

util.extend(thdfn, {

  instanceString: function(){ return 'thread'; },

  require: function( fn, as ){
    var requires = this._private.requires;

    if( isPathStr(fn) ){
      this._private.files.push( fn );

      return this;
    }

    if( as ){
      if( is.fn(fn) ){
        fn = { name: as, fn: fn };
      } else {
        fn = { name: as, obj: fn };
      }
    } else {
      if( is.fn(fn) ){
        if( !fn.name ){
          throw 'The function name could not be automatically determined.  Use thread.require( someFunction, "someFunction" )';
        }

        fn = { name: fn.name, fn: fn };
      }
    }

    requires.push( fn );

    return this; // chaining
  },

  pass: function( data ){
    this._private.pass.push( data );

    return this; // chaining
  },

  run: function( fn, pass ){ // fn used like main()
    var self = this;
    var _p = this._private;
    pass = pass || _p.pass.shift();

    if( _p.stopped ){
      throw 'Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.';
    }

    if( _p.running ){
      return ( _p.queue = _p.queue.then(function(){ // inductive step
        return self.run( fn, pass );
      }) );
    }

    var useWW = window != null && !_p.disabled;
    var useNode = !window && typeof module !== 'undefined' && !_p.disabled;

    self.trigger('run');

    var runP = new Promise(function( resolve, reject ){

      _p.running = true;

      var threadTechAlreadyExists = _p.ran;

      var fnImplStr = is.string( fn ) ? fn : fn.toString();

      // worker code to exec
      var fnStr = '\n' + ( _p.requires.map(function( r ){
        return fnAsRequire( r );
      }) ).concat( _p.files.map(function( f ){
        if( useWW ){
          var wwifyFile = function( file ){
            if( file.match(/^\.\//) || file.match(/^\.\./) ){
              return window.location.origin + window.location.pathname + file;
            } else if( file.match(/^\//) ){
              return window.location.origin + '/' + file;
            }
            return file;
          };

          return 'importScripts("' + wwifyFile(f) + '");';
        } else if( useNode ) {
          return 'eval( require("fs").readFileSync("' + f + '", { encoding: "utf8" }) );';
        } else {
          throw 'External file `' + f + '` can not be required without any threading technology.';
        }
      }) ).concat([
        '( function(){',
          'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',
          'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it
        '} )()\n'
      ]).join('\n');

      // because we've now consumed the requires, empty the list so we don't dupe on next run()
      _p.requires = [];
      _p.files = [];

      if( useWW ){
        var fnBlob, fnUrl;

        // add normalised thread api functions
        if( !threadTechAlreadyExists ){
          var fnPre = fnStr + '';

          fnStr = [
            'function _ref_(o){ return eval(o); };',
            'function broadcast(m){ return message(m); };', // alias
            'function message(m){ postMessage(m); };',
            'function listen(fn){',
            '  self.addEventListener("message", function(m){ ',
            '    if( typeof m === "object" && (m.data.$$eval || m.data === "$$start") ){',
            '    } else { ',
            '      fn( m.data );',
            '    }',
            '  });',
            '};',
            'self.addEventListener("message", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',
            'function resolve(v){ postMessage({ $$resolve: v }); };',
            'function reject(v){ postMessage({ $$reject: v }); };'
          ].join('\n');

          fnStr += fnPre;

          fnBlob = new Blob([ fnStr ], {
            type: 'application/javascript'
          });
          fnUrl = window.URL.createObjectURL( fnBlob );
        }
        // create webworker and let it exec the serialised code
        var ww = _p.webworker = _p.webworker || new Worker( fnUrl );

        if( threadTechAlreadyExists ){ // then just exec new run() code
          ww.postMessage({
            $$eval: fnStr
          });
        }

        // worker messages => events
        var cb;
        ww.addEventListener('message', cb = function( m ){
          var isObject = is.object(m) && is.object( m.data );

          if( isObject && ('$$resolve' in m.data) ){
            ww.removeEventListener('message', cb); // done listening b/c resolve()

            resolve( m.data.$$resolve );
          } else if( isObject && ('$$reject' in m.data) ){
            ww.removeEventListener('message', cb); // done listening b/c reject()

            reject( m.data.$$reject );
          } else {
            self.trigger( new Event(m, { type: 'message', message: m.data }) );
          }
        }, false);

        if( !threadTechAlreadyExists ){
          ww.postMessage('$$start'); // start up the worker
        }

      } else if( useNode ){
        // create a new process

        if( !_p.child ){
          _p.child = ( _dereq_('child_process').fork( _dereq_('path').join(__dirname, 'thread-node-fork') ) );
        }

        var child = _p.child;

        // child process messages => events
        var cb;
        child.on('message', cb = function( m ){
          if( is.object(m) && ('$$resolve' in m) ){
            child.removeListener('message', cb); // done listening b/c resolve()

            resolve( m.$$resolve );
          } else if( is.object(m) && ('$$reject' in m) ){
            child.removeListener('message', cb); // done listening b/c reject()

            reject( m.$$reject );
          } else {
            self.trigger( new Event({}, { type: 'message', message: m }) );
          }
        });

        // ask the child process to eval the worker code
        child.send({
          $$eval: fnStr
        });

      } else { // use a fallback mechanism using a timeout

        var promiseResolve = resolve;
        var promiseReject = reject;

        var timer = _p.timer = _p.timer || {

          listeners: [],

          exec: function(){
            // as a string so it can't be mangled by minifiers and processors
            fnStr = [
              'function _ref_(o){ return eval(o); };',
              'function broadcast(m){ return message(m); };',
              'function message(m){ self.trigger( new Event({}, { type: "message", message: m }) ); };',
              'function listen(fn){ timer.listeners.push( fn ); };',
              'function resolve(v){ promiseResolve(v); };',
              'function reject(v){ promiseReject(v); };'
            ].join('\n') + fnStr;

            // the .run() code
            eval( fnStr ); // jshint ignore:line
          },

          message: function( m ){
            var ls = timer.listeners;

            for( var i = 0; i < ls.length; i++ ){
              var fn = ls[i];

              fn( m );
            }
          }

        };

        timer.exec();
      }

    }).then(function( v ){
      _p.running = false;
      _p.ran = true;

      self.trigger('ran');

      return v;
    });

    if( _p.queue == null ){
      _p.queue = runP; // i.e. first step of inductive promise chain (for queue)
    }

    return runP;
  },

  // send the thread a message
  message: function( m ){
    var _p = this._private;

    if( _p.webworker ){
      _p.webworker.postMessage( m );
    }

    if( _p.child ){
      _p.child.send( m );
    }

    if( _p.timer ){
      _p.timer.message( m );
    }

    return this; // chaining
  },

  stop: function(){
    var _p = this._private;

    if( _p.webworker ){
      _p.webworker.terminate();
    }

    if( _p.child ){
      _p.child.kill();
    }

    if( _p.timer ){
      // nothing we can do if we've run a timeout
    }

    _p.stopped = true;

    return this.trigger('stop'); // chaining
  },

  stopped: function(){
    return this._private.stopped;
  }

});

// turns a stringified function into a (re)named function
var fnAs = function( fn, name ){
  var fnStr = fn.toString();
  fnStr = fnStr.replace(/function\s*?\S*?\s*?\(/, 'function ' + name + '(');

  return fnStr;
};

var defineFnal = function( opts ){
  opts = opts || {};

  return function fnalImpl( fn, arg1 ){
    var fnStr = fnAs( fn, '_$_$_' + opts.name );

    this.require( fnStr );

    return this.run( [
      'function( data ){',
      '  var origResolve = resolve;',
      '  var res = [];',
      '  ',
      '  resolve = function( val ){',
      '    res.push( val );',
      '  };',
      '  ',
      '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',
      '  ',
      '  resolve = origResolve;',
      '  resolve( res.length > 0 ? res : ret );',
      '}'
    ].join('\n') );
  };
};

util.extend(thdfn, {
  reduce: defineFnal({ name: 'reduce' }),

  reduceRight: defineFnal({ name: 'reduceRight' }),

  map: defineFnal({ name: 'map' })
});

// aliases
var fn = thdfn;
fn.promise = fn.run;
fn.terminate = fn.halt = fn.stop;
fn.include = fn.require;

// pull in event apis
util.extend(thdfn, {
  on: define.on(),
  one: define.on({ unbindSelfOnTrigger: true }),
  off: define.off(),
  trigger: define.trigger()
});

define.eventAliasesOn( thdfn );

module.exports = Thread;

},{"./define":41,"./event":42,"./is":77,"./promise":80,"./util":94,"./window":100,"child_process":undefined,"path":undefined}],93:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');

module.exports = {
  // get [r, g, b] from #abc or #aabbcc
  hex2tuple: function( hex ){
    if( !(hex.length === 4 || hex.length === 7) || hex[0] !== "#" ){ return; }

    var shortHex = hex.length === 4;
    var r, g, b;
    var base = 16;

    if( shortHex ){
      r = parseInt( hex[1] + hex[1], base );
      g = parseInt( hex[2] + hex[2], base );
      b = parseInt( hex[3] + hex[3], base );
    } else {
      r = parseInt( hex[1] + hex[2], base );
      g = parseInt( hex[3] + hex[4], base );
      b = parseInt( hex[5] + hex[6], base );
    }

    return [r, g, b];
  },

  // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
  hsl2tuple: function( hsl ){
    var ret;
    var h, s, l, a, r, g, b;
    function hue2rgb(p, q, t){
      if(t < 0) t += 1;
      if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var m = new RegExp("^" + this.regex.hsla + "$").exec(hsl);
    if( m ){

      // get hue
      h = parseInt( m[1] );
      if( h < 0 ){
        h = ( 360 - (-1*h % 360) ) % 360;
      } else if( h > 360 ){
        h = h % 360;
      }
      h /= 360; // normalise on [0, 1]

      s = parseFloat( m[2] );
      if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
      s = s/100; // normalise on [0, 1]

      l = parseFloat( m[3] );
      if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
      l = l/100; // normalise on [0, 1]

      a = m[4];
      if( a !== undefined ){
        a = parseFloat( a );

        if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
      }

      // now, convert to rgb
      // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
      if( s === 0 ){
        r = g = b = Math.round(l * 255); // achromatic
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );
        g = Math.round( 255 * hue2rgb(p, q, h) );
        b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );
      }

      ret = [r, g, b, a];
    }

    return ret;
  },

  // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
  rgb2tuple: function( rgb ){
    var ret;

    var m = new RegExp("^" + this.regex.rgba + "$").exec(rgb);
    if( m ){
      ret = [];

      var isPct = [];
      for( var i = 1; i <= 3; i++ ){
        var channel = m[i];

        if( channel[ channel.length - 1 ] === "%" ){
          isPct[i] = true;
        }
        channel = parseFloat( channel );

        if( isPct[i] ){
          channel = channel/100 * 255; // normalise to [0, 255]
        }

        if( channel < 0 || channel > 255 ){ return; } // invalid channel value

        ret.push( Math.floor(channel) );
      }

      var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
      var allArePct = isPct[1] && isPct[2] && isPct[3];
      if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

      var alpha = m[4];
      if( alpha !== undefined ){
        alpha = parseFloat( alpha );

        if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

        ret.push( alpha );
      }
    }

    return ret;
  },

  colorname2tuple: function( color ){
    return this.colors[ color.toLowerCase() ];
  },

  color2tuple: function( color ){
    return ( is.array(color) ? color : null )
      || this.colorname2tuple(color)
      || this.hex2tuple(color)
      || this.rgb2tuple(color)
      || this.hsl2tuple(color);
  },

  colors: {
    // special colour names
    transparent: [0, 0, 0, 0], // NB alpha === 0

    // regular colours
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    grey: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }
};

},{"../is":77}],94:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');
var math = _dereq_('../math');

var util = {

  falsify: function(){ return false; },

  zeroify: function(){ return 0; },

  noop: function(){},

  /* jshint ignore:start */
  error: function( msg ){
    if( console.error ){
      console.error.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    } else {
      console.log.apply( console, arguments );

      if( console.trace ){ console.trace(); }
    }
  },
  /* jshint ignore:end */

  clone: function( obj ){
    return this.extend( {}, obj );
  },

  // gets a shallow copy of the argument
  copy: function( obj ){
    if( obj == null ){
      return obj;
    } if( is.array(obj) ){
      return obj.slice();
    } else if( is.plainObject(obj) ){
      return this.clone( obj );
    } else {
      return obj;
    }
  }

};

util.makeBoundingBox = math.makeBoundingBox.bind( math );

util._staticEmptyObject = {};

util.staticEmptyObject = function(){
  return util._staticEmptyObject;
};

util.extend = Object.assign != null ? Object.assign : function( tgt ){
  var args = arguments;

  for( var i = 1; i < args.length; i++ ){
    var obj = args[i];

    for( var k in obj ){
      tgt[k] = obj[k];
    }
  }

  return tgt;
};

[
  _dereq_('./colors'),
  _dereq_('./maps'),
  { memoize: _dereq_('./memoize') },
  _dereq_('./regex'),
  _dereq_('./strings'),
  _dereq_('./timing')
].forEach(function( req ){
  util.extend( util, req );
});

module.exports = util;

},{"../is":77,"../math":79,"./colors":93,"./maps":95,"./memoize":96,"./regex":97,"./strings":98,"./timing":99}],95:[function(_dereq_,module,exports){
'use strict';

var is = _dereq_('../is');

module.exports = {
  // has anything been set in the map
  mapEmpty: function( map ){
    var empty = true;

    if( map != null ){
      for(var i in map){ // jshint ignore:line
        empty = false;
        break;
      }
    }

    return empty;
  },

  // pushes to the array at the end of a map (map may not be built)
  pushMap: function( options ){
    var array = this.getMap(options);

    if( array == null ){ // if empty, put initial array
      this.setMap( this.extend({}, options, {
        value: [ options.value ]
      }) );
    } else {
      array.push( options.value );
    }
  },

  // sets the value in a map (map may not be built)
  setMap: function( options ){
    var obj = options.map;
    var key;
    var keys = options.keys;
    var l = keys.length;

    for(var i = 0; i < l; i++){
      var key = keys[i];

      if( is.plainObject( key ) ){
        this.error('Tried to set map with object key');
      }

      if( i < keys.length - 1 ){

        // extend the map if necessary
        if( obj[key] == null ){
          obj[key] = {};
        }

        obj = obj[key];
      } else {
        // set the value
        obj[key] = options.value;
      }
    }
  },

  // gets the value in a map even if it's not built in places
  getMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;

    for(var i = 0; i < l; i++){
      var key = keys[i];

      if( is.plainObject( key ) ){
        this.error('Tried to get map with object key');
      }

      obj = obj[key];

      if( obj == null ){
        return obj;
      }
    }

    return obj;
  },

  // deletes the entry in the map
  deleteMap: function( options ){
    var obj = options.map;
    var keys = options.keys;
    var l = keys.length;
    var keepChildren = options.keepChildren;

    for(var i = 0; i < l; i++){
      var key = keys[i];

      if( is.plainObject( key ) ){
        this.error('Tried to delete map with object key');
      }

      var lastKey = i === options.keys.length - 1;
      if( lastKey ){

        if( keepChildren ){ // then only delete child fields not in keepChildren
          for( var child in obj ){
            if( !keepChildren[child] ){
              obj[child] = undefined;
            }
          }
        } else {
          obj[key] = undefined;
        }

      } else {
        obj = obj[key];
      }
    }
  }
};

},{"../is":77}],96:[function(_dereq_,module,exports){
'use strict';

module.exports = function memoize( fn, keyFn ){
  var self = this;
  var cache = {};

  if( !keyFn ){
    keyFn = function(){
      if( arguments.length === 1 ){
        return arguments[0];
      }

      var args = [];

      for( var i = 0; i < arguments.length; i++ ){
        args.push( arguments[i] );
      }

      return args.join('$');
    };
  }

  return function memoizedFn(){
    var args = arguments;
    var ret;
    var k = keyFn.apply( self, args );

    if( !(ret = cache[k]) ){
      ret = cache[k] = fn.apply( self, args );
    }

    return ret;
  };
};

},{}],97:[function(_dereq_,module,exports){
'use strict';

var number = "(?:[-+]?(?:(?:\\d+|\\d*\\.\\d+)(?:[Ee][+-]?\\d+)?))";

var rgba = "rgb[a]?\\(("+ number +"[%]?)\\s*,\\s*("+ number +"[%]?)\\s*,\\s*("+ number +"[%]?)(?:\\s*,\\s*("+ number +"))?\\)";
var rgbaNoBackRefs = "rgb[a]?\\((?:"+ number +"[%]?)\\s*,\\s*(?:"+ number +"[%]?)\\s*,\\s*(?:"+ number +"[%]?)(?:\\s*,\\s*(?:"+ number +"))?\\)";

var hsla = "hsl[a]?\\(("+ number +")\\s*,\\s*("+ number +"[%])\\s*,\\s*("+ number +"[%])(?:\\s*,\\s*("+ number +"))?\\)";
var hslaNoBackRefs = "hsl[a]?\\((?:"+ number +")\\s*,\\s*(?:"+ number +"[%])\\s*,\\s*(?:"+ number +"[%])(?:\\s*,\\s*(?:"+ number +"))?\\)";

var hex3 = "\\#[0-9a-fA-F]{3}";
var hex6 = "\\#[0-9a-fA-F]{6}";

module.exports = {
  regex: {
    number: number,
    rgba: rgba,
    rgbaNoBackRefs: rgbaNoBackRefs,
    hsla: hsla,
    hslaNoBackRefs: hslaNoBackRefs,
    hex3: hex3,
    hex6: hex6
  }
};

},{}],98:[function(_dereq_,module,exports){
'use strict';

var memoize = _dereq_('./memoize');
var is = _dereq_('../is');

module.exports = {

  camel2dash: memoize( function( str ){
    return str.replace(/([A-Z])/g, function( v ){
      return '-' + v.toLowerCase();
    });
  } ),

  dash2camel: memoize( function( str ){
    return str.replace(/(-\w)/g, function( v ){
      return v[1].toUpperCase();
    });
  } ),

  capitalize: function(str){
    if( is.emptyString(str) ){
      return str;
    }

    return str.charAt(0).toUpperCase() + str.substring(1);
  }

};

},{"../is":77,"./memoize":96}],99:[function(_dereq_,module,exports){
'use strict';

var window = _dereq_('../window');
var is = _dereq_('../is');
var performance = window ? window.performance : null;

var util = {};

var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );

raf = raf || function( fn ){
  if( fn ){
    setTimeout(function(){
      fn( pnow() );
    }, 1000/60);
  }
};

util.requestAnimationFrame = function(fn){
  raf( fn );
};

var pnow = performance && performance.now ? function(){ return performance.now(); } : function(){ return Date.now(); };

util.performanceNow = pnow;

// ported lodash throttle function
util.throttle = function(func, wait, options) {
  var leading = true,
      trailing = true;

  if (options === false) {
    leading = false;
  } else if (is.plainObject(options)) {
    leading = 'leading' in options ? options.leading : leading;
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  options = options || {};
  options.leading = leading;
  options.maxWait = wait;
  options.trailing = trailing;

  return util.debounce(func, wait, options);
};

util.now = function(){
  return Date.now();
};

util.debounce = function(func, wait, options) { // ported lodash debounce function
  var util = this;
  var args,
      maxTimeoutId,
      result,
      stamp,
      thisArg,
      timeoutId,
      trailingCall,
      lastCalled = 0,
      maxWait = false,
      trailing = true;

  if (!is.fn(func)) {
    return;
  }
  wait = Math.max(0, wait) || 0;
  if (options === true) {
    var leading = true;
    trailing = false;
  } else if (is.plainObject(options)) {
    leading = options.leading;
    maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
    trailing = 'trailing' in options ? options.trailing : trailing;
  }
  var delayed = function() {
    var remaining = wait - (util.now() - stamp);
    if (remaining <= 0) {
      if (maxTimeoutId) {
        clearTimeout(maxTimeoutId);
      }
      var isCalled = trailingCall;
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (isCalled) {
        lastCalled = util.now();
        result = func.apply(thisArg, args);
        if (!timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
      }
    } else {
      timeoutId = setTimeout(delayed, remaining);
    }
  };

  var maxDelayed = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    maxTimeoutId = timeoutId = trailingCall = undefined;
    if (trailing || (maxWait !== wait)) {
      lastCalled = util.now();
      result = func.apply(thisArg, args);
      if (!timeoutId && !maxTimeoutId) {
        args = thisArg = null;
      }
    }
  };

  return function() {
    args = arguments;
    stamp = util.now();
    thisArg = this;
    trailingCall = trailing && (timeoutId || !leading);

    if (maxWait === false) {
      var leadingCall = leading && !timeoutId;
    } else {
      if (!maxTimeoutId && !leading) {
        lastCalled = stamp;
      }
      var remaining = maxWait - (stamp - lastCalled),
          isCalled = remaining <= 0;

      if (isCalled) {
        if (maxTimeoutId) {
          maxTimeoutId = clearTimeout(maxTimeoutId);
        }
        lastCalled = stamp;
        result = func.apply(thisArg, args);
      }
      else if (!maxTimeoutId) {
        maxTimeoutId = setTimeout(maxDelayed, remaining);
      }
    }
    if (isCalled && timeoutId) {
      timeoutId = clearTimeout(timeoutId);
    }
    else if (!timeoutId && wait !== maxWait) {
      timeoutId = setTimeout(delayed, wait);
    }
    if (leadingCall) {
      isCalled = true;
      result = func.apply(thisArg, args);
    }
    if (isCalled && !timeoutId && !maxTimeoutId) {
      args = thisArg = null;
    }
    return result;
  };
};

module.exports = util;

},{"../is":77,"../window":100}],100:[function(_dereq_,module,exports){
module.exports = ( typeof window === 'undefined' ? null : window );

},{}]},{},[76])(76)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvYW5pbWF0aW9uLmpzIiwic3JjL2NvbGxlY3Rpb24vYWxnb3JpdGhtcy9hLXN0YXIuanMiLCJzcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2JlbGxtYW4tZm9yZC5qcyIsInNyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvYmV0d2Vlbm5lc3MtY2VudHJhbGl0eS5qcyIsInNyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvYmZzLWRmcy5qcyIsInNyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvY2xvc2VuZXNzLWNlbnRyYWxpdHkuanMiLCJzcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2RlZ3JlZS1jZW50cmFsaXR5LmpzIiwic3JjL2NvbGxlY3Rpb24vYWxnb3JpdGhtcy9mbG95ZC13YXJzaGFsbC5qcyIsInNyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvaW5kZXguanMiLCJzcmMvY29sbGVjdGlvbi9hbGdvcml0aG1zL2tlcmdlci1zdGVpbi5qcyIsInNyYy9jb2xsZWN0aW9uL2FsZ29yaXRobXMvcGFnZS1yYW5rLmpzIiwic3JjL2NvbGxlY3Rpb24vYW5pbWF0aW9uLmpzIiwic3JjL2NvbGxlY3Rpb24vY2xhc3MuanMiLCJzcmMvY29sbGVjdGlvbi9jb21wYXJhdG9ycy5qcyIsInNyYy9jb2xsZWN0aW9uL2NvbXBvdW5kcy5qcyIsInNyYy9jb2xsZWN0aW9uL2RhdGEuanMiLCJzcmMvY29sbGVjdGlvbi9kZWdyZWUuanMiLCJzcmMvY29sbGVjdGlvbi9kaW1lbnNpb25zLmpzIiwic3JjL2NvbGxlY3Rpb24vZWxlbWVudC5qcyIsInNyYy9jb2xsZWN0aW9uL2V2ZW50cy5qcyIsInNyYy9jb2xsZWN0aW9uL2ZpbHRlci5qcyIsInNyYy9jb2xsZWN0aW9uL2dyb3VwLmpzIiwic3JjL2NvbGxlY3Rpb24vaW5kZXguanMiLCJzcmMvY29sbGVjdGlvbi9pdGVyYXRpb24uanMiLCJzcmMvY29sbGVjdGlvbi9sYXlvdXQuanMiLCJzcmMvY29sbGVjdGlvbi9zdHlsZS5qcyIsInNyYy9jb2xsZWN0aW9uL3N3aXRjaC1mdW5jdGlvbnMuanMiLCJzcmMvY29sbGVjdGlvbi90cmF2ZXJzaW5nLmpzIiwic3JjL2NvbGxlY3Rpb24venNvcnQuanMiLCJzcmMvY29yZS9hZGQtcmVtb3ZlLmpzIiwic3JjL2NvcmUvYW5pbWF0aW9uLmpzIiwic3JjL2NvcmUvZXZlbnRzLmpzIiwic3JjL2NvcmUvZXhwb3J0LmpzIiwic3JjL2NvcmUvaW5kZXguanMiLCJzcmMvY29yZS9sYXlvdXQuanMiLCJzcmMvY29yZS9ub3RpZmljYXRpb24uanMiLCJzcmMvY29yZS9yZW5kZXJlci5qcyIsInNyYy9jb3JlL3NlYXJjaC5qcyIsInNyYy9jb3JlL3N0eWxlLmpzIiwic3JjL2NvcmUvdmlld3BvcnQuanMiLCJzcmMvZGVmaW5lLmpzIiwic3JjL2V2ZW50LmpzIiwic3JjL2V4dGVuc2lvbi5qcyIsInNyYy9leHRlbnNpb25zL2luZGV4LmpzIiwic3JjL2V4dGVuc2lvbnMvbGF5b3V0L2JyZWFkdGhmaXJzdC5qcyIsInNyYy9leHRlbnNpb25zL2xheW91dC9jaXJjbGUuanMiLCJzcmMvZXh0ZW5zaW9ucy9sYXlvdXQvY29uY2VudHJpYy5qcyIsInNyYy9leHRlbnNpb25zL2xheW91dC9jb3NlLmpzIiwic3JjL2V4dGVuc2lvbnMvbGF5b3V0L2dyaWQuanMiLCJzcmMvZXh0ZW5zaW9ucy9sYXlvdXQvaW5kZXguanMiLCJzcmMvZXh0ZW5zaW9ucy9sYXlvdXQvbnVsbC5qcyIsInNyYy9leHRlbnNpb25zL2xheW91dC9wcmVzZXQuanMiLCJzcmMvZXh0ZW5zaW9ucy9sYXlvdXQvcmFuZG9tLmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9hcnJvdy1zaGFwZXMuanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9iYXNlL2NhY2hlZC1lbGVzLmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9jb29yZC1lbGUtbWF0aC5qcyIsInNyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvaW1hZ2VzLmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9pbmRleC5qcyIsInNyYy9leHRlbnNpb25zL3JlbmRlcmVyL2Jhc2UvbG9hZC1saXN0ZW5lcnMuanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9iYXNlL25vZGUtc2hhcGVzLmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvYmFzZS9yZWRyYXcuanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvYXJyb3ctc2hhcGVzLmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctZWRnZXMuanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZHJhd2luZy1pbWFnZXMuanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZHJhd2luZy1sYWJlbC10ZXh0LmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2RyYXdpbmctbm9kZXMuanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZHJhd2luZy1yZWRyYXcuanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZHJhd2luZy1zaGFwZXMuanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9jYW52YXMvZXhwb3J0LWltYWdlLmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL2luZGV4LmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvY2FudmFzL25vZGUtc2hhcGVzLmpzIiwic3JjL2V4dGVuc2lvbnMvcmVuZGVyZXIvaW5kZXguanMiLCJzcmMvZXh0ZW5zaW9ucy9yZW5kZXJlci9udWxsL2luZGV4LmpzIiwic3JjL2ZhYnJpYy5qcyIsInNyYy9oZWFwLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL2lzLmpzIiwic3JjL2pxdWVyeS1wbHVnaW4uanMiLCJzcmMvbWF0aC5qcyIsInNyYy9wcm9taXNlLmpzIiwic3JjL3NlbGVjdG9yLmpzIiwic3JjL3N0eWxlL2FwcGx5LmpzIiwic3JjL3N0eWxlL2J5cGFzcy5qcyIsInNyYy9zdHlsZS9jb250YWluZXIuanMiLCJzcmMvc3R5bGUvZ2V0LWZvci1lbGUuanMiLCJzcmMvc3R5bGUvaW5kZXguanMiLCJzcmMvc3R5bGUvanNvbi5qcyIsInNyYy9zdHlsZS9wYXJzZS5qcyIsInNyYy9zdHlsZS9wcm9wZXJ0aWVzLmpzIiwic3JjL3N0eWxlL3N0cmluZy1zaGVldC5qcyIsInNyYy9zdHlsZXNoZWV0LmpzIiwic3JjL3RocmVhZC5qcyIsInNyYy91dGlsL2NvbG9ycy5qcyIsInNyYy91dGlsL2luZGV4LmpzIiwic3JjL3V0aWwvbWFwcy5qcyIsInNyYy91dGlsL21lbW9pemUuanMiLCJzcmMvdXRpbC9yZWdleC5qcyIsInNyYy91dGlsL3N0cmluZ3MuanMiLCJzcmMvdXRpbC90aW1pbmcuanMiLCJzcmMvd2luZG93LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25yQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3A0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMza0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcblxudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCB0YXJnZXQsIG9wdHMsIG9wdHMyICl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBBbmltYXRpb24pICl7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRpb24oIHRhcmdldCwgb3B0cywgb3B0czIgKTtcbiAgfVxuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB1dGlsLmV4dGVuZCgge1xuICAgIGR1cmF0aW9uOiAxMDAwXG4gIH0sIG9wdHMsIG9wdHMyICk7XG5cbiAgX3AudGFyZ2V0ID0gdGFyZ2V0O1xuICBfcC5zdHlsZSA9IF9wLnN0eWxlIHx8IF9wLmNzcztcbiAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gIF9wLmhvb2tlZCA9IGZhbHNlO1xuICBfcC5hcHBseWluZyA9IGZhbHNlO1xuICBfcC5wcm9ncmVzcyA9IDA7XG4gIF9wLmNvbXBsZXRlcyA9IFtdO1xuICBfcC5mcmFtZXMgPSBbXTtcblxuICBpZiggX3AuY29tcGxldGUgJiYgaXMuZm4oX3AuY29tcGxldGUpICl7XG4gICAgX3AuY29tcGxldGVzLnB1c2goIF9wLmNvbXBsZXRlICk7XG4gIH1cblxuICAvLyBmb3IgZnV0dXJlIHRpbWVsaW5lL2FuaW1hdGlvbnMgaW1wbFxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xufTtcblxudmFyIGFuaWZuID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxudXRpbC5leHRlbmQoIGFuaWZuLCB7XG5cbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAnYW5pbWF0aW9uJzsgfSxcblxuICBob29rOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggIV9wLmhvb2tlZCApe1xuICAgICAgLy8gYWRkIHRvIHRhcmdldCdzIGFuaW1hdGlvbiBxdWV1ZVxuICAgICAgdmFyIHE7XG4gICAgICB2YXIgdEFuaSA9IF9wLnRhcmdldC5fcHJpdmF0ZS5hbmltYXRpb247XG4gICAgICBpZiggX3AucXVldWUgKXtcbiAgICAgICAgcSA9IHRBbmkucXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxID0gdEFuaS5jdXJyZW50O1xuICAgICAgfVxuICAgICAgcS5wdXNoKCB0aGlzICk7XG5cbiAgICAgIC8vIGFkZCB0byB0aGUgYW5pbWF0aW9uIGxvb3AgcG9vbFxuICAgICAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIF9wLnRhcmdldCApICl7XG4gICAgICAgIF9wLnRhcmdldC5jeSgpLmFkZFRvQW5pbWF0aW9uUG9vbCggX3AudGFyZ2V0ICk7XG4gICAgICB9XG5cbiAgICAgIF9wLmhvb2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGxheTogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgLy8gYXV0b3Jld2luZFxuICAgIGlmKCBfcC5wcm9ncmVzcyA9PT0gMSApe1xuICAgICAgX3AucHJvZ3Jlc3MgPSAwO1xuICAgIH1cblxuICAgIF9wLnBsYXlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuaG9vaygpO1xuXG4gICAgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgc3RhcnQgdGhlIGFuaW1hdGlvbi4uLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcGxheWluZzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wbGF5aW5nO1xuICB9LFxuXG4gIGFwcGx5OiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5hcHBseWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5ob29rKCk7XG5cbiAgICAvLyB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBhcHBseSB0aGUgYW5pbWF0aW9uIGF0IHRoaXMgcHJvZ3Jlc3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGFwcGx5aW5nOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmFwcGx5aW5nO1xuICB9LFxuXG4gIHBhdXNlOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBfcC5zdG9wcGVkID0gdHJ1ZTsgLy8gdG8gYmUgcmVtb3ZlZCBmcm9tIGFuaW1hdGlvbiBxdWV1ZXNcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJld2luZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygwKTtcbiAgfSxcblxuICBmYXN0Zm9yd2FyZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygxKTtcbiAgfSxcblxuICB0aW1lOiBmdW5jdGlvbiggdCApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggdCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3MgKiBfcC5kdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoIHQgLyBfcC5kdXJhdGlvbiApO1xuICAgIH1cbiAgfSxcblxuICBwcm9ncmVzczogZnVuY3Rpb24oIHAgKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB3YXNQbGF5aW5nID0gX3AucGxheWluZztcblxuICAgIGlmKCBwID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBfcC5wcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIHdhc1BsYXlpbmcgKXtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICBfcC5wcm9ncmVzcyA9IHA7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvbXBsZXRlZDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wcm9ncmVzcyA9PT0gMTtcbiAgfSxcblxuICByZXZlcnNlOiBmdW5jdGlvbigpe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuXG4gICAgaWYoIHdhc1BsYXlpbmcgKXtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICBfcC5wcm9ncmVzcyA9IDEgLSBfcC5wcm9ncmVzcztcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICB2YXIgc3dhcCA9IGZ1bmN0aW9uKCBhLCBiICl7XG4gICAgICB2YXIgX3BhID0gX3BbYV07XG5cbiAgICAgIF9wW2FdID0gX3BbYl07XG4gICAgICBfcFtiXSA9IF9wYTtcbiAgICB9O1xuXG4gICAgc3dhcCggJ3pvb20nLCAnc3RhcnRab29tJyApO1xuICAgIHN3YXAoICdwYW4nLCAnc3RhcnRQYW4nICk7XG4gICAgc3dhcCggJ3Bvc2l0aW9uJywgJ3N0YXJ0UG9zaXRpb24nICk7XG5cbiAgICAvLyBzd2FwIHN0eWxlc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgX3Auc3R5bGUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gX3Auc3R5bGVbaV07XG4gICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgIHZhciBzdGFydFN0eWxlUHJvcCA9IF9wLnN0YXJ0U3R5bGVbIG5hbWUgXTtcblxuICAgICAgX3Auc3RhcnRTdHlsZVsgbmFtZSBdID0gX3Auc3RhcnRTdHlsZVsgdXRpbC5kYXNoMmNhbWVsKCBuYW1lICkgXSA9IHByb3A7XG4gICAgICBfcC5zdHlsZVtpXSA9IHN0YXJ0U3R5bGVQcm9wO1xuICAgIH1cblxuICAgIGlmKCB3YXNQbGF5aW5nICl7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBwcm9taXNlOiBmdW5jdGlvbiggdHlwZSApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICB2YXIgYXJyO1xuXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICAgIGFyciA9IF9wLmZyYW1lcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgYXJyID0gX3AuY29tcGxldGVzO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiggcmVzb2x2ZSwgcmVqZWN0ICl7XG4gICAgICBhcnIucHVzaChmdW5jdGlvbigpe1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59ICk7XG5cbmFuaWZuLmNvbXBsZXRlID0gYW5pZm4uY29tcGxldGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFuaW1hdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vaXMnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGFTdGFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBSZWNvbnN0cnVjdHMgdGhlIHBhdGggZnJvbSBTdGFydCB0byBFbmQsIGFjdW11bGF0aW5nIHRoZSByZXN1bHQgaW4gcGF0aEFjdW1cbiAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgY2FtZUZyb21NYXAsIHBhdGhBY3VtKSB7XG4gICAgICAvLyBCYXNlIGNhc2VcbiAgICAgIGlmIChzdGFydCA9PSBlbmQpIHtcbiAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoZW5kKSApO1xuICAgICAgICByZXR1cm4gcGF0aEFjdW07XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgaW4gY2FtZUZyb21NYXApIHtcbiAgICAgICAgLy8gV2Uga25vdyB3aGljaCBub2RlIGlzIGJlZm9yZSB0aGUgbGFzdCBvbmVcbiAgICAgICAgdmFyIHByZXZpb3VzID0gY2FtZUZyb21NYXBbZW5kXTtcbiAgICAgICAgdmFyIHByZXZpb3VzRWRnZSA9IGNhbWVGcm9tRWRnZVtlbmRdO1xuXG4gICAgICAgIHBhdGhBY3VtLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKGVuZCkgKTtcbiAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocHJldmlvdXNFZGdlKSApO1xuXG5cbiAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0UGF0aChzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLFxuICAgICAgICAgICAgICAgICAgICAgY2FtZUZyb21NYXAsXG4gICAgICAgICAgICAgICAgICAgICBwYXRoQWN1bSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHNob3VsZCBub3QgcmVhY2ggaGVyZSFcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGluIG9wZW5TZXQgd2hpY2ggaGFzIG1pbmltdW0gZlNjb3JlXG4gICAgdmFyIGZpbmRNaW4gPSBmdW5jdGlvbihvcGVuU2V0LCBmU2NvcmUpIHtcbiAgICAgIGlmIChvcGVuU2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgYmUgdGhlIGNhc2VcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5Qb3MgPSAwO1xuICAgICAgdmFyIHRlbXBTY29yZSA9IGZTY29yZVtvcGVuU2V0WzBdXTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb3BlblNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcyA9IGZTY29yZVtvcGVuU2V0W2ldXTtcbiAgICAgICAgaWYgKHMgPCB0ZW1wU2NvcmUpIHtcbiAgICAgICAgICB0ZW1wU2NvcmUgPSBzO1xuICAgICAgICAgIG1pblBvcyA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW5Qb3M7XG4gICAgfTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5yb290ICE9IG51bGwpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBpcy5zdHJpbmcob3B0aW9ucy5yb290KSA/XG4gICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdIDpcbiAgICAgICAgb3B0aW9ucy5yb290WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIGdvYWwgLSBtYW5kYXRvcnkhXG4gICAgaWYgKG9wdGlvbnMuZ29hbCAhPSBudWxsKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gaXMuc3RyaW5nKG9wdGlvbnMuZ29hbCkgP1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNnb2FsSURcbiAgICAgICAgdGhpcy5maWx0ZXIob3B0aW9ucy5nb2FsKVswXSA6XG4gICAgICAgIG9wdGlvbnMuZ29hbFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBIZXVyaXN0aWMgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmhldXJpc3RpYyAhPSBudWxsICYmIGlzLmZuKG9wdGlvbnMuaGV1cmlzdGljKSkge1xuICAgICAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaGV1cmlzdGljID0gZnVuY3Rpb24oKXsgcmV0dXJuIDA7IH07IC8vIHVzZSBjb25zdGFudCBpZiB1bnNwZWNpZmllZFxuICAgIH1cblxuICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7XG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjbG9zZWRTZXQgPSBbXTtcbiAgICB2YXIgb3BlblNldCA9IFtzb3VyY2UuaWQoKV07XG4gICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgdmFyIGNhbWVGcm9tRWRnZSA9IHt9O1xuICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICB2YXIgZlNjb3JlID0ge307XG5cbiAgICBnU2NvcmVbc291cmNlLmlkKCldID0gMDtcbiAgICBmU2NvcmVbc291cmNlLmlkKCldID0gaGV1cmlzdGljKHNvdXJjZSk7XG5cbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKGUpeyByZXR1cm4gIWUuaXNMb29wKCk7IH0pO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIC8vIENvdW50ZXJcbiAgICB2YXIgc3RlcHMgPSAwO1xuXG4gICAgLy8gTWFpbiBsb29wXG4gICAgd2hpbGUgKG9wZW5TZXQubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIG1pblBvcyA9IGZpbmRNaW4ob3BlblNldCwgZlNjb3JlKTtcbiAgICAgIHZhciBjTWluID0gY3kuZ2V0RWxlbWVudEJ5SWQoIG9wZW5TZXRbbWluUG9zXSApO1xuICAgICAgc3RlcHMrKztcblxuICAgICAgLy8gSWYgd2UndmUgZm91bmQgb3VyIGdvYWwsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgIGlmIChjTWluLmlkKCkgPT0gdGFyZ2V0LmlkKCkpIHtcbiAgICAgICAgdmFyIHJQYXRoID0gcmVjb25zdHJ1Y3RQYXRoKHNvdXJjZS5pZCgpLCB0YXJnZXQuaWQoKSwgY2FtZUZyb20sIFtdKTtcbiAgICAgICAgclBhdGgucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGZvdW5kIDogdHJ1ZSxcbiAgICAgICAgICBkaXN0YW5jZSA6IGdTY29yZVtjTWluLmlkKCldLFxuICAgICAgICAgIHBhdGggOiBlbGVzLnNwYXduKHJQYXRoKSxcbiAgICAgICAgICBzdGVwcyA6IHN0ZXBzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuICAgICAgY2xvc2VkU2V0LnB1c2goY01pbi5pZCgpKTtcbiAgICAgIC8vIFJlbW92ZSBjTWluIGZyb20gYm91bmRhcnkgbm9kZXNcbiAgICAgIG9wZW5TZXQuc3BsaWNlKG1pblBvcywgMSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBzY29yZXMgZm9yIG5laWdoYm9ycyBvZiBjTWluXG4gICAgICAvLyBUYWtlIGludG8gYWNjb3VudCBpZiBncmFwaCBpcyBkaXJlY3RlZCBvciBub3RcbiAgICAgIHZhciB2d0VkZ2VzID0gY01pbi5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgaWYoIGRpcmVjdGVkICl7IHZ3RWRnZXMgPSB2d0VkZ2VzLnN0ZEZpbHRlcihmdW5jdGlvbihlbGUpeyByZXR1cm4gZWxlLmRhdGEoJ3NvdXJjZScpID09PSBjTWluLmlkKCk7IH0pOyB9XG4gICAgICB2d0VkZ2VzID0gdndFZGdlcy5pbnRlcnNlY3QoZWRnZXMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldO1xuICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24obil7IHJldHVybiBuLmlkKCkgIT09IGNNaW4uaWQoKTsgfSkuaW50ZXJzZWN0KG5vZGVzKTtcblxuICAgICAgICAvLyBpZiBub2RlIGlzIGluIGNsb3NlZFNldCwgaWdub3JlIGl0XG4gICAgICAgIGlmIChjbG9zZWRTZXQuaW5kZXhPZih3LmlkKCkpICE9IC0xKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZXcgdGVudGF0aXZlIHNjb3JlIGZvciBub2RlIHdcbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluLmlkKCldICsgd2VpZ2h0Rm4uYXBwbHkoZSwgW2VdKTtcblxuICAgICAgICAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgIC8vIE9SXG4gICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcblxuICAgICAgICAvLyB3IG5vdCBpbiBvcGVuU2V0XG4gICAgICAgIGlmIChvcGVuU2V0LmluZGV4T2Yody5pZCgpKSA9PSAtMSkge1xuICAgICAgICAgIGdTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlO1xuICAgICAgICAgIGZTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgIG9wZW5TZXQucHVzaCh3LmlkKCkpOyAvLyBBZGQgbm9kZSB0byBvcGVuU2V0XG4gICAgICAgICAgY2FtZUZyb21bdy5pZCgpXSA9IGNNaW4uaWQoKTtcbiAgICAgICAgICBjYW1lRnJvbUVkZ2Vbdy5pZCgpXSA9IGUuaWQoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcbiAgICAgICAgaWYgKHRlbXBTY29yZSA8IGdTY29yZVt3LmlkKCldKSB7XG4gICAgICAgICAgZ1Njb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgY2FtZUZyb21bdy5pZCgpXSA9IGNNaW4uaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICB9IC8vIEVuZCBvZiBuZWlnaGJvcnMgdXBkYXRlXG5cbiAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcblxuICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgaGVyZSwgdGhlbiB3ZSd2ZSBub3QgcmVhY2hlZCBvdXIgZ29hbFxuICAgIHJldHVybiB7XG4gICAgICBmb3VuZCA6IGZhbHNlLFxuICAgICAgZGlzdGFuY2UgOiB1bmRlZmluZWQsXG4gICAgICBwYXRoIDogdW5kZWZpbmVkLFxuICAgICAgc3RlcHMgOiBzdGVwc1xuICAgIH07XG4gIH1cblxufSk7IC8vIGVsZXNmblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi8uLi9pcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBiZWxsbWFuRm9yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICBpZiAob3B0aW9ucy5yb290ICE9IG51bGwpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5yb290KSkge1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc291cmNlID0gb3B0aW9ucy5yb290WzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemF0aW9uc1xuICAgIHZhciBjb3N0ID0gW107XG4gICAgdmFyIHByZWRlY2Vzc29yID0gW107XG4gICAgdmFyIHByZWRFZGdlID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGlmIChub2Rlc1tpXS5pZCgpID09PSBzb3VyY2UuaWQoKSkge1xuICAgICAgICBjb3N0W2ldID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvc3RbaV0gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHByZWRlY2Vzc29yW2ldID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIEVkZ2VzIHJlbGF4YXRpb25cbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKykge1xuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0udGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseShlZGdlc1tlXSwgW2VkZ2VzW2VdXSk7XG5cbiAgICAgICAgdmFyIHRlbXAgPSBjb3N0W3NvdXJjZUluZGV4XSArIHdlaWdodDtcbiAgICAgICAgaWYgKHRlbXAgPCBjb3N0W3RhcmdldEluZGV4XSkge1xuICAgICAgICAgIGNvc3RbdGFyZ2V0SW5kZXhdID0gdGVtcDtcbiAgICAgICAgICBwcmVkZWNlc3Nvclt0YXJnZXRJbmRleF0gPSBzb3VyY2VJbmRleDtcbiAgICAgICAgICBwcmVkRWRnZVt0YXJnZXRJbmRleF0gPSBlZGdlc1tlXTtcbiAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG4gICAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgdGVtcCA9IGNvc3RbdGFyZ2V0SW5kZXhdICsgd2VpZ2h0O1xuICAgICAgICAgIGlmICh0ZW1wIDwgY29zdFtzb3VyY2VJbmRleF0pIHtcbiAgICAgICAgICAgIGNvc3Rbc291cmNlSW5kZXhdID0gdGVtcDtcbiAgICAgICAgICAgIHByZWRlY2Vzc29yW3NvdXJjZUluZGV4XSA9IHRhcmdldEluZGV4O1xuICAgICAgICAgICAgcHJlZEVkZ2Vbc291cmNlSW5kZXhdID0gZWRnZXNbZV07XG4gICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmbGFnKSB7XG4gICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKykge1xuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0udGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseShlZGdlc1tlXSwgW2VkZ2VzW2VdXSk7XG5cbiAgICAgICAgaWYgKGNvc3Rbc291cmNlSW5kZXhdICsgd2VpZ2h0IDwgY29zdFt0YXJnZXRJbmRleF0pIHtcbiAgICAgICAgICB1dGlsLmVycm9yKFwiR3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGUgZm9yIEJlbGxtYW4tRm9yZFwiKTtcbiAgICAgICAgICByZXR1cm4geyBwYXRoVG86IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgIGRpc3RhbmNlVG86IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IHRydWV9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgcmVzdWx0IG9iamVjdFxuICAgIHZhciBwb3NpdGlvbjJpZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgcG9zaXRpb24yaWQucHVzaChub2Rlc1tpXS5pZCgpKTtcbiAgICB9XG5cblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZVRvIDogZnVuY3Rpb24odG8pIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvc3RbaWQycG9zaXRpb25bdG9JZF1dO1xuICAgICAgfSxcblxuICAgICAgcGF0aFRvIDogZnVuY3Rpb24odG8pIHtcblxuICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24ocHJlZGVjZXNzb3IsIGZyb21Qb3MsIHRvUG9zLCBwb3NpdGlvbjJpZCwgYWN1bVBhdGgsIHByZWRFZGdlKSB7XG4gICAgICAgICAgZm9yKDs7KXtcbiAgICAgICAgICAgIC8vIEFkZCB0b0lkIHRvIHBhdGhcbiAgICAgICAgICAgIGFjdW1QYXRoLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKHBvc2l0aW9uMmlkW3RvUG9zXSkgKTtcbiAgICAgICAgICAgIGFjdW1QYXRoLnB1c2goIHByZWRFZGdlW3RvUG9zXSApO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVBvcyA9PT0gdG9Qb3MpIHtcbiAgICAgICAgICAgICAgLy8gcmVhY2hlZCBzdGFydGluZyBub2RlXG4gICAgICAgICAgICAgIHJldHVybiBhY3VtUGF0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm8gcGF0aCBleGlzdHMsIGRpc2NhcnQgYWN1bXVsYXRlZCBwYXRoIGFuZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICB2YXIgcHJlZFBvcyA9IHByZWRlY2Vzc29yW3RvUG9zXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZFBvcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b1BvcyA9IHByZWRQb3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gW107XG5cbiAgICAgICAgLy8gVGhpcyByZXR1cm5zIGEgcmV2ZXJzZWQgcGF0aFxuICAgICAgICB2YXIgcmVzID0gIHJlY29uc3RydWN0UGF0aEF1eChwcmVkZWNlc3NvcixcbiAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvbltzb3VyY2UuaWQoKV0sXG4gICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bdG9JZF0sXG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yaWQsXG4gICAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVkRWRnZSk7XG5cbiAgICAgICAgLy8gR2V0IGl0IGluIHRoZSBjb3JyZWN0IG9yZGVyIGFuZCByZXR1cm4gaXRcbiAgICAgICAgaWYgKHJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVzLnNwYXduKHJlcyk7XG4gICAgICB9LFxuXG4gICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBmYWxzZVxuICAgIH07XG5cbiAgICByZXR1cm4gcmVzO1xuXG4gIH0gLy8gYmVsbG1hbkZvcmRcblxufSk7IC8vIGVsZXNmblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vaXMnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gV2VpZ2h0IC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgdmFyIHdlaWdodGVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdlaWdodGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRGlyZWN0ZWQgLSBkZWZhdWx0IGZhbHNlXG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCAmJiBpcy5ib29sKG9wdGlvbnMuZGlyZWN0ZWQpKSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdHlJbnNlcnQgPSBmdW5jdGlvbiAocXVldWUsIGVsZSkge1xuICAgICAgcXVldWUudW5zaGlmdChlbGUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGRbcXVldWVbaV1dIDwgZFtxdWV1ZVtpICsgMV1dICYmIGkgPCBxdWV1ZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHRtcCA9IHF1ZXVlW2ldO1xuICAgICAgICBxdWV1ZVtpXSA9IHF1ZXVlW2kgKyAxXTtcbiAgICAgICAgcXVldWVbaSArIDFdID0gdG1wO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgLy8gc3RhcnRpbmdcbiAgICB2YXIgViA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgQSA9IHt9O1xuICAgIHZhciBDID0ge307XG5cbiAgICAvLyBBIGNvbnRhaW5zIHRoZSBuZWlnaGJvcmhvb2RzIG9mIGV2ZXJ5IG5vZGVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBBW1ZbaV0uaWQoKV0gPSBWW2ldLm91dGdvZXJzKFwibm9kZVwiKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFbVltpXS5pZCgpXSA9IFZbaV0ub3Blbk5laWdoYm9yaG9vZChcIm5vZGVcIik7IC8vIGdldCBuZWlnaGJvcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEMgY29udGFpbnMgdGhlIGJldHdlZW5uZXNzIHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKykge1xuICAgICAgQ1tWW2ldLmlkKCldID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IFYubGVuZ3RoOyBzKyspIHtcbiAgICAgIHZhciBTID0gW107IC8vIHN0YWNrXG4gICAgICB2YXIgUCA9IHt9O1xuICAgICAgdmFyIGcgPSB7fTtcbiAgICAgIHZhciBkID0ge307XG4gICAgICB2YXIgUSA9IFtdOyAvLyBxdWV1ZVxuXG4gICAgICAvLyBpbml0IGRpY3Rpb25hcmllc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIFBbVltpXS5pZCgpXSA9IFtdO1xuICAgICAgICBnW1ZbaV0uaWQoKV0gPSAwO1xuICAgICAgICBkW1ZbaV0uaWQoKV0gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB9XG5cbiAgICAgIGdbVltzXS5pZCgpXSA9IDE7IC8vIHNpZ21hXG4gICAgICBkW1Zbc10uaWQoKV0gPSAwOyAvLyBkaXN0YW5jZSB0byBzXG5cbiAgICAgIFEudW5zaGlmdChWW3NdLmlkKCkpO1xuXG4gICAgICB3aGlsZSAoUS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB2ID0gUS5wb3AoKTtcbiAgICAgICAgUy5wdXNoKHYpO1xuICAgICAgICBpZiAod2VpZ2h0ZWQpIHtcbiAgICAgICAgICBBW3ZdLmZvckVhY2goZnVuY3Rpb24gKHcpIHtcbiAgICAgICAgICAgIGlmIChjeS4kKCcjJyArIHYpLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB2YXIgZWRnZSA9IGN5LiQoJyMnICsgdikuZWRnZXNUbyh3KVswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBlZGdlID0gdy5lZGdlc1RvKCcjJyArIHYpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG5cbiAgICAgICAgICAgIGlmIChkW3cuaWQoKV0gPiBkW3ZdICsgZWRnZVdlaWdodCkge1xuICAgICAgICAgICAgICBkW3cuaWQoKV0gPSBkW3ZdICsgZWRnZVdlaWdodDtcbiAgICAgICAgICAgICAgaWYgKFEuaW5kZXhPZih3LmlkKCkpIDwgMCkgeyAvL2lmIHcgaXMgbm90IGluIFFcbiAgICAgICAgICAgICAgICBwcmlvcml0eUluc2VydChRLCB3LmlkKCkpO1xuICAgICAgICAgICAgICB9IGVsc2UgeyAvLyB1cGRhdGUgcG9zaXRpb24gaWYgdyBpcyBpbiBRXG4gICAgICAgICAgICAgICAgUS5zcGxpY2UoUS5pbmRleE9mKHcuaWQoKSksIDEpO1xuICAgICAgICAgICAgICAgIHByaW9yaXR5SW5zZXJ0KFEsIHcuaWQoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZ1t3LmlkKCldID0gMDtcbiAgICAgICAgICAgICAgUFt3LmlkKCldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZFt3LmlkKCldID09IGRbdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgIGdbdy5pZCgpXSA9IGdbdy5pZCgpXSArIGdbdl07XG4gICAgICAgICAgICAgIFBbdy5pZCgpXS5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFbdl0uZm9yRWFjaChmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgaWYgKGRbdy5pZCgpXSA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgUS51bnNoaWZ0KHcuaWQoKSk7XG4gICAgICAgICAgICAgIGRbdy5pZCgpXSA9IGRbdl0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbdy5pZCgpXSA9PSBkW3ZdICsgMSkge1xuICAgICAgICAgICAgICBnW3cuaWQoKV0gPSBnW3cuaWQoKV0gKyBnW3ZdO1xuICAgICAgICAgICAgICBQW3cuaWQoKV0ucHVzaCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZSA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVbVltpXS5pZCgpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHcgPSBTLnBvcCgpO1xuICAgICAgICBQW3ddLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICBlW3ZdID0gZVt2XSArIChnW3ZdIC8gZ1t3XSkgKiAoMSArIGVbd10pO1xuICAgICAgICAgIGlmICh3ICE9IFZbc10uaWQoKSlcbiAgICAgICAgICAgIENbd10gPSBDW3ddICsgZVt3XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1heCA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIEMpIHtcbiAgICAgIGlmIChtYXggPCBDW2tleV0pXG4gICAgICAgIG1heCA9IENba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgYmV0d2Vlbm5lc3M6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChpcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ1tub2RlXTtcbiAgICAgIH0sXG5cbiAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBDW25vZGVdIC8gbWF4O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhbGlhc1xuICAgIHJldC5iZXR3ZWVubmVzc05vcm1hbGlzZWQgPSByZXQuYmV0d2Vlbm5lc3NOb3JtYWxpemVkO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSAvLyBiZXR3ZWVubmVzc0NlbnRyYWxpdHlcblxufSk7IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uYmMgPSBlbGVzZm4uYmV0d2Vlbm5lc3NDZW50cmFsaXR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vaXMnKTtcbnZhciBIZWFwID0gcmVxdWlyZSgnLi4vLi4vaGVhcCcpO1xuXG52YXIgZGVmaW5lU2VhcmNoID0gZnVuY3Rpb24oIHBhcmFtcyApe1xuICBwYXJhbXMgPSB7XG4gICAgYmZzOiBwYXJhbXMuYmZzIHx8ICFwYXJhbXMuZGZzLFxuICAgIGRmczogcGFyYW1zLmRmcyB8fCAhcGFyYW1zLmJmc1xuICB9O1xuXG4gIC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWFcbiAgcmV0dXJuIGZ1bmN0aW9uIHNlYXJjaEZuKCByb290cywgZm4sIGRpcmVjdGVkICl7XG4gICAgdmFyIG9wdGlvbnM7XG4gICAgdmFyIHN0ZDtcbiAgICB2YXIgdGhpc0FyZztcbiAgICBpZiggaXMucGxhaW5PYmplY3Qocm9vdHMpICYmICFpcy5lbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSApe1xuICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzIHx8IG9wdGlvbnMucm9vdDtcbiAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIHN0ZCA9IG9wdGlvbnMuc3RkO1xuICAgICAgdGhpc0FyZyA9IG9wdGlvbnMudGhpc0FyZztcbiAgICB9XG5cbiAgICBkaXJlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIWlzLmZuKGZuKSA/IGZuIDogZGlyZWN0ZWQ7XG4gICAgZm4gPSBpcy5mbihmbikgPyBmbiA6IGZ1bmN0aW9uKCl7fTtcblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHYgPSByb290cyA9IGlzLnN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICB2YXIgUSA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgIHZhciBWID0ge307XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBmb3VuZDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuXG4gICAgLy8gZW5xdWV1ZSB2XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrICl7XG4gICAgICBpZiggdltpXS5pc05vZGUoKSApe1xuICAgICAgICBRLnVuc2hpZnQoIHZbaV0gKTtcblxuICAgICAgICBpZiggcGFyYW1zLmJmcyApe1xuICAgICAgICAgIFZbIHZbaV0uaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHZbaV0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkMmRlcHRoWyB2W2ldLmlkKCkgXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUoIFEubGVuZ3RoICE9PSAwICl7XG4gICAgICB2YXIgdiA9IHBhcmFtcy5iZnMgPyBRLnNoaWZ0KCkgOiBRLnBvcCgpO1xuXG4gICAgICBpZiggcGFyYW1zLmRmcyApe1xuICAgICAgICBpZiggVlsgdi5pZCgpIF0gKXsgY29udGludWU7IH1cblxuICAgICAgICBWWyB2LmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdiApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgdi5pZCgpIF07XG4gICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVsgdi5pZCgpIF07XG4gICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogcHJldkVkZ2UuY29ubmVjdGVkTm9kZXMoKS5ub3QoIHYgKVswXTtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmKCBzdGQgKXtcbiAgICAgICAgcmV0ID0gZm4uY2FsbCh0aGlzQXJnLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gZm4uY2FsbCh2LCBqKyssIGRlcHRoLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiggcmV0ID09PSB0cnVlICl7XG4gICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoZGlyZWN0ZWQgPyBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhKCdzb3VyY2UnKSA9PT0gdi5pZCgpOyB9IDogdW5kZWZpbmVkKS5pbnRlcnNlY3QoIGVkZ2VzICk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldO1xuICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaWQoKSAhPT0gdi5pZCgpOyB9KS5pbnRlcnNlY3QoIG5vZGVzICk7XG5cbiAgICAgICAgaWYoIHcubGVuZ3RoICE9PSAwICYmICFWWyB3LmlkKCkgXSApe1xuICAgICAgICAgIHcgPSB3WzBdO1xuXG4gICAgICAgICAgUS5wdXNoKCB3ICk7XG5cbiAgICAgICAgICBpZiggcGFyYW1zLmJmcyApe1xuICAgICAgICAgICAgVlsgdy5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB3ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29ubmVjdGVkQnlbIHcuaWQoKSBdID0gZTtcblxuICAgICAgICAgIGlkMmRlcHRoWyB3LmlkKCkgXSA9IGlkMmRlcHRoWyB2LmlkKCkgXSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBjb25uZWN0ZWRFbGVzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzW2ldO1xuICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRCeVsgbm9kZS5pZCgpIF07XG5cbiAgICAgIGlmKCBlZGdlICl7XG4gICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIG5vZGUgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogY3kuY29sbGVjdGlvbiggY29ubmVjdGVkRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgZm91bmQ6IGN5LmNvbGxlY3Rpb24oIGZvdW5kIClcbiAgICB9O1xuICB9O1xufTtcblxuLy8gc2VhcmNoLCBzcGFubmluZyB0cmVlcywgZXRjXG52YXIgZWxlc2ZuID0gKHtcblxuICBicmVhZHRoRmlyc3RTZWFyY2g6IGRlZmluZVNlYXJjaCh7IGJmczogdHJ1ZSB9KSxcbiAgZGVwdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHsgZGZzOiB0cnVlIH0pLFxuXG4gIC8vIGtydXNrYWwncyBhbGdvcml0aG0gKGZpbmRzIG1pbiBzcGFubmluZyB0cmVlLCBhc3N1bWluZyB1bmRpcmVjdGVkIGdyYXBoKVxuICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAga3J1c2thbDogZnVuY3Rpb24oIHdlaWdodEZuICl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgd2VpZ2h0Rm4gPSBpcy5mbih3ZWlnaHRGbikgPyB3ZWlnaHRGbiA6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9OyAvLyBpZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG5cbiAgICBmdW5jdGlvbiBmaW5kU2V0KGVsZSl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlcyA9IGZvcmVzdFtpXTtcblxuICAgICAgICBpZiggZWxlcy5hbnlTYW1lKGVsZSkgKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlczogZWxlcyxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBBID0gY3kuY29sbGVjdGlvbihjeSwgW10pO1xuICAgIHZhciBmb3Jlc3QgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICBmb3Jlc3QucHVzaCggbm9kZXNbaV0uY29sbGVjdGlvbigpICk7XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgIHZhciBTID0gZWRnZXMudG9BcnJheSgpLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICB2YXIgd2VpZ2h0QSA9IHdlaWdodEZuLmNhbGwoYSwgYSk7XG4gICAgICB2YXIgd2VpZ2h0QiA9IHdlaWdodEZuLmNhbGwoYiwgYik7XG5cbiAgICAgIHJldHVybiB3ZWlnaHRBIC0gd2VpZ2h0QjtcbiAgICB9KTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBTLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBlZGdlID0gU1tpXTtcbiAgICAgIHZhciB1ID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB2ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICAgIHZhciBzZXRVID0gZmluZFNldCh1KTtcbiAgICAgIHZhciBzZXRWID0gZmluZFNldCh2KTtcblxuICAgICAgaWYoIHNldFUuaW5kZXggIT09IHNldFYuaW5kZXggKXtcbiAgICAgICAgQSA9IEEuYWRkKCBlZGdlICk7XG5cbiAgICAgICAgLy8gY29tYmluZSBmb3Jlc3RzIGZvciB1IGFuZCB2XG4gICAgICAgIGZvcmVzdFsgc2V0VS5pbmRleCBdID0gc2V0VS5lbGVzLmFkZCggc2V0Vi5lbGVzICk7XG4gICAgICAgIGZvcmVzdC5zcGxpY2UoIHNldFYuaW5kZXgsIDEgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXMuYWRkKCBBICk7XG5cbiAgfSxcblxuICBkaWprc3RyYTogZnVuY3Rpb24oIHJvb3QsIHdlaWdodEZuLCBkaXJlY3RlZCApe1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmKCBpcy5wbGFpbk9iamVjdChyb290KSAmJiAhaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290KSApe1xuICAgICAgb3B0aW9ucyA9IHJvb3Q7XG4gICAgICByb290ID0gb3B0aW9ucy5yb290O1xuICAgICAgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHdlaWdodEZuID0gaXMuZm4od2VpZ2h0Rm4pID8gd2VpZ2h0Rm4gOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfTsgLy8gaWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuXG4gICAgdmFyIHNvdXJjZSA9IGlzLnN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdIDogcm9vdFswXTtcbiAgICB2YXIgZGlzdCA9IHt9O1xuICAgIHZhciBwcmV2ID0ge307XG4gICAgdmFyIGtub3duRGlzdCA9IHt9O1xuXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLmZpbHRlcihmdW5jdGlvbigpeyByZXR1cm4gIXRoaXMuaXNMb29wKCk7IH0pO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIHZhciBnZXREaXN0ID0gZnVuY3Rpb24obm9kZSl7XG4gICAgICByZXR1cm4gZGlzdFsgbm9kZS5pZCgpIF07XG4gICAgfTtcblxuICAgIHZhciBzZXREaXN0ID0gZnVuY3Rpb24obm9kZSwgZCl7XG4gICAgICBkaXN0WyBub2RlLmlkKCkgXSA9IGQ7XG5cbiAgICAgIFEudXBkYXRlSXRlbSggbm9kZSApO1xuICAgIH07XG5cbiAgICB2YXIgUSA9IG5ldyBIZWFwKGZ1bmN0aW9uKCBhLCBiICl7XG4gICAgICByZXR1cm4gZ2V0RGlzdChhKSAtIGdldERpc3QoYik7XG4gICAgfSk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBkaXN0WyBub2RlLmlkKCkgXSA9IG5vZGUuc2FtZSggc291cmNlICkgPyAwIDogSW5maW5pdHk7XG4gICAgICBRLnB1c2goIG5vZGUgKTtcbiAgICB9XG5cbiAgICB2YXIgZGlzdEJldHdlZW4gPSBmdW5jdGlvbih1LCB2KXtcbiAgICAgIHZhciB1dnMgPSAoIGRpcmVjdGVkID8gdS5lZGdlc1RvKHYpIDogdS5lZGdlc1dpdGgodikgKS5pbnRlcnNlY3QoZWRnZXMpO1xuICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdXZzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gdXZzW2ldO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2UsIFtlZGdlXSApO1xuXG4gICAgICAgIGlmKCB3ZWlnaHQgPCBzbWFsbGVzdERpc3RhbmNlIHx8ICFzbWFsbGVzdEVkZ2UgKXtcbiAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gd2VpZ2h0O1xuICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWRnZTogc21hbGxlc3RFZGdlLFxuICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICB9O1xuICAgIH07XG5cbiAgICB3aGlsZSggUS5zaXplKCkgPiAwICl7XG4gICAgICB2YXIgdSA9IFEucG9wKCk7XG4gICAgICB2YXIgc21hbGxldHNEaXN0ID0gZ2V0RGlzdCh1KTtcbiAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG5cbiAgICAgIGtub3duRGlzdFt1aWRdID0gc21hbGxldHNEaXN0O1xuXG4gICAgICBpZiggc21hbGxldHNEaXN0ID09PSBNYXRoLkluZmluaXRlICl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVpZ2hib3JzID0gdS5uZWlnaGJvcmhvb2QoKS5pbnRlcnNlY3Qobm9kZXMpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHYgPSBuZWlnaGJvcnNbaV07XG4gICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuXG4gICAgICAgIHZhciBhbHQgPSBzbWFsbGV0c0Rpc3QgKyB2RGlzdC5kaXN0O1xuXG4gICAgICAgIGlmKCBhbHQgPCBnZXREaXN0KHYpICl7XG4gICAgICAgICAgc2V0RGlzdCh2LCBhbHQpO1xuXG4gICAgICAgICAgcHJldlsgdmlkIF0gPSB7XG4gICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgZWRnZTogdkRpc3QuZWRnZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yXG4gICAgfSAvLyB3aGlsZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICB2YXIgdGFyZ2V0ID0gaXMuc3RyaW5nKG5vZGUpID8gbm9kZXMuZmlsdGVyKG5vZGUpWzBdIDogbm9kZVswXTtcblxuICAgICAgICByZXR1cm4ga25vd25EaXN0WyB0YXJnZXQuaWQoKSBdO1xuICAgICAgfSxcblxuICAgICAgcGF0aFRvOiBmdW5jdGlvbihub2RlKXtcbiAgICAgICAgdmFyIHRhcmdldCA9IGlzLnN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKVswXSA6IG5vZGVbMF07XG4gICAgICAgIHZhciBTID0gW107XG4gICAgICAgIHZhciB1ID0gdGFyZ2V0O1xuXG4gICAgICAgIGlmKCB0YXJnZXQubGVuZ3RoID4gMCApe1xuICAgICAgICAgIFMudW5zaGlmdCggdGFyZ2V0ICk7XG5cbiAgICAgICAgICB3aGlsZSggcHJldlsgdS5pZCgpIF0gKXtcbiAgICAgICAgICAgIHZhciBwID0gcHJldlsgdS5pZCgpIF07XG5cbiAgICAgICAgICAgIFMudW5zaGlmdCggcC5lZGdlICk7XG4gICAgICAgICAgICBTLnVuc2hpZnQoIHAubm9kZSApO1xuXG4gICAgICAgICAgICB1ID0gcC5ub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCBTICk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbmVsZXNmbi5iZnMgPSBlbGVzZm4uYnJlYWR0aEZpcnN0U2VhcmNoO1xuZWxlc2ZuLmRmcyA9IGVsZXNmbi5kZXB0aEZpcnN0U2VhcmNoO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vaXMnKTtcblxudmFyIGVsZXNmbiA9ICh7XG5cbiAgY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICB2YXIgaGFybW9uaWMgPSBvcHRpb25zLmhhcm1vbmljO1xuICAgIGlmKCBoYXJtb25pYyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBoYXJtb25pYyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGNsb3NlbmVzc2VzID0ge307XG4gICAgdmFyIG1heENsb3NlbmVzcyA9IDA7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIHZhciBmdyA9IHRoaXMuZmxveWRXYXJzaGFsbCh7IHdlaWdodDogb3B0aW9ucy53ZWlnaHQsIGRpcmVjdGVkOiBvcHRpb25zLmRpcmVjdGVkIH0pO1xuXG4gICAgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgIHZhciBjdXJyQ2xvc2VuZXNzID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKGkgIT0gaikge1xuICAgICAgICAgIHZhciBkID0gZncuZGlzdGFuY2Uobm9kZXNbaV0sIG5vZGVzW2pdKTtcblxuICAgICAgICAgIGlmKCBoYXJtb25pYyApe1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSAxIC8gZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIWhhcm1vbmljICl7XG4gICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cblxuICAgICAgaWYgKG1heENsb3NlbmVzcyA8IGN1cnJDbG9zZW5lc3Mpe1xuICAgICAgICBtYXhDbG9zZW5lc3MgPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICBjbG9zZW5lc3Nlc1tub2Rlc1tpXS5pZCgpXSA9IGN1cnJDbG9zZW5lc3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsb3NlbmVzczogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbG9zZW5lc3Nlc1tub2RlXSAvIG1heENsb3NlbmVzcztcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBjbG9zZW5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICBpZiAob3B0aW9ucy5yb290ICE9IG51bGwpIHtcbiAgICAgIGlmIChpcy5zdHJpbmcob3B0aW9ucy5yb290KSkge1xuICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJvb3QgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gd2VpZ2h0IC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHdlaWdodCA9IGZ1bmN0aW9uKCl7cmV0dXJuIDE7fTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCAmJiBpcy5ib29sKG9wdGlvbnMuZGlyZWN0ZWQpKSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaGFybW9uaWMgPSBvcHRpb25zLmhhcm1vbmljO1xuICAgIGlmKCBoYXJtb25pYyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBoYXJtb25pYyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG4gICAgdmFyIGRpamtzdHJhID0gdGhpcy5kaWprc3RyYSh7XG4gICAgICByb290OiByb290LFxuICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICBkaXJlY3RlZDogZGlyZWN0ZWRcbiAgICB9KTtcbiAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG5cbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyl7XG4gICAgICBpZiAobm9kZXNbaV0uaWQoKSAhPSByb290LmlkKCkpe1xuICAgICAgICB2YXIgZCA9IGRpamtzdHJhLmRpc3RhbmNlVG8obm9kZXNbaV0pO1xuXG4gICAgICAgIGlmKCBoYXJtb25pYyApe1xuICAgICAgICAgIHRvdGFsRGlzdGFuY2UgKz0gMSAvIGQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhcm1vbmljID8gdG90YWxEaXN0YW5jZSA6IDEgLyB0b3RhbERpc3RhbmNlO1xuICB9IC8vIGNsb3NlbmVzc0NlbnRyYWxpdHlcblxufSk7IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uY2MgPSBlbGVzZm4uY2xvc2VuZXNzQ2VudHJhbGl0eTtcbmVsZXNmbi5jY24gPSBlbGVzZm4uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi8uLi9pcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICB2YXIgZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heERlZ3JlZSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcbiAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkodXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtyb290OiBub2RlfSkpO1xuICAgICAgICBpZiAobWF4RGVncmVlIDwgY3VyckRlZ3JlZS5kZWdyZWUpXG4gICAgICAgICAgbWF4RGVncmVlID0gY3VyckRlZ3JlZS5kZWdyZWU7XG5cbiAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGVncmVlc1tub2RlXSAvIG1heERlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG91dGRlZ3JlZXMgPSB7fTtcbiAgICAgIHZhciBtYXhJbmRlZ3JlZSA9IDA7XG4gICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eVxuICAgICAgICB2YXIgY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eSh1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge3Jvb3Q6IG5vZGV9KSk7XG5cbiAgICAgICAgaWYgKG1heEluZGVncmVlIDwgY3VyckRlZ3JlZS5pbmRlZ3JlZSlcbiAgICAgICAgICBtYXhJbmRlZ3JlZSA9IGN1cnJEZWdyZWUuaW5kZWdyZWU7XG5cbiAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA8IGN1cnJEZWdyZWUub3V0ZGVncmVlKVxuICAgICAgICAgIG1heE91dGRlZ3JlZSA9IGN1cnJEZWdyZWUub3V0ZGVncmVlO1xuXG4gICAgICAgIGluZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5pbmRlZ3JlZTtcbiAgICAgICAgb3V0ZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGVncmVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChpcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmRlZ3JlZXNbbm9kZV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIGlmIChpcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvdXRkZWdyZWVzW25vZGVdIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICB9XG5cbiAgICAgIH07XG4gICAgfVxuXG4gIH0sIC8vIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkXG5cbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIE9wc2FobCdzIHBhcGVyXG4gIC8vIFwiTm9kZSBjZW50cmFsaXR5IGluIHdlaWdodGVkIG5ldHdvcmtzOiBHZW5lcmFsaXppbmcgZGVncmVlIGFuZCBzaG9ydGVzdCBwYXRoc1wiXG4gIC8vIGNoZWNrIHRoZSBoZWFkaW5nIDIgXCJEZWdyZWVcIlxuICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNhbGxpbmdFbGVzID0gdGhpcztcblxuICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnJvb3QgIT0gbnVsbCkge1xuICAgICAgdmFyIHJvb3QgPSBpcy5zdHJpbmcob3B0aW9ucy5yb290KSA/IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF0gOiBvcHRpb25zLnJvb3RbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gd2VpZ2h0IC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGFscGhhIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy5hbHBoYSAhPSBudWxsICYmIGlzLm51bWJlcihvcHRpb25zLmFscGhhKSkge1xuICAgICAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxwaGEgPSAwO1xuICAgIH1cblxuXG4gICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgdmFyIGNvbm5FZGdlcyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIgayA9IGNvbm5FZGdlcy5sZW5ndGg7XG4gICAgICB2YXIgcyA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25uRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uRWRnZXNbaV07XG4gICAgICAgIHMgKz0gd2VpZ2h0Rm4uYXBwbHkoZWRnZSwgW2VkZ2VdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBNYXRoLnBvdyhrLCAxIC0gYWxwaGEpICogTWF0aC5wb3cocywgYWxwaGEpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5jb21pbmcgPSByb290LmNvbm5lY3RlZEVkZ2VzKCdlZGdlW3RhcmdldCA9IFwiJyArIHJvb3QuaWQoKSArICdcIl0nKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIgb3V0Z29pbmcgPSByb290LmNvbm5lY3RlZEVkZ2VzKCdlZGdlW3NvdXJjZSA9IFwiJyArIHJvb3QuaWQoKSArICdcIl0nKS5pbnRlcnNlY3Rpb24oIGNhbGxpbmdFbGVzICk7XG4gICAgICB2YXIga19pbiA9IGluY29taW5nLmxlbmd0aDtcbiAgICAgIHZhciBrX291dCA9IG91dGdvaW5nLmxlbmd0aDtcbiAgICAgIHZhciBzX2luID0gMDtcbiAgICAgIHZhciBzX291dCA9IDA7XG5cbiAgICAgIC8vIE5vdywgc3VtIGluY29taW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNvbWluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGluY29taW5nW2ldO1xuICAgICAgICBzX2luICs9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRnb2luZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IG91dGdvaW5nW2ldO1xuICAgICAgICBzX291dCArPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgb3V0ZGVncmVlOiBNYXRoLnBvdyhrX291dCwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfb3V0LCBhbHBoYSlcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxufSk7IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG5lbGVzZm4uZGMgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eTtcbmVsZXNmbi5kY24gPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQgPSBlbGVzZm4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi8uLi9pcycpO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgZmxveWRXYXJzaGFsbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBpcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICB9XG5cbiAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgdmFyIGRpc3QgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIHZhciBuZXdSb3cgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICBuZXdSb3dbal0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jvd1tqXSA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkaXN0LnB1c2gobmV3Um93KTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIG1hdHJpeCB1c2VkIGZvciBwYXRoIHJlY29uc3RydWN0aW9uXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICB2YXIgbmV4dCA9IFtdO1xuICAgIHZhciBlZGdlTmV4dCA9IFtdO1xuXG4gICAgdmFyIGluaXRNYXRyaXggPSBmdW5jdGlvbihuZXh0KXtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICB2YXIgbmV3Um93ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgbmV3Um93W2pdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIG5leHQucHVzaChuZXdSb3cpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0TWF0cml4KG5leHQpO1xuICAgIGluaXRNYXRyaXgoZWRnZU5leHQpO1xuXG4gICAgLy8gUHJvY2VzcyBlZGdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnRhcmdldCgpLmlkKCldO1xuICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2ldLCBbZWRnZXNbaV1dKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuICAgICAgaWYgKGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA+IHdlaWdodCkge1xuICAgICAgICBkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB3ZWlnaHQ7XG4gICAgICAgIG5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHRhcmdldEluZGV4O1xuICAgICAgICBlZGdlTmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gZWRnZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VzXG4gICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0udGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZXNbaV0sIFtlZGdlc1tpXV0pO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgICAgaWYgKGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA+IHdlaWdodCkge1xuICAgICAgICAgIGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHdlaWdodDtcbiAgICAgICAgICBuZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICBlZGdlTmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gZWRnZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICBpZiAoZGlzdFtpXVtrXSArIGRpc3Rba11bal0gPCBkaXN0W2ldW2pdKSB7XG4gICAgICAgICAgICBkaXN0W2ldW2pdID0gZGlzdFtpXVtrXSArIGRpc3Rba11bal07XG4gICAgICAgICAgICBuZXh0W2ldW2pdID0gbmV4dFtpXVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCdWlsZCByZXN1bHQgb2JqZWN0XG4gICAgdmFyIHBvc2l0aW9uMmlkID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBwb3NpdGlvbjJpZC5wdXNoKG5vZGVzW2ldLmlkKCkpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyhmcm9tKSkge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgZnJvbUlkID0gKGN5LmZpbHRlcihmcm9tKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciBmcm9tSWQgPSBmcm9tLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlzdFtpZDJwb3NpdGlvbltmcm9tSWRdXVtpZDJwb3NpdGlvblt0b0lkXV07XG4gICAgICB9LFxuXG4gICAgICBwYXRoOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG5leHQsIHBvc2l0aW9uMmlkLCBlZGdlTmV4dCkge1xuICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgcmV0dXJuIGN5LmdldEVsZW1lbnRCeUlkKCBwb3NpdGlvbjJpZFtmcm9tXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dFtmcm9tXVt0b10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGF0aCA9IFsgY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbZnJvbV0pIF07XG4gICAgICAgICAgdmFyIHByZXYgPSBmcm9tO1xuICAgICAgICAgIHdoaWxlIChmcm9tICE9PSB0bykge1xuICAgICAgICAgICAgcHJldiA9IGZyb207XG4gICAgICAgICAgICBmcm9tID0gbmV4dFtmcm9tXVt0b107XG5cbiAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZU5leHRbcHJldl1bZnJvbV07XG4gICAgICAgICAgICBwYXRoLnB1c2goIGVkZ2UgKTtcblxuICAgICAgICAgICAgcGF0aC5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChwb3NpdGlvbjJpZFtmcm9tXSkgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGlzLnN0cmluZyhmcm9tKSkge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICB2YXIgZnJvbUlkID0gKGN5LmZpbHRlcihmcm9tKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgIHZhciBmcm9tSWQgPSBmcm9tLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0aEFyciA9IHJlY29uc3RydWN0UGF0aEF1eChpZDJwb3NpdGlvbltmcm9tSWRdLFxuICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uW3RvSWRdLFxuICAgICAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yaWQsXG4gICAgICAgICAgICAgICAgICAgICAgZWRnZU5leHQpO1xuXG4gICAgICAgIHJldHVybiBjeS5jb2xsZWN0aW9uKCBwYXRoQXJyICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiByZXM7XG5cbiAgfSAvLyBmbG95ZFdhcnNoYWxsXG5cbn0pOyAvLyBlbGVzZm5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbltcbiAgcmVxdWlyZSgnLi9iZnMtZGZzJyksXG4gIHJlcXVpcmUoJy4vYS1zdGFyJyksXG4gIHJlcXVpcmUoJy4vZmxveWQtd2Fyc2hhbGwnKSxcbiAgcmVxdWlyZSgnLi9iZWxsbWFuLWZvcmQnKSxcbiAgcmVxdWlyZSgnLi9rZXJnZXItc3RlaW4nKSxcbiAgcmVxdWlyZSgnLi9wYWdlLXJhbmsnKSxcbiAgcmVxdWlyZSgnLi9kZWdyZWUtY2VudHJhbGl0eScpLFxuICByZXF1aXJlKCcuL2Nsb3NlbmVzcy1jZW50cmFsaXR5JyksXG4gIHJlcXVpcmUoJy4vYmV0d2Vlbm5lc3MtY2VudHJhbGl0eScpXG5dLmZvckVhY2goZnVuY3Rpb24oIHByb3BzICl7XG4gIHV0aWwuZXh0ZW5kKCBlbGVzZm4sIHByb3BzICk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyBDb21wdXRlcyB0aGUgbWluaW11bSBjdXQgb2YgYW4gdW5kaXJlY3RlZCBncmFwaFxuICAvLyBSZXR1cm5zIHRoZSBjb3JyZWN0IGFuc3dlciB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbiAga2FyZ2VyU3RlaW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEZ1bmN0aW9uIHdoaWNoIGNvbGFwc2VzIDIgKG1ldGEpIG5vZGVzIGludG8gb25lXG4gICAgLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbiAgICAvLyBSZWNlaXZlcyBhcyBhIHBhcmFtYXRlciB0aGUgZWRnZSB3aGljaCBjYXVzZXMgdGhlIGNvbGxhcHNlXG4gICAgdmFyIGNvbGFwc2UgPSBmdW5jdGlvbihlZGdlSW5kZXgsIG5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKSB7XG4gICAgICB2YXIgZWRnZUluZm8gPSByZW1haW5pbmdFZGdlc1tlZGdlSW5kZXhdO1xuICAgICAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gICAgICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgICAgIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFtzb3VyY2VJbl07XG4gICAgICB2YXIgcGFydGl0aW9uMiA9IG5vZGVNYXBbdGFyZ2V0SW5dO1xuXG4gICAgICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuICAgICAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgaWYgKG5vZGVNYXBbZWRnZVsxXV0gPT09IHBhcnRpdGlvbjEgJiYgbm9kZU1hcFtlZGdlWzJdXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZU1hcFtlZGdlWzFdXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwW2VkZ2VbMl1dID09PSBwYXJ0aXRpb24xKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IG5ld0VkZ2VzW2ldO1xuICAgICAgICBpZiAoZWRnZVsxXSA9PT0gcGFydGl0aW9uMikgeyAvLyBDaGVjayBzb3VyY2VcbiAgICAgICAgICBuZXdFZGdlc1tpXSA9IGVkZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgbmV3RWRnZXNbaV1bMV0gPSBwYXJ0aXRpb24xO1xuICAgICAgICB9IGVsc2UgaWYgKGVkZ2VbMl0gPT09IHBhcnRpdGlvbjIpIHsgLy8gQ2hlY2sgdGFyZ2V0XG4gICAgICAgICAgbmV3RWRnZXNbaV0gPSBlZGdlLnNsaWNlKDApO1xuICAgICAgICAgIG5ld0VkZ2VzW2ldWzJdID0gcGFydGl0aW9uMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNb3ZlIGFsbCBub2RlcyBmcm9tIHBhcnRpdGlvbjIgdG8gcGFydGl0aW9uMVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlTWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlTWFwW2ldID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAgICAgbm9kZU1hcFtpXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0VkZ2VzO1xuICAgIH07XG5cblxuICAgIC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuICAgIHZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24obWV0YU5vZGVNYXAsXG4gICAgICAgICAgICAgICAgICAgcmVtYWluaW5nRWRnZXMsXG4gICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICBzaXplTGltaXQpIHtcbiAgICAgIC8vIFN0b3AgY29uZGl0aW9uXG4gICAgICBpZiAoc2l6ZSA8PSBzaXplTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0VkZ2VzO1xuICAgICAgfVxuXG4gICAgICAvLyBDaG9vc2UgYW4gZWRnZSByYW5kb21seVxuICAgICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiByZW1haW5pbmdFZGdlcy5sZW5ndGgpKTtcblxuICAgICAgLy8gQ29sYXBzZSBncmFwaCBiYXNlZCBvbiBlZGdlXG4gICAgICB2YXIgbmV3RWRnZXMgPSBjb2xhcHNlKGVkZ2VJbmRleCwgbWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKTtcblxuICAgICAgcmV0dXJuIGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsXG4gICAgICAgICAgICAgICAgIG5ld0VkZ2VzLFxuICAgICAgICAgICAgICAgICBzaXplIC0gMSxcbiAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0KTtcbiAgICB9O1xuXG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKGUpeyByZXR1cm4gIWUuaXNMb29wKCk7IH0pO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuICAgIHZhciBudW1JdGVyID0gTWF0aC5jZWlsKE1hdGgucG93KE1hdGgubG9nKG51bU5vZGVzKSAvIE1hdGguTE4yLCAyKSk7XG4gICAgdmFyIHN0b3BTaXplID0gTWF0aC5mbG9vcihudW1Ob2RlcyAvIE1hdGguc3FydCgyKSk7XG5cbiAgICBpZiAobnVtTm9kZXMgPCAyKSB7XG4gICAgICB1dGlsLmVycm9yKFwiQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlci1TdGVpbiBhbGdvcml0aG1cIik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gTm93IHN0b3JlIGVkZ2UgZGVzdGluYXRpb24gYXMgaW5kZXhlc1xuICAgIC8vIEZvcm1hdCBmb3IgZWFjaCBlZGdlIChlZGdlIGluZGV4LCBzb3VyY2Ugbm9kZSBpbmRleCwgdGFyZ2V0IG5vZGUgaW5kZXgpXG4gICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgZWRnZUluZGV4ZXMucHVzaChbaSwgaWQycG9zaXRpb25bZS5zb3VyY2UoKS5pZCgpXSwgaWQycG9zaXRpb25bZS50YXJnZXQoKS5pZCgpXV0pO1xuICAgIH1cblxuICAgIC8vIFdlIHdpbGwgc3RvcmUgdGhlIGJlc3QgY3V0IGZvdW5kIGhlcmVcbiAgICB2YXIgbWluQ3V0U2l6ZSA9IEluZmluaXR5O1xuICAgIHZhciBtaW5DdXQ7XG5cbiAgICAvLyBJbml0aWFsIG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICB2YXIgb3JpZ2luYWxNZXRhTm9kZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgb3JpZ2luYWxNZXRhTm9kZS5wdXNoKGkpO1xuICAgIH1cblxuICAgIC8vIE1haW4gbG9vcFxuICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDw9IG51bUl0ZXI7IGl0ZXIrKykge1xuICAgICAgLy8gQ3JlYXRlIG5ldyBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICB2YXIgbWV0YU5vZGVNYXAgPSBvcmlnaW5hbE1ldGFOb2RlLnNsaWNlKDApO1xuXG4gICAgICAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcbiAgICAgIHZhciBlZGdlc1N0YXRlID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZUluZGV4ZXMsIG51bU5vZGVzLCBzdG9wU2l6ZSk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbGFwc2VkIG5vZGVzIHN0YXRlXG4gICAgICB2YXIgbWV0YU5vZGVNYXAyID0gbWV0YU5vZGVNYXAuc2xpY2UoMCk7XG5cbiAgICAgIC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcbiAgICAgIHZhciByZXMxID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuICAgICAgdmFyIHJlczIgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwMiwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuXG4gICAgICAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuICAgICAgaWYgKHJlczEubGVuZ3RoIDw9IHJlczIubGVuZ3RoICYmIHJlczEubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMS5sZW5ndGg7XG4gICAgICAgIG1pbkN1dCA9IFtyZXMxLCBtZXRhTm9kZU1hcF07XG4gICAgICB9IGVsc2UgaWYgKHJlczIubGVuZ3RoIDw9IHJlczEubGVuZ3RoICYmIHJlczIubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICBtaW5DdXRTaXplID0gcmVzMi5sZW5ndGg7XG4gICAgICAgIG1pbkN1dCA9IFtyZXMyLCBtZXRhTm9kZU1hcDJdO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuXG5cbiAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgdmFyIHJlc0VkZ2VzID0gKG1pbkN1dFswXSkubWFwKGZ1bmN0aW9uKGUpeyByZXR1cm4gZWRnZXNbZVswXV07IH0pO1xuICAgIHZhciBwYXJ0aXRpb24xID0gW107XG4gICAgdmFyIHBhcnRpdGlvbjIgPSBbXTtcblxuICAgIC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dFsxXVswXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkN1dFsxXS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0WzFdW2ldO1xuICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICBwYXJ0aXRpb24xLnB1c2gobm9kZXNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydGl0aW9uMi5wdXNoKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmV0ID0ge1xuICAgICAgY3V0OiBlbGVzLnNwYXduKGN5LCByZXNFZGdlcyksXG4gICAgICBwYXJ0aXRpb24xOiBlbGVzLnNwYXduKHBhcnRpdGlvbjEpLFxuICAgICAgcGFydGl0aW9uMjogZWxlcy5zcGF3bihwYXJ0aXRpb24yKVxuICAgIH07XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59KTsgLy8gZWxlc2ZuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4uLy4uL2lzJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIHBhZ2VSYW5rOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB2YXIgbm9ybWFsaXplVmVjdG9yID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdmVjdG9yLmxlbmd0aDtcblxuICAgICAgLy8gRmlyc3QsIGdldCBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gICAgICB2YXIgdG90YWwgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbCArPSB2ZWN0b3JbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgZGl2aWRlIGVhY2ggYnkgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmVjdG9yW2ldID0gdmVjdG9yW2ldIC8gdG90YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGRhbXBpbmdGYWN0b3IgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiZcbiAgICAgIG9wdGlvbnMuZGFtcGluZ0ZhY3RvciAhPSBudWxsKSB7XG4gICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IG9wdGlvbnMuZGFtcGluZ0ZhY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhbXBpbmdGYWN0b3IgPSAwLjg7IC8vIERlZmF1bHQgZGFtcGluZyBmYWN0b3JcbiAgICB9XG5cbiAgICAvLyBkZXNpcmVkIHByZWNpc2lvbiAtIG9wdGlvbmFsXG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJlxuICAgICAgb3B0aW9ucy5wcmVjaXNpb24gIT0gbnVsbCkge1xuICAgICAgdmFyIGVwc2lsb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVwc2lsb24gPSAwLjAwMDAwMTsgLy8gRGVmYXVsdCBwcmVjaXNpb25cbiAgICB9XG5cbiAgICAvLyBNYXggbnVtYmVyIG9mIGl0ZXJhdGlvbnMgLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiZcbiAgICAgIG9wdGlvbnMuaXRlcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICB2YXIgbnVtSXRlciA9IG9wdGlvbnMuaXRlcmF0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG51bUl0ZXIgPSAyMDA7IC8vIERlZmF1bHQgbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAgICB9XG5cbiAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiZcbiAgICAgIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiZcbiAgICAgIGlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKGUpIHtyZXR1cm4gMTt9O1xuICAgIH1cblxuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcblxuICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gQ29uc3RydWN0IHRyYW5zcG9zZWQgYWRqYWNlbmN5IG1hdHJpeFxuICAgIC8vIEZpcnN0IGxldHMgaGF2ZSBhIHplcm9lZCBtYXRyaXggb2YgdGhlIHJpZ2h0IHNpemVcbiAgICAvLyBXZSdsbCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHN1bSBvZiBlYWNoIGNvbHVtblxuICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICB2YXIgY29sdW1uU3VtID0gW107XG4gICAgdmFyIGFkZGl0aW9uYWxQcm9iID0gKDEgLSBkYW1waW5nRmFjdG9yKSAvIG51bU5vZGVzO1xuXG4gICAgLy8gQ3JlYXRlIG51bGwgbWF0cmljXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICB2YXIgbmV3Um93ID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgbmV3Um93LnB1c2goMC4wKTtcbiAgICAgIH1cbiAgICAgIG1hdHJpeC5wdXNoKG5ld1Jvdyk7XG4gICAgICBjb2x1bW5TdW0ucHVzaCgwLjApO1xuICAgIH1cblxuICAgIC8vIE5vdywgcHJvY2VzcyBlZGdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBzID0gaWQycG9zaXRpb25bZWRnZS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgIHZhciB0ID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgIHZhciB3ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZSwgW2VkZ2VdKTtcblxuICAgICAgLy8gVXBkYXRlIG1hdHJpeFxuICAgICAgbWF0cml4W3RdW3NdICs9IHc7XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2x1bW4gc3VtXG4gICAgICBjb2x1bW5TdW1bc10gKz0gdztcbiAgICB9XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBwcm9iYWJpbGl0eSBiYXNlZCBvbiBkYW1waW5nIGZhY3RvclxuICAgIC8vIEFsc28sIHRha2UgaW50byBhY2NvdW50IGNvbHVtbnMgdGhhdCBoYXZlIHN1bSA9IDBcbiAgICB2YXIgcCA9IDEuMCAvIG51bU5vZGVzICsgYWRkaXRpb25hbFByb2I7IC8vIFNob3J0aGFuZFxuICAgIC8vIFRyYXZlcnNlIG1hdHJpeCwgY29sdW1uIGJ5IGNvbHVtblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgaWYgKGNvbHVtblN1bVtqXSA9PT0gMCkge1xuICAgICAgICAvLyBObyAnbGlua3MnIG91dCBmcm9tIG5vZGUganRoLCBhc3N1bWUgZXF1YWwgcHJvYmFiaWxpdHkgZm9yIGVhY2ggcG9zc2libGUgbm9kZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICBtYXRyaXhbaV1bal0gPSBwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGp0aCBoYXMgb3V0Z29pbmcgbGluaywgY29tcHV0ZSBub3JtYWxpemVkIHByb2JhYmlsaXRpZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2ldW2pdIC8gY29sdW1uU3VtW2pdICsgYWRkaXRpb25hbFByb2I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuICAgIHZhciBlaWdlbnZlY3RvciA9IFtdO1xuICAgIHZhciBudWxsVmVjdG9yID0gW107XG4gICAgdmFyIHByZXZpb3VzO1xuXG4gICAgLy8gU3RhcnQgd2l0aCBhIHZlY3RvciBvZiBhbGwgMSdzXG4gICAgLy8gQWxzbywgaW5pdGlhbGl6ZSBhIG51bGwgdmVjdG9yIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBzaG9ydGhhbmRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgIGVpZ2VudmVjdG9yLnB1c2goMS4wKTtcbiAgICAgIG51bGxWZWN0b3IucHVzaCgwLjApO1xuICAgIH1cblxuICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDwgbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAvLyBOZXcgYXJyYXkgd2l0aCBhbGwgMCdzXG4gICAgICB2YXIgdGVtcCA9IG51bGxWZWN0b3Iuc2xpY2UoMCk7XG5cbiAgICAgIC8vIE11bHRpcGx5IG1hdHJpeCB3aXRoIHByZXZpb3VzIHJlc3VsdFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgIHRlbXBbaV0gKz0gbWF0cml4W2ldW2pdICogZWlnZW52ZWN0b3Jbal07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9ybWFsaXplVmVjdG9yKHRlbXApO1xuICAgICAgcHJldmlvdXMgPSBlaWdlbnZlY3RvcjtcbiAgICAgIGVpZ2VudmVjdG9yID0gdGVtcDtcblxuICAgICAgdmFyIGRpZmYgPSAwO1xuICAgICAgLy8gQ29tcHV0ZSBkaWZmZXJlbmNlIChzcXVhcmVkIG1vZHVsZSkgb2YgYm90aCB2ZWN0b3JzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZGlmZiArPSBNYXRoLnBvdyhwcmV2aW91c1tpXSAtIGVpZ2VudmVjdG9yW2ldLCAyKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gdGhlIGRlc2lyZWQgdGhyZXNob2xkLCBzdG9wIGl0ZXJhdGluZ1xuICAgICAgaWYgKGRpZmYgPCBlcHNpbG9uKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICB2YXIgcmVzID0ge1xuICAgICAgcmFuayA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgIC8vIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgdmFyIG5vZGVJZCA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXMgYSBub2RlIG9iamVjdFxuICAgICAgICAgIHZhciBub2RlSWQgPSBub2RlLmlkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVpZ2VudmVjdG9yW2lkMnBvc2l0aW9uW25vZGVJZF1dO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIHJldHVybiByZXM7XG4gIH0gLy8gcGFnZVJhbmtcblxufSk7IC8vIGVsZXNmblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmluZSA9IHJlcXVpcmUoJy4uL2RlZmluZScpO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgYW5pbWF0ZTogZGVmaW5lLmFuaW1hdGUoKSxcbiAgYW5pbWF0aW9uOiBkZWZpbmUuYW5pbWF0aW9uKCksXG4gIGFuaW1hdGVkOiBkZWZpbmUuYW5pbWF0ZWQoKSxcbiAgY2xlYXJRdWV1ZTogZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgZGVsYXk6IGRlZmluZS5kZWxheSgpLFxuICBkZWxheUFuaW1hdGlvbjogZGVmaW5lLmRlbGF5QW5pbWF0aW9uKCksXG4gIHN0b3A6IGRlZmluZS5zdG9wKClcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuICBjbGFzc2VzOiBmdW5jdGlvbiggY2xhc3NlcyApe1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgIHZhciBjbGFzc2VzTWFwID0ge307XG5cbiAgICAvLyBmaWxsIGluIGNsYXNzZXMgbWFwXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcblxuICAgICAgY2xhc3Nlc01hcFsgY2xzIF0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGFuZCB1cGRhdGUgZWFjaCBlbGVcbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2pdO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGVsZUNsYXNzZXMgPSBfcC5jbGFzc2VzO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgZWxlIGhhcyBhbGwgb2YgdGhlIHBhc3NlZCBjbGFzc2VzXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbaV07XG4gICAgICAgIHZhciBlbGVIYXNDbGFzcyA9IGVsZUNsYXNzZXNbIGNscyBdO1xuXG4gICAgICAgIGlmKCAhZWxlSGFzQ2xhc3MgKXtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiBlbGUgaGFzIGNsYXNzZXMgb3V0c2lkZSBvZiB0aG9zZSBwYXNzZWRcbiAgICAgIGlmKCAhY2hhbmdlZEVsZSApeyBmb3IoIHZhciBlbGVDbHMgaW4gZWxlQ2xhc3NlcyApe1xuICAgICAgICB2YXIgZWxlSGFzQ2xhc3MgPSBlbGVDbGFzc2VzWyBlbGVDbHMgXTtcbiAgICAgICAgdmFyIHNwZWNkQ2xhc3MgPSBjbGFzc2VzTWFwWyBlbGVDbHMgXTsgLy8gaS5lLiB0aGlzIGNsYXNzIGlzIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cblxuICAgICAgICBpZiggZWxlSGFzQ2xhc3MgJiYgIXNwZWNkQ2xhc3MgKXtcbiAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSB9XG5cbiAgICAgIGlmKCBjaGFuZ2VkRWxlICl7XG4gICAgICAgIF9wLmNsYXNzZXMgPSB1dGlsLmNvcHkoIGNsYXNzZXNNYXAgKTtcblxuICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgIGlmKCBjaGFuZ2VkLmxlbmd0aCA+IDAgKXtcbiAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZClcbiAgICAgICAgLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgLnRyaWdnZXIoJ2NsYXNzJylcbiAgICAgIDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICBhZGRDbGFzczogZnVuY3Rpb24oIGNsYXNzZXMgKXtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyggY2xhc3NlcywgdHJ1ZSApO1xuICB9LFxuXG4gIGhhc0NsYXNzOiBmdW5jdGlvbiggY2xhc3NOYW1lICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuICggZWxlICE9IG51bGwgJiYgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xhc3NOYW1lXSApID8gdHJ1ZSA6IGZhbHNlO1xuICB9LFxuXG4gIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggY2xhc3Nlc1N0ciwgdG9nZ2xlICl7XG4gICAgdmFyIGNsYXNzZXMgPSBjbGFzc2VzU3RyLm1hdGNoKC9cXFMrL2cpIHx8IFtdO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhbmdlZCA9IFtdOyAvLyBlbGVzIHdobyBoYWQgY2xhc3NlcyBjaGFuZ2VkXG5cbiAgICBmb3IoIHZhciBpID0gMCwgaWwgPSBzZWxmLmxlbmd0aDsgaSA8IGlsOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuICAgICAgdmFyIGNoYW5nZWRFbGUgPSBmYWxzZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuICAgICAgICB2YXIgZWxlQ2xhc3NlcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzO1xuICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGVDbGFzc2VzW2Nsc107XG4gICAgICAgIHZhciBzaG91bGRBZGQgPSB0b2dnbGUgfHwgKHRvZ2dsZSA9PT0gdW5kZWZpbmVkICYmICFoYXNDbGFzcyk7XG5cbiAgICAgICAgaWYoIHNob3VsZEFkZCApe1xuICAgICAgICAgIGVsZUNsYXNzZXNbY2xzXSA9IHRydWU7XG5cbiAgICAgICAgICBpZiggIWhhc0NsYXNzICYmICFjaGFuZ2VkRWxlICl7XG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goZWxlKTtcbiAgICAgICAgICAgIGNoYW5nZWRFbGUgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZW1vdmVcbiAgICAgICAgICBlbGVDbGFzc2VzW2Nsc10gPSBmYWxzZTtcblxuICAgICAgICAgIGlmKCBoYXNDbGFzcyAmJiAhY2hhbmdlZEVsZSApe1xuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSAvLyBmb3IgaiBjbGFzc2VzXG4gICAgfSAvLyBmb3IgaSBlbGVzXG5cbiAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICB0aGlzLnNwYXduKGNoYW5nZWQpXG4gICAgICAgIC51cGRhdGVTdHlsZSgpXG4gICAgICAgIC50cmlnZ2VyKCdjbGFzcycpXG4gICAgICA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCBjbGFzc2VzICl7XG4gICAgcmV0dXJuIHRoaXMudG9nZ2xlQ2xhc3MoIGNsYXNzZXMsIGZhbHNlICk7XG4gIH0sXG5cbiAgZmxhc2hDbGFzczogZnVuY3Rpb24oIGNsYXNzZXMsIGR1cmF0aW9uICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYoIGR1cmF0aW9uID09IG51bGwgKXtcbiAgICAgIGR1cmF0aW9uID0gMjUwO1xuICAgIH0gZWxzZSBpZiggZHVyYXRpb24gPT09IDAgKXtcbiAgICAgIHJldHVybiBzZWxmOyAvLyBub3RoaW5nIHRvIGRvIHJlYWxseVxuICAgIH1cblxuICAgIHNlbGYuYWRkQ2xhc3MoIGNsYXNzZXMgKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc2VzICk7XG4gICAgfSwgZHVyYXRpb24pO1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVsZXNmbiA9ICh7XG4gIGFsbEFyZTogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKS5sZW5ndGggPT09IHRoaXMubGVuZ3RoO1xuICB9LFxuXG4gIGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpLmxlbmd0aCA+IDA7XG4gIH0sXG5cbiAgc29tZTogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcmV0ID0gIXRoaXNBcmcgPyBmbiggdGhpc1tpXSwgaSwgdGhpcyApIDogZm4uYXBwbHkoIHRoaXNBcmcsIFsgdGhpc1tpXSwgaSwgdGhpcyBdICk7XG5cbiAgICAgIGlmKCByZXQgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIGV2ZXJ5OiBmdW5jdGlvbiggZm4sIHRoaXNBcmcgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKCB0aGlzW2ldLCBpLCB0aGlzICkgOiBmbi5hcHBseSggdGhpc0FyZywgWyB0aGlzW2ldLCBpLCB0aGlzIF0gKTtcblxuICAgICAgaWYoICFyZXQgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIHNhbWU6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICAvLyBjaGVhcCBleHRyYSBjaGVja1xuICAgIGlmKCB0aGlzLmxlbmd0aCAhPT0gY29sbGVjdGlvbi5sZW5ndGggKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPT09IHRoaXMubGVuZ3RoO1xuICB9LFxuXG4gIGFueVNhbWU6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPiAwO1xuICB9LFxuXG4gIGFsbEFyZU5laWdoYm9yczogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA9PT0gY29sbGVjdGlvbi5sZW5ndGg7XG4gIH1cbn0pO1xuXG5lbGVzZm4uYWxsQXJlTmVpZ2hib3VycyA9IGVsZXNmbi5hbGxBcmVOZWlnaGJvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgcGFyZW50OiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKCBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQgKTtcblxuICAgICAgaWYoIHBhcmVudC5zaXplKCkgPiAwICl7XG4gICAgICAgIHBhcmVudHMucHVzaCggcGFyZW50ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHBhcmVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgcGFyZW50czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgIHZhciBlbGVzID0gdGhpcy5wYXJlbnQoKTtcbiAgICB3aGlsZSggZWxlcy5ub25lbXB0eSgpICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHBhcmVudHMucHVzaCggZWxlICk7XG4gICAgICB9XG5cbiAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBwYXJlbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGNvbW1vbkFuY2VzdG9yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGFuY2VzdG9ycztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICB2YXIgcGFyZW50cyA9IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuXG4gICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuaW50ZXJzZWN0KCBwYXJlbnRzICk7IC8vIGN1cnJlbnQgbGlzdCBtdXN0IGJlIGNvbW1vbiB3aXRoIGN1cnJlbnQgZWxlIHBhcmVudHMgc2V0XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ycy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgb3JwaGFuczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLnBhcmVudCgpLmVtcHR5KCk7XG4gICAgfSkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIG5vbm9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgIH0pLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBjaGlsZHJlbjogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5jb25jYXQoIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbiApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBjaGlsZHJlbiwgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBzaWJsaW5nczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QoIHRoaXMgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgaXNQYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMDtcbiAgICB9XG4gIH0sXG5cbiAgaXNDaGlsZDogZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBlbGUucGFyZW50KCkubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgfSxcblxuICBkZXNjZW5kYW50czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICBmdW5jdGlvbiBhZGQoIGVsZXMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcblxuICAgICAgICBpZiggZWxlLmNoaWxkcmVuKCkubm9uZW1wdHkoKSApe1xuICAgICAgICAgIGFkZCggZWxlLmNoaWxkcmVuKCkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGFkZCggdGhpcy5jaGlsZHJlbigpICk7XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzXG5lbGVzZm4uYW5jZXN0b3JzID0gZWxlc2ZuLnBhcmVudHM7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnLi4vZGVmaW5lJyk7XG52YXIgZm4sIGVsZXNmbjtcblxuZm4gPSBlbGVzZm4gPSAoe1xuXG4gIGRhdGE6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ2RhdGEnLFxuICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAnaWQnOiB0cnVlLFxuICAgICAgJ3NvdXJjZSc6IHRydWUsXG4gICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgfSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcblxuICByZW1vdmVEYXRhOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBldmVudDogJ2RhdGEnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG5cbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcblxuICByc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgfSksXG5cbiAgcmVtb3ZlUnNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3JzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gIH0pLFxuXG4gIGlkOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgIH1cbiAgfVxuXG59KTtcblxuLy8gYWxpYXNlc1xuZm4uYXR0ciA9IGZuLmRhdGE7XG5mbi5yZW1vdmVBdHRyID0gZm4ucmVtb3ZlRGF0YTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCBpbmNsdWRlTG9vcHMgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiggaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQgKXtcbiAgICAgIGluY2x1ZGVMb29wcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIHNlbGYubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgaWYoIHNlbGYuaXNOb2RlKCkgJiYgIXNlbGYucmVtb3ZlZCgpICl7XG4gICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgIHZhciBub2RlID0gc2VsZlswXTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tpXTtcblxuICAgICAgICBpZiggIWluY2x1ZGVMb29wcyAmJiBlZGdlLmlzTG9vcCgpICl7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBkZWdyZWUgKz0gY2FsbGJhY2soIG5vZGUsIGVkZ2UgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfTtcbn1cblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgaWYoIGVkZ2Uuc291cmNlKCkuc2FtZSggZWRnZS50YXJnZXQoKSApICl7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KSxcblxuICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgaWYoIGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSksXG5cbiAgb3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbihub2RlLCBlZGdlKXtcbiAgICBpZiggZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpICl7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjayl7XG4gIHJldHVybiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgICB2YXIgZGVncmVlID0gZWxlW2RlZ3JlZUZuXSggaW5jbHVkZUxvb3BzICk7XG4gICAgICBpZiggZGVncmVlICE9PSB1bmRlZmluZWQgJiYgKHJldCA9PT0gdW5kZWZpbmVkIHx8IGNhbGxiYWNrKGRlZ3JlZSwgcmV0KSkgKXtcbiAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICBtaW5EZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG5cbiAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuXG4gIG1pbkluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG5cbiAgbWF4SW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWF4KXtcbiAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICB9KSxcblxuICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1pbil7XG4gICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgfSksXG5cbiAgbWF4T3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pXG59KTtcblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIHRvdGFsRGVncmVlOiBmdW5jdGlvbiggaW5jbHVkZUxvb3BzICl7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoIGluY2x1ZGVMb29wcyApO1xuICAgIH1cblxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnLi4vZGVmaW5lJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgZm4sIGVsZXNmbjtcblxuZm4gPSBlbGVzZm4gPSAoe1xuXG4gIHBvc2l0aW9uOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgIHRyaWdnZXJGbk5hbWU6ICdydHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHZhbGlkS2V5czogWyd4JywgJ3knXSxcbiAgICBvblNldDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIHZhciB1cGRhdGVkRWxlcyA9IGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIHVwZGF0ZWRFbGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgIH0sXG4gICAgY2FuU2V0OiBmdW5jdGlvbiggZWxlICl7XG4gICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKSAmJiAhZWxlLmlzUGFyZW50KCk7XG4gICAgfVxuICB9KSxcblxuICAvLyBwb3NpdGlvbiBidXQgbm8gbm90aWZpY2F0aW9uIHRvIHJlbmRlcmVyXG4gIHNpbGVudFBvc2l0aW9uOiBkZWZpbmUuZGF0YSh7XG4gICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB2YWxpZEtleXM6IFsneCcsICd5J10sXG4gICAgb25TZXQ6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgfSxcbiAgICBjYW5TZXQ6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIHJldHVybiAhZWxlLmxvY2tlZCgpICYmICFlbGUuaXNQYXJlbnQoKTtcbiAgICB9XG4gIH0pLFxuXG4gIHBvc2l0aW9uczogZnVuY3Rpb24oIHBvcywgc2lsZW50ICl7XG4gICAgaWYoIGlzLnBsYWluT2JqZWN0KHBvcykgKXtcbiAgICAgIHRoaXMucG9zaXRpb24ocG9zKTtcblxuICAgIH0gZWxzZSBpZiggaXMuZm4ocG9zKSApe1xuICAgICAgdmFyIGZuID0gcG9zO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgdmFyIHBvcyA9IGZuLmFwcGx5KGVsZSwgW2ksIGVsZV0pO1xuXG4gICAgICAgIGlmKCBwb3MgJiYgIWVsZS5sb2NrZWQoKSAmJiAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgICB2YXIgZWxlUG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIGVsZVBvcy54ID0gcG9zLng7XG4gICAgICAgICAgZWxlUG9zLnkgPSBwb3MueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlZEVsZXMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB2YXIgdG9UcmlnZ2VyID0gdXBkYXRlZEVsZXMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkRWxlcyApIDogdGhpcztcblxuICAgICAgaWYoIHNpbGVudCApe1xuICAgICAgICB0b1RyaWdnZXIudHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvVHJpZ2dlci5ydHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBzaWxlbnRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MgKXtcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMoIHBvcywgdHJ1ZSApO1xuICB9LFxuXG4gIC8vIGdldC9zZXQgdGhlIHJlbmRlcmVkIChpLmUuIG9uIHNjcmVlbikgcG9zaXRvbiBvZiB0aGUgZWxlbWVudFxuICByZW5kZXJlZFBvc2l0aW9uOiBmdW5jdGlvbiggZGltLCB2YWwgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciBycG9zID0gaXMucGxhaW5PYmplY3QoIGRpbSApID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcnBvcyAhPT0gdW5kZWZpbmVkIHx8ICggdmFsICE9PSB1bmRlZmluZWQgJiYgaXMuc3RyaW5nKGRpbSkgKTtcblxuICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmKCBzZXR0aW5nICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb25bZGltXSA9ICggdmFsIC0gcGFuW2RpbV0gKS96b29tO1xuICAgICAgICAgIH0gZWxzZSBpZiggcnBvcyAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICB4OiAoIHJwb3MueCAtIHBhbi54ICkgL3pvb20sXG4gICAgICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvem9vbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgfSBlbHNlIHsgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICBycG9zID0ge1xuICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGRpbSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBycG9zWyBkaW0gXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiggIXNldHRpbmcgKXtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBnZXQvc2V0IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gIHJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uKCBkaW0sIHZhbCApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgcHBvcyA9IGlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmIGlzLnN0cmluZyhkaW0pICk7XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiggZWxlICYmIGVsZS5pc05vZGUoKSApeyAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiggc2V0dGluZyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbiA6IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb25bZGltXSA9IHZhbCArIG9yaWdpbltkaW1dO1xuICAgICAgICAgIH0gZWxzZSBpZiggcHBvcyAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICB4OiBwcG9zLnggKyBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgeTogcHBvcy55ICsgb3JpZ2luLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcblxuICAgICAgfSBlbHNlIHsgLy8gZ2V0dGluZ1xuICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuXG4gICAgICAgIGlmKCBoYXNQYXJlbnQgKXtcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbiA6IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgIHBwb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggLSBvcmlnaW4ueCxcbiAgICAgICAgICB5OiBwb3MueSAtIG9yaWdpbi55XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGRpbSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgIHJldHVybiBwcG9zO1xuICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBwcG9zWyBkaW0gXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiggIXNldHRpbmcgKXtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICByZW5kZXJlZEJvdW5kaW5nQm94OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3goIG9wdGlvbnMgKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgdmFyIHgxID0gYmIueDEgKiB6b29tICsgcGFuLng7XG4gICAgdmFyIHgyID0gYmIueDIgKiB6b29tICsgcGFuLng7XG4gICAgdmFyIHkxID0gYmIueTEgKiB6b29tICsgcGFuLnk7XG4gICAgdmFyIHkyID0gYmIueTIgKiB6b29tICsgcGFuLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHgxLFxuICAgICAgeDI6IHgyLFxuICAgICAgeTE6IHkxLFxuICAgICAgeTI6IHkyLFxuICAgICAgdzogeDIgLSB4MSxcbiAgICAgIGg6IHkyIC0geTFcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZUNvbXBvdW5kQm91bmRzOiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgfHwgIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApeyByZXR1cm4gY3kuY29sbGVjdGlvbigpOyB9IC8vIHNhdmUgY3ljbGVzIGZvciBub24gY29tcG91bmQgZ3JhcGhzIG9yIHdoZW4gc3R5bGUgZGlzYWJsZWRcblxuICAgIHZhciB1cGRhdGVkID0gW107XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoIHBhcmVudCApe1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuKCk7XG4gICAgICB2YXIgc3R5bGUgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgaW5jbHVkZUxhYmVscyA9IHN0eWxlWydjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyddLnZhbHVlID09PSAnaW5jbHVkZSc7XG4gICAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IGluY2x1ZGVMYWJlbHMsIGluY2x1ZGVFZGdlczogdHJ1ZSB9KTtcbiAgICAgIHZhciBwYWRkaW5nID0ge1xuICAgICAgICB0b3A6IHN0eWxlWydwYWRkaW5nLXRvcCddLnBmVmFsdWUsXG4gICAgICAgIGJvdHRvbTogc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10ucGZWYWx1ZSxcbiAgICAgICAgbGVmdDogc3R5bGVbJ3BhZGRpbmctbGVmdCddLnBmVmFsdWUsXG4gICAgICAgIHJpZ2h0OiBzdHlsZVsncGFkZGluZy1yaWdodCddLnBmVmFsdWVcbiAgICAgIH07XG4gICAgICB2YXIgcG9zID0gcGFyZW50Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIGRpZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICBpZiggc3R5bGVbJ3dpZHRoJ10udmFsdWUgPT09ICdhdXRvJyApe1xuICAgICAgICBwYXJlbnQuX3ByaXZhdGUuYXV0b1dpZHRoID0gYmIudztcbiAgICAgICAgcG9zLnggPSAoYmIueDEgKyBiYi54MiAtIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQpLzI7XG4gICAgICAgIGRpZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBzdHlsZVsnaGVpZ2h0J10udmFsdWUgPT09ICdhdXRvJyApe1xuICAgICAgICBwYXJlbnQuX3ByaXZhdGUuYXV0b0hlaWdodCA9IGJiLmg7XG4gICAgICAgIHBvcy55ID0gKGJiLnkxICsgYmIueTIgLSBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tKS8yO1xuICAgICAgICBkaWRVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggZGlkVXBkYXRlICl7XG4gICAgICAgIHVwZGF0ZWQucHVzaCggcGFyZW50ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZ28gdXAsIGxldmVsIGJ5IGxldmVsXG4gICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuICAgIHdoaWxlKCBlbGVzLm5vbmVtcHR5KCkgKXtcblxuICAgICAgLy8gdXBkYXRlIGVhY2ggcGFyZW50IG5vZGUgaW4gdGhpcyBsZXZlbFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgIHVwZGF0ZSggZWxlICk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5leHQgbGV2ZWxcbiAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBjaGFuZ2VkXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHVwZGF0ZWQgKTtcbiAgfSxcblxuICAvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudHMgKGluIHJhdyBtb2RlbCBwb3NpdGlvbilcbiAgYm91bmRpbmdCb3g6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBjeSA9IGVsZXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGN5X3AgPSBjeS5fcHJpdmF0ZTtcbiAgICB2YXIgc3R5bGVFbmFibGVkID0gY3lfcC5zdHlsZUVuYWJsZWQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB1dGlsLnN0YXRpY0VtcHR5T2JqZWN0KCk7XG5cbiAgICB2YXIgaW5jbHVkZU5vZGVzID0gb3B0aW9ucy5pbmNsdWRlTm9kZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVOb2RlcztcbiAgICB2YXIgaW5jbHVkZUVkZ2VzID0gb3B0aW9ucy5pbmNsdWRlRWRnZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVFZGdlcztcbiAgICB2YXIgaW5jbHVkZUxhYmVscyA9IG9wdGlvbnMuaW5jbHVkZUxhYmVscyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuaW5jbHVkZUxhYmVscztcblxuICAgIC8vIHJlY2FsY3VsYXRlIHByb2plY3Rpb25zIGV0Y1xuICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgIGN5X3AucmVuZGVyZXIucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCB0aGlzICk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gSW5maW5pdHk7XG4gICAgdmFyIHgyID0gLUluZmluaXR5O1xuICAgIHZhciB5MSA9IEluZmluaXR5O1xuICAgIHZhciB5MiA9IC1JbmZpbml0eTtcblxuICAgIC8vIGZpbmQgYm91bmRzIG9mIGVsZW1lbnRzXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgICAgdmFyIGRpc3BsYXkgPSBzdHlsZUVuYWJsZWQgPyBfcC5zdHlsZVsnZGlzcGxheSddLnZhbHVlIDogJ2VsZW1lbnQnO1xuICAgICAgdmFyIGlzTm9kZSA9IF9wLmdyb3VwID09PSAnbm9kZXMnO1xuICAgICAgdmFyIGV4MSwgZXgyLCBleTEsIGV5MiwgeCwgeTtcbiAgICAgIHZhciBpbmNsdWRlZEVsZSA9IGZhbHNlO1xuXG4gICAgICBpZiggZGlzcGxheSA9PT0gJ25vbmUnICl7IGNvbnRpbnVlOyB9IC8vIHRoZW4gZWxlIGRvZXNuJ3QgdGFrZSB1cCBzcGFjZVxuXG4gICAgICBpZiggaXNOb2RlICYmIGluY2x1ZGVOb2RlcyApe1xuICAgICAgICBpbmNsdWRlZEVsZSA9IHRydWU7XG5cbiAgICAgICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuICAgICAgICB4ID0gcG9zLng7XG4gICAgICAgIHkgPSBwb3MueTtcbiAgICAgICAgdmFyIHcgPSBlbGUub3V0ZXJXaWR0aCgpO1xuICAgICAgICB2YXIgaGFsZlcgPSB3LzI7XG4gICAgICAgIHZhciBoID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIHZhciBoYWxmSCA9IGgvMjtcblxuICAgICAgICAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBleDEgPSB4IC0gaGFsZlc7XG4gICAgICAgIGV4MiA9IHggKyBoYWxmVztcbiAgICAgICAgZXkxID0geSAtIGhhbGZIO1xuICAgICAgICBleTIgPSB5ICsgaGFsZkg7XG5cbiAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICB4MiA9IGV4MiA+IHgyID8gZXgyIDogeDI7XG4gICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyO1xuXG4gICAgICB9IGVsc2UgaWYoIGVsZS5pc0VkZ2UoKSAmJiBpbmNsdWRlRWRnZXMgKXtcbiAgICAgICAgaW5jbHVkZWRFbGUgPSB0cnVlO1xuXG4gICAgICAgIHZhciBuMSA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIG4xX3AgPSBuMS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIG4xcG9zID0gbjFfcC5wb3NpdGlvbjtcblxuICAgICAgICB2YXIgbjIgPSBfcC50YXJnZXQ7XG4gICAgICAgIHZhciBuMl9wID0gbjIuX3ByaXZhdGU7XG4gICAgICAgIHZhciBuMnBvcyA9IG4yX3AucG9zaXRpb247XG5cblxuICAgICAgICAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlIHx8IHt9O1xuICAgICAgICB2YXIgdyA9IDA7XG4gICAgICAgIHZhciB3SGFsZiA9IDA7XG5cbiAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICAgIHcgPSBzdHlsZVsnd2lkdGgnXS5wZlZhbHVlO1xuICAgICAgICAgIHdIYWxmID0gdy8yO1xuICAgICAgICB9XG5cbiAgICAgICAgZXgxID0gbjFwb3MueDtcbiAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgZXkxID0gbjFwb3MueTtcbiAgICAgICAgZXkyID0gbjJwb3MueTtcblxuICAgICAgICBpZiggZXgxID4gZXgyICl7XG4gICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgZXgxID0gZXgyO1xuICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZXkxID4gZXkyICl7XG4gICAgICAgICAgdmFyIHRlbXAgPSBleTE7XG4gICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgIGV5MiA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBlZGdlIHdpZHRoXG4gICAgICAgIGV4MSAtPSB3SGFsZjtcbiAgICAgICAgZXgyICs9IHdIYWxmO1xuICAgICAgICBleTEgLT0gd0hhbGY7XG4gICAgICAgIGV5MiArPSB3SGFsZjtcblxuICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgIHgyID0gZXgyID4geDIgPyBleDIgOiB4MjtcbiAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG5cbiAgICAgICAgLy8gaGFuZGxlIHBvaW50cyBhbG9uZyBlZGdlIChzYW5pdHkgY2hlY2spXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgcHRzID0gcnN0eWxlLmJlemllclB0cyB8fCByc3R5bGUubGluZVB0cyB8fCBbXTtcblxuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgcHQgPSBwdHNbal07XG5cbiAgICAgICAgICAgIGV4MSA9IHB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgIGV4MiA9IHB0LnggKyB3SGFsZjtcbiAgICAgICAgICAgIGV5MSA9IHB0LnkgLSB3SGFsZjtcbiAgICAgICAgICAgIGV5MiA9IHB0LnkgKyB3SGFsZjtcblxuICAgICAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZWNpc2UgaGF5c3RhY2tzIChzYW5pdHkgY2hlY2spXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCAmJiBzdHlsZVsnY3VydmUtc3R5bGUnXS5zdHJWYWx1ZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgICAgIHZhciBocHRzID0gcnN0eWxlLmhheXN0YWNrUHRzO1xuXG4gICAgICAgICAgZXgxID0gaHB0c1swXS54O1xuICAgICAgICAgIGV5MSA9IGhwdHNbMF0ueTtcbiAgICAgICAgICBleDIgPSBocHRzWzFdLng7XG4gICAgICAgICAgZXkyID0gaHB0c1sxXS55O1xuXG4gICAgICAgICAgaWYoIGV4MSA+IGV4MiApe1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICBleDIgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBleTEgPiBleTIgKXtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZXkxO1xuICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgZXkyID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG4gICAgICAgIH1cblxuICAgICAgfSAvLyBlZGdlc1xuXG5cbiAgICAgIC8vIGhhbmRsZSBsYWJlbCBkaW1lbnNpb25zXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICBpZiggc3R5bGVFbmFibGVkICl7XG5cbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICAgICAgdmFyIGxhYmVsID0gc3R5bGVbJ2xhYmVsJ10uc3RyVmFsdWU7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHN0eWxlWydmb250LXNpemUnXTtcbiAgICAgICAgdmFyIGhhbGlnbiA9IHN0eWxlWyd0ZXh0LWhhbGlnbiddO1xuICAgICAgICB2YXIgdmFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ107XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gcnN0eWxlLmxhYmVsV2lkdGg7XG4gICAgICAgIHZhciBsYWJlbEhlaWdodCA9IHJzdHlsZS5sYWJlbEhlaWdodDtcbiAgICAgICAgdmFyIGxhYmVsWCA9IHJzdHlsZS5sYWJlbFg7XG4gICAgICAgIHZhciBsYWJlbFkgPSByc3R5bGUubGFiZWxZO1xuICAgICAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgICAgICB2YXIgYXV0b3JvdGF0ZSA9IHN0eWxlWydlZGdlLXRleHQtcm90YXRpb24nXS5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnO1xuXG4gICAgICAgIGlmKCBpbmNsdWRlTGFiZWxzICYmIGxhYmVsICYmIGZvbnRTaXplICYmIGxhYmVsSGVpZ2h0ICE9IG51bGwgJiYgbGFiZWxXaWR0aCAhPSBudWxsICYmIGxhYmVsWCAhPSBudWxsICYmIGxhYmVsWSAhPSBudWxsICYmIGhhbGlnbiAmJiB2YWxpZ24gKXtcbiAgICAgICAgICB2YXIgbGggPSBsYWJlbEhlaWdodDtcbiAgICAgICAgICB2YXIgbHcgPSBsYWJlbFdpZHRoO1xuICAgICAgICAgIHZhciBseDEsIGx4MiwgbHkxLCBseTI7XG5cbiAgICAgICAgICBpZiggaXNFZGdlICl7XG4gICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdy8yO1xuICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHcvMjtcbiAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoLzI7XG4gICAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaC8yO1xuXG4gICAgICAgICAgICBpZiggYXV0b3JvdGF0ZSApe1xuICAgICAgICAgICAgICB2YXIgdGhldGEgPSBfcC5yc2NyYXRjaC5sYWJlbEFuZ2xlO1xuICAgICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoIHRoZXRhICk7XG4gICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgICAgICAgICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24oIHgsIHkgKXtcbiAgICAgICAgICAgICAgICB4ID0geCAtIGxhYmVsWDtcbiAgICAgICAgICAgICAgICB5ID0geSAtIGxhYmVsWTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB4OiB4KmNvcyAtIHkqc2luICsgbGFiZWxYLFxuICAgICAgICAgICAgICAgICAgeTogeCpzaW4gKyB5KmNvcyArIGxhYmVsWVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgdmFyIHB4MXkxID0gcm90YXRlKCBseDEsIGx5MSApO1xuICAgICAgICAgICAgICB2YXIgcHgxeTIgPSByb3RhdGUoIGx4MSwgbHkyICk7XG4gICAgICAgICAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZSggbHgyLCBseTEgKTtcbiAgICAgICAgICAgICAgdmFyIHB4MnkyID0gcm90YXRlKCBseDIsIGx5MiApO1xuXG4gICAgICAgICAgICAgIGx4MSA9IE1hdGgubWluKCBweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54ICk7XG4gICAgICAgICAgICAgIGx4MiA9IE1hdGgubWF4KCBweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54ICk7XG4gICAgICAgICAgICAgIGx5MSA9IE1hdGgubWluKCBweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55ICk7XG4gICAgICAgICAgICAgIGx5MiA9IE1hdGgubWF4KCBweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCggaGFsaWduLnZhbHVlICl7XG4gICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3LzI7XG4gICAgICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHcvMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2goIHZhbGlnbi52YWx1ZSApe1xuICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoLzI7XG4gICAgICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGgvMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MSA9IGx4MSA8IHgxID8gbHgxIDogeDE7XG4gICAgICAgICAgeDIgPSBseDIgPiB4MiA/IGx4MiA6IHgyO1xuICAgICAgICAgIHkxID0gbHkxIDwgeTEgPyBseTEgOiB5MTtcbiAgICAgICAgICB5MiA9IGx5MiA+IHkyID8gbHkyIDogeTI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gc3R5bGUgZW5hYmxlZCBmb3IgbGFiZWxzXG4gICAgfSAvLyBmb3JcblxuICAgIHZhciBub25pbmYgPSBmdW5jdGlvbih4KXtcbiAgICAgIGlmKCB4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkgKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4O1xuICAgIH07XG5cbiAgICB4MSA9IG5vbmluZih4MSk7XG4gICAgeDIgPSBub25pbmYoeDIpO1xuICAgIHkxID0gbm9uaW5mKHkxKTtcbiAgICB5MiA9IG5vbmluZih5Mik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IHgxLFxuICAgICAgeDI6IHgyLFxuICAgICAgeTE6IHkxLFxuICAgICAgeTI6IHkyLFxuICAgICAgdzogeDIgLSB4MSxcbiAgICAgIGg6IHkyIC0geTFcbiAgICB9O1xuICB9XG59KTtcblxudmFyIGRlZmluZURpbUZucyA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIG9wdHMudXBwZXJjYXNlTmFtZSA9IHV0aWwuY2FwaXRhbGl6ZSggb3B0cy5uYW1lICk7XG4gIG9wdHMuYXV0b05hbWUgPSAnYXV0bycgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMubGFiZWxOYW1lID0gJ2xhYmVsJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy5vdXRlck5hbWUgPSAnb3V0ZXInICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLnVwcGVyY2FzZU91dGVyTmFtZSA9IHV0aWwuY2FwaXRhbGl6ZSggb3B0cy5vdXRlck5hbWUgKTtcblxuICBmblsgb3B0cy5uYW1lIF0gPSBmdW5jdGlvbiBkaW1JbXBsKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgIHZhciBkID0gX3Auc3R5bGVbIG9wdHMubmFtZSBdO1xuXG4gICAgICAgIHN3aXRjaCggZC5zdHJWYWx1ZSApe1xuICAgICAgICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgICAgICAgcmV0dXJuIF9wWyBvcHRzLmF1dG9OYW1lIF0gfHwgMDtcbiAgICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgICByZXR1cm4gX3AucnN0eWxlWyBvcHRzLmxhYmVsTmFtZSBdIHx8IDA7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBkLnBmVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmblsgJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZSBdID0gZnVuY3Rpb24gb3V0ZXJEaW1JbXBsKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuICAgICAgICB2YXIgZGltID0gZWxlWyBvcHRzLm5hbWUgXSgpO1xuICAgICAgICB2YXIgYm9yZGVyID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnBmVmFsdWU7XG4gICAgICAgIHZhciBwYWRkaW5nID0gc3R5bGVbIG9wdHMucGFkZGluZ3NbMF0gXS5wZlZhbHVlICsgc3R5bGVbIG9wdHMucGFkZGluZ3NbMV0gXS5wZlZhbHVlO1xuXG4gICAgICAgIHJldHVybiBkaW0gKyBib3JkZXIgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZuWyAncmVuZGVyZWQnICsgb3B0cy51cHBlcmNhc2VOYW1lIF0gPSBmdW5jdGlvbiByZW5kZXJlZERpbUltcGwoKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBkID0gZWxlWyBvcHRzLm5hbWUgXSgpO1xuICAgICAgcmV0dXJuIGQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgIH1cbiAgfTtcblxuICBmblsgJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lIF0gPSBmdW5jdGlvbiByZW5kZXJlZE91dGVyRGltSW1wbCgpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdmFyIG9kID0gZWxlWyBvcHRzLm91dGVyTmFtZSBdKCk7XG4gICAgICByZXR1cm4gb2QgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgIH1cbiAgfTtcbn07XG5cbmRlZmluZURpbUZucyh7XG4gIG5hbWU6ICd3aWR0aCcsXG4gIHBhZGRpbmdzOiBbJ3BhZGRpbmctbGVmdCcsICdwYWRkaW5nLXJpZ2h0J11cbn0pO1xuXG5kZWZpbmVEaW1GbnMoe1xuICBuYW1lOiAnaGVpZ2h0JyxcbiAgcGFkZGluZ3M6IFsncGFkZGluZy10b3AnLCAncGFkZGluZy1ib3R0b20nXVxufSk7XG5cbi8vIGFsaWFzZXNcbmZuLm1vZGVsUG9zaXRpb24gPSBmbi5wb2ludCA9IGZuLnBvc2l0aW9uO1xuZm4ubW9kZWxQb3NpdGlvbnMgPSBmbi5wb2ludHMgPSBmbi5wb3NpdGlvbnM7XG5mbi5yZW5kZXJlZFBvaW50ID0gZm4ucmVuZGVyZWRQb3NpdGlvbjtcbmZuLnJlbGF0aXZlUG9pbnQgPSBmbi5yZWxhdGl2ZVBvc2l0aW9uO1xuZm4uYm91bmRpbmdib3ggPSBmbi5ib3VuZGluZ0JveDtcbmZuLnJlbmRlcmVkQm91bmRpbmdib3ggPSBmbi5yZW5kZXJlZEJvdW5kaW5nQm94O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG4vLyByZXByZXNlbnRzIGEgbm9kZSBvciBhbiBlZGdlXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uKGN5LCBwYXJhbXMsIHJlc3RvcmUpe1xuICBpZiggISh0aGlzIGluc3RhbmNlb2YgRWxlbWVudCkgKXtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnQoY3ksIHBhcmFtcywgcmVzdG9yZSk7XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlc3RvcmUgPSAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgPyB0cnVlIDogZmFsc2UpO1xuXG4gIGlmKCBjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICFpcy5jb3JlKGN5KSApe1xuICAgIHV0aWwuZXJyb3IoJ0FuIGVsZW1lbnQgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UgYW5kIHBhcmFtZXRlcnMgc2V0Jyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdyb3VwID0gcGFyYW1zLmdyb3VwO1xuXG4gIC8vIHRyeSB0byBhdXRvbWF0aWNhbGx5IGluZmVyIHRoZSBncm91cCBpZiB1bnNwZWNpZmllZFxuICBpZiggZ3JvdXAgPT0gbnVsbCApe1xuICAgIGlmKCBwYXJhbXMuZGF0YS5zb3VyY2UgIT0gbnVsbCAmJiBwYXJhbXMuZGF0YS50YXJnZXQgIT0gbnVsbCApe1xuICAgICAgZ3JvdXAgPSAnZWRnZXMnO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9ICdub2Rlcyc7XG4gICAgfVxuICB9XG5cbiAgLy8gdmFsaWRhdGUgZ3JvdXBcbiAgaWYoIGdyb3VwICE9PSAnbm9kZXMnICYmIGdyb3VwICE9PSAnZWRnZXMnICl7XG4gICAgdXRpbC5lcnJvcignQW4gZWxlbWVudCBtdXN0IGJlIG9mIHR5cGUgYG5vZGVzYCBvciBgZWRnZXNgOyB5b3Ugc3BlY2lmaWVkIGAnICsgZ3JvdXAgKyAnYCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG1ha2UgdGhlIGVsZW1lbnQgYXJyYXktbGlrZSwganVzdCBsaWtlIGEgY29sbGVjdGlvblxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xuXG4gIC8vIE5PVEU6IHdoZW4gc29tZXRoaW5nIGlzIGFkZGVkIGhlcmUsIGFkZCBhbHNvIHRvIGVsZS5qc29uKClcbiAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgc2luZ2xlOiB0cnVlLCAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgZGF0YTogcGFyYW1zLmRhdGEgfHwge30sIC8vIGRhdGEgb2JqZWN0XG4gICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbiB8fCB7fSwgLy8gKHgsIHkpIHBvc2l0aW9uIHBhaXJcbiAgICBhdXRvV2lkdGg6IHVuZGVmaW5lZCwgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgIGF1dG9IZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBsaXN0ZW5lcnM6IFtdLCAvLyBhcnJheSBvZiBib3VuZCBsaXN0ZW5lcnNcbiAgICBncm91cDogZ3JvdXAsIC8vIHN0cmluZzsgJ25vZGVzJyBvciAnZWRnZXMnXG4gICAgc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGFzIHNldCBieSB0aGUgc3R5bGVcbiAgICByc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgc3R5bGVDeHRzOiBbXSwgLy8gYXBwbGllZCBzdHlsZSBjb250ZXh0cyBmcm9tIHRoZSBzdHlsZXJcbiAgICByZW1vdmVkOiB0cnVlLCAvLyB3aGV0aGVyIGl0J3MgaW5zaWRlIHRoZSB2aXM7IHRydWUgaWYgcmVtb3ZlZCAoc2V0IHRydWUgaGVyZSBzaW5jZSB3ZSBjYWxsIHJlc3RvcmUpXG4gICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgc2VsZWN0YWJsZTogcGFyYW1zLnNlbGVjdGFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAoIHBhcmFtcy5zZWxlY3RhYmxlID8gdHJ1ZSA6IGZhbHNlICksIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RhYmxlXG4gICAgbG9ja2VkOiBwYXJhbXMubG9ja2VkID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGxvY2tlZCAoY2Fubm90IGJlIG1vdmVkKVxuICAgIGdyYWJiZWQ6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGdyYWJiZWQgYnkgdGhlIG1vdXNlOyByZW5kZXJlciBzZXRzIHRoaXMgcHJpdmF0ZWx5XG4gICAgZ3JhYmJhYmxlOiBwYXJhbXMuZ3JhYmJhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogKCBwYXJhbXMuZ3JhYmJhYmxlID8gdHJ1ZSA6IGZhbHNlICksIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgY2FuIGJlIGdyYWJiZWRcbiAgICBhY3RpdmU6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFjdGl2ZSBmcm9tIHVzZXIgaW50ZXJhY3Rpb25cbiAgICBjbGFzc2VzOiB7fSwgLy8gbWFwICggY2xhc3NOYW1lID0+IHRydWUgKVxuICAgIGFuaW1hdGlvbjogeyAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgcXVldWU6IFtdXG4gICAgfSxcbiAgICByc2NyYXRjaDoge30sIC8vIG9iamVjdCBpbiB3aGljaCB0aGUgcmVuZGVyZXIgY2FuIHN0b3JlIGluZm9ybWF0aW9uXG4gICAgc2NyYXRjaDogcGFyYW1zLnNjcmF0Y2ggfHwge30sIC8vIHNjcmF0Y2ggb2JqZWN0c1xuICAgIGVkZ2VzOiBbXSwgLy8gYXJyYXkgb2YgY29ubmVjdGVkIGVkZ2VzXG4gICAgY2hpbGRyZW46IFtdIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gIH07XG5cbiAgLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG4gIGlmKCBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiApe1xuICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgdGhpcy5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgIHg6IChycG9zLnggLSBwYW4ueCkvem9vbSxcbiAgICAgIHk6IChycG9zLnkgLSBwYW4ueSkvem9vbVxuICAgIH07XG4gIH1cblxuICBpZiggaXMuc3RyaW5nKHBhcmFtcy5jbGFzc2VzKSApe1xuICAgIHZhciBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgIGlmKCAhY2xzIHx8IGNscyA9PT0gJycgKXsgY29udGludWU7IH1cblxuICAgICAgc2VsZi5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBwYXJhbXMuc3R5bGUgfHwgcGFyYW1zLmNzcyApe1xuICAgIGN5LnN0eWxlKCkuYXBwbHlCeXBhc3MoIHRoaXMsIHBhcmFtcy5zdHlsZSB8fCBwYXJhbXMuY3NzICk7XG4gIH1cblxuICBpZiggcmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgKXtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVsZW1lbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCcuLi9kZWZpbmUnKTtcblxudmFyIGVsZXNmbiA9ICh7XG4gIG9uOiBkZWZpbmUub24oKSwgLy8gLm9uKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGRhdGFdLCBoYW5kbGVyKVxuICBvbmU6IGRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gIG9uY2U6IGRlZmluZS5vbih7IHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSksXG4gIG9mZjogZGVmaW5lLm9mZigpLCAvLyAub2ZmKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGhhbmRsZXJdIClcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKSwgLy8gLnRyaWdnZXIoIGV2ZW50cyBbLCBleHRyYVBhcmFtc10gKVxuXG4gIHJ0cmlnZ2VyOiBmdW5jdGlvbihldmVudCwgZXh0cmFQYXJhbXMpeyAvLyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICBpZiggdGhpcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuOyB9IC8vIGVtcHR5IGNvbGxlY3Rpb25zIGRvbid0IG5lZWQgdG8gbm90aWZ5IGFueXRoaW5nXG5cbiAgICAvLyBub3RpZnkgcmVuZGVyZXJcbiAgICB0aGlzLmN5KCkubm90aWZ5KHtcbiAgICAgIHR5cGU6IGV2ZW50LFxuICAgICAgY29sbGVjdGlvbjogdGhpc1xuICAgIH0pO1xuXG4gICAgdGhpcy50cmlnZ2VyKGV2ZW50LCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzOlxuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBlbGVzZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbGVzZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4uL2lzJyk7XG52YXIgU2VsZWN0b3IgPSByZXF1aXJlKCcuLi9zZWxlY3RvcicpO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgbm9kZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihpLCBlbGVtZW50KXtcbiAgICAgIHJldHVybiBlbGVtZW50LmlzTm9kZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG5cbiAgZWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihpLCBlbGVtZW50KXtcbiAgICAgIHJldHVybiBlbGVtZW50LmlzRWRnZSgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG5cbiAgZmlsdGVyOiBmdW5jdGlvbiggZmlsdGVyICl7XG4gICAgaWYoIGlzLmZuKGZpbHRlcikgKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgaWYoIGZpbHRlci5hcHBseShlbGUsIFtpLCBlbGVdKSApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cyk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLnN0cmluZyhmaWx0ZXIpIHx8IGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZmlsdGVyKSApe1xuICAgICAgcmV0dXJuIFNlbGVjdG9yKGZpbHRlcikuZmlsdGVyKHRoaXMpO1xuXG4gICAgfSBlbHNlIGlmKCBmaWx0ZXIgPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oKTsgLy8gaWYgbm90IGhhbmRsZWQgYnkgYWJvdmUsIGdpdmUgJ2VtIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgfSxcblxuICBub3Q6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgIGlmKCAhdG9SZW1vdmUgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmKCBpcy5zdHJpbmcoIHRvUmVtb3ZlICkgKXtcbiAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlciggdG9SZW1vdmUgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbaV07XG5cbiAgICAgICAgdmFyIHJlbW92ZSA9IHRvUmVtb3ZlLl9wcml2YXRlLmlkc1sgZWxlbWVudC5pZCgpIF07XG4gICAgICAgIGlmKCAhcmVtb3ZlICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlbWVudCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cyApO1xuICAgIH1cblxuICB9LFxuXG4gIGFic29sdXRlQ29tcGxlbWVudDogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgcmV0dXJuIGN5LmVsZW1lbnRzKCkubm90KCB0aGlzICk7XG4gIH0sXG5cbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICAvLyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZCwgdGhlbiBmaWx0ZXIgYnkgaXQgaW5zdGVhZFxuICAgIGlmKCBpcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICB2YXIgY29sMVNtYWxsZXIgPSB0aGlzLmxlbmd0aCA8IG90aGVyLmxlbmd0aDtcbiAgICAvLyB2YXIgaWRzMSA9IGNvbDFTbWFsbGVyID8gY29sMS5fcHJpdmF0ZS5pZHMgOiBjb2wyLl9wcml2YXRlLmlkcztcbiAgICB2YXIgaWRzMiA9IGNvbDFTbWFsbGVyID8gY29sMi5fcHJpdmF0ZS5pZHMgOiBjb2wxLl9wcml2YXRlLmlkcztcbiAgICB2YXIgY29sID0gY29sMVNtYWxsZXIgPyBjb2wxIDogY29sMjtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29sLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgaWQgPSBjb2xbaV0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIHZhciBlbGUgPSBpZHMyWyBpZCBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cyApO1xuICB9LFxuXG4gIHhvcjogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmKCBpcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICBvdGhlciA9IGN5LiQoIG90aGVyICk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG5cbiAgICB2YXIgYWRkID0gZnVuY3Rpb24oIGNvbCwgb3RoZXIgKXtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuX3ByaXZhdGUuaWRzWyBpZCBdO1xuXG4gICAgICAgIGlmKCAhaW5PdGhlciApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgYWRkKCBjb2wxLCBjb2wyICk7XG4gICAgYWRkKCBjb2wyLCBjb2wxICk7XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggZWxlbWVudHMgKTtcbiAgfSxcblxuICBkaWZmOiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoIGlzLnN0cmluZyhvdGhlcikgKXtcbiAgICAgIG90aGVyID0gY3kuJCggb3RoZXIgKTtcbiAgICB9XG5cbiAgICB2YXIgbGVmdCA9IFtdO1xuICAgIHZhciByaWdodCA9IFtdO1xuICAgIHZhciBib3RoID0gW107XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG5cbiAgICB2YXIgYWRkID0gZnVuY3Rpb24oIGNvbCwgb3RoZXIsIHJldEVsZXMgKXtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuX3ByaXZhdGUuaWRzWyBpZCBdO1xuXG4gICAgICAgIGlmKCBpbk90aGVyICl7XG4gICAgICAgICAgYm90aC5wdXNoKCBlbGUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXRFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgYWRkKCBjb2wxLCBjb2wyLCBsZWZ0ICk7XG4gICAgYWRkKCBjb2wyLCBjb2wxLCByaWdodCApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMuc3Bhd24oIGxlZnQsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgIHJpZ2h0OiB0aGlzLnNwYXduKCByaWdodCwgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgYm90aDogdGhpcy5zcGF3biggYm90aCwgeyB1bmlxdWU6IHRydWUgfSApXG4gICAgfTtcbiAgfSxcblxuICBhZGQ6IGZ1bmN0aW9uKCB0b0FkZCApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggIXRvQWRkICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiggaXMuc3RyaW5nKHRvQWRkKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5LmVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgZWxlbWVudHMucHVzaCggdGhpc1tpXSApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKysgKXtcblxuICAgICAgdmFyIGFkZCA9ICF0aGlzLl9wcml2YXRlLmlkc1sgdG9BZGRbaV0uaWQoKSBdO1xuICAgICAgaWYoIGFkZCApe1xuICAgICAgICBlbGVtZW50cy5wdXNoKCB0b0FkZFtpXSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGVsZW1lbnRzKTtcbiAgfSxcblxuICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgbWVyZ2U6IGZ1bmN0aW9uKCB0b0FkZCApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG5cbiAgICBpZiggIXRvQWRkICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiggaXMuc3RyaW5nKHRvQWRkKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5LmVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvQWRkLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdG9BZGRFbGUgPSB0b0FkZFtpXTtcbiAgICAgIHZhciBpZCA9IHRvQWRkRWxlLmlkKCk7XG4gICAgICB2YXIgYWRkID0gIV9wLmlkc1sgaWQgXTtcblxuICAgICAgaWYoIGFkZCApe1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxlbmd0aCsrO1xuXG4gICAgICAgIHRoaXNbIGluZGV4IF0gPSB0b0FkZEVsZTtcbiAgICAgICAgX3AuaWRzWyBpZCBdID0gdG9BZGRFbGU7XG4gICAgICAgIF9wLmluZGV4ZXNbIGlkIF0gPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyByZW1vdmUgc2luZ2xlIGVsZSBpbiBwbGFjZSBpbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgdW5tZXJnZU9uZTogZnVuY3Rpb24oIGVsZSApe1xuICAgIGVsZSA9IGVsZVswXTtcblxuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgdmFyIGkgPSBfcC5pbmRleGVzWyBpZCBdO1xuXG4gICAgaWYoIGkgPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIG5vIG5lZWQgdG8gcmVtb3ZlXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVsZVxuICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgX3AuaWRzWyBpZCBdID0gdW5kZWZpbmVkO1xuICAgIF9wLmluZGV4ZXNbIGlkIF0gPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgdW5tZXJnZWRMYXN0RWxlID0gaSA9PT0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgLy8gcmVwbGFjZSBlbXB0eSBzcG90IHdpdGggbGFzdCBlbGUgaW4gY29sbGVjdGlvblxuICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgIXVubWVyZ2VkTGFzdEVsZSApe1xuICAgICAgdmFyIGxhc3RFbGVJID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGxhc3RFbGUgPSB0aGlzWyBsYXN0RWxlSSBdO1xuXG4gICAgICB0aGlzWyBsYXN0RWxlSSBdID0gdW5kZWZpbmVkO1xuICAgICAgdGhpc1tpXSA9IGxhc3RFbGU7XG4gICAgICBfcC5pbmRleGVzWyBsYXN0RWxlLmlkKCkgXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGNvbGxlY3Rpb24gaXMgbm93IDEgZWxlIHNtYWxsZXJcbiAgICB0aGlzLmxlbmd0aC0tO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLy8gcmVtb3ZlIGVsZXMgaW4gcGxhY2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2U6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggIXRvUmVtb3ZlICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiggaXMuc3RyaW5nKHRvUmVtb3ZlKSApe1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9SZW1vdmU7XG4gICAgICB0b1JlbW92ZSA9IGN5LmVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICB0aGlzLnVubWVyZ2VPbmUoIHRvUmVtb3ZlW2ldICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgbWFwOiBmdW5jdGlvbiggbWFwRm4sIHRoaXNBcmcgKXtcbiAgICB2YXIgYXJyID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gbWFwRm4uYXBwbHkoIHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdICkgOiBtYXBGbiggZWxlLCBpLCBlbGVzICk7XG5cbiAgICAgIGFyci5wdXNoKCByZXQgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyO1xuICB9LFxuXG4gIHN0ZEZpbHRlcjogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgdmFyIGZpbHRlckVsZXMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIGluY2x1ZGUgPSB0aGlzQXJnID8gZm4uYXBwbHkoIHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdICkgOiBmbiggZWxlLCBpLCBlbGVzICk7XG5cbiAgICAgIGlmKCBpbmNsdWRlICl7XG4gICAgICAgIGZpbHRlckVsZXMucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGZpbHRlckVsZXMgKTtcbiAgfSxcblxuICBtYXg6IGZ1bmN0aW9uKCB2YWxGbiwgdGhpc0FyZyApe1xuICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1heEVsZTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogdmFsRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICBpZiggdmFsID4gbWF4ICl7XG4gICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgbWF4RWxlID0gZWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogbWF4LFxuICAgICAgZWxlOiBtYXhFbGVcbiAgICB9O1xuICB9LFxuXG4gIG1pbjogZnVuY3Rpb24oIHZhbEZuLCB0aGlzQXJnICl7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtaW5FbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCBlbGVzIF0gKSA6IHZhbEZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgaWYoIHZhbCA8IG1pbiApe1xuICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgIG1pbkVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1pbixcbiAgICAgIGVsZTogbWluRWxlXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXNcbnZhciBmbiA9IGVsZXNmbjtcbmZuWyd1J10gPSBmblsnfCddID0gZm5bJysnXSA9IGZuLnVuaW9uID0gZm4ub3IgPSBmbi5hZGQ7XG5mblsnXFxcXCddID0gZm5bJyEnXSA9IGZuWyctJ10gPSBmbi5kaWZmZXJlbmNlID0gZm4ucmVsYXRpdmVDb21wbGVtZW50ID0gZm4uc3VidHJhY3QgPSBmbi5ub3Q7XG5mblsnbiddID0gZm5bJyYnXSA9IGZuWycuJ10gPSBmbi5hbmQgPSBmbi5pbnRlcnNlY3Rpb24gPSBmbi5pbnRlcnNlY3Q7XG5mblsnXiddID0gZm5bJygrKSddID0gZm5bJygtKSddID0gZm4uc3ltbWV0cmljRGlmZmVyZW5jZSA9IGZuLnN5bWRpZmYgPSBmbi54b3I7XG5mbi5mbkZpbHRlciA9IGZuLmZpbHRlckZuID0gZm4uc3RkRmlsdGVyO1xuZm4uY29tcGxlbWVudCA9IGZuLmFic2NvbXAgPSBmbi5hYnNvbHV0ZUNvbXBsZW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0gKHtcbiAgaXNOb2RlOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdub2Rlcyc7XG4gIH0sXG5cbiAgaXNFZGdlOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdlZGdlcyc7XG4gIH0sXG5cbiAgaXNMb29wOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKCkuaWQoKSA9PT0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICB9LFxuXG4gIGlzU2ltcGxlOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKCkuaWQoKSAhPT0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICB9LFxuXG4gIGdyb3VwOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncm91cDtcbiAgICB9XG4gIH1cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4uL2lzJyk7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi9lbGVtZW50Jyk7XG5cbi8vIGZhY3RvcnkgZm9yIGdlbmVyYXRpbmcgZWRnZSBpZHMgd2hlbiBubyBpZCBpcyBzcGVjaWZpZWQgZm9yIGEgbmV3IGVsZW1lbnRcbnZhciBpZEZhY3RvcnkgPSB7XG4gIHByZWZpeDogJ2VsZScsXG4gIGlkOiAwLFxuICBnZW5lcmF0ZTogZnVuY3Rpb24oY3ksIGVsZW1lbnQsIHRyeVRoaXNJZCl7XG4gICAgdmFyIGpzb24gPSBpcy5lbGVtZW50KCBlbGVtZW50ICkgPyBlbGVtZW50Ll9wcml2YXRlIDogZWxlbWVudDtcbiAgICB2YXIgaWQgPSB0cnlUaGlzSWQgIT0gbnVsbCA/IHRyeVRoaXNJZCA6IHRoaXMucHJlZml4ICsgdGhpcy5pZDtcblxuICAgIGlmKCBjeS5nZXRFbGVtZW50QnlJZChpZCkuZW1wdHkoKSApe1xuICAgICAgdGhpcy5pZCsrOyAvLyB3ZSd2ZSB1c2VkIHRoZSBjdXJyZW50IGlkLCBzbyBtb3ZlIGl0IHVwXG4gICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIGtlZXAgdHJ5aW5nIHN1Y2Nlc3NpdmUgdW51c2VkIGlkc1xuICAgICAgd2hpbGUoICFjeS5nZXRFbGVtZW50QnlJZChpZCkuZW1wdHkoKSApe1xuICAgICAgICBpZCA9IHRoaXMucHJlZml4ICsgKCArK3RoaXMuaWQgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cbn07XG5cbi8vIHJlcHJlc2VudHMgYSBzZXQgb2Ygbm9kZXMsIGVkZ2VzLCBvciBib3RoIHRvZ2V0aGVyXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKGN5LCBlbGVtZW50cywgb3B0aW9ucyl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSApe1xuICAgIHJldHVybiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlbWVudHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgIWlzLmNvcmUoY3kpICl7XG4gICAgdXRpbC5lcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZHMgPSB7fTtcbiAgdmFyIGluZGV4ZXMgPSB7fTtcbiAgdmFyIGNyZWF0ZWRFbGVtZW50cyA9IGZhbHNlO1xuXG4gIGlmKCAhZWxlbWVudHMgKXtcbiAgICBlbGVtZW50cyA9IFtdO1xuICB9IGVsc2UgaWYoIGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgaXMucGxhaW5PYmplY3QoIGVsZW1lbnRzWzBdICkgJiYgIWlzLmVsZW1lbnQoIGVsZW1lbnRzWzBdICkgKXtcbiAgICBjcmVhdGVkRWxlbWVudHMgPSB0cnVlO1xuXG4gICAgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcbiAgICB2YXIgZWxlcyA9IFtdO1xuICAgIHZhciBlbGVzSWRzID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcblxuICAgICAgaWYoIGpzb24uZGF0YSA9PSBudWxsICl7XG4gICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IGpzb24uZGF0YTtcblxuICAgICAgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcbiAgICAgIGlmKCBkYXRhLmlkID09IG51bGwgKXtcbiAgICAgICAgZGF0YS5pZCA9IGlkRmFjdG9yeS5nZW5lcmF0ZSggY3ksIGpzb24gKTtcbiAgICAgIH0gZWxzZSBpZiggY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuaWQgKS5sZW5ndGggIT09IDAgfHwgZWxlc0lkc1sgZGF0YS5pZCBdICl7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBwcmlvciBpZCBhbHJlYWR5IGV4aXN0c1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoIGN5LCBqc29uLCBmYWxzZSApO1xuICAgICAgZWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgIGVsZXNJZHNbIGRhdGEuaWQgXSA9IHRydWU7XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBlbGVzO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICBpZiggIWVsZW1lbnQgKXsgIGNvbnRpbnVlOyB9XG5cbiAgICB2YXIgaWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG5cbiAgICBpZiggIW9wdGlvbnMgfHwgKG9wdGlvbnMudW5pcXVlICYmICFpZHNbIGlkIF0gKSApe1xuICAgICAgaWRzWyBpZCBdID0gZWxlbWVudDtcbiAgICAgIGluZGV4ZXNbIGlkIF0gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgdGhpc1sgdGhpcy5sZW5ndGggXSA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGlkczogaWRzLFxuICAgIGluZGV4ZXM6IGluZGV4ZXNcbiAgfTtcblxuICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gIGlmKCBjcmVhdGVkRWxlbWVudHMgKXtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxufTtcblxuLy8gRnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbi8vIGFuZCB1c2UgZWxlZm4gYW5kIGVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG52YXIgZWxlc2ZuID0gRWxlbWVudC5wcm90b3R5cGUgPSBDb2xsZWN0aW9uLnByb3RvdHlwZTtcblxuZWxlc2ZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICdjb2xsZWN0aW9uJztcbn07XG5cbmVsZXNmbi5zcGF3biA9IGZ1bmN0aW9uKCBjeSwgZWxlcywgb3B0cyApe1xuICBpZiggIWlzLmNvcmUoY3kpICl7IC8vIGN5IGlzIG9wdGlvbmFsXG4gICAgb3B0cyA9IGVsZXM7XG4gICAgZWxlcyA9IGN5O1xuICAgIGN5ID0gdGhpcy5jeSgpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCBjeSwgZWxlcywgb3B0cyApO1xufTtcblxuZWxlc2ZuLmN5ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG59O1xuXG5lbGVzZm4uZWxlbWVudCA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzWzBdO1xufTtcblxuZWxlc2ZuLmNvbGxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICBpZiggaXMuY29sbGVjdGlvbih0aGlzKSApe1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgeyAvLyBhbiBlbGVtZW50XG4gICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBbdGhpc10gKTtcbiAgfVxufTtcblxuZWxlc2ZuLnVuaXF1ZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgdGhpcywgeyB1bmlxdWU6IHRydWUgfSApO1xufTtcblxuZWxlc2ZuLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24oIGlkICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGUgPSB0aGlzLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICByZXR1cm4gZWxlID8gZWxlIDogbmV3IENvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbn07XG5cbmVsZXNmbi5qc29uID0gZnVuY3Rpb24oIG9iaiApe1xuICB2YXIgZWxlID0gdGhpcy5lbGVtZW50KCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICBpZiggZWxlID09IG51bGwgJiYgb2JqICl7IHJldHVybiB0aGlzOyB9IC8vIGNhbid0IHNldCB0byBubyBlbGVzXG5cbiAgaWYoIGVsZSA9PSBudWxsICl7IHJldHVybiB1bmRlZmluZWQ7IH0gLy8gY2FuJ3QgZ2V0IGZyb20gbm8gZWxlc1xuXG4gIHZhciBwID0gZWxlLl9wcml2YXRlO1xuXG4gIGlmKCBpcy5wbGFpbk9iamVjdChvYmopICl7IC8vIHNldFxuXG4gICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgaWYoIG9iai5kYXRhICl7XG4gICAgICBlbGUuZGF0YSggb2JqLmRhdGEgKTtcbiAgICB9XG5cbiAgICBpZiggb2JqLnBvc2l0aW9uICl7XG4gICAgICBlbGUucG9zaXRpb24oIG9iai5wb3NpdGlvbiApO1xuICAgIH1cblxuICAgIC8vIGlnbm9yZSBncm91cCAtLSBpbW11dGFibGVcblxuICAgIHZhciBjaGVja1N3aXRjaCA9IGZ1bmN0aW9uKCBrLCB0cnVlRm5OYW1lLCBmYWxzZUZuTmFtZSApe1xuICAgICAgdmFyIG9ial9rID0gb2JqW2tdO1xuXG4gICAgICBpZiggb2JqX2sgIT0gbnVsbCAmJiBvYmpfayAhPT0gcFtrXSApe1xuICAgICAgICBpZiggb2JqX2sgKXtcbiAgICAgICAgICBlbGVbIHRydWVGbk5hbWUgXSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZVsgZmFsc2VGbk5hbWUgXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrU3dpdGNoKCAncmVtb3ZlZCcsICdyZW1vdmUnLCAncmVzdG9yZScgKTtcblxuICAgIGNoZWNrU3dpdGNoKCAnc2VsZWN0ZWQnLCAnc2VsZWN0JywgJ3Vuc2VsZWN0JyApO1xuXG4gICAgY2hlY2tTd2l0Y2goICdzZWxlY3RhYmxlJywgJ3NlbGVjdGlmeScsICd1bnNlbGVjdGlmeScgKTtcblxuICAgIGNoZWNrU3dpdGNoKCAnbG9ja2VkJywgJ2xvY2snLCAndW5sb2NrJyApO1xuXG4gICAgY2hlY2tTd2l0Y2goICdncmFiYmFibGUnLCAnZ3JhYmlmeScsICd1bmdyYWJpZnknICk7XG5cbiAgICBpZiggb2JqLmNsYXNzZXMgIT0gbnVsbCApe1xuICAgICAgZWxlLmNsYXNzZXMoIG9iai5jbGFzc2VzICk7XG4gICAgfVxuXG4gICAgY3kuZW5kQmF0Y2goKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0gZWxzZSBpZiggb2JqID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0XG5cbiAgICB2YXIganNvbiA9IHtcbiAgICAgIGRhdGE6IHV0aWwuY29weSggcC5kYXRhICksXG4gICAgICBwb3NpdGlvbjogdXRpbC5jb3B5KCBwLnBvc2l0aW9uICksXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICBjbGFzc2VzOiBudWxsXG4gICAgfTtcblxuICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgZm9yKCB2YXIgY2xzIGluIHAuY2xhc3NlcyApe1xuICAgICAgaWYoIHAuY2xhc3Nlc1tjbHNdICl7XG4gICAgICAgIGNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBqc29uLmNsYXNzZXMgPSBjbGFzc2VzLmpvaW4oJyAnKTtcblxuICAgIHJldHVybiBqc29uO1xuICB9XG59O1xuXG5lbGVzZm4uanNvbnMgPSBmdW5jdGlvbigpe1xuICB2YXIganNvbnMgPSBbXTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG5cbiAgICBqc29ucy5wdXNoKCBqc29uICk7XG4gIH1cblxuICByZXR1cm4ganNvbnM7XG59O1xuXG5lbGVzZm4uY2xvbmUgPSBmdW5jdGlvbigpe1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBlbGVzQXJyID0gW107XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgIHZhciBjbG9uZSA9IG5ldyBFbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgIGVsZXNBcnIucHVzaCggY2xvbmUgKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQ29sbGVjdGlvbiggY3ksIGVsZXNBcnIgKTtcbn07XG5lbGVzZm4uY29weSA9IGVsZXNmbi5jbG9uZTtcblxuZWxlc2ZuLnJlc3RvcmUgPSBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcmVzdG9yZWQgPSBbXTtcbiAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuXG4gIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gY3JlYXRlIGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMsIHNpbmNlIHdlIG5lZWQgdG9cbiAgLy8gcmVzdG9yZSB0aGUgbm9kZXMgZmlyc3RcbiAgdmFyIGVsZW1lbnRzID0gW107XG4gIHZhciBub2RlcyA9IFtdLCBlZGdlcyA9IFtdO1xuICB2YXIgbnVtTm9kZXMgPSAwO1xuICB2YXIgbnVtRWRnZXMgPSAwO1xuICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcbiAgICBpZiggZWxlLmlzTm9kZSgpICl7IC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICBub2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgIG51bU5vZGVzKys7XG4gICAgfSBlbHNlIHsgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICAgIG51bUVkZ2VzKys7XG4gICAgfVxuICB9XG5cbiAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoIGVkZ2VzICk7XG5cbiAgLy8gbm93LCByZXN0b3JlIGVhY2ggZWxlbWVudFxuICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVtZW50c1tpXTtcblxuICAgIGlmKCAhZWxlLnJlbW92ZWQoKSApe1xuICAgICAgLy8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIF9wcml2YXRlID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBkYXRhID0gX3ByaXZhdGUuZGF0YTtcblxuICAgIC8vIHNldCBpZCBhbmQgdmFsaWRhdGVcbiAgICBpZiggZGF0YS5pZCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBkYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKCBjeSwgZWxlICk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLm51bWJlcihkYXRhLmlkKSApe1xuICAgICAgZGF0YS5pZCA9ICcnICsgZGF0YS5pZDsgLy8gbm93IGl0J3MgYSBzdHJpbmdcblxuICAgIH0gZWxzZSBpZiggaXMuZW1wdHlTdHJpbmcoZGF0YS5pZCkgfHwgIWlzLnN0cmluZyhkYXRhLmlkKSApe1xuICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgZGF0YS5pZCArICdgJyk7XG5cbiAgICAgIC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIGl0IGhhcyBlbXB0eSBzdHJpbmcgYXMgaWQgb3Igbm9uLXN0cmluZyBpZFxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmKCBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS5pZCApLmxlbmd0aCAhPT0gMCApe1xuICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgc2Vjb25kIGVsZW1lbnQgd2l0aCBJRCBgJyArIGRhdGEuaWQgKyAnYCcpO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gZGF0YS5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuXG4gICAgaWYoIGVsZS5pc05vZGUoKSApeyAvLyBleHRyYSBjaGVja3MgZm9yIG5vZGVzXG4gICAgICB2YXIgbm9kZSA9IGVsZTtcbiAgICAgIHZhciBwb3MgPSBfcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBub2RlcyBoYXZlIGEgZGVmaW5lZCBwb3NpdGlvblxuXG4gICAgICBpZiggcG9zLnggPT0gbnVsbCApe1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmKCBwb3MueSA9PSBudWxsICl7XG4gICAgICAgIHBvcy55ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggZWxlLmlzRWRnZSgpICl7IC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcblxuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgZmllbGRzID0gWydzb3VyY2UnLCAndGFyZ2V0J107XG4gICAgICB2YXIgZmllbGRzTGVuZ3RoID0gZmllbGRzLmxlbmd0aDtcbiAgICAgIHZhciBiYWRTb3VyY2VPclRhcmdldCA9IGZhbHNlO1xuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGZpZWxkc0xlbmd0aDsgaisrKXtcblxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgIHZhciB2YWwgPSBkYXRhW2ZpZWxkXTtcblxuICAgICAgICBpZiggaXMubnVtYmVyKHZhbCkgKXtcbiAgICAgICAgICB2YWwgPSBkYXRhW2ZpZWxkXSA9ICcnICsgZGF0YVtmaWVsZF07IC8vIG5vdyBzdHJpbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCB2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnICl7XG4gICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGRlZmluZWQgcHJvcGVybHlcbiAgICAgICAgICB1dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYoIGN5LmdldEVsZW1lbnRCeUlkKHZhbCkuZW1wdHkoKSApe1xuICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggbm9uZXhpc3RhbnQgJyArIGZpZWxkICsgJyBgJyArIHZhbCArICdgJyk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBiYWRTb3VyY2VPclRhcmdldCApeyBjb250aW51ZTsgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuXG4gICAgICB2YXIgc3JjID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuc291cmNlICk7XG4gICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEudGFyZ2V0ICk7XG5cbiAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuXG4gICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuXG4gICAgfSAvLyBpZiBpcyBlZGdlXG5cbiAgICAvLyBjcmVhdGUgbW9jayBpZHMgbWFwIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcbiAgICBfcHJpdmF0ZS5pZHMgPSB7fTtcbiAgICBfcHJpdmF0ZS5pZHNbIGlkIF0gPSBlbGU7XG5cbiAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG4gICAgY3kuYWRkVG9Qb29sKCBlbGUgKTtcblxuICAgIHJlc3RvcmVkLnB1c2goIGVsZSApO1xuICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcblxuICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7IC8vIGVhY2ggbm9kZVxuICAgIHZhciBub2RlID0gZWxlbWVudHNbaV07XG4gICAgdmFyIGRhdGEgPSBub2RlLl9wcml2YXRlLmRhdGE7XG5cbiAgICBpZiggaXMubnVtYmVyKGRhdGEucGFyZW50KSApeyAvLyB0aGVuIGF1dG9tYWtlIHN0cmluZ1xuICAgICAgZGF0YS5wYXJlbnQgPSAnJyArIGRhdGEucGFyZW50O1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRJZCA9IGRhdGEucGFyZW50O1xuXG4gICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG5cbiAgICBpZiggc3BlY2lmaWVkUGFyZW50ICl7XG4gICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHBhcmVudElkICk7XG5cbiAgICAgIGlmKCBwYXJlbnQuZW1wdHkoKSApe1xuICAgICAgICAvLyBub24tZXhpc3RhbnQgcGFyZW50OyBqdXN0IHJlbW92ZSBpdFxuICAgICAgICBkYXRhLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmQXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgICB3aGlsZSggIWFuY2VzdG9yLmVtcHR5KCkgKXtcbiAgICAgICAgICBpZiggbm9kZS5zYW1lKGFuY2VzdG9yKSApe1xuICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGRhdGEucGFyZW50ID0gdW5kZWZpbmVkOyAvLyByZW1vdmUgcGFyZW50IHJlZmVyZW5jZVxuXG4gICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhc2VsZkFzUGFyZW50ICl7XG4gICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2goIG5vZGUgKTtcbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IHBhcmVudFswXTtcblxuICAgICAgICAgIC8vIGxldCB0aGUgY29yZSBrbm93IHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaFxuICAgICAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVsc2VcbiAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcbiAgfSAvLyBmb3IgZWFjaCBub2RlXG5cbiAgcmVzdG9yZWQgPSBuZXcgQ29sbGVjdGlvbiggY3ksIHJlc3RvcmVkICk7XG4gIGlmKCByZXN0b3JlZC5sZW5ndGggPiAwICl7XG5cbiAgICB2YXIgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkLmFkZCggcmVzdG9yZWQuY29ubmVjdGVkTm9kZXMoKSApLmFkZCggcmVzdG9yZWQucGFyZW50KCkgKTtcbiAgICB0b1VwZGF0ZVN0eWxlLnVwZGF0ZVN0eWxlKCBub3RpZnlSZW5kZXJlciApO1xuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICByZXN0b3JlZC5ydHJpZ2dlcignYWRkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVkLnRyaWdnZXIoJ2FkZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbn07XG5cbmVsZXNmbi5yZW1vdmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuXG5lbGVzZm4uaW5zaWRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgIWVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xufTtcblxuZWxlc2ZuLnJlbW92ZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByZW1vdmVkID0gW107XG4gIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5O1xuXG4gIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICB9XG5cbiAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlc1xuICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyhub2RlKXtcbiAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGFkZCggZWRnZXNbaV0gKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGFkZCBkZXNjZW5kYW50IG5vZGVzXG4gIGZ1bmN0aW9uIGFkZENoaWxkcmVuKG5vZGUpe1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICl7XG4gICAgICBhZGQoIGNoaWxkcmVuW2ldICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkKCBlbGUgKXtcbiAgICB2YXIgYWxyZWFkeUFkZGVkID0gIGVsZXNUb1JlbW92ZUlkc1sgZWxlLmlkKCkgXTtcbiAgICBpZiggYWxyZWFkeUFkZGVkICl7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXNUb1JlbW92ZUlkc1sgZWxlLmlkKCkgXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgZWxlc1RvUmVtb3ZlLnB1c2goIGVsZSApOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKCBlbGUgKTtcbiAgICAgIGFkZENoaWxkcmVuKCBlbGUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlc1RvUmVtb3ZlLnVuc2hpZnQoIGVsZSApOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgIH1cbiAgfVxuXG4gIC8vIG1ha2UgdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICBhZGQoIGVsZSApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRWRnZVJlZihub2RlLCBlZGdlKXtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG5cbiAgICAgIGlmKCBlZGdlID09PSBjb25uZWN0ZWRFZGdlICl7XG4gICAgICAgIGNvbm5lY3RlZEVkZ2VzLnNwbGljZSggaiwgMSApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSl7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrICl7XG4gICAgICBpZiggY2hpbGRyZW5bal1bMF0gPT09IGVsZVswXSApe1xuICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNUb1JlbW92ZVtpXTtcblxuICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgIGVsZS5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcblxuICAgIC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICAgIGN5LnJlbW92ZUZyb21Qb29sKCBlbGUgKTtcblxuICAgIC8vIGFkZCB0byBsaXN0IG9mIHJlbW92ZWQgZWxlbWVudHNcbiAgICByZW1vdmVkLnB1c2goIGVsZSApO1xuXG4gICAgaWYoIGVsZS5pc0VkZ2UoKSApeyAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgdmFyIHNyYyA9IGVsZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB0Z3QgPSBlbGUudGFyZ2V0KClbMF07XG5cbiAgICAgIHJlbW92ZUVkZ2VSZWYoIHNyYywgZWxlICk7XG4gICAgICByZW1vdmVFZGdlUmVmKCB0Z3QsIGVsZSApO1xuXG4gICAgfSBlbHNlIHsgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KCk7XG5cbiAgICAgIGlmKCBwYXJlbnQubGVuZ3RoICE9PSAwICl7XG4gICAgICAgIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgZWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1N0aWxsSW5zaWRlW2ldO1xuXG4gICAgaWYoIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbiggdGhpcy5jeSgpLCByZW1vdmVkICk7XG4gIGlmKCByZW1vdmVkRWxlbWVudHMuc2l6ZSgpID4gMCApe1xuICAgIC8vIG11c3QgbWFudWFsbHkgbm90aWZ5IHNpbmNlIHRyaWdnZXIgd29uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IG9uY2UgcmVtb3ZlZFxuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB0aGlzLmN5KCkubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgIGNvbGxlY3Rpb246IHJlbW92ZWRFbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlZEVsZW1lbnRzLnRyaWdnZXIoJ3JlbW92ZScpO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGVtcHR5IHJlbWFpbmluZyBwYXJlbnQgbm9kZXNcbiAgdmFyIGNoZWNrZWRQYXJlbnRJZCA9IHt9O1xuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBlbGVzVG9SZW1vdmVbaV07XG4gICAgdmFyIGlzTm9kZSA9IGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJztcbiAgICB2YXIgcGFyZW50SWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQ7XG5cbiAgICBpZiggaXNOb2RlICYmIHBhcmVudElkICE9PSB1bmRlZmluZWQgJiYgIWNoZWNrZWRQYXJlbnRJZFsgcGFyZW50SWQgXSApe1xuICAgICAgY2hlY2tlZFBhcmVudElkWyBwYXJlbnRJZCBdID0gdHJ1ZTtcbiAgICAgIHZhciBwYXJlbnQgPSBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKTtcblxuICAgICAgaWYoIHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoICE9PSAwICYmICFwYXJlbnQuX3ByaXZhdGUucmVtb3ZlZCAmJiBwYXJlbnQuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgcGFyZW50LnVwZGF0ZVN0eWxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKCBjeSwgcmVtb3ZlZCApO1xufTtcblxuZWxlc2ZuLm1vdmUgPSBmdW5jdGlvbiggc3RydWN0ICl7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgaWYoIHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQgKXtcbiAgICB2YXIgc3JjSWQgPSBzdHJ1Y3Quc291cmNlO1xuICAgIHZhciB0Z3RJZCA9IHN0cnVjdC50YXJnZXQ7XG4gICAgdmFyIHNyY0V4aXN0cyA9IGN5LmdldEVsZW1lbnRCeUlkKCBzcmNJZCApLmxlbmd0aCA+IDA7XG4gICAgdmFyIHRndEV4aXN0cyA9IGN5LmdldEVsZW1lbnRCeUlkKCB0Z3RJZCApLmxlbmd0aCA+IDA7XG5cbiAgICBpZiggc3JjRXhpc3RzIHx8IHRndEV4aXN0cyApe1xuICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuXG4gICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG5cbiAgICAgICAgaWYoIGpzb24uZ3JvdXAgPT09ICdlZGdlcycgKXtcbiAgICAgICAgICBpZiggc3JjRXhpc3RzICl7IGpzb24uZGF0YS5zb3VyY2UgPSBzcmNJZDsgfVxuICAgICAgICAgIGlmKCB0Z3RFeGlzdHMgKXsganNvbi5kYXRhLnRhcmdldCA9IHRndElkOyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKTtcbiAgICB9XG5cbiAgfSBlbHNlIGlmKCBzdHJ1Y3QucGFyZW50ICE9PSB1bmRlZmluZWQgKXsgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICB2YXIgcGFyZW50SWQgPSBzdHJ1Y3QucGFyZW50O1xuICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKS5sZW5ndGggPiAwO1xuXG4gICAgaWYoIHBhcmVudEV4aXN0cyApe1xuICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuICAgICAgdmFyIGRlc2NzID0gdGhpcy5kZXNjZW5kYW50cygpO1xuICAgICAgdmFyIGRlc2NzRXRjID0gZGVzY3MubWVyZ2UoIGRlc2NzLmFkZCh0aGlzKS5jb25uZWN0ZWRFZGdlcygpICk7XG5cbiAgICAgIHRoaXMucmVtb3ZlKCk7IC8vIE5COiBhbHNvIHJlbW92ZXMgZGVzY2VuZGFudHMgYW5kIHRoZWlyIGNvbm5lY3RlZCBlZGdlc1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcblxuICAgICAgICBpZigganNvbi5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICAgIGpzb24uZGF0YS5wYXJlbnQgPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKS5tZXJnZSggZGVzY3NFdGMucmVzdG9yZSgpICk7XG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gaWYgbm90aGluZyBkb25lXG59O1xuXG5bXG4gIHJlcXVpcmUoJy4vYWxnb3JpdGhtcycpLFxuICByZXF1aXJlKCcuL2FuaW1hdGlvbicpLFxuICByZXF1aXJlKCcuL2NsYXNzJyksXG4gIHJlcXVpcmUoJy4vY29tcGFyYXRvcnMnKSxcbiAgcmVxdWlyZSgnLi9jb21wb3VuZHMnKSxcbiAgcmVxdWlyZSgnLi9kYXRhJyksXG4gIHJlcXVpcmUoJy4vZGVncmVlJyksXG4gIHJlcXVpcmUoJy4vZGltZW5zaW9ucycpLFxuICByZXF1aXJlKCcuL2V2ZW50cycpLFxuICByZXF1aXJlKCcuL2ZpbHRlcicpLFxuICByZXF1aXJlKCcuL2dyb3VwJyksXG4gIHJlcXVpcmUoJy4vaW5kZXgnKSxcbiAgcmVxdWlyZSgnLi9pdGVyYXRpb24nKSxcbiAgcmVxdWlyZSgnLi9sYXlvdXQnKSxcbiAgcmVxdWlyZSgnLi9zdHlsZScpLFxuICByZXF1aXJlKCcuL3N3aXRjaC1mdW5jdGlvbnMnKSxcbiAgcmVxdWlyZSgnLi90cmF2ZXJzaW5nJylcbl0uZm9yRWFjaChmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIGVsZXNmbiwgcHJvcHMgKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4uL2lzJyk7XG52YXIgekluZGV4U29ydCA9IHJlcXVpcmUoJy4venNvcnQnKTtcblxudmFyIGVsZXNmbiA9ICh7XG4gIGVhY2g6IGZ1bmN0aW9uKGZuKXtcbiAgICBpZiggaXMuZm4oZm4pICl7XG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gZm4uYXBwbHkoIGVsZSwgWyBpLCBlbGUgXSApO1xuXG4gICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7IGJyZWFrOyB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZm9yRWFjaDogZnVuY3Rpb24oZm4sIHRoaXNBcmcpe1xuICAgIGlmKCBpcy5mbihmbikgKXtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBmbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIHRoaXMgXSApIDogZm4oIGVsZSwgaSwgdGhpcyApO1xuXG4gICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7IGJyZWFrOyB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbigpe1xuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgYXJyYXkucHVzaCggdGhpc1tpXSApO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcblxuICBzbGljZTogZnVuY3Rpb24oc3RhcnQsIGVuZCl7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIHRoaXNTaXplID0gdGhpcy5sZW5ndGg7XG5cbiAgICBpZiggZW5kID09IG51bGwgKXtcbiAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgIH1cblxuICAgIGlmKCBzdGFydCA9PSBudWxsICl7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuXG4gICAgaWYoIHN0YXJ0IDwgMCApe1xuICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgIH1cblxuICAgIGlmKCBlbmQgPCAwICl7XG4gICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICB9XG5cbiAgICBmb3IodmFyIGkgPSBzdGFydDsgaSA+PSAwICYmIGkgPCBlbmQgJiYgaSA8IHRoaXNTaXplOyBpKyspe1xuICAgICAgYXJyYXkucHVzaCggdGhpc1tpXSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKGFycmF5KTtcbiAgfSxcblxuICBzaXplOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfSxcblxuICBlcTogZnVuY3Rpb24oaSl7XG4gICAgcmV0dXJuIHRoaXNbaV0gfHwgdGhpcy5zcGF3bigpO1xuICB9LFxuXG4gIGZpcnN0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzWzBdIHx8IHRoaXMuc3Bhd24oKTtcbiAgfSxcblxuICBsYXN0OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzWyB0aGlzLmxlbmd0aCAtIDEgXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG5cbiAgZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICB9LFxuXG4gIG5vbmVtcHR5OiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhdGhpcy5lbXB0eSgpO1xuICB9LFxuXG4gIHNvcnQ6IGZ1bmN0aW9uKCBzb3J0Rm4gKXtcbiAgICBpZiggIWlzLmZuKCBzb3J0Rm4gKSApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIHNvcnRlZCA9IHRoaXMudG9BcnJheSgpLnNvcnQoIHNvcnRGbiApO1xuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc29ydGVkKTtcbiAgfSxcblxuICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuc29ydCggekluZGV4U29ydCApO1xuICB9LFxuXG4gIHpEZXB0aDogZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiggIWVsZSApeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAvLyB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGdyb3VwID0gX3AuZ3JvdXA7XG5cbiAgICBpZiggZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgIHZhciBkZXB0aCA9IF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKS5zaXplKCkgOiAwO1xuXG4gICAgICBpZiggIWVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFOyAvLyBjaGlsZGxlc3Mgbm9kZXMgYWx3YXlzIG9uIHRvcFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLnpEZXB0aCgpO1xuICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuXG4gICAgICByZXR1cm4gTWF0aC5tYXgoIHNyY0RlcHRoLCB0Z3REZXB0aCwgMCApOyAvLyBkZXB0aCBvZiBkZWVwZXN0IHBhcmVudFxuICAgIH1cbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBlbGVzZm4gPSAoe1xuXG4gIC8vIHVzaW5nIHN0YW5kYXJkIGxheW91dCBvcHRpb25zLCBhcHBseSBwb3NpdGlvbiBmdW5jdGlvbiAody8gb3Igdy9vIGFuaW1hdGlvbilcbiAgbGF5b3V0UG9zaXRpb25zOiBmdW5jdGlvbiggbGF5b3V0LCBvcHRpb25zLCBmbiApe1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgbGF5b3V0LmFuaW1hdGlvbnMgPSBbXTtcblxuICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGxhc3ROb2RlID0gaSA9PT0gbm9kZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICB2YXIgbmV3UG9zID0gZm4uY2FsbCggbm9kZSwgaSwgbm9kZSApO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuXG4gICAgICAgIGlmKCAhaXMubnVtYmVyKHBvcy54KSB8fCAhaXMubnVtYmVyKHBvcy55KSApe1xuICAgICAgICAgIG5vZGUuc2lsZW50UG9zaXRpb24oeyB4OiAwLCB5OiAwIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuaSA9IG5vZGUuYW5pbWF0aW9uKHtcbiAgICAgICAgICBwb3NpdGlvbjogbmV3UG9zLFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmcsXG4gICAgICAgICAgc3RlcDogIWxhc3ROb2RlID8gdW5kZWZpbmVkIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICBjeS5maXQoIG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb21wbGV0ZTogIWxhc3ROb2RlID8gdW5kZWZpbmVkIDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKCBvcHRpb25zLnpvb20gIT0gbnVsbCApe1xuICAgICAgICAgICAgICBjeS56b29tKCBvcHRpb25zLnpvb20gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIG9wdGlvbnMucGFuICl7XG4gICAgICAgICAgICAgIGN5LnBhbiggb3B0aW9ucy5wYW4gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsYXlvdXQuYW5pbWF0aW9ucy5wdXNoKCBhbmkgKTtcblxuICAgICAgICBhbmkucGxheSgpO1xuICAgICAgfVxuXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMucG9zaXRpb25zKCBmbiApO1xuXG4gICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgY3kuZml0KCBvcHRpb25zLmVsZXMsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy56b29tICE9IG51bGwgKXtcbiAgICAgICAgY3kuem9vbSggb3B0aW9ucy56b29tICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRpb25zLnBhbiApe1xuICAgICAgICBjeS5wYW4oIG9wdGlvbnMucGFuICk7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBsYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgY3kubGF5b3V0KCB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgZWxlczogdGhpc1xuICAgIH0pICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtYWtlTGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIHJldHVybiBjeS5tYWtlTGF5b3V0KCB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgZWxlczogdGhpc1xuICAgIH0pICk7XG4gIH1cblxufSk7XG5cbi8vIGFsaWFzZXM6XG5lbGVzZm4uY3JlYXRlTGF5b3V0ID0gZWxlc2ZuLm1ha2VMYXlvdXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG52YXIgZWxlc2ZuID0gKHtcblxuICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgaWYoIGN5Ll9wcml2YXRlLmJhdGNoaW5nU3R5bGUgKXtcbiAgICAgIHZhciBiRWxlcyA9IGN5Ll9wcml2YXRlLmJhdGNoU3R5bGVFbGVzO1xuXG4gICAgICBiRWxlcy5tZXJnZSggdGhpcyApO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmcgYW5kIGV4aXQgZWFybHkgd2hlbiBiYXRjaGluZ1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgc3R5bGUuYXBwbHkoIHRoaXMgKTtcblxuICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgIH0gZWxzZSB7XG4gICAgICB0b05vdGlmeS50cmlnZ2VyKCdzdHlsZScpOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIC8vIGp1c3QgdXBkYXRlIHRoZSBtYXBwZXJzIGluIHRoZSBlbGVtZW50cycgc3R5bGVzOyBjaGVhcGVyIHRoYW4gZWxlcy51cGRhdGVTdHlsZSgpXG4gIHVwZGF0ZU1hcHBlcnM6IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICBzdHlsZS51cGRhdGVNYXBwZXJzKCB0aGlzICk7XG5cbiAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcblxuICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgdG9Ob3RpZnkudHJpZ2dlcignc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBnZXQgdGhlIHNwZWNpZmllZCBjc3MgcHJvcGVydHkgYXMgYSByZW5kZXJlZCB2YWx1ZSAoaS5lLiBvbi1zY3JlZW4gdmFsdWUpXG4gIC8vIG9yIGdldCB0aGUgd2hvbGUgcmVuZGVyZWQgc3R5bGUgaWYgbm8gcHJvcGVydHkgc3BlY2lmaWVkIChOQiBkb2Vzbid0IGFsbG93IHNldHRpbmcpXG4gIHJlbmRlcmVkQ3NzOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgcmVuc3R5bGUgPSBlbGUuY3koKS5zdHlsZSgpLmdldFJlbmRlcmVkU3R5bGUoIGVsZSApO1xuXG4gICAgICBpZiggcHJvcGVydHkgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gcmVuc3R5bGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVuc3R5bGVbIHByb3BlcnR5IF07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICBjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICBpZiggaXMucGxhaW5PYmplY3QobmFtZSkgKXsgLy8gdGhlbiBleHRlbmQgdGhlIGJ5cGFzc1xuICAgICAgdmFyIHByb3BzID0gbmFtZTtcbiAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKCB0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcblxuICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgfSBlbHNlIGlmKCBpcy5zdHJpbmcobmFtZSkgKXtcblxuICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKCBlbGUsIG5hbWUgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7IC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3MoIHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuXG4gICAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoIG5hbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKCBlbGUgKTtcbiAgICAgIH0gZWxzZSB7IC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVtb3ZlQ3NzOiBmdW5jdGlvbiggbmFtZXMgKXtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgIGlmKCBuYW1lcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoIGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoIGVsZSwgbmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG4gICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBzaG93OiBmdW5jdGlvbigpe1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ2VsZW1lbnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBoaWRlOiBmdW5jdGlvbigpe1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB2aXNpYmxlOiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0cnVlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgaWYoXG4gICAgICAgIHN0eWxlWyd2aXNpYmlsaXR5J10udmFsdWUgIT09ICd2aXNpYmxlJ1xuICAgICAgICB8fCBzdHlsZVsnZGlzcGxheSddLnZhbHVlICE9PSAnZWxlbWVudCdcbiAgICAgICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICB2YXIgcGFyZW50cyA9IGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkgOiBudWxsO1xuXG4gICAgICAgIGlmKCBwYXJlbnRzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBwU3R5bGUgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgICB2YXIgcFZpcyA9IHBTdHlsZVsndmlzaWJpbGl0eSddLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHBEaXMgPSBwU3R5bGVbJ2Rpc3BsYXknXS52YWx1ZTtcblxuICAgICAgICAgICAgaWYoIHBWaXMgIT09ICd2aXNpYmxlJyB8fCBwRGlzICE9PSAnZWxlbWVudCcgKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAgIHJldHVybiBzcmMudmlzaWJsZSgpICYmIHRndC52aXNpYmxlKCk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0sXG5cbiAgaGlkZGVuOiBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICAgIH1cbiAgfSxcblxuICBlZmZlY3RpdmVPcGFjaXR5OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiAxOyB9XG5cbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gX3Auc3R5bGUub3BhY2l0eS52YWx1ZTtcblxuICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7IHJldHVybiBwYXJlbnRPcGFjaXR5OyB9XG5cbiAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG5cbiAgICAgIGlmKCBwYXJlbnRzICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50Ll9wcml2YXRlLnN0eWxlLm9wYWNpdHkudmFsdWU7XG5cbiAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgfVxuICB9LFxuXG4gIHRyYW5zcGFyZW50OiBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZS5vcGFjaXR5LnZhbHVlID09PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGlzRnVsbEF1dG9QYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciBhdXRvVyA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS52YWx1ZSA9PT0gJ2F1dG8nO1xuICAgICAgdmFyIGF1dG9IID0gZWxlLl9wcml2YXRlLnN0eWxlWydoZWlnaHQnXS52YWx1ZSA9PT0gJ2F1dG8nO1xuXG4gICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCkgJiYgYXV0b1cgJiYgYXV0b0g7XG4gICAgfVxuICB9LFxuXG4gIGJhY2tncm91bmRpbmc6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYmFja2dyb3VuZGluZyA/IHRydWUgOiBmYWxzZTtcbiAgfVxuXG59KTtcblxuXG5lbGVzZm4uYnlwYXNzID0gZWxlc2ZuLnN0eWxlID0gZWxlc2ZuLmNzcztcbmVsZXNmbi5yZW5kZXJlZFN0eWxlID0gZWxlc2ZuLnJlbmRlcmVkQ3NzO1xuZWxlc2ZuLnJlbW92ZUJ5cGFzcyA9IGVsZXNmbi5yZW1vdmVTdHlsZSA9IGVsZXNmbi5yZW1vdmVDc3M7XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxlc2ZuID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZVN3aXRjaEZ1bmN0aW9uKHBhcmFtcyl7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBjaGFuZ2VkRWxlcyA9IFtdO1xuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggZGF0YSwgaGFuZGxlciApXG4gICAgaWYoIGFyZ3MubGVuZ3RoID09PSAyICl7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICB0aGlzLmJpbmQoIHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlciApO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGhhbmRsZXIgKVxuICAgIGVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAxICl7XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICB0aGlzLmJpbmQoIHBhcmFtcy5ldmVudCwgaGFuZGxlciApO1xuICAgIH1cblxuICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgIGVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAwICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBhYmxlID0gIXBhcmFtcy5hYmxlRmllbGQgfHwgZWxlLl9wcml2YXRlW3BhcmFtcy5hYmxlRmllbGRdO1xuICAgICAgICB2YXIgY2hhbmdlZCA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuZmllbGRdICE9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICBpZiggcGFyYW1zLm92ZXJyaWRlQWJsZSApe1xuICAgICAgICAgIHZhciBvdmVycmlkZUFibGUgPSBwYXJhbXMub3ZlcnJpZGVBYmxlKGVsZSk7XG5cbiAgICAgICAgICBpZiggb3ZlcnJpZGVBYmxlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIGFibGUgPSBvdmVycmlkZUFibGU7XG5cbiAgICAgICAgICAgIGlmKCAhb3ZlcnJpZGVBYmxlICl7IHJldHVybiB0aGlzOyB9IC8vIHRvIHNhdmUgY3ljbGVzIGFzc3VtZSBub3QgYWJsZSBmb3IgYWxsIG9uIG92ZXJyaWRlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGFibGUgKXtcbiAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcblxuICAgICAgICAgIGlmKCBjaGFuZ2VkICl7XG4gICAgICAgICAgICBjaGFuZ2VkRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWRDb2xsID0gdGhpcy5zcGF3biggY2hhbmdlZEVsZXMgKTtcbiAgICAgIGNoYW5nZWRDb2xsLnVwZGF0ZVN0eWxlKCk7IC8vIGNoYW5nZSBvZiBzdGF0ZSA9PiBwb3NzaWJsZSBjaGFuZ2Ugb2Ygc3R5bGVcbiAgICAgIGNoYW5nZWRDb2xsLnRyaWdnZXIoIHBhcmFtcy5ldmVudCApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQoIHBhcmFtcyApe1xuICBlbGVzZm5bIHBhcmFtcy5maWVsZCBdID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIGlmKCBwYXJhbXMub3ZlcnJpZGVGaWVsZCApe1xuICAgICAgICB2YXIgdmFsID0gcGFyYW1zLm92ZXJyaWRlRmllbGQoZWxlKTtcblxuICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGVbIHBhcmFtcy5maWVsZCBdO1xuICAgIH1cbiAgfTtcblxuICBlbGVzZm5bIHBhcmFtcy5vbiBdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgIGV2ZW50OiBwYXJhbXMub24sXG4gICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuXG4gIGVsZXNmblsgcGFyYW1zLm9mZiBdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogZmFsc2VcbiAgfSk7XG59XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnbG9ja2VkJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oZWxlKXtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b2xvY2soKSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnbG9jaycsXG4gIG9mZjogJ3VubG9jaydcbn0pO1xuXG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2dyYWJiYWJsZScsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKGVsZSl7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bmdyYWJpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ2dyYWJpZnknLFxuICBvZmY6ICd1bmdyYWJpZnknXG59KTtcblxuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdzZWxlY3RlZCcsXG4gIGFibGVGaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUFibGU6IGZ1bmN0aW9uKGVsZSl7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnc2VsZWN0JyxcbiAgb2ZmOiAndW5zZWxlY3QnXG59KTtcblxuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oZWxlKXtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdzZWxlY3RpZnknLFxuICBvZmY6ICd1bnNlbGVjdGlmeSdcbn0pO1xuXG5lbGVzZm4uZGVzZWxlY3QgPSBlbGVzZm4udW5zZWxlY3Q7XG5cbmVsZXNmbi5ncmFiYmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmKCBlbGUgKXtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyYWJiZWQ7XG4gIH1cbn07XG5cbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnYWN0aXZlJyxcbiAgb246ICdhY3RpdmF0ZScsXG4gIG9mZjogJ3VuYWN0aXZhdGUnXG59KTtcblxuZWxlc2ZuLmluYWN0aXZlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmKCBlbGUgKXtcbiAgICByZXR1cm4gIWVsZS5fcHJpdmF0ZS5hY3RpdmU7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZWxlc2ZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4uL2lzJyk7XG5cbnZhciBlbGVzZm4gPSB7fTtcblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIC8vIGdldCB0aGUgcm9vdCBub2RlcyBpbiB0aGUgREFHXG4gIHJvb3RzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHJvb3RzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNFZGdlc1BvaW50aW5nSW4gPSBlbGUuY29ubmVjdGVkRWRnZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgndGFyZ2V0JykgPT09IGVsZS5pZCgpICYmIHRoaXMuZGF0YSgnc291cmNlJykgIT09IGVsZS5pZCgpO1xuICAgICAgfSkubGVuZ3RoID4gMDtcblxuICAgICAgaWYoICFoYXNFZGdlc1BvaW50aW5nSW4gKXtcbiAgICAgICAgcm9vdHMucHVzaCggZWxlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHJvb3RzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIC8vIGdldCB0aGUgbGVhZiBub2RlcyBpbiB0aGUgREFHXG4gIGxlYXZlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBsZWF2ZXMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICBpZiggIWVsZS5pc05vZGUoKSApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0VkZ2VzUG9pbnRpbmdPdXQgPSBlbGUuY29ubmVjdGVkRWRnZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgnc291cmNlJykgPT09IGVsZS5pZCgpICYmIHRoaXMuZGF0YSgndGFyZ2V0JykgIT09IGVsZS5pZCgpO1xuICAgICAgfSkubGVuZ3RoID4gMDtcblxuICAgICAgaWYoICFoYXNFZGdlc1BvaW50aW5nT3V0ICl7XG4gICAgICAgIGxlYXZlcy5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggbGVhdmVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIC8vIG5vcm1hbGx5IGNhbGxlZCBjaGlsZHJlbiBpbiBncmFwaCB0aGVvcnlcbiAgLy8gdGhlc2Ugbm9kZXMgPWVkZ2VzPT4gb3V0Z29pbmcgbm9kZXNcbiAgb3V0Z29lcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgb0VsZXMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgZWxlSWQgPSBlbGUuaWQoKTtcblxuICAgICAgaWYoICFlbGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgdmFyIGVkZ2VzID0gZWxlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjSWQgPSBlZGdlLl9wcml2YXRlLmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgdGd0SWQgPSBlZGdlLl9wcml2YXRlLmRhdGEudGFyZ2V0O1xuXG4gICAgICAgIGlmKCBzcmNJZCA9PT0gZWxlSWQgJiYgdGd0SWQgIT09IGVsZUlkICl7XG4gICAgICAgICAgb0VsZXMucHVzaCggZWRnZSApO1xuICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2UudGFyZ2V0KClbMF0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBvRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICAvLyBha2EgREFHIGRlc2NlbmRhbnRzXG4gIHN1Y2Nlc3NvcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgc0VsZXMgPSBbXTtcbiAgICB2YXIgc0VsZXNJZHMgPSB7fTtcblxuICAgIGZvcig7Oyl7XG4gICAgICB2YXIgb3V0Z29lcnMgPSBlbGVzLm91dGdvZXJzKCk7XG5cbiAgICAgIGlmKCBvdXRnb2Vycy5sZW5ndGggPT09IDAgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiBubyBvdXRnb2VycyBsZWZ0XG5cbiAgICAgIHZhciBuZXdPdXRnb2VycyA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvdXRnb2Vycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgb3V0Z29lciA9IG91dGdvZXJzW2ldO1xuICAgICAgICB2YXIgb3V0Z29lcklkID0gb3V0Z29lci5pZCgpO1xuXG4gICAgICAgIGlmKCAhc0VsZXNJZHNbIG91dGdvZXJJZCBdICl7XG4gICAgICAgICAgc0VsZXNJZHNbIG91dGdvZXJJZCBdID0gdHJ1ZTtcbiAgICAgICAgICBzRWxlcy5wdXNoKCBvdXRnb2VyICk7XG4gICAgICAgICAgbmV3T3V0Z29lcnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhbmV3T3V0Z29lcnMgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBvdXRnb2VycyBhbHJlYWR5XG5cbiAgICAgIGVsZXMgPSBvdXRnb2VycztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggc0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gIC8vIHRoZXNlIG5vZGVzIDw9ZWRnZXM9IGluY29taW5nIG5vZGVzXG4gIGluY29tZXJzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIG9FbGVzID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIGVsZUlkID0gZWxlLmlkKCk7XG5cbiAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciBlZGdlcyA9IGVsZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyY0lkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndElkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgICBpZiggdGd0SWQgPT09IGVsZUlkICYmIHNyY0lkICE9PSBlbGVJZCApe1xuICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgICBvRWxlcy5wdXNoKCBlZGdlLnNvdXJjZSgpWzBdICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggb0VsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgcHJlZGVjZXNzb3JzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHBFbGVzID0gW107XG4gICAgdmFyIHBFbGVzSWRzID0ge307XG5cbiAgICBmb3IoOzspe1xuICAgICAgdmFyIGluY29tZXJzID0gZWxlcy5pbmNvbWVycygpO1xuXG4gICAgICBpZiggaW5jb21lcnMubGVuZ3RoID09PSAwICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgbm8gaW5jb21lcnMgbGVmdFxuXG4gICAgICB2YXIgbmV3SW5jb21lcnMgPSBmYWxzZTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaW5jb21lcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGluY29tZXIgPSBpbmNvbWVyc1tpXTtcbiAgICAgICAgdmFyIGluY29tZXJJZCA9IGluY29tZXIuaWQoKTtcblxuICAgICAgICBpZiggIXBFbGVzSWRzWyBpbmNvbWVySWQgXSApe1xuICAgICAgICAgIHBFbGVzSWRzWyBpbmNvbWVySWQgXSA9IHRydWU7XG4gICAgICAgICAgcEVsZXMucHVzaCggaW5jb21lciApO1xuICAgICAgICAgIG5ld0luY29tZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIW5ld0luY29tZXJzICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgdG91Y2hlZCBhbGwgaW5jb21lcnMgYWxyZWFkeVxuXG4gICAgICBlbGVzID0gaW5jb21lcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHBFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9XG59KTtcblxuXG4vLyBOZWlnaGJvdXJob29kIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIG5laWdoYm9yaG9vZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGFsbCBub2Rlc1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgLy8gZm9yIGVhY2ggY29ubmVjdGVkIGVkZ2UsIGFkZCB0aGUgZWRnZSBhbmQgdGhlIG90aGVyIG5vZGVcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2UuX3ByaXZhdGUuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS5fcHJpdmF0ZS50YXJnZXQ7XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSBub2RlID09PSBzcmMgPyB0Z3QgOiBzcmM7XG5cbiAgICAgICAgLy8gbmVlZCBjaGVjayBpbiBjYXNlIG9mIGxvb3BcbiAgICAgICAgaWYoIG90aGVyTm9kZS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggb3RoZXJOb2RlWzBdICk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBjb25uZWN0ZWQgZWRnZVxuICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlWzBdICk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gKCB0aGlzLnNwYXduKCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGNsb3NlZE5laWdoYm9yaG9vZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCggdGhpcyApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfSxcblxuICBvcGVuTmVpZ2hib3Job29kOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCBzZWxlY3RvciApO1xuICB9XG59KTtcblxuLy8gYWxpYXNlc1xuZWxlc2ZuLm5laWdoYm91cmhvb2QgPSBlbGVzZm4ubmVpZ2hib3Job29kO1xuZWxlc2ZuLmNsb3NlZE5laWdoYm91cmhvb2QgPSBlbGVzZm4uY2xvc2VkTmVpZ2hib3Job29kO1xuZWxlc2ZuLm9wZW5OZWlnaGJvdXJob29kID0gZWxlc2ZuLm9wZW5OZWlnaGJvcmhvb2Q7XG5cbi8vIEVkZ2UgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG51dGlsLmV4dGVuZChlbGVzZm4sIHtcbiAgc291cmNlOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgc3JjO1xuXG4gICAgaWYoIGVsZSApe1xuICAgICAgc3JjID0gZWxlLl9wcml2YXRlLnNvdXJjZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3JjICYmIHNlbGVjdG9yID8gc3JjLmZpbHRlciggc2VsZWN0b3IgKSA6IHNyYztcbiAgfSxcblxuICB0YXJnZXQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciB0Z3Q7XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiB0Z3QgJiYgc2VsZWN0b3IgPyB0Z3QuZmlsdGVyKCBzZWxlY3RvciApIDogdGd0O1xuICB9LFxuXG4gIHNvdXJjZXM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICBhdHRyOiAnc291cmNlJ1xuICB9KSxcblxuICB0YXJnZXRzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3RhcmdldCdcbiAgfSlcbn0pO1xuXG5mdW5jdGlvbiBkZWZpbmVTb3VyY2VGdW5jdGlvbiggcGFyYW1zICl7XG4gIHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGVbIHBhcmFtcy5hdHRyIF07XG5cbiAgICAgIGlmKCBzcmMgKXtcbiAgICAgICAgc291cmNlcy5wdXNoKCBzcmMgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zcGF3biggc291cmNlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfTtcbn1cblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIGVkZ2VzV2l0aDogZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSxcblxuICBlZGdlc1RvOiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgdGhpc0lzOiAnc291cmNlJ1xuICB9KVxufSk7XG5cbmZ1bmN0aW9uIGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCBwYXJhbXMgKXtcblxuICByZXR1cm4gZnVuY3Rpb24gZWRnZXNXaXRoSW1wbCggb3RoZXJOb2RlcyApe1xuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIHAgPSBwYXJhbXMgfHwge307XG5cbiAgICAvLyBnZXQgZWxlbWVudHMgaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWRcbiAgICBpZiggaXMuc3RyaW5nKG90aGVyTm9kZXMpICl7XG4gICAgICBvdGhlck5vZGVzID0gY3kuJCggb3RoZXJOb2RlcyApO1xuICAgIH1cblxuICAgIHZhciB0aGlzSWRzID0gdGhpcy5fcHJpdmF0ZS5pZHM7XG4gICAgdmFyIG90aGVySWRzID0gb3RoZXJOb2Rlcy5fcHJpdmF0ZS5pZHM7XG5cbiAgICBmb3IoIHZhciBoID0gMDsgaCA8IG90aGVyTm9kZXMubGVuZ3RoOyBoKysgKXtcbiAgICAgIHZhciBlZGdlcyA9IG90aGVyTm9kZXNbaF0uX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgdmFyIGVkZ2VEYXRhID0gZWRnZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICB2YXIgdGhpc1RvT3RoZXIgPSB0aGlzSWRzWyBlZGdlRGF0YS5zb3VyY2UgXSAmJiBvdGhlcklkc1sgZWRnZURhdGEudGFyZ2V0IF07XG4gICAgICAgIHZhciBvdGhlclRvVGhpcyA9IG90aGVySWRzWyBlZGdlRGF0YS5zb3VyY2UgXSAmJiB0aGlzSWRzWyBlZGdlRGF0YS50YXJnZXQgXTtcbiAgICAgICAgdmFyIGVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciA9IHRoaXNUb090aGVyIHx8IG90aGVyVG9UaGlzO1xuXG4gICAgICAgIGlmKCAhZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYoIHAudGhpc0lzICl7XG4gICAgICAgICAgaWYoIHAudGhpc0lzID09PSAnc291cmNlJyAmJiAhdGhpc1RvT3RoZXIgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIGlmKCBwLnRoaXNJcyA9PT0gJ3RhcmdldCcgJiYgIW90aGVyVG9UaGlzICl7IGNvbnRpbnVlOyB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICk7XG4gIH07XG59XG5cbnV0aWwuZXh0ZW5kKGVsZXNmbiwge1xuICBjb25uZWN0ZWRFZGdlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIHJldEVsZXMgPSBbXTtcblxuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gZWxlc1tpXTtcbiAgICAgIGlmKCAhbm9kZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgIHJldEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCByZXRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICB9LFxuXG4gIGNvbm5lY3RlZE5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgcmV0RWxlcyA9IFtdO1xuXG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuICAgICAgaWYoICFlZGdlLmlzRWRnZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHJldEVsZXMucHVzaCggZWRnZS5zb3VyY2UoKVswXSApO1xuICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlLnRhcmdldCgpWzBdICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gIH0sXG5cbiAgcGFyYWxsZWxFZGdlczogZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCksXG5cbiAgY29kaXJlY3RlZEVkZ2VzOiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oe1xuICAgIGNvZGlyZWN0ZWQ6IHRydWVcbiAgfSlcbn0pO1xuXG5mdW5jdGlvbiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24ocGFyYW1zKXtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGNvZGlyZWN0ZWQ6IGZhbHNlXG4gIH07XG4gIHBhcmFtcyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcblxuICByZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgIHZhciBwID0gcGFyYW1zO1xuXG4gICAgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVkZ2UxID0gZWRnZXNbaV07XG4gICAgICB2YXIgc3JjMSA9IGVkZ2UxLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHNyY2lkMSA9IHNyYzEuaWQoKTtcbiAgICAgIHZhciB0Z3QxID0gZWRnZTEudGFyZ2V0KClbMF07XG4gICAgICB2YXIgdGd0aWQxID0gdGd0MS5pZCgpO1xuICAgICAgdmFyIHNyY0VkZ2VzMSA9IHNyYzEuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgIC8vIGxvb2sgYXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzcmMgbm9kZSBvZiB0aGlzIGVkZ2VcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc3JjRWRnZXMxLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlZGdlMiA9IHNyY0VkZ2VzMVtqXTtcbiAgICAgICAgdmFyIGVkZ2UyZGF0YSA9IGVkZ2UyLl9wcml2YXRlLmRhdGE7XG4gICAgICAgIHZhciB0Z3RpZDIgPSBlZGdlMmRhdGEudGFyZ2V0O1xuICAgICAgICB2YXIgc3JjaWQyID0gZWRnZTJkYXRhLnNvdXJjZTtcblxuICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcblxuICAgICAgICBpZiggKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkKSB8fCAoIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZTIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNwYXduKCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgfTtcblxufVxuXG4vLyBNaXNjIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxudXRpbC5leHRlbmQoZWxlc2ZuLCB7XG4gIGNvbXBvbmVudHM6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB2aXNpdGVkID0gY3kuY29sbGVjdGlvbigpO1xuICAgIHZhciB1bnZpc2l0ZWQgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICAgIHZhciB2aXNpdEluQ29tcG9uZW50ID0gZnVuY3Rpb24oIG5vZGUsIGNvbXBvbmVudCApe1xuICAgICAgdmlzaXRlZC5tZXJnZSggbm9kZSApO1xuICAgICAgdW52aXNpdGVkLnVubWVyZ2UoIG5vZGUgKTtcbiAgICAgIGNvbXBvbmVudC5tZXJnZSggbm9kZSApO1xuICAgIH07XG5cbiAgICBkbyB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKCBjb21wb25lbnQgKTtcblxuICAgICAgdmFyIHJvb3QgPSB1bnZpc2l0ZWRbMF07XG4gICAgICB2aXNpdEluQ29tcG9uZW50KCByb290LCBjb21wb25lbnQgKTtcblxuICAgICAgdGhpcy5iZnMoe1xuICAgICAgICBkaXJlY3RlZDogZmFsc2UsXG4gICAgICAgIHJvb3RzOiByb290LFxuICAgICAgICB2aXNpdDogZnVuY3Rpb24oIGksIGRlcHRoLCB2LCBlLCB1ICl7XG4gICAgICAgICAgdmlzaXRJbkNvbXBvbmVudCggdiwgY29tcG9uZW50ICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfSB3aGlsZSggdW52aXNpdGVkLmxlbmd0aCA+IDAgKTtcblxuICAgIHJldHVybiBjb21wb25lbnRzLm1hcChmdW5jdGlvbiggY29tcG9uZW50ICl7XG4gICAgICByZXR1cm4gY29tcG9uZW50LmNsb3NlZE5laWdoYm9yaG9vZCgpOyAvLyBhZGQgdGhlIGVkZ2VzXG4gICAgfSk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVsZXNmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHpJbmRleFNvcnQgPSBmdW5jdGlvbiggYSwgYiApe1xuICB2YXIgY3kgPSBhLmN5KCk7XG4gIHZhciBhX3AgPSBhLl9wcml2YXRlO1xuICB2YXIgYl9wID0gYi5fcHJpdmF0ZTtcbiAgdmFyIHpEaWZmID0gYV9wLnN0eWxlWyd6LWluZGV4J10udmFsdWUgLSBiX3Auc3R5bGVbJ3otaW5kZXgnXS52YWx1ZTtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIHZhciBkZXB0aEIgPSAwO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGFJc05vZGUgPSBhX3AuZ3JvdXAgPT09ICdub2Rlcyc7XG4gIHZhciBhSXNFZGdlID0gYV9wLmdyb3VwID09PSAnZWRnZXMnO1xuICB2YXIgYklzTm9kZSA9IGJfcC5ncm91cCA9PT0gJ25vZGVzJztcbiAgdmFyIGJJc0VkZ2UgPSBiX3AuZ3JvdXAgPT09ICdlZGdlcyc7XG5cbiAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgZWxlbWVudCBkZXB0aCBpZiB0aGVyZSBpcyBubyBjb21wb3VuZCBub2RlXG4gIGlmKCBoYXNDb21wb3VuZE5vZGVzICl7XG4gICAgZGVwdGhBID0gYS56RGVwdGgoKTtcbiAgICBkZXB0aEIgPSBiLnpEZXB0aCgpO1xuICB9XG5cbiAgdmFyIGRlcHRoRGlmZiA9IGRlcHRoQSAtIGRlcHRoQjtcbiAgdmFyIHNhbWVEZXB0aCA9IGRlcHRoRGlmZiA9PT0gMDtcblxuICBpZiggc2FtZURlcHRoICl7XG5cbiAgICBpZiggYUlzTm9kZSAmJiBiSXNFZGdlICl7XG4gICAgICByZXR1cm4gMTsgLy8gJ2EnIGlzIGEgbm9kZSwgaXQgc2hvdWxkIGJlIGRyYXduIGxhdGVyXG5cbiAgICB9IGVsc2UgaWYoIGFJc0VkZ2UgJiYgYklzTm9kZSApe1xuICAgICAgcmV0dXJuIC0xOyAvLyAnYScgaXMgYW4gZWRnZSwgaXQgc2hvdWxkIGJlIGRyYXduIGZpcnN0XG5cbiAgICB9IGVsc2UgeyAvLyBib3RoIG5vZGVzIG9yIGJvdGggZWRnZXNcbiAgICAgIGlmKCB6RGlmZiA9PT0gMCApeyAvLyBzYW1lIHotaW5kZXggPT4gY29tcGFyZSBpbmRpY2VzIGluIHRoZSBjb3JlIChvcmRlciBhZGRlZCB0byBncmFwaCB3LyBsYXN0IG9uIHRvcClcbiAgICAgICAgcmV0dXJuIGFfcC5pbmRleCAtIGJfcC5pbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB6RGlmZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgLy8gZWxlbWVudHMgb24gZGlmZmVyZW50IGxldmVsXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlcHRoRGlmZjsgLy8gZGVlcGVyIGVsZW1lbnQgc2hvdWxkIGJlIGRyYXduIGxhdGVyXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB6SW5kZXhTb3J0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2NvbGxlY3Rpb24nKTtcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbi9lbGVtZW50Jyk7XG52YXIgd2luZG93ID0gcmVxdWlyZSgnLi4vd2luZG93Jyk7XG52YXIgZG9jdW1lbnQgPSB3aW5kb3cgPyB3aW5kb3cuZG9jdW1lbnQgOiBudWxsO1xudmFyIE51bGxSZW5kZXJlciA9IHJlcXVpcmUoJy4uL2V4dGVuc2lvbnMvcmVuZGVyZXIvbnVsbCcpO1xuXG52YXIgY29yZWZuID0ge1xuICBhZGQ6IGZ1bmN0aW9uKG9wdHMpe1xuXG4gICAgdmFyIGVsZW1lbnRzO1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAvLyBhZGQgdGhlIGVsZW1lbnRzXG4gICAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0cykgKXtcbiAgICAgIHZhciBlbGVzID0gb3B0cztcblxuICAgICAgaWYoIGVsZXMuX3ByaXZhdGUuY3kgPT09IGN5ICl7IC8vIHNhbWUgaW5zdGFuY2UgPT4ganVzdCByZXN0b3JlXG4gICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgY29weSBmcm9tIGpzb25cbiAgICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgICAganNvbnMucHVzaCggZWxlLmpzb24oKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbiggY3ksIGpzb25zICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc3BlY2lmeSBhbiBhcnJheSBvZiBvcHRpb25zXG4gICAgZWxzZSBpZiggaXMuYXJyYXkob3B0cykgKXtcbiAgICAgIHZhciBqc29ucyA9IG9wdHM7XG5cbiAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIGpzb25zKTtcbiAgICB9XG5cbiAgICAvLyBzcGVjaWZ5IHZpYSBvcHRzLm5vZGVzIGFuZCBvcHRzLmVkZ2VzXG4gICAgZWxzZSBpZiggaXMucGxhaW5PYmplY3Qob3B0cykgJiYgKGlzLmFycmF5KG9wdHMubm9kZXMpIHx8IGlzLmFycmF5KG9wdHMuZWRnZXMpKSApe1xuICAgICAgdmFyIGVsZXNCeUdyb3VwID0gb3B0cztcbiAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICB2YXIgZ3JzID0gWydub2RlcycsICdlZGdlcyddO1xuICAgICAgZm9yKCB2YXIgaSA9IDAsIGlsID0gZ3JzLmxlbmd0aDsgaSA8IGlsOyBpKysgKXtcbiAgICAgICAgdmFyIGdyb3VwID0gZ3JzW2ldO1xuICAgICAgICB2YXIgZWxlc0FycmF5ID0gZWxlc0J5R3JvdXBbZ3JvdXBdO1xuXG4gICAgICAgIGlmKCBpcy5hcnJheShlbGVzQXJyYXkpICl7XG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKyApe1xuICAgICAgICAgICAgdmFyIGpzb24gPSB1dGlsLmV4dGVuZCggeyBncm91cDogZ3JvdXAgfSwgZWxlc0FycmF5W2pdICk7XG5cbiAgICAgICAgICAgIGpzb25zLnB1c2goIGpzb24gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMgPSBuZXcgQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgb3B0aW9ucyBmb3Igb25lIGVsZW1lbnRcbiAgICBlbHNlIHtcbiAgICAgIHZhciBqc29uID0gb3B0cztcbiAgICAgIGVsZW1lbnRzID0gKG5ldyBFbGVtZW50KCBjeSwganNvbiApKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oY29sbGVjdGlvbil7XG4gICAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24oY29sbGVjdGlvbikgKXtcbiAgICAgIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgIH0gZWxzZSBpZiggaXMuc3RyaW5nKGNvbGxlY3Rpb24pICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuJCggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgfSxcblxuICBsb2FkOiBmdW5jdGlvbihlbGVtZW50cywgb25sb2FkLCBvbmRvbmUpe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBjeS5ub3RpZmljYXRpb25zKGZhbHNlKTtcblxuICAgIC8vIHJlbW92ZSBvbGQgZWxlbWVudHNcbiAgICB2YXIgb2xkRWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgaWYoIG9sZEVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiggZWxlbWVudHMgIT0gbnVsbCApe1xuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KGVsZW1lbnRzKSB8fCBpcy5hcnJheShlbGVtZW50cykgKXtcbiAgICAgICAgY3kuYWRkKCBlbGVtZW50cyApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN5Lm9uZSgnbGF5b3V0cmVhZHknLCBmdW5jdGlvbihlKXtcbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgICBjeS50cmlnZ2VyKGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgIGN5Lm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdsb2FkJyxcbiAgICAgICAgY29sbGVjdGlvbjogY3kuZWxlbWVudHMoKVxuICAgICAgfSk7XG5cbiAgICAgIGN5Lm9uZSgnbG9hZCcsIG9ubG9hZCk7XG4gICAgICBjeS50cmlnZ2VyKCdsb2FkJyk7XG4gICAgfSkub25lKCdsYXlvdXRzdG9wJywgZnVuY3Rpb24oKXtcbiAgICAgIGN5Lm9uZSgnZG9uZScsIG9uZG9uZSk7XG4gICAgICBjeS50cmlnZ2VyKCdkb25lJyk7XG4gICAgfSk7XG5cbiAgICB2YXIgbGF5b3V0T3B0cyA9IHV0aWwuZXh0ZW5kKHt9LCBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dCk7XG4gICAgbGF5b3V0T3B0cy5lbGVzID0gY3kuJCgpO1xuXG4gICAgY3kubGF5b3V0KCBsYXlvdXRPcHRzICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCcuLi9kZWZpbmUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcblxudmFyIGNvcmVmbiA9ICh7XG5cbiAgLy8gcHVsbCBpbiBhbmltYXRpb24gZnVuY3Rpb25zXG4gIGFuaW1hdGU6IGRlZmluZS5hbmltYXRlKCksXG4gIGFuaW1hdGlvbjogZGVmaW5lLmFuaW1hdGlvbigpLFxuICBhbmltYXRlZDogZGVmaW5lLmFuaW1hdGVkKCksXG4gIGNsZWFyUXVldWU6IGRlZmluZS5jbGVhclF1ZXVlKCksXG4gIGRlbGF5OiBkZWZpbmUuZGVsYXkoKSxcbiAgZGVsYXlBbmltYXRpb246IGRlZmluZS5kZWxheUFuaW1hdGlvbigpLFxuICBzdG9wOiBkZWZpbmUuc3RvcCgpLFxuXG4gIGFkZFRvQW5pbWF0aW9uUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm47IH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cbiAgICBjeS5fcHJpdmF0ZS5hbmlFbGVzLm1lcmdlKCBlbGVzICk7XG4gIH0sXG5cbiAgc3RvcEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IGZhbHNlO1xuICB9LFxuXG4gIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgY3kuX3ByaXZhdGUuYW5pbWF0aW9uc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm47IH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cbiAgICAvLyBOQiB0aGUgYW5pbWF0aW9uIGxvb3Agd2lsbCBleGVjIGluIGhlYWRsZXNzIGVudmlyb25tZW50cyBpZiBzdHlsZSBlbmFibGVkXG4gICAgLy8gYW5kIGV4cGxpY2l0IGN5LmRlc3Ryb3koKSBpcyBuZWNlc3NhcnkgdG8gc3RvcCB0aGUgbG9vcFxuXG4gICAgZnVuY3Rpb24gZ2xvYmFsQW5pbWF0aW9uU3RlcCgpe1xuICAgICAgaWYoICFjeS5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyApeyByZXR1cm47IH1cblxuICAgICAgdXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24obm93KXtcbiAgICAgICAgaGFuZGxlRWxlbWVudHMobm93KTtcbiAgICAgICAgZ2xvYmFsQW5pbWF0aW9uU3RlcCgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2xvYmFsQW5pbWF0aW9uU3RlcCgpOyAvLyBmaXJzdCBjYWxsXG5cbiAgICBmdW5jdGlvbiBoYW5kbGVFbGVtZW50cyggbm93ICl7XG4gICAgICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gICAgICB2YXIgZG9uZUVsZXMgPSBbXTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRWxlbWVudCggZWxlLCBpc0NvcmUgKXtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgY3VycmVudCA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuICAgICAgICB2YXIgcXVldWUgPSBfcC5hbmltYXRpb24ucXVldWU7XG4gICAgICAgIHZhciByYW5BbmlzID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBjdXJyZW50bHkgYW5pbWF0aW5nLCBnZXQgc29tZXRoaW5nIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgIGlmKCBjdXJyZW50Lmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIHZhciBuZXh0ID0gcXVldWUuc2hpZnQoKTtcblxuICAgICAgICAgIGlmKCBuZXh0ICl7XG4gICAgICAgICAgICBjdXJyZW50LnB1c2goIG5leHQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2FsbGJhY2tzID0gZnVuY3Rpb24oIGNhbGxiYWNrcyApe1xuICAgICAgICAgIGZvciggdmFyIGogPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0gKXtcbiAgICAgICAgICAgIHZhciBjYiA9IGNhbGxiYWNrc1tqXTtcblxuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKCAwLCBjYWxsYmFja3MubGVuZ3RoICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gc3RlcCBhbmQgcmVtb3ZlIGlmIGRvbmVcbiAgICAgICAgZm9yKCB2YXIgaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKXtcbiAgICAgICAgICB2YXIgYW5pID0gY3VycmVudFtpXTtcbiAgICAgICAgICB2YXIgYW5pX3AgPSBhbmkuX3ByaXZhdGU7XG5cbiAgICAgICAgICBpZiggYW5pX3Auc3RvcHBlZCApe1xuICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoIGksIDEgKTtcblxuICAgICAgICAgICAgYW5pX3AuaG9va2VkID0gZmFsc2U7XG4gICAgICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNhbGxiYWNrcyggYW5pX3AuZnJhbWVzICk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhYW5pX3AucGxheWluZyAmJiAhYW5pX3AuYXBwbHlpbmcgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIC8vIGFuIGFwcGx5KCkgd2hpbGUgcGxheWluZyBzaG91bGRuJ3QgZG8gYW55dGhpbmdcbiAgICAgICAgICBpZiggYW5pX3AucGxheWluZyAmJiBhbmlfcC5hcHBseWluZyApe1xuICAgICAgICAgICAgYW5pX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWFuaV9wLnN0YXJ0ZWQgKXtcbiAgICAgICAgICAgIHN0YXJ0QW5pbWF0aW9uKCBlbGUsIGFuaSwgbm93ICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RlcCggZWxlLCBhbmksIG5vdywgaXNDb3JlICk7XG5cbiAgICAgICAgICBpZiggYW5pX3AuYXBwbHlpbmcgKXtcbiAgICAgICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FsbGJhY2tzKCBhbmlfcC5mcmFtZXMgKTtcblxuICAgICAgICAgIGlmKCBhbmkuY29tcGxldGVkKCkgKXtcbiAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGFuaV9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgY2FsbGJhY2tzKCBhbmlfcC5jb21wbGV0ZXMgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByYW5BbmlzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhaXNDb3JlICYmIGN1cnJlbnQubGVuZ3RoID09PSAwICYmIHF1ZXVlLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIGRvbmVFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhbkFuaXM7XG4gICAgICB9IC8vIGhhbmRsZUVsZW1lbnRcblxuICAgICAgLy8gaGFuZGxlIGFsbCBlbGVzXG4gICAgICB2YXIgcmFuRWxlQW5pID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBlID0gMDsgZSA8IGVsZXMubGVuZ3RoOyBlKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbZV07XG4gICAgICAgIHZhciBoYW5kbGVkVGhpc0VsZSA9IGhhbmRsZUVsZW1lbnQoIGVsZSApO1xuXG4gICAgICAgIHJhbkVsZUFuaSA9IHJhbkVsZUFuaSB8fCBoYW5kbGVkVGhpc0VsZTtcbiAgICAgIH0gLy8gZWFjaCBlbGVtZW50XG5cbiAgICAgIHZhciByYW5Db3JlQW5pID0gaGFuZGxlRWxlbWVudCggY3ksIHRydWUgKTtcblxuICAgICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgICBpZiggcmFuRWxlQW5pIHx8IHJhbkNvcmVBbmkgKXtcbiAgICAgICAgdmFyIHRvTm90aWZ5O1xuXG4gICAgICAgIGlmKCBlbGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgdG9Ob3RpZnkgPSB1cGRhdGVkRWxlcy5sZW5ndGggPiAwID8gZWxlcy5hZGQoIHVwZGF0ZWRFbGVzICkgOiBlbGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgICB0eXBlOiAnZHJhdycsXG4gICAgICAgICAgY29sbGVjdGlvbjogdG9Ob3RpZnlcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBlbGVtZW50cyBmcm9tIGxpc3Qgb2YgY3VycmVudGx5IGFuaW1hdGluZyBpZiBpdHMgcXVldWVzIGFyZSBlbXB0eVxuICAgICAgZWxlcy51bm1lcmdlKCBkb25lRWxlcyApO1xuXG4gICAgfSAvLyBoYW5kbGVFbGVtZW50c1xuXG4gICAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oIHNlbGYsIGFuaSwgbm93ICl7XG4gICAgICB2YXIgaXNDb3JlID0gaXMuY29yZSggc2VsZiApO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICB2YXIgZWxlID0gc2VsZjtcbiAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuXG4gICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgIHZhciBwb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgYW5pX3Auc3RhcnRQb3NpdGlvbiA9IGFuaV9wLnN0YXJ0UG9zaXRpb24gfHwge1xuICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgIHk6IHBvcy55XG4gICAgICAgIH07XG5cbiAgICAgICAgYW5pX3Auc3RhcnRTdHlsZSA9IGFuaV9wLnN0YXJ0U3R5bGUgfHwgc3R5bGUuZ2V0VmFsdWVTdHlsZSggZWxlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpc0NvcmUgKXtcbiAgICAgICAgdmFyIHBhbiA9IGN5Ll9wcml2YXRlLnBhbjtcblxuICAgICAgICBhbmlfcC5zdGFydFBhbiA9IGFuaV9wLnN0YXJ0UGFuIHx8IHtcbiAgICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgICB5OiBwYW4ueVxuICAgICAgICB9O1xuXG4gICAgICAgIGFuaV9wLnN0YXJ0Wm9vbSA9IGFuaV9wLnN0YXJ0Wm9vbSAhPSBudWxsID8gYW5pX3Auc3RhcnRab29tIDogY3kuX3ByaXZhdGUuem9vbTtcbiAgICAgIH1cblxuICAgICAgYW5pX3Auc3RhcnRlZCA9IHRydWU7XG4gICAgICBhbmlfcC5zdGFydFRpbWUgPSBub3cgLSBhbmlfcC5wcm9ncmVzcyAqIGFuaV9wLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0ZXAoIHNlbGYsIGFuaSwgbm93LCBpc0NvcmUgKXtcbiAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICAgICAgdmFyIGFuaV9wID0gYW5pLl9wcml2YXRlO1xuICAgICAgdmFyIHBFYXNpbmcgPSBhbmlfcC5lYXNpbmc7XG4gICAgICB2YXIgc3RhcnRUaW1lID0gYW5pX3Auc3RhcnRUaW1lO1xuXG4gICAgICBpZiggIWFuaV9wLmVhc2luZ0ltcGwgKXtcblxuICAgICAgICBpZiggcEVhc2luZyA9PSBudWxsICl7IC8vIHVzZSBkZWZhdWx0XG4gICAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbJ2xpbmVhciddO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gZGVmaW5lIHcvIG5hbWVcbiAgICAgICAgICB2YXIgZWFzaW5nVmFscztcblxuICAgICAgICAgIGlmKCBpcy5zdHJpbmcoIHBFYXNpbmcgKSApe1xuICAgICAgICAgICAgdmFyIGVhc2luZ1Byb3AgPSBzdHlsZS5wYXJzZSgndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCBwRWFzaW5nKTtcblxuICAgICAgICAgICAgZWFzaW5nVmFscyA9IGVhc2luZ1Byb3AudmFsdWU7XG5cbiAgICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIGFzc3VtZSBwcmVwYXJzZWQgYXJyYXlcbiAgICAgICAgICAgIGVhc2luZ1ZhbHMgPSBwRWFzaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuYW1lLCBhcmdzO1xuXG4gICAgICAgICAgaWYoIGlzLnN0cmluZyggZWFzaW5nVmFscyApICl7XG4gICAgICAgICAgICBuYW1lID0gZWFzaW5nVmFscztcbiAgICAgICAgICAgIGFyZ3MgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHNbMV07XG4gICAgICAgICAgICBhcmdzID0gZWFzaW5nVmFscy5zbGljZSgyKS5tYXAoZnVuY3Rpb24obil7IHJldHVybiArbjsgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGFyZ3MubGVuZ3RoID4gMCApeyAvLyBjcmVhdGUgd2l0aCBhcmdzXG4gICAgICAgICAgICBpZiggbmFtZSA9PT0gJ3NwcmluZycgKXtcbiAgICAgICAgICAgICAgYXJncy5wdXNoKCBhbmlfcC5kdXJhdGlvbiApOyAvLyBuZWVkIGR1cmF0aW9uIHRvIGdlbmVyYXRlIHNwcmluZ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1sgbmFtZSBdLmFwcGx5KCBudWxsLCBhcmdzICk7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gc3RhdGljIGltcGwgYnkgbmFtZVxuICAgICAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbIG5hbWUgXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgZWFzaW5nID0gYW5pX3AuZWFzaW5nSW1wbDtcbiAgICAgIHZhciBwZXJjZW50O1xuXG4gICAgICBpZiggYW5pX3AuZHVyYXRpb24gPT09IDAgKXtcbiAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJjZW50ID0gKG5vdyAtIHN0YXJ0VGltZSkgLyBhbmlfcC5kdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYoIGFuaV9wLmFwcGx5aW5nICl7XG4gICAgICAgIHBlcmNlbnQgPSBhbmlfcC5wcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYoIGFuaV9wLmRlbGF5ID09IG51bGwgKXsgLy8gdGhlbiB1cGRhdGVcblxuICAgICAgICB2YXIgc3RhcnRQb3MgPSBhbmlfcC5zdGFydFBvc2l0aW9uO1xuICAgICAgICB2YXIgZW5kUG9zID0gYW5pX3AucG9zaXRpb247XG4gICAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICAgICAgaWYoIGVuZFBvcyAmJiBpc0VsZXMgKXtcbiAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UG9zLngsIGVuZFBvcy54ICkgKXtcbiAgICAgICAgICAgIHBvcy54ID0gZWFzZSggc3RhcnRQb3MueCwgZW5kUG9zLngsIHBlcmNlbnQsIGVhc2luZyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQb3MueSwgZW5kUG9zLnkgKSApe1xuICAgICAgICAgICAgcG9zLnkgPSBlYXNlKCBzdGFydFBvcy55LCBlbmRQb3MueSwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0UGFuID0gYW5pX3Auc3RhcnRQYW47XG4gICAgICAgIHZhciBlbmRQYW4gPSBhbmlfcC5wYW47XG4gICAgICAgIHZhciBwYW4gPSBfcC5wYW47XG4gICAgICAgIHZhciBhbmltYXRpbmdQYW4gPSBlbmRQYW4gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgICAgIGlmKCBhbmltYXRpbmdQYW4gKXtcbiAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UGFuLngsIGVuZFBhbi54ICkgKXtcbiAgICAgICAgICAgIHBhbi54ID0gZWFzZSggc3RhcnRQYW4ueCwgZW5kUGFuLngsIHBlcmNlbnQsIGVhc2luZyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQYW4ueSwgZW5kUGFuLnkgKSApe1xuICAgICAgICAgICAgcGFuLnkgPSBlYXNlKCBzdGFydFBhbi55LCBlbmRQYW4ueSwgcGVyY2VudCwgZWFzaW5nICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdwYW4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydFpvb20gPSBhbmlfcC5zdGFydFpvb207XG4gICAgICAgIHZhciBlbmRab29tID0gYW5pX3Auem9vbTtcbiAgICAgICAgdmFyIGFuaW1hdGluZ1pvb20gPSBlbmRab29tICE9IG51bGwgJiYgaXNDb3JlO1xuICAgICAgICBpZiggYW5pbWF0aW5nWm9vbSApe1xuICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRab29tLCBlbmRab29tICkgKXtcbiAgICAgICAgICAgIF9wLnpvb20gPSBlYXNlKCBzdGFydFpvb20sIGVuZFpvb20sIHBlcmNlbnQsIGVhc2luZyApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYudHJpZ2dlcignem9vbScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tICl7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3cG9ydCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BzID0gYW5pX3Auc3R5bGU7XG4gICAgICAgIGlmKCBwcm9wcyAmJiBpc0VsZXMgKXtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBwcm9wO1xuXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBhbmlfcC5zdGFydFN0eWxlWyBuYW1lIF07XG4gICAgICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmcgKTtcblxuICAgICAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3MoIHNlbGYsIG5hbWUsIGVhc2VkVmFsICk7XG4gICAgICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgICB9IC8vIGlmXG5cbiAgICAgIH1cblxuICAgICAgaWYoIGlzLmZuKGFuaV9wLnN0ZXApICl7XG4gICAgICAgIGFuaV9wLnN0ZXAuYXBwbHkoIHNlbGYsIFsgbm93IF0gKTtcbiAgICAgIH1cblxuICAgICAgYW5pX3AucHJvZ3Jlc3MgPSBwZXJjZW50O1xuXG4gICAgICByZXR1cm4gcGVyY2VudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZChzdGFydCwgZW5kKXtcbiAgICAgIGlmKCBzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLm51bWJlcihzdGFydCkgJiYgaXMubnVtYmVyKGVuZCkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYoIChzdGFydCkgJiYgKGVuZCkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBhc3N1bWVzIHAwID0gMCwgcDMgPSAxXG4gICAgZnVuY3Rpb24gZXZhbEN1YmljQmV6aWVyKCBwMSwgcDIsIHQgKXtcbiAgICAgIHZhciBvbmVfdCA9IDEgLSB0O1xuICAgICAgdmFyIHRzcSA9IHQqdDtcblxuICAgICAgcmV0dXJuICggMyAqIG9uZV90ICogb25lX3QgKiB0ICogcDEgKSArICggMyAqIG9uZV90ICogdHNxICogcDIgKSArIHRzcSAqIHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3ViaWNCZXppZXIoIHAxLCBwMiApe1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCBzdGFydCwgZW5kLCBwZXJjZW50ICl7XG4gICAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBldmFsQ3ViaWNCZXppZXIoIHAxLCBwMiwgcGVyY2VudCApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiBSdW5nZS1LdXR0YSBzcHJpbmcgcGh5c2ljcyBmdW5jdGlvbiBnZW5lcmF0b3IuIEFkYXB0ZWQgZnJvbSBGcmFtZXIuanMsIGNvcHlyaWdodCBLb2VuIEJvay4gTUlUIExpY2Vuc2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTUlUX0xpY2Vuc2UgKi9cbiAgICAvKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuICAgICAgIHRoZW4gYWRqdXN0cyB0aGUgdGltZSBkZWx0YSAtLSB1c2luZyB0aGUgcmVsYXRpb24gYmV0d2VlbiBhY3R1YWwgdGltZSBhbmQgZHVyYXRpb24gLS0gdG8gY2FsY3VsYXRlIHRoZSBwYXRoIGZvciB0aGUgZHVyYXRpb24tY29uc3RyYWluZWQgYW5pbWF0aW9uLiAqL1xuICAgIHZhciBnZW5lcmF0ZVNwcmluZ1JLNCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgtc3RhdGUudGVuc2lvbiAqIHN0YXRlLngpIC0gKHN0YXRlLmZyaWN0aW9uICogc3RhdGUudik7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUgKGluaXRpYWxTdGF0ZSwgZHQsIGRlcml2YXRpdmUpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB4OiBpbml0aWFsU3RhdGUueCArIGRlcml2YXRpdmUuZHggKiBkdCxcbiAgICAgICAgICAgICAgICB2OiBpbml0aWFsU3RhdGUudiArIGRlcml2YXRpdmUuZHYgKiBkdCxcbiAgICAgICAgICAgICAgICB0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcbiAgICAgICAgICAgICAgICBmcmljdGlvbjogaW5pdGlhbFN0YXRlLmZyaWN0aW9uXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyBkeDogc3RhdGUudiwgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3ByaW5nSW50ZWdyYXRlU3RhdGUgKHN0YXRlLCBkdCkge1xuICAgICAgICAgICAgdmFyIGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGR4OiBzdGF0ZS52LFxuICAgICAgICAgICAgICAgICAgICBkdjogc3ByaW5nQWNjZWxlcmF0aW9uRm9yU3RhdGUoc3RhdGUpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiID0gc3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlKHN0YXRlLCBkdCAqIDAuNSwgYSksXG4gICAgICAgICAgICAgICAgYyA9IHNwcmluZ0V2YWx1YXRlU3RhdGVXaXRoRGVyaXZhdGl2ZShzdGF0ZSwgZHQgKiAwLjUsIGIpLFxuICAgICAgICAgICAgICAgIGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0LCBjKSxcbiAgICAgICAgICAgICAgICBkeGR0ID0gMS4wIC8gNi4wICogKGEuZHggKyAyLjAgKiAoYi5keCArIGMuZHgpICsgZC5keCksXG4gICAgICAgICAgICAgICAgZHZkdCA9IDEuMCAvIDYuMCAqIChhLmR2ICsgMi4wICogKGIuZHYgKyBjLmR2KSArIGQuZHYpO1xuXG4gICAgICAgICAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICAgICAgICAgIHN0YXRlLnYgPSBzdGF0ZS52ICsgZHZkdCAqIGR0O1xuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3ByaW5nUks0RmFjdG9yeSAodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG5cbiAgICAgICAgICAgIHZhciBpbml0U3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IC0xLFxuICAgICAgICAgICAgICAgICAgICB2OiAwLFxuICAgICAgICAgICAgICAgICAgICB0ZW5zaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmcmljdGlvbjogbnVsbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGF0aCA9IFswXSxcbiAgICAgICAgICAgICAgICB0aW1lX2xhcHNlZCA9IDAsXG4gICAgICAgICAgICAgICAgdG9sZXJhbmNlID0gMSAvIDEwMDAwLFxuICAgICAgICAgICAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgICAgICAgICAgIGhhdmVfZHVyYXRpb24sIGR0LCBsYXN0X3N0YXRlO1xuXG4gICAgICAgICAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCh0ZW5zaW9uKSB8fCA1MDA7XG4gICAgICAgICAgICBmcmljdGlvbiA9IHBhcnNlRmxvYXQoZnJpY3Rpb24pIHx8IDIwO1xuICAgICAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbiB8fCBudWxsO1xuXG4gICAgICAgICAgICBpbml0U3RhdGUudGVuc2lvbiA9IHRlbnNpb247XG4gICAgICAgICAgICBpbml0U3RhdGUuZnJpY3Rpb24gPSBmcmljdGlvbjtcblxuICAgICAgICAgICAgaGF2ZV9kdXJhdGlvbiA9IGR1cmF0aW9uICE9PSBudWxsO1xuXG4gICAgICAgICAgICAvKiBDYWxjdWxhdGUgdGhlIGFjdHVhbCB0aW1lIGl0IHRha2VzIGZvciB0aGlzIGFuaW1hdGlvbiB0byBjb21wbGV0ZSB3aXRoIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLiAqL1xuICAgICAgICAgICAgaWYgKGhhdmVfZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvKiBSdW4gdGhlIHNpbXVsYXRpb24gd2l0aG91dCBhIGR1cmF0aW9uLiAqL1xuICAgICAgICAgICAgICAgIHRpbWVfbGFwc2VkID0gc3ByaW5nUks0RmFjdG9yeSh0ZW5zaW9uLCBmcmljdGlvbik7XG4gICAgICAgICAgICAgICAgLyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cbiAgICAgICAgICAgICAgICBkdCA9IHRpbWVfbGFwc2VkIC8gZHVyYXRpb24gKiBEVDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHQgPSBEVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAvKiBOZXh0L3N0ZXAgZnVuY3Rpb24gLiovXG4gICAgICAgICAgICAgICAgbGFzdF9zdGF0ZSA9IHNwcmluZ0ludGVncmF0ZVN0YXRlKGxhc3Rfc3RhdGUgfHwgaW5pdFN0YXRlLCBkdCk7XG4gICAgICAgICAgICAgICAgLyogU3RvcmUgdGhlIHBvc2l0aW9uLiAqL1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaCgxICsgbGFzdF9zdGF0ZS54KTtcbiAgICAgICAgICAgICAgICB0aW1lX2xhcHNlZCArPSAxNjtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgY2hhbmdlIHRocmVzaG9sZCBpcyByZWFjaGVkLCBicmVhay4gKi9cbiAgICAgICAgICAgICAgICBpZiAoIShNYXRoLmFicyhsYXN0X3N0YXRlLngpID4gdG9sZXJhbmNlICYmIE1hdGguYWJzKGxhc3Rfc3RhdGUudikgPiB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogSWYgZHVyYXRpb24gaXMgbm90IGRlZmluZWQsIHJldHVybiB0aGUgYWN0dWFsIHRpbWUgcmVxdWlyZWQgZm9yIGNvbXBsZXRpbmcgdGhpcyBhbmltYXRpb24uIE90aGVyd2lzZSwgcmV0dXJuIGEgY2xvc3VyZSB0aGF0IGhvbGRzIHRoZVxuICAgICAgICAgICAgICAgY29tcHV0ZWQgcGF0aCBhbmQgcmV0dXJucyBhIHNuYXBzaG90IG9mIHRoZSBwb3NpdGlvbiBhY2NvcmRpbmcgdG8gYSBnaXZlbiBwZXJjZW50Q29tcGxldGUuICovXG4gICAgICAgICAgICByZXR1cm4gIWhhdmVfZHVyYXRpb24gPyB0aW1lX2xhcHNlZCA6IGZ1bmN0aW9uKHBlcmNlbnRDb21wbGV0ZSkgeyByZXR1cm4gcGF0aFsgKHBlcmNlbnRDb21wbGV0ZSAqIChwYXRoLmxlbmd0aCAtIDEpKSB8IDAgXTsgfTtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgdmFyIGVhc2luZ3MgPSB7XG4gICAgICAnbGluZWFyJzogZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG4gICAgICB9LFxuXG4gICAgICAvLyBkZWZhdWx0IGVhc2luZ3NcbiAgICAgICdlYXNlJzogY3ViaWNCZXppZXIoIDAuMjUsIDAuMSwgMC4yNSwgMSApLFxuICAgICAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllciggMC40MiwgMCwgMSwgMSApLFxuICAgICAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoIDAsIDAsIDAuNTgsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKCAwLjQyLCAwLCAwLjU4LCAxICksXG5cbiAgICAgIC8vIHNpbmVcbiAgICAgICdlYXNlLWluLXNpbmUnOiBjdWJpY0JlemllciggMC40NywgMCwgMC43NDUsIDAuNzE1ICksXG4gICAgICAnZWFzZS1vdXQtc2luZSc6IGN1YmljQmV6aWVyKCAwLjM5LCAwLjU3NSwgMC41NjUsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1zaW5lJzogY3ViaWNCZXppZXIoIDAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1ICksXG5cbiAgICAgIC8vIHF1YWRcbiAgICAgICdlYXNlLWluLXF1YWQnOiBjdWJpY0JlemllciggMC41NSwgMC4wODUsIDAuNjgsIDAuNTMgKSxcbiAgICAgICdlYXNlLW91dC1xdWFkJzogY3ViaWNCZXppZXIoIDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWFkJzogY3ViaWNCZXppZXIoIDAuNDU1LCAwLjAzLCAwLjUxNSwgMC45NTUgKSxcblxuICAgICAgLy8gY3ViaWNcbiAgICAgICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoIDAuNTUsIDAuMDU1LCAwLjY3NSwgMC4xOSApLFxuICAgICAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoIDAuMjE1LCAwLjYxLCAwLjM1NSwgMSApLFxuICAgICAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoIDAuNjQ1LCAwLjA0NSwgMC4zNTUsIDEgKSxcblxuICAgICAgLy8gcXVhcnRcbiAgICAgICdlYXNlLWluLXF1YXJ0JzogY3ViaWNCZXppZXIoIDAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMiApLFxuICAgICAgJ2Vhc2Utb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoIDAuMTY1LCAwLjg0LCAwLjQ0LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtcXVhcnQnOiBjdWJpY0JlemllciggMC43NywgMCwgMC4xNzUsIDEgKSxcblxuICAgICAgLy8gcXVpbnRcbiAgICAgICdlYXNlLWluLXF1aW50JzogY3ViaWNCZXppZXIoIDAuNzU1LCAwLjA1LCAwLjg1NSwgMC4wNiApLFxuICAgICAgJ2Vhc2Utb3V0LXF1aW50JzogY3ViaWNCZXppZXIoIDAuMjMsIDEsIDAuMzIsIDEgKSxcbiAgICAgICdlYXNlLWluLW91dC1xdWludCc6IGN1YmljQmV6aWVyKCAwLjg2LCAwLCAwLjA3LCAxICksXG5cbiAgICAgIC8vIGV4cG9cbiAgICAgICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllciggMC45NSwgMC4wNSwgMC43OTUsIDAuMDM1ICksXG4gICAgICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKCAwLjE5LCAxLCAwLjIyLCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKCAxLCAwLCAwLCAxICksXG5cbiAgICAgIC8vIGNpcmNcbiAgICAgICdlYXNlLWluLWNpcmMnOiBjdWJpY0JlemllciggMC42LCAwLjA0LCAwLjk4LCAwLjMzNSApLFxuICAgICAgJ2Vhc2Utb3V0LWNpcmMnOiBjdWJpY0JlemllciggMC4wNzUsIDAuODIsIDAuMTY1LCAxICksXG4gICAgICAnZWFzZS1pbi1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKCAwLjc4NSwgMC4xMzUsIDAuMTUsIDAuODYgKSxcblxuXG4gICAgICAvLyB1c2VyIHBhcmFtIGVhc2luZ3MuLi5cblxuICAgICAgJ3NwcmluZyc6IGZ1bmN0aW9uKCB0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24gKXtcbiAgICAgICAgdmFyIHNwcmluZyA9IGdlbmVyYXRlU3ByaW5nUks0KCB0ZW5zaW9uLCBmcmljdGlvbiwgZHVyYXRpb24gKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oIHN0YXJ0LCBlbmQsIHBlcmNlbnQgKXtcbiAgICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogc3ByaW5nKCBwZXJjZW50ICk7XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAnY3ViaWMtYmV6aWVyJzogZnVuY3Rpb24oIHgxLCB5MSwgeDIsIHkyICl7XG4gICAgICAgIHJldHVybiBjdWJpY0JlemllciggeDEsIHkxLCB4MiwgeTIgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZWFzZSggc3RhcnRQcm9wLCBlbmRQcm9wLCBwZXJjZW50LCBlYXNpbmdGbiApe1xuICAgICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgICAgIGlmKCBzdGFydFByb3AucGZWYWx1ZSAhPSBudWxsIHx8IHN0YXJ0UHJvcC52YWx1ZSAhPSBudWxsICl7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnRQcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHN0YXJ0UHJvcC5wZlZhbHVlIDogc3RhcnRQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydFByb3A7XG4gICAgICB9XG5cbiAgICAgIGlmKCBlbmRQcm9wLnBmVmFsdWUgIT0gbnVsbCB8fCBlbmRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgZW5kID0gZW5kUHJvcC5wZlZhbHVlICE9IG51bGwgPyBlbmRQcm9wLnBmVmFsdWUgOiBlbmRQcm9wLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gZW5kUHJvcDtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLm51bWJlcihzdGFydCkgJiYgaXMubnVtYmVyKGVuZCkgKXtcbiAgICAgICAgcmV0dXJuIGVhc2luZ0ZuKCBzdGFydCwgZW5kLCBwZXJjZW50ICk7XG5cbiAgICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoc3RhcnQpICYmIGlzLmFycmF5KGVuZCkgKXtcbiAgICAgICAgdmFyIGVhc2VkQXJyID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbmQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgc2kgPSBzdGFydFtpXTtcbiAgICAgICAgICB2YXIgZWkgPSBlbmRbaV07XG5cbiAgICAgICAgICBpZiggc2kgIT0gbnVsbCAmJiBlaSAhPSBudWxsICl7XG4gICAgICAgICAgICB2YXIgdmFsID0gZWFzaW5nRm4oc2ksIGVpLCBwZXJjZW50KTtcblxuICAgICAgICAgICAgaWYoIHN0YXJ0UHJvcC5yb3VuZFZhbHVlICl7IHZhbCA9IE1hdGgucm91bmQoIHZhbCApOyB9XG5cbiAgICAgICAgICAgIGVhc2VkQXJyLnB1c2goIHZhbCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYXNlZEFyci5wdXNoKCBlaSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlYXNlZEFycjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSByZXF1aXJlKCcuLi9kZWZpbmUnKTtcblxudmFyIGNvcmVmbiA9ICh7XG4gIG9uOiBkZWZpbmUub24oKSwgLy8gLm9uKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGRhdGFdLCBoYW5kbGVyKVxuICBvbmU6IGRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gIG9uY2U6IGRlZmluZS5vbih7IHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSksXG4gIG9mZjogZGVmaW5lLm9mZigpLCAvLyAub2ZmKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGhhbmRsZXJdIClcbiAgdHJpZ2dlcjogZGVmaW5lLnRyaWdnZXIoKSAvLyAudHJpZ2dlciggZXZlbnRzIFssIGV4dHJhUGFyYW1zXSApXG59KTtcblxuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBjb3JlZm4gKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlZm4gPSAoe1xuXG4gIHBuZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgcmV0dXJuIHJlbmRlcmVyLnBuZyggb3B0aW9ucyApO1xuICB9LFxuXG4gIGpwZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgb3B0aW9ucy5iZyA9IG9wdGlvbnMuYmcgfHwgJyNmZmYnO1xuXG4gICAgcmV0dXJuIHJlbmRlcmVyLmpwZyggb3B0aW9ucyApO1xuICB9XG5cbn0pO1xuXG5jb3JlZm4uanBlZyA9IGNvcmVmbi5qcGc7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSgnLi4vd2luZG93Jyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbicpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi4vcHJvbWlzZScpO1xudmFyIGRlZmluZSA9IHJlcXVpcmUoJy4uL2RlZmluZScpO1xuXG52YXIgQ29yZSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBDb3JlKSApe1xuICAgIHJldHVybiBuZXcgQ29yZShvcHRzKTtcbiAgfVxuICB2YXIgY3kgPSB0aGlzO1xuXG4gIG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyk7XG5cbiAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyO1xuXG4gIC8vIGFsbG93IGZvciBwYXNzaW5nIGEgd3JhcHBlZCBqcXVlcnkgb2JqZWN0XG4gIC8vIGUuZy4gY3l0b3NjYXBlKHsgY29udGFpbmVyOiAkKCcjY3knKSB9KVxuICBpZiggY29udGFpbmVyICYmICFpcy5odG1sRWxlbWVudCggY29udGFpbmVyICkgJiYgaXMuaHRtbEVsZW1lbnQoIGNvbnRhaW5lclswXSApICl7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyWzBdO1xuICB9XG5cbiAgdmFyIHJlZyA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5fY3lyZWcgOiBudWxsOyAvLyBlLmcuIGFscmVhZHkgcmVnaXN0ZXJlZCBzb21lIGluZm8gKGUuZy4gcmVhZGllcykgdmlhIGpxdWVyeVxuICByZWcgPSByZWcgfHwge307XG5cbiAgaWYoIHJlZyAmJiByZWcuY3kgKXtcbiAgICByZWcuY3kuZGVzdHJveSgpO1xuXG4gICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gIH1cblxuICB2YXIgcmVhZGllcyA9IHJlZy5yZWFkaWVzID0gcmVnLnJlYWRpZXMgfHwgW107XG5cbiAgaWYoIGNvbnRhaW5lciApeyBjb250YWluZXIuX2N5cmVnID0gcmVnOyB9IC8vIG1ha2Ugc3VyZSBjb250YWluZXIgYXNzb2MnZCByZWcgcG9pbnRzIHRvIHRoaXMgY3lcbiAgcmVnLmN5ID0gY3k7XG5cbiAgdmFyIGhlYWQgPSB3aW5kb3cgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgdmFyIG9wdGlvbnMgPSBvcHRzO1xuICBvcHRpb25zLmxheW91dCA9IHV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCcgfSwgb3B0aW9ucy5sYXlvdXQgKTtcbiAgb3B0aW9ucy5yZW5kZXJlciA9IHV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJyB9LCBvcHRpb25zLnJlbmRlcmVyICk7XG5cbiAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uKCBkZWYsIHZhbCwgYWx0VmFsICl7XG4gICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSBpZiggYWx0VmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiBhbHRWYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICB9O1xuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICByZWFkeTogZmFsc2UsIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgaW5pdHJlbmRlcjogZmFsc2UsIC8vIGhhcyBpbml0cmVuZGVyIGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgZWxlbWVudHM6IFtdLCAvLyBhcnJheSBvZiBlbGVtZW50c1xuICAgIGlkMmluZGV4OiB7fSwgLy8gZWxlbWVudCBpZCA9PiBpbmRleCBpbiBlbGVtZW50cyBhcnJheVxuICAgIGxpc3RlbmVyczogW10sIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgb25SZW5kZXJzOiBbXSwgLy8gcmVuZGVyaW5nIGxpc3RlbmVyc1xuICAgIGFuaUVsZXM6IENvbGxlY3Rpb24odGhpcyksIC8vIGVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkXG4gICAgc2NyYXRjaDoge30sIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgbGF5b3V0OiBudWxsLFxuICAgIHJlbmRlcmVyOiBudWxsLFxuICAgIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB0cnVlLCAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgbWluWm9vbTogMWUtNTAsXG4gICAgbWF4Wm9vbTogMWU1MCxcbiAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICBwYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMucGFubmluZ0VuYWJsZWQpLFxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgIGF1dG91bmdyYWJpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5LCBvcHRpb25zLmF1dG91bmdyYWJpZnlOb2RlcyksXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgem9vbTogaXMubnVtYmVyKG9wdGlvbnMuem9vbSkgPyBvcHRpb25zLnpvb20gOiAxLFxuICAgIHBhbjoge1xuICAgICAgeDogaXMucGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIGlzLm51bWJlcihvcHRpb25zLnBhbi54KSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgeTogaXMucGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIGlzLm51bWJlcihvcHRpb25zLnBhbi55KSA/IG9wdGlvbnMucGFuLnkgOiAwXG4gICAgfSxcbiAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgaGFzQ29tcG91bmROb2RlczogZmFsc2UsXG4gICAgZGVmZXJyZWRFeGVjUXVldWU6IFtdXG4gIH07XG5cbiAgLy8gc2V0IHNlbGVjdGlvbiB0eXBlXG4gIHZhciBzZWxUeXBlID0gb3B0aW9ucy5zZWxlY3Rpb25UeXBlO1xuICBpZiggc2VsVHlwZSA9PT0gdW5kZWZpbmVkIHx8IChzZWxUeXBlICE9PSAnYWRkaXRpdmUnICYmIHNlbFR5cGUgIT09ICdzaW5nbGUnKSApe1xuICAgIC8vIHRoZW4gc2V0IGRlZmF1bHRcblxuICAgIF9wLnNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbiAgfSBlbHNlIHtcbiAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgfVxuXG4gIC8vIGluaXQgem9vbSBib3VuZHNcbiAgaWYoIGlzLm51bWJlcihvcHRpb25zLm1pblpvb20pICYmIGlzLm51bWJlcihvcHRpb25zLm1heFpvb20pICYmIG9wdGlvbnMubWluWm9vbSA8IG9wdGlvbnMubWF4Wm9vbSApe1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgfSBlbHNlIGlmKCBpcy5udW1iZXIob3B0aW9ucy5taW5ab29tKSAmJiBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gIH0gZWxzZSBpZiggaXMubnVtYmVyKG9wdGlvbnMubWF4Wm9vbSkgJiYgb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgKXtcbiAgICBfcC5tYXhab29tID0gb3B0aW9ucy5tYXhab29tO1xuICB9XG5cbiAgdmFyIGxvYWRFeHREYXRhID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICB2YXIgYW55SXNQcm9taXNlID0gZmFsc2U7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV4dERhdGEubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBkYXR1bSA9IGV4dERhdGFbaV07XG5cbiAgICAgIGlmKCBpcy5wcm9taXNlKGRhdHVtKSApe1xuICAgICAgICBhbnlJc1Byb21pc2UgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggYW55SXNQcm9taXNlICl7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoIGV4dERhdGEgKS50aGVuKCBuZXh0ICk7IC8vIGxvYWQgYWxsIGRhdGEgYXN5bmNocm9ub3VzbHksIHRoZW4gZXhlYyByZXN0IG9mIGluaXRcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dCggZXh0RGF0YSApOyAvLyBleGVjIHN5bmNocm9ub3VzbHkgZm9yIGNvbnZlbmllbmNlXG4gICAgfVxuICB9O1xuXG4gIC8vIGNyZWF0ZSB0aGUgcmVuZGVyZXJcbiAgY3kuaW5pdFJlbmRlcmVyKCB1dGlsLmV4dGVuZCh7XG4gICAgaGlkZUVkZ2VzT25WaWV3cG9ydDogb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0LFxuICAgIGhpZGVMYWJlbHNPblZpZXdwb3J0OiBvcHRpb25zLmhpZGVMYWJlbHNPblZpZXdwb3J0LFxuICAgIHRleHR1cmVPblZpZXdwb3J0OiBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0LFxuICAgIHdoZWVsU2Vuc2l0aXZpdHk6IGlzLm51bWJlcihvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkpICYmIG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSA+IDAgPyBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgOiAxLFxuICAgIG1vdGlvbkJsdXI6IG9wdGlvbnMubW90aW9uQmx1ciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMubW90aW9uQmx1ciwgLy8gb24gYnkgZGVmYXVsdFxuICAgIG1vdGlvbkJsdXJPcGFjaXR5OiBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5ID09PSB1bmRlZmluZWQgPyAwLjA1IDogb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eSxcbiAgICBwaXhlbFJhdGlvOiBpcy5udW1iZXIob3B0aW9ucy5waXhlbFJhdGlvKSAmJiBvcHRpb25zLnBpeGVsUmF0aW8gPiAwID8gb3B0aW9ucy5waXhlbFJhdGlvIDogdW5kZWZpbmVkLFxuICAgIGRlc2t0b3BUYXBUaHJlc2hvbGQ6IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gNCA6IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCxcbiAgICB0b3VjaFRhcFRocmVzaG9sZDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gOCA6IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGRcbiAgfSwgb3B0aW9ucy5yZW5kZXJlcikgKTtcblxuICB2YXIgZXh0RGF0YSA9IFsgb3B0aW9ucy5zdHlsZSwgb3B0aW9ucy5lbGVtZW50cyBdO1xuICBsb2FkRXh0RGF0YShmdW5jdGlvbiggdGhlbnMgKXtcbiAgICB2YXIgaW5pdFN0eWxlID0gdGhlbnNbMF07XG4gICAgdmFyIGluaXRFbGVzID0gdGhlbnNbMV07XG5cbiAgICAvLyBpbml0IHN0eWxlXG4gICAgaWYoIF9wLnN0eWxlRW5hYmxlZCApe1xuICAgICAgY3kuc2V0U3R5bGUoIGluaXRTdHlsZSApO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdGhlIHBhc3NlZCBmdW5jdGlvbiBmb3IgdGhlIGBpbml0cmVuZGVyYCBldmVudFxuICAgIGlmKCBvcHRpb25zLmluaXRyZW5kZXIgKXtcbiAgICAgIGN5Lm9uKCdpbml0cmVuZGVyJywgb3B0aW9ucy5pbml0cmVuZGVyKTtcbiAgICAgIGN5Lm9uKCdpbml0cmVuZGVyJywgZnVuY3Rpb24oKXtcbiAgICAgICAgX3AuaW5pdHJlbmRlciA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsIGxvYWRcbiAgICBjeS5sb2FkKGluaXRFbGVzLCBmdW5jdGlvbigpeyAvLyBvbnJlYWR5XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIF9wLnJlYWR5ID0gdHJ1ZTtcblxuICAgICAgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuICAgICAgaWYoIGlzLmZuKCBvcHRpb25zLnJlYWR5ICkgKXtcbiAgICAgICAgY3kub24oJ3JlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHJlYWRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZuID0gcmVhZGllc1tpXTtcbiAgICAgICAgY3kub24oJ3JlYWR5JywgZm4pO1xuICAgICAgfVxuICAgICAgaWYoIHJlZyApeyByZWcucmVhZGllcyA9IFtdOyB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG5cbiAgICAgIGN5LnRyaWdnZXIoJ3JlYWR5Jyk7XG4gICAgfSwgb3B0aW9ucy5kb25lKTtcblxuICB9KTtcbn07XG5cbnZhciBjb3JlZm4gPSBDb3JlLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxudXRpbC5leHRlbmQoY29yZWZuLCB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiAnY29yZSc7XG4gIH0sXG5cbiAgaXNSZWFkeTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgfSxcblxuICByZWFkeTogZnVuY3Rpb24oIGZuICl7XG4gICAgaWYoIHRoaXMuaXNSZWFkeSgpICl7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlYWR5JywgW10sIGZuKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBpbml0cmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmluaXRyZW5kZXI7XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcblxuICAgIGN5Lm5vdGlmeSh7IHR5cGU6ICdkZXN0cm95JyB9KTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgIHZhciBkb21FbGUgPSBjeS5jb250YWluZXIoKTtcbiAgICBpZiggZG9tRWxlICl7XG4gICAgICBkb21FbGUuX2N5cmVnID0gbnVsbDtcblxuICAgICAgd2hpbGUoIGRvbUVsZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgZG9tRWxlLnJlbW92ZUNoaWxkKCBkb21FbGUuY2hpbGROb2Rlc1swXSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjeTtcbiAgfSxcblxuICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24oIGlkICl7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fcHJpdmF0ZS5pZDJpbmRleFsgaWQgXTtcbiAgICBpZiggaW5kZXggIT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHNbIGluZGV4IF07XG4gICAgfVxuXG4gICAgLy8gd29yc3QgY2FzZSwgcmV0dXJuIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgICByZXR1cm4gQ29sbGVjdGlvbiggdGhpcyApO1xuICB9LFxuXG4gIHNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc2VsZWN0aW9uVHlwZTtcbiAgfSxcblxuICBoYXNDb21wb3VuZE5vZGVzOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gIH0sXG5cbiAgc3R5bGVFbmFibGVkOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgfSxcblxuICBhZGRUb1Bvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICB2YXIgaWQyaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgaW5kZXggPSBpZDJpbmRleFsgaWQgXTtcbiAgICAgIHZhciBhbHJlYWR5SW5Qb29sID0gaW5kZXggIT09IHVuZGVmaW5lZDtcblxuICAgICAgaWYoICFhbHJlYWR5SW5Qb29sICl7XG4gICAgICAgIGluZGV4ID0gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgaWQyaW5kZXhbIGlkIF0gPSBpbmRleDtcbiAgICAgICAgZWxlLl9wcml2YXRlLmluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICB2YXIgaWQyaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB2YXIgaW5kZXggPSBpZDJpbmRleFsgaWQgXTtcbiAgICAgIHZhciBpblBvb2wgPSBpbmRleCAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiggaW5Qb29sICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuaWQyaW5kZXhbIGlkIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGVsZW1lbnRzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgLy8gYWRqdXN0IHRoZSBpbmRleCBvZiBhbGwgZWxlbWVudHMgcGFzdCB0aGlzIGluZGV4XG4gICAgICAgIGZvciggdmFyIGogPSBpbmRleDsgaiA8IGVsZW1lbnRzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGppZCA9IGVsZW1lbnRzW2pdLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgaWQyaW5kZXhbIGppZCBdLS07XG4gICAgICAgICAgZWxlbWVudHNbal0uX3ByaXZhdGUuaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb250YWluZXI6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuICB9LFxuXG4gIG9wdGlvbnM6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHV0aWwuY29weSggdGhpcy5fcHJpdmF0ZS5vcHRpb25zICk7XG4gIH0sXG5cbiAganNvbjogZnVuY3Rpb24oIG9iaiApe1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG5cbiAgICBpZiggaXMucGxhaW5PYmplY3Qob2JqKSApeyAvLyBzZXRcblxuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuXG4gICAgICBpZiggb2JqLmVsZW1lbnRzICl7XG4gICAgICAgIHZhciBpZEluSnNvbiA9IHt9O1xuXG4gICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24oIGpzb25zLCBnciApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG4gICAgICAgICAgICB2YXIgaWQgPSBqc29uLmRhdGEuaWQ7XG4gICAgICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cbiAgICAgICAgICAgIGlkSW5Kc29uWyBpZCBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoIGVsZS5sZW5ndGggIT09IDAgKXsgLy8gZXhpc3RpbmcgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICBlbGUuanNvbigganNvbiApO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAgICAgICBpZiggZ3IgKXtcbiAgICAgICAgICAgICAgICBjeS5hZGQoIHV0aWwuZXh0ZW5kKHsgZ3JvdXA6IGdyIH0sIGpzb24pICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3kuYWRkKCBqc29uICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGlzLmFycmF5KG9iai5lbGVtZW50cykgKXsgLy8gZWxlbWVudHM6IFtdXG4gICAgICAgICAgdXBkYXRlRWxlcyggb2JqLmVsZW1lbnRzICk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gZWxlbWVudHM6IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfVxuICAgICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1sgZ3IgXTtcblxuICAgICAgICAgICAgaWYoIGlzLmFycmF5KGVsZW1lbnRzKSApe1xuICAgICAgICAgICAgICB1cGRhdGVFbGVzKCBlbGVtZW50cywgZ3IgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbGVtZW50cyBub3Qgc3BlY2lmaWVkIGluIGpzb24gc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgICAgY3kuZWxlbWVudHMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICAgIHJldHVybiAhaWRJbkpzb25bIGVsZS5pZCgpIF07XG4gICAgICAgIH0pLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiggb2JqLnN0eWxlICl7XG4gICAgICAgIGN5LnN0eWxlKCBvYmouc3R5bGUgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9iai56b29tICE9IG51bGwgJiYgb2JqLnpvb20gIT09IF9wLnpvb20gKXtcbiAgICAgICAgY3kuem9vbSggb2JqLnpvb20gKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9iai5wYW4gKXtcbiAgICAgICAgaWYoIG9iai5wYW4ueCAhPT0gX3AucGFuLnggfHwgb2JqLnBhbi55ICE9PSBfcC5wYW4ueSApe1xuICAgICAgICAgIGN5LnBhbiggb2JqLnBhbiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmaWVsZHMgPSBbXG4gICAgICAgICdtaW5ab29tJywgJ21heFpvb20nLCAnem9vbWluZ0VuYWJsZWQnLCAndXNlclpvb21pbmdFbmFibGVkJyxcbiAgICAgICAgJ3Bhbm5pbmdFbmFibGVkJywgJ3VzZXJQYW5uaW5nRW5hYmxlZCcsXG4gICAgICAgICdib3hTZWxlY3Rpb25FbmFibGVkJyxcbiAgICAgICAgJ2F1dG9sb2NrJywgJ2F1dG91bmdyYWJpZnknLCAnYXV0b3Vuc2VsZWN0aWZ5J1xuICAgICAgXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGYgPSBmaWVsZHNbaV07XG5cbiAgICAgICAgaWYoIG9ialtmXSAhPSBudWxsICl7XG4gICAgICAgICAgY3lbZl0oIG9ialtmXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0gZWxzZSBpZiggb2JqID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0XG4gICAgICB2YXIganNvbiA9IHt9O1xuXG4gICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICBjeS5lbGVtZW50cygpLmVhY2goZnVuY3Rpb24oaSwgZWxlKXtcbiAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG5cbiAgICAgICAgaWYoICFqc29uLmVsZW1lbnRzW2dyb3VwXSApe1xuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBqc29uLmVsZW1lbnRzW2dyb3VwXS5wdXNoKCBlbGUuanNvbigpICk7XG4gICAgICB9KTtcblxuICAgICAgaWYoIHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkICl7XG4gICAgICAgIGpzb24uc3R5bGUgPSBjeS5zdHlsZSgpLmpzb24oKTtcbiAgICAgIH1cblxuICAgICAganNvbi56b29taW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyWm9vbWluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnpvb20gPSBjeS5fcHJpdmF0ZS56b29tO1xuICAgICAganNvbi5taW5ab29tID0gY3kuX3ByaXZhdGUubWluWm9vbTtcbiAgICAgIGpzb24ubWF4Wm9vbSA9IGN5Ll9wcml2YXRlLm1heFpvb207XG4gICAgICBqc29uLnBhbm5pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24ucGFuID0gdXRpbC5jb3B5KCBjeS5fcHJpdmF0ZS5wYW4gKTtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IGN5Ll9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLnJlbmRlcmVyID0gdXRpbC5jb3B5KCBjeS5fcHJpdmF0ZS5vcHRpb25zLnJlbmRlcmVyICk7XG4gICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICBqc29uLmhpZGVMYWJlbHNPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy5oaWRlTGFiZWxzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gY3kuX3ByaXZhdGUub3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gY3kuX3ByaXZhdGUub3B0aW9ucy5tb3Rpb25CbHVyO1xuXG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH0sXG5cbiAgc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgYmluZGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gIH0pLFxuXG4gIHJlbW92ZVNjcmF0Y2g6IGRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIHRyaWdnZXJFdmVudDogdHJ1ZVxuICB9KVxuXG59KTtcblxuW1xuICByZXF1aXJlKCcuL2FkZC1yZW1vdmUnKSxcbiAgcmVxdWlyZSgnLi9hbmltYXRpb24nKSxcbiAgcmVxdWlyZSgnLi9ldmVudHMnKSxcbiAgcmVxdWlyZSgnLi9leHBvcnQnKSxcbiAgcmVxdWlyZSgnLi9sYXlvdXQnKSxcbiAgcmVxdWlyZSgnLi9ub3RpZmljYXRpb24nKSxcbiAgcmVxdWlyZSgnLi9yZW5kZXJlcicpLFxuICByZXF1aXJlKCcuL3NlYXJjaCcpLFxuICByZXF1aXJlKCcuL3N0eWxlJyksXG4gIHJlcXVpcmUoJy4vdmlld3BvcnQnKVxuXS5mb3JFYWNoKGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggY29yZWZuLCBwcm9wcyApO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG52YXIgY29yZWZuID0gKHtcblxuICBsYXlvdXQ6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5fcHJpdmF0ZS5wcmV2TGF5b3V0ID0gKCBwYXJhbXMgPT0gbnVsbCA/IHRoaXMuX3ByaXZhdGUucHJldkxheW91dCA6IHRoaXMubWFrZUxheW91dCggcGFyYW1zICkgKTtcblxuICAgIGxheW91dC5ydW4oKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIGlmKCBvcHRpb25zID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoJ0xheW91dCBvcHRpb25zIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggb3B0aW9ucy5uYW1lID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgTGF5b3V0ID0gY3kuZXh0ZW5zaW9uKCdsYXlvdXQnLCBuYW1lKTtcblxuICAgIGlmKCBMYXlvdXQgPT0gbnVsbCApe1xuICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCBhcHBseSBsYXlvdXQ6IE5vIHN1Y2ggbGF5b3V0IGAnICsgbmFtZSArICdgIGZvdW5kOyBkaWQgeW91IGluY2x1ZGUgaXRzIEpTIGZpbGU/Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZXM7XG4gICAgaWYoIGlzLnN0cmluZyggb3B0aW9ucy5lbGVzICkgKXtcbiAgICAgIGVsZXMgPSBjeS4kKCBvcHRpb25zLmVsZXMgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogY3kuJCgpO1xuICAgIH1cblxuICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0KCB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5LFxuICAgICAgZWxlczogZWxlc1xuICAgIH0pICk7XG5cbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG5cbn0pO1xuXG5jb3JlZm4uY3JlYXRlTGF5b3V0ID0gY29yZWZuLm1ha2VMYXlvdXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yZWZuID0gKHtcbiAgbm90aWZ5OiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIGlmKCBfcC5iYXRjaGluZ05vdGlmeSApe1xuICAgICAgdmFyIGJFbGVzID0gX3AuYmF0Y2hOb3RpZnlFbGVzO1xuICAgICAgdmFyIGJUeXBlcyA9IF9wLmJhdGNoTm90aWZ5VHlwZXM7XG5cbiAgICAgIGlmKCBwYXJhbXMuY29sbGVjdGlvbiApe1xuICAgICAgICBiRWxlcy5tZXJnZSggcGFyYW1zLmNvbGxlY3Rpb24gKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFiVHlwZXMuaWRzWyBwYXJhbXMudHlwZSBdICl7XG4gICAgICAgIGJUeXBlcy5wdXNoKCBwYXJhbXMudHlwZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47IC8vIG5vdGlmaWNhdGlvbnMgYXJlIGRpc2FibGVkIGR1cmluZyBiYXRjaGluZ1xuICAgIH1cblxuICAgIGlmKCAhX3Aubm90aWZpY2F0aW9uc0VuYWJsZWQgKXsgcmV0dXJuOyB9IC8vIGV4aXQgb24gZGlzYWJsZWRcblxuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTtcblxuICAgIHJlbmRlcmVyLm5vdGlmeShwYXJhbXMpO1xuICB9LFxuXG4gIG5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgdmFyIHAgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIGJvb2wgPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHAubm90aWZpY2F0aW9uc0VuYWJsZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAubm90aWZpY2F0aW9uc0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBub05vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyhmYWxzZSk7XG4gICAgY2FsbGJhY2soKTtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gIH0sXG5cbiAgc3RhcnRCYXRjaDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLmJhdGNoQ291bnQgPT0gbnVsbCApe1xuICAgICAgX3AuYmF0Y2hDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgaWYoIF9wLmJhdGNoQ291bnQgPT09IDAgKXtcbiAgICAgIF9wLmJhdGNoaW5nU3R5bGUgPSBfcC5iYXRjaGluZ05vdGlmeSA9IHRydWU7XG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcyA9IHRoaXMuY29sbGVjdGlvbigpO1xuICAgICAgX3AuYmF0Y2hOb3RpZnlFbGVzID0gdGhpcy5jb2xsZWN0aW9uKCk7XG4gICAgICBfcC5iYXRjaE5vdGlmeVR5cGVzID0gW107XG5cbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMuaWRzID0ge307XG4gICAgfVxuXG4gICAgX3AuYmF0Y2hDb3VudCsrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZW5kQmF0Y2g6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIF9wLmJhdGNoQ291bnQtLTtcblxuICAgIGlmKCBfcC5iYXRjaENvdW50ID09PSAwICl7XG4gICAgICAvLyB1cGRhdGUgc3R5bGUgZm9yIGRpcnR5IGVsZXNcbiAgICAgIF9wLmJhdGNoaW5nU3R5bGUgPSBmYWxzZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzLnVwZGF0ZVN0eWxlKCk7XG5cbiAgICAgIC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgcXVldWVkIGVsZXMgYW5kIGV2ZW50IHR5cGVzXG4gICAgICBfcC5iYXRjaGluZ05vdGlmeSA9IGZhbHNlO1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiBfcC5iYXRjaE5vdGlmeVR5cGVzLFxuICAgICAgICBjb2xsZWN0aW9uOiBfcC5iYXRjaE5vdGlmeUVsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGJhdGNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMuZW5kQmF0Y2goKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBiYXRjaERhdGE6IGZ1bmN0aW9uKCBtYXAgKXtcbiAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHRoaXMuYmF0Y2goZnVuY3Rpb24oKXtcbiAgICAgIGZvciggdmFyIGlkIGluIG1hcCApe1xuICAgICAgICB2YXIgZGF0YSA9IG1hcFtpZF07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuICAgICAgICBlbGUuZGF0YSggZGF0YSApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgY29yZWZuID0gKHtcblxuICByZW5kZXJUbzogZnVuY3Rpb24oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApe1xuICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcblxuICAgIHIucmVuZGVyVG8oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIHJlbmRlcmVyOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICB9LFxuXG4gIGZvcmNlUmVuZGVyOiBmdW5jdGlvbigpe1xuICAgIHRoaXMubm90aWZ5KHtcbiAgICAgIHR5cGU6ICdkcmF3J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgcmVzaXplOiBmdW5jdGlvbigpe1xuICAgIHRoaXMubm90aWZ5KHtcbiAgICAgIHR5cGU6ICdyZXNpemUnXG4gICAgfSk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICB2YXIgUmVuZGVyZXJQcm90byA9IGN5LmV4dGVuc2lvbigncmVuZGVyZXInLCBvcHRpb25zLm5hbWUpO1xuICAgIGlmKCBSZW5kZXJlclByb3RvID09IG51bGwgKXtcbiAgICAgIHV0aWwuZXJyb3IoJ0NhbiBub3QgaW5pdGlhbGlzZTogTm8gc3VjaCByZW5kZXJlciBgJXNgIGZvdW5kOyBkaWQgeW91IGluY2x1ZGUgaXRzIEpTIGZpbGU/Jywgb3B0aW9ucy5uYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgck9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5XG4gICAgfSk7XG4gICAgdmFyIHJlbmRlcmVyID0gY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byggck9wdHMgKTtcblxuICAgIHJlbmRlcmVyLmluaXQoIHJPcHRzICk7XG5cbiAgfSxcblxuICB0cmlnZ2VyT25SZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGNicyA9IHRoaXMuX3ByaXZhdGUub25SZW5kZXJzO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjYnMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjYiA9IGNic1tpXTtcblxuICAgICAgY2IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvblJlbmRlcjogZnVuY3Rpb24oIGNiICl7XG4gICAgdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnMucHVzaCggY2IgKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIG9mZlJlbmRlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgdmFyIGNicyA9IHRoaXMuX3ByaXZhdGUub25SZW5kZXJzO1xuXG4gICAgaWYoIGZuID09IG51bGwgKXsgLy8gdW5iaW5kIGFsbFxuICAgICAgdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnMgPSBbXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrICl7IC8vIHVuYmluZCBzcGVjaWZpZWRcbiAgICAgIHZhciBjYiA9IGNic1tpXTtcblxuICAgICAgaWYoIGZuID09PSBjYiApe1xuICAgICAgICBjYnMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn0pO1xuXG5jb3JlZm4uaW52YWxpZGF0ZURpbWVuc2lvbnMgPSBjb3JlZm4ucmVzaXplO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vY29sbGVjdGlvbicpO1xuXG52YXIgY29yZWZuID0gKHtcblxuICAvLyBnZXQgYSBjb2xsZWN0aW9uXG4gIC8vIC0gZW1wdHkgY29sbGVjdGlvbiBvbiBubyBhcmdzXG4gIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gIC8vIC0gZ3VhcmFudGVlIGEgcmV0dXJuZWQgY29sbGVjdGlvbiB3aGVuIGVsZW1lbnRzIG9yIGNvbGxlY3Rpb24gc3BlY2lmaWVkXG4gIGNvbGxlY3Rpb246IGZ1bmN0aW9uKCBlbGVzLCBvcHRzICl7XG5cbiAgICBpZiggaXMuc3RyaW5nKCBlbGVzICkgKXtcbiAgICAgIHJldHVybiB0aGlzLiQoIGVsZXMgKTtcblxuICAgIH0gZWxzZSBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggZWxlcyApICl7XG4gICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLmFycmF5KCBlbGVzICkgKXtcbiAgICAgIHJldHVybiBDb2xsZWN0aW9uKCB0aGlzLCBlbGVzLCBvcHRzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbGxlY3Rpb24oIHRoaXMgKTtcbiAgfSxcblxuICBub2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIG5vZGVzID0gdGhpcy4kKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5pc05vZGUoKTtcbiAgICB9KTtcblxuICAgIGlmKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXM7XG4gIH0sXG5cbiAgZWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBlZGdlcyA9IHRoaXMuJChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCk7XG4gICAgfSk7XG5cbiAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVkZ2VzO1xuICB9LFxuXG4gIC8vIHNlYXJjaCB0aGUgZ3JhcGggbGlrZSBqUXVlcnlcbiAgJDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGVsZXMgPSBuZXcgQ29sbGVjdGlvbiggdGhpcywgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cyApO1xuXG4gICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gZWxlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZXM7XG4gIH1cblxufSk7XG5cbi8vIGFsaWFzZXNcbmNvcmVmbi5lbGVtZW50cyA9IGNvcmVmbi5maWx0ZXIgPSBjb3JlZm4uJDtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlZm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4uL2lzJyk7XG52YXIgU3R5bGUgPSByZXF1aXJlKCcuLi9zdHlsZScpO1xuXG52YXIgY29yZWZuID0gKHtcblxuICBzdHlsZTogZnVuY3Rpb24oIG5ld1N0eWxlICl7XG4gICAgaWYoIG5ld1N0eWxlICl7XG4gICAgICB2YXIgcyA9IHRoaXMuc2V0U3R5bGUoIG5ld1N0eWxlICk7XG5cbiAgICAgIHMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGU7XG4gIH0sXG5cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uKCBzdHlsZSApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICBpZiggaXMuc3R5bGVzaGVldChzdHlsZSkgKXtcbiAgICAgIF9wLnN0eWxlID0gc3R5bGUuZ2VuZXJhdGVTdHlsZSh0aGlzKTtcblxuICAgIH0gZWxzZSBpZiggaXMuYXJyYXkoc3R5bGUpICkge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZS5mcm9tSnNvbih0aGlzLCBzdHlsZSk7XG5cbiAgICB9IGVsc2UgaWYoIGlzLnN0cmluZyhzdHlsZSkgKXtcbiAgICAgIF9wLnN0eWxlID0gU3R5bGUuZnJvbVN0cmluZyh0aGlzLCBzdHlsZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgX3Auc3R5bGUgPSBTdHlsZSggdGhpcyApO1xuICAgIH1cblxuICAgIHJldHVybiBfcC5zdHlsZTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG52YXIgY29yZWZuID0gKHtcblxuICBhdXRvbG9jazogZnVuY3Rpb24oYm9vbCl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvbG9jayA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG9sb2NrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGF1dG91bmdyYWJpZnk6IGZ1bmN0aW9uKGJvb2wpe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbihib29sKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBwYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgdXNlclBhbm5pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB1c2VyWm9vbWluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHBhbjogZnVuY3Rpb24oKXtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuXG4gICAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICAgIGNhc2UgMDogLy8gLnBhbigpXG4gICAgICByZXR1cm4gcGFuO1xuXG4gICAgY2FzZSAxOlxuXG4gICAgICBpZiggaXMuc3RyaW5nKCBhcmdzWzBdICkgKXsgLy8gLnBhbigneCcpXG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHJldHVybiBwYW5bIGRpbSBdO1xuXG4gICAgICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KCBhcmdzWzBdICkgKSB7IC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICBpZiggaXMubnVtYmVyKHgpICl7XG4gICAgICAgICAgcGFuLnggPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGlzLm51bWJlcih5KSApe1xuICAgICAgICAgIHBhbi55ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjogLy8gLnBhbigneCcsIDEwMClcbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgIGlmKCAoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIGlzLm51bWJlcih2YWwpICl7XG4gICAgICAgIHBhbltkaW1dID0gdmFsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcGFuQnk6IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICAgIGNhc2UgMTpcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBhcmdzWzBdICkgKSB7IC8vIC5wYW5CeSh7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgeCA9IGRpbXMueDtcbiAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICBpZiggaXMubnVtYmVyKHgpICl7XG4gICAgICAgICAgcGFuLnggKz0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpcy5udW1iZXIoeSkgKXtcbiAgICAgICAgICBwYW4ueSArPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gdmlld3BvcnQnKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAyOiAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgaWYoIChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgaXMubnVtYmVyKHZhbCkgKXtcbiAgICAgICAgcGFuW2RpbV0gKz0gdmFsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgZml0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICB2YXIgdmlld3BvcnRTdGF0ZSA9IHRoaXMuZ2V0Rml0Vmlld3BvcnQoIGVsZW1lbnRzLCBwYWRkaW5nICk7XG5cbiAgICBpZiggdmlld3BvcnRTdGF0ZSApe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIF9wLnpvb20gPSB2aWV3cG9ydFN0YXRlLnpvb207XG4gICAgICBfcC5wYW4gPSB2aWV3cG9ydFN0YXRlLnBhbjtcblxuICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBnZXRGaXRWaWV3cG9ydDogZnVuY3Rpb24oIGVsZW1lbnRzLCBwYWRkaW5nICl7XG4gICAgaWYoIGlzLm51bWJlcihlbGVtZW50cykgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkICl7IC8vIGVsZW1lbnRzIGlzIG9wdGlvbmFsXG4gICAgICBwYWRkaW5nID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYmI7XG5cbiAgICBpZiggaXMuc3RyaW5nKGVsZW1lbnRzKSApe1xuICAgICAgdmFyIHNlbCA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLiQoIHNlbCApO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5ib3VuZGluZ0JveChlbGVtZW50cykgKXsgLy8gYXNzdW1lIGJiXG4gICAgICB2YXIgYmJlID0gZWxlbWVudHM7XG4gICAgICBiYiA9IHtcbiAgICAgICAgeDE6IGJiZS54MSxcbiAgICAgICAgeTE6IGJiZS55MSxcbiAgICAgICAgeDI6IGJiZS54MixcbiAgICAgICAgeTI6IGJiZS55MlxuICAgICAgfTtcblxuICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcblxuICAgIH0gZWxzZSBpZiggIWlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICl7XG4gICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG5cbiAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICB2YXIgaCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgdmFyIHpvb207XG4gICAgcGFkZGluZyA9IGlzLm51bWJlcihwYWRkaW5nKSA/IHBhZGRpbmcgOiAwO1xuXG4gICAgaWYoICFpc05hTih3KSAmJiAhaXNOYU4oaCkgJiYgdyA+IDAgJiYgaCA+IDAgJiYgIWlzTmFOKGJiLncpICYmICFpc05hTihiYi5oKSAmJiAgYmIudyA+IDAgJiYgYmIuaCA+IDAgKXtcbiAgICAgIHpvb20gPSBNYXRoLm1pbiggKHcgLSAyKnBhZGRpbmcpL2JiLncsIChoIC0gMipwYWRkaW5nKS9iYi5oICk7XG5cbiAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuXG4gICAgICB2YXIgcGFuID0geyAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICB4OiAodyAtIHpvb20qKCBiYi54MSArIGJiLngyICkpLzIsXG4gICAgICAgIHk6IChoIC0gem9vbSooIGJiLnkxICsgYmIueTIgKSkvMlxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBwYW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9LFxuXG4gIG1pblpvb206IGZ1bmN0aW9uKCB6b29tICl7XG4gICAgaWYoIHpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWluWm9vbTtcbiAgICB9IGVsc2UgaWYoIGlzLm51bWJlcih6b29tKSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5taW5ab29tID0gem9vbTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBtYXhab29tOiBmdW5jdGlvbiggem9vbSApe1xuICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1heFpvb207XG4gICAgfSBlbHNlIGlmKCBpcy5udW1iZXIoem9vbSkgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA9IHpvb207XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgem9vbTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBwb3M7IC8vIGluIHJlbmRlcmVkIHB4XG4gICAgdmFyIHpvb207XG5cbiAgICBpZiggcGFyYW1zID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHpvb21cbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG5cbiAgICB9IGVsc2UgaWYoIGlzLm51bWJlcihwYXJhbXMpICl7IC8vIHRoZW4gc2V0IHRoZSB6b29tXG4gICAgICB6b29tID0gcGFyYW1zO1xuXG4gICAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdChwYXJhbXMpICl7IC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICBpZiggcGFyYW1zLnBvc2l0aW9uICl7XG4gICAgICAgIHZhciBwID0gcGFyYW1zLnBvc2l0aW9uO1xuICAgICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICAgIHZhciB6ID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuXG4gICAgICAgIHBvcyA9IHsgLy8gY29udmVydCB0byByZW5kZXJlZCBweFxuICAgICAgICAgIHg6IHAueCAqIHogKyBwYW4ueCxcbiAgICAgICAgICB5OiBwLnkgKiB6ICsgcGFuLnlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiggcGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gKXtcbiAgICAgICAgcG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmKCBwb3MgJiYgIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHBhbm5pbmcgZGlzYWJsZWRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgIHJldHVybiB0aGlzOyAvLyB6b29taW5nIGRpc2FibGVkXG4gICAgfVxuXG4gICAgaWYoICFpcy5udW1iZXIoem9vbSkgfHwgKCBwb3MgJiYgKCFpcy5udW1iZXIocG9zLngpIHx8ICFpcy5udW1iZXIocG9zLnkpKSApICl7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG4gICAgfVxuXG4gICAgLy8gY3JvcCB6b29tXG4gICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgIGlmKCBwb3MgKXsgLy8gc2V0IHpvb20gYWJvdXQgcG9zaXRpb25cbiAgICAgIHZhciBwYW4xID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICB2YXIgem9vbTEgPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICB2YXIgem9vbTIgPSB6b29tO1xuXG4gICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgeDogLXpvb20yL3pvb20xICogKHBvcy54IC0gcGFuMS54KSArIHBvcy54LFxuICAgICAgICB5OiAtem9vbTIvem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuem9vbSA9IHpvb207XG4gICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjI7XG5cbiAgICAgIHZhciBwb3NDaGFuZ2VkID0gcGFuMS54ICE9PSBwYW4yLnggfHwgcGFuMS55ICE9PSBwYW4yLnk7XG4gICAgICB0aGlzLnRyaWdnZXIoJyB6b29tICcgKyAocG9zQ2hhbmdlZCA/ICcgcGFuICcgOiAnJykgKyAnIHZpZXdwb3J0ICcgKTtcblxuICAgIH0gZWxzZSB7IC8vIGp1c3Qgc2V0IHRoZSB6b29tXG4gICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgdGhpcy50cmlnZ2VyKCd6b29tIHZpZXdwb3J0Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHZpZXdwb3J0OiBmdW5jdGlvbiggb3B0cyApe1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICB2YXIgcGFuRGVmZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG4gICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICB2YXIgcGFuRmFpbGVkID0gZmFsc2U7XG5cbiAgICBpZiggIW9wdHMgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICBpZiggIWlzLm51bWJlcihvcHRzLnpvb20pICl7IHpvb21EZWZkID0gZmFsc2U7IH1cbiAgICBpZiggIWlzLnBsYWluT2JqZWN0KG9wdHMucGFuKSApeyBwYW5EZWZkID0gZmFsc2U7IH1cbiAgICBpZiggIXpvb21EZWZkICYmICFwYW5EZWZkICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICBpZiggem9vbURlZmQgKXtcbiAgICAgIHZhciB6ID0gb3B0cy56b29tO1xuXG4gICAgICBpZiggeiA8IF9wLm1pblpvb20gfHwgeiA+IF9wLm1heFpvb20gfHwgIV9wLnpvb21pbmdFbmFibGVkICl7XG4gICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC56b29tID0gejtcblxuICAgICAgICBldmVudHMucHVzaCgnem9vbScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBwYW5EZWZkICYmICghem9vbUZhaWxlZCB8fCAhb3B0cy5jYW5jZWxPbkZhaWxlZFpvb20pICYmIF9wLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICB2YXIgcCA9IG9wdHMucGFuO1xuXG4gICAgICBpZiggaXMubnVtYmVyKHAueCkgKXtcbiAgICAgICAgX3AucGFuLnggPSBwLng7XG4gICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggaXMubnVtYmVyKHAueSkgKXtcbiAgICAgICAgX3AucGFuLnkgPSBwLnk7XG4gICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiggIXBhbkZhaWxlZCApe1xuICAgICAgICBldmVudHMucHVzaCgncGFuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGV2ZW50cy5sZW5ndGggPiAwICl7XG4gICAgICBldmVudHMucHVzaCgndmlld3BvcnQnKTtcbiAgICAgIHRoaXMudHJpZ2dlciggZXZlbnRzLmpvaW4oJyAnKSApO1xuXG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24oIGVsZW1lbnRzICl7XG4gICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKCBlbGVtZW50cyApO1xuXG4gICAgaWYoIHBhbiApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW47XG5cbiAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG5cbiAgICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIGdldENlbnRlclBhbjogZnVuY3Rpb24oIGVsZW1lbnRzLCB6b29tICl7XG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIGlzLnN0cmluZyhlbGVtZW50cykgKXtcbiAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCBzZWxlY3RvciApO1xuICAgIH0gZWxzZSBpZiggIWlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICl7XG4gICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICB2YXIgYmIgPSBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICB6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fcHJpdmF0ZS56b29tIDogem9vbTtcblxuICAgIHZhciBwYW4gPSB7IC8vIG1pZGRsZVxuICAgICAgeDogKHcgLSB6b29tKiggYmIueDEgKyBiYi54MiApKS8yLFxuICAgICAgeTogKGggLSB6b29tKiggYmIueTEgKyBiYi55MiApKS8yXG4gICAgfTtcblxuICAgIHJldHVybiBwYW47XG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uKCl7XG4gICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLnZpZXdwb3J0KHtcbiAgICAgIHBhbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICB6b29tOiAxXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICB3aWR0aDogZnVuY3Rpb24oKXtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG5cbiAgICBpZiggY29udGFpbmVyICl7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiAxOyAvLyBmYWxsYmFjayBpZiBubyBjb250YWluZXIgKG5vdCAwIGIvYyBjYW4gYmUgdXNlZCBmb3IgZGl2aWRpbmcgZXRjKVxuICB9LFxuXG4gIGhlaWdodDogZnVuY3Rpb24oKXtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG5cbiAgICBpZiggY29udGFpbmVyICl7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gMTsgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgfSxcblxuICBleHRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgIHZhciByYiA9IHRoaXMucmVuZGVyZWRFeHRlbnQoKTtcblxuICAgIHZhciBiID0ge1xuICAgICAgeDE6ICggcmIueDEgLSBwYW4ueCApL3pvb20sXG4gICAgICB4MjogKCByYi54MiAtIHBhbi54ICkvem9vbSxcbiAgICAgIHkxOiAoIHJiLnkxIC0gcGFuLnkgKS96b29tLFxuICAgICAgeTI6ICggcmIueTIgLSBwYW4ueSApL3pvb21cbiAgICB9O1xuXG4gICAgYi53ID0gYi54MiAtIGIueDE7XG4gICAgYi5oID0gYi55MiAtIGIueTE7XG5cbiAgICByZXR1cm4gYjtcbiAgfSxcblxuICByZW5kZXJlZEV4dGVudDogZnVuY3Rpb24oKXtcbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHgyOiB3aWR0aCxcbiAgICAgIHkyOiBoZWlnaHQsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBhbGlhc2VzXG5jb3JlZm4uY2VudHJlID0gY29yZWZuLmNlbnRlcjtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmNvcmVmbi5hdXRvbG9ja05vZGVzID0gY29yZWZuLmF1dG9sb2NrO1xuY29yZWZuLmF1dG91bmdyYWJpZnlOb2RlcyA9IGNvcmVmbi5hdXRvdW5ncmFiaWZ5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gdXNlIHRoaXMgbW9kdWxlIHRvIGNoZXJyeSBwaWNrIGZ1bmN0aW9ucyBpbnRvIHlvdXIgcHJvdG90eXBlXG4vLyAodXNlZnVsIGZvciBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gdGhlIGNvcmUgYW5kIGNvbGxlY3Rpb25zLCBmb3IgZXhhbXBsZSlcblxuLy8gZS5nLlxuLy8gdmFyIGZvbyA9IGRlZmluZS5mb28oeyAvKiBwYXJhbXMuLi4gKi8gfSlcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcbnZhciBTZWxlY3RvciA9IHJlcXVpcmUoJy4vc2VsZWN0b3InKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG52YXIgQW5pbWF0aW9uID0gcmVxdWlyZSgnLi9hbmltYXRpb24nKTtcblxudmFyIGRlZmluZSA9IHtcblxuICAvLyBhY2Nlc3MgZGF0YSBmaWVsZFxuICBkYXRhOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSwgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICBvblNldDogZnVuY3Rpb24oIHNlbGYgKXt9LFxuICAgICAgY2FuU2V0OiBmdW5jdGlvbiggc2VsZiApeyByZXR1cm4gdHJ1ZTsgfVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKCBuYW1lLCB2YWx1ZSApe1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBzaW5nbGUgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmWzBdIDogc2VsZjtcblxuICAgICAgLy8gLmRhdGEoJ2ZvbycsIC4uLilcbiAgICAgIGlmKCBpcy5zdHJpbmcobmFtZSkgKXsgLy8gc2V0IG9yIGdldCBwcm9wZXJ0eVxuXG4gICAgICAgIC8vIC5kYXRhKCdmb28nKVxuICAgICAgICBpZiggcC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyBnZXRcblxuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICAvLyAuZGF0YSgnZm9vJywgJ2JhcicpXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHsgLy8gc2V0XG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1tuYW1lXTtcbiAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGFsbFtpXSApICl7XG4gICAgICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXSA9IHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICAgICAgcC5vblNldCggc2VsZiApO1xuXG4gICAgICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5zZXR0aW5nRXZlbnQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgLy8gLmRhdGEoeyAnZm9vJzogJ2JhcicgfSlcbiAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgaXMucGxhaW5PYmplY3QobmFtZSkgKXsgLy8gZXh0ZW5kXG4gICAgICAgIHZhciBvYmogPSBuYW1lO1xuICAgICAgICB2YXIgaywgdjtcblxuICAgICAgICBmb3IoIGsgaW4gb2JqICl7XG4gICAgICAgICAgdiA9IG9ialsgayBdO1xuXG4gICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1trXTtcbiAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGFsbFtpXSApICl7XG4gICAgICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlWyBwLmZpZWxkIF1bIGsgXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgIHAub25TZXQoIHNlbGYgKTtcblxuICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLnNldHRpbmdFdmVudCApO1xuICAgICAgICB9XG5cbiAgICAgIC8vIC5kYXRhKGZ1bmN0aW9uKCl7IC4uLiB9KVxuICAgICAgfSBlbHNlIGlmKCBwLmFsbG93QmluZGluZyAmJiBpcy5mbihuYW1lKSApeyAvLyBiaW5kIHRvIGV2ZW50XG4gICAgICAgIHZhciBmbiA9IG5hbWU7XG4gICAgICAgIHNlbGYuYmluZCggcC5iaW5kaW5nRXZlbnQsIGZuICk7XG5cbiAgICAgIC8vIC5kYXRhKClcbiAgICAgIH0gZWxzZSBpZiggcC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkICl7IC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgaWYoIHNpbmdsZSApe1xuICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmFiaWxpdHlcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyBkYXRhXG5cbiAgLy8gcmVtb3ZlIGRhdGEgZmllbGRcbiAgcmVtb3ZlRGF0YTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZURhdGFJbXBsKCBuYW1lcyApe1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgLy8gLnJlbW92ZURhdGEoJ2ZvbyBiYXInKVxuICAgICAgaWYoIGlzLnN0cmluZyhuYW1lcykgKXsgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGw7IGkrKyApeyAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYoIGlzLmVtcHR5U3RyaW5nKGtleSkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdOyAvLyBub3QgdmFsaWQgaWYgaW1tdXRhYmxlXG4gICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgICAgIGFsbFsgaV9hIF0uX3ByaXZhdGVbIHAuZmllbGQgXVsga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyAucmVtb3ZlRGF0YSgpXG4gICAgICB9IGVsc2UgaWYoIG5hbWVzID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBkZWxldGUgYWxsIGtleXNcblxuICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsWyBpX2EgXS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuXG4gICAgICAgICAgZm9yKCB2YXIga2V5IGluIF9wcml2YXRlRmllbGRzICl7XG4gICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbIGtleSBdO1xuXG4gICAgICAgICAgICBpZiggdmFsaWRLZXlUb0RlbGV0ZSApe1xuICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1sga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyByZW1vdmVEYXRhXG5cbiAgLy8gZXZlbnQgZnVuY3Rpb24gcmV1c2FibGUgc3R1ZmZcbiAgZXZlbnQ6IHtcbiAgICByZWdleDogLyhcXHcrKShcXC5cXHcrKT8vLCAvLyByZWdleCBmb3IgbWF0Y2hpbmcgZXZlbnQgc3RyaW5ncyAoZS5nLiBcImNsaWNrLm5hbWVzcGFjZVwiKVxuICAgIG9wdGlvbmFsVHlwZVJlZ2V4OiAvKFxcdyspPyhcXC5cXHcrKT8vLFxuICAgIGZhbHNlQ2FsbGJhY2s6IGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfVxuICB9LFxuXG4gIC8vIGV2ZW50IGJpbmRpbmdcbiAgb246IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBmYWxzZSxcbiAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IGZhbHNlXG4gICAgfTtcbiAgICBwYXJhbXMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gb25JbXBsKGV2ZW50cywgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKGV2ZW50cyk7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KHNlbGVjdG9yKSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBkYXRhXG4gICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHNlbGVjdG9yO1xuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiggaXMuZm4oc2VsZWN0b3IpIHx8IHNlbGVjdG9yID09PSBmYWxzZSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYoIGlzLmZuKGRhdGEpIHx8IGRhdGEgPT09IGZhbHNlICl7IC8vIGRhdGEgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSBpc24ndCBhIGNhbGxiYWNrLCB3ZSBjYW4ndCByZWFsbHkgZG8gYW55dGhpbmdcbiAgICAgIC8vIChjYW4ndCBzcGVhayBmb3IgbWFwcGVkIGV2ZW50cyBhcmcgdmVyc2lvbilcbiAgICAgIGlmKCAhKGlzLmZuKGNhbGxiYWNrKSB8fCBjYWxsYmFjayA9PT0gZmFsc2UpICYmIGV2ZW50c0lzU3RyaW5nICl7XG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfVxuXG4gICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBldnRzIGluIGV2ZW50cyApe1xuICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1tldnRzXTtcbiAgICAgICAgaWYoIGNhbGxiYWNrID09PSBmYWxzZSApe1xuICAgICAgICAgIGNhbGxiYWNrID0gZGVmaW5lLmV2ZW50LmZhbHNlQ2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWlzLmZuKGNhbGxiYWNrKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBldnQgPSBldnRzW2ldO1xuICAgICAgICAgIGlmKCBpcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goIGRlZmluZS5ldmVudC5yZWdleCApOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0ge1xuICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssIC8vIGNhbGxiYWNrIHRvIHJ1blxuICAgICAgICAgICAgICBkYXRhOiBkYXRhLCAvLyBleHRyYSBkYXRhIGluIGV2ZW50T2JqLmRhdGFcbiAgICAgICAgICAgICAgZGVsZWdhdGVkOiBzZWxlY3RvciA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZXZ0IGlzIGRlbGVnYXRlZFxuICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsIC8vIHRoZSBzZWxlY3RvciB0byBtYXRjaCBmb3IgZGVsZWdhdGVkIGV2ZW50c1xuICAgICAgICAgICAgICBzZWxPYmo6IG5ldyBTZWxlY3RvcihzZWxlY3RvciksIC8vIGNhY2hlZCBzZWxlY3RvciBvYmplY3QgdG8gc2F2ZSByZWJ1aWxkaW5nXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsIC8vIHRoZSBldmVudCB0eXBlIChlLmcuICdjbGljaycpXG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLCAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICAgICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBwLnVuYmluZFNlbGZPblRyaWdnZXIsXG4gICAgICAgICAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHAudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcixcbiAgICAgICAgICAgICAgYmluZGVyczogYWxsIC8vIHdobyBib3VuZCB0b2dldGhlclxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgdmFyIF9wID0gYWxsW2pdLl9wcml2YXRlO1xuXG4gICAgICAgICAgICAgIF9wLmxpc3RlbmVycyA9IF9wLmxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgICAgICAgX3AubGlzdGVuZXJzLnB1c2goIGxpc3RlbmVyICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcbiAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcblxuICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSwgLy8gb25cblxuICBldmVudEFsaWFzZXNPbjogZnVuY3Rpb24oIHByb3RvICl7XG4gICAgdmFyIHAgPSBwcm90bztcblxuICAgIHAuYWRkTGlzdGVuZXIgPSBwLmxpc3RlbiA9IHAuYmluZCA9IHAub247XG4gICAgcC5yZW1vdmVMaXN0ZW5lciA9IHAudW5saXN0ZW4gPSBwLnVuYmluZCA9IHAub2ZmO1xuICAgIHAuZW1pdCA9IHAudHJpZ2dlcjtcblxuICAgIC8vIHRoaXMgaXMganVzdCBhIHdyYXBwZXIgYWxpYXMgb2YgLm9uKClcbiAgICBwLnBvbiA9IHAucHJvbWlzZU9uID0gZnVuY3Rpb24oIGV2ZW50cywgc2VsZWN0b3IgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiggZSApe1xuICAgICAgICAgIHNlbGYub2ZmLmFwcGx5KCBzZWxmLCBvZmZBcmdzICk7XG5cbiAgICAgICAgICByZXNvbHZlKCBlICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG9uQXJncyA9IGFyZ3MuY29uY2F0KFsgY2FsbGJhY2sgXSk7XG4gICAgICAgIHZhciBvZmZBcmdzID0gb25BcmdzLmNvbmNhdChbXSk7XG5cbiAgICAgICAgc2VsZi5vbi5hcHBseSggc2VsZiwgb25BcmdzICk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuXG4gIG9mZjogZnVuY3Rpb24gb2ZmSW1wbCggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgIH07XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKGV2ZW50cyk7XG5cbiAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICl7IC8vIHRoZW4gdW5iaW5kIGFsbFxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9XG5cbiAgICAgIGlmKCBpcy5mbihzZWxlY3RvcikgfHwgc2VsZWN0b3IgPT09IGZhbHNlICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBldnRzIGluIGV2ZW50cyApe1xuICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1tldnRzXTtcblxuICAgICAgICBpZiggY2FsbGJhY2sgPT09IGZhbHNlICl7XG4gICAgICAgICAgY2FsbGJhY2sgPSBkZWZpbmUuZXZlbnQuZmFsc2VDYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGZvciggdmFyIGggPSAwOyBoIDwgZXZ0cy5sZW5ndGg7IGgrKyApe1xuICAgICAgICAgIHZhciBldnQgPSBldnRzW2hdO1xuICAgICAgICAgIGlmKCBpcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goIGRlZmluZS5ldmVudC5vcHRpb25hbFR5cGVSZWdleCApOyAvLyBbdHlwZV1bLm5hbWVzcGFjZV1cbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApeyAvL1xuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyA9IGFsbFtpXS5fcHJpdmF0ZS5saXN0ZW5lcnMgfHwgW107XG5cbiAgICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBsaXN0ZW5lcnMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbal07XG4gICAgICAgICAgICAgICAgdmFyIG5zTWF0Y2hlcyA9ICFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSBsaXN0ZW5lci5uYW1lc3BhY2U7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVNYXRjaGVzID0gIXR5cGUgfHwgbGlzdGVuZXIudHlwZSA9PT0gdHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgY2JNYXRjaGVzID0gIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBsaXN0ZW5lci5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXRjaGVzID0gbnNNYXRjaGVzICYmIHR5cGVNYXRjaGVzICYmIGNiTWF0Y2hlcztcblxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBsaXN0ZW5lciBpZiBpdCBtYXRjaGVzXG4gICAgICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApe1xuICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gZm9yIGxpc3RlbmVyc1xuICAgICAgICAgICAgfSAvLyBmb3IgYWxsXG4gICAgICAgICAgfSAvLyBpZiBtYXRjaFxuICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcblxuICAgICAgfSAvLyBmb3IgZXZlbnRzIG1hcFxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyBvZmZcblxuICB0cmlnZ2VyOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgcGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRyaWdnZXJJbXBsKGV2ZW50cywgZXh0cmFQYXJhbXMsIGZuVG9UcmlnZ2VyKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gaXMuc3RyaW5nKGV2ZW50cyk7XG4gICAgICB2YXIgZXZlbnRzSXNPYmplY3QgPSBpcy5wbGFpbk9iamVjdChldmVudHMpO1xuICAgICAgdmFyIGV2ZW50c0lzRXZlbnQgPSBpcy5ldmVudChldmVudHMpO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCAoIGlzLmNvcmUodGhpcykgPyB0aGlzIDogbnVsbCApO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5ID8gY3kuaGFzQ29tcG91bmROb2RlcygpIDogZmFsc2U7XG5cbiAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIG1ha2UgYSBwbGFpbiBldmVudCBvYmplY3QgZm9yIGVhY2ggZXZlbnQgbmFtZVxuICAgICAgICB2YXIgZXZ0cyA9IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBldmVudHMgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1tpXTtcbiAgICAgICAgICBpZiggaXMuZW1wdHlTdHJpbmcoZXZ0KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCBkZWZpbmUuZXZlbnQucmVnZXggKTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBldmVudHMucHVzaCgge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlXG4gICAgICAgICAgfSApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoIGV2ZW50c0lzT2JqZWN0ICl7IC8vIHB1dCBpbiBsZW5ndGggMSBhcnJheVxuICAgICAgICB2YXIgZXZlbnRBcmdPYmogPSBldmVudHM7XG5cbiAgICAgICAgZXZlbnRzID0gWyBldmVudEFyZ09iaiBdO1xuICAgICAgfVxuXG4gICAgICBpZiggZXh0cmFQYXJhbXMgKXtcbiAgICAgICAgaWYoICFpcy5hcnJheShleHRyYVBhcmFtcykgKXsgLy8gbWFrZSBzdXJlIGV4dHJhIHBhcmFtcyBhcmUgaW4gYW4gYXJyYXkgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgZXh0cmFQYXJhbXMgPSBbIGV4dHJhUGFyYW1zIF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgd2UndmUgZ290IG5vdGhpbmdcbiAgICAgICAgZXh0cmFQYXJhbXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKysgKXsgLy8gdHJpZ2dlciBlYWNoIGV2ZW50IGluIG9yZGVyXG4gICAgICAgIHZhciBldnRPYmogPSBldmVudHNbaV07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2hcbiAgICAgICAgICB2YXIgdHJpZ2dlcmVyID0gYWxsW2pdO1xuICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0cmlnZ2VyZXIuX3ByaXZhdGUubGlzdGVuZXJzID0gdHJpZ2dlcmVyLl9wcml2YXRlLmxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgICB2YXIgdHJpZ2dlcmVySXNFbGVtZW50ID0gaXMuZWxlbWVudCh0cmlnZ2VyZXIpO1xuICAgICAgICAgIHZhciBidWJibGVVcCA9IHRyaWdnZXJlcklzRWxlbWVudCB8fCBwYXJhbXMubGF5b3V0O1xuXG4gICAgICAgICAgLy8gY3JlYXRlIHRoZSBldmVudCBmb3IgdGhpcyBlbGVtZW50IGZyb20gdGhlIGV2ZW50IG9iamVjdFxuICAgICAgICAgIHZhciBldnQ7XG5cbiAgICAgICAgICBpZiggZXZlbnRzSXNFdmVudCApeyAvLyB0aGVuIGp1c3QgZ2V0IHRoZSBvYmplY3RcbiAgICAgICAgICAgIGV2dCA9IGV2dE9iajtcblxuICAgICAgICAgICAgZXZ0LmN5VGFyZ2V0ID0gZXZ0LmN5VGFyZ2V0IHx8IHRyaWdnZXJlcjtcbiAgICAgICAgICAgIGV2dC5jeSA9IGV2dC5jeSB8fCBjeTtcblxuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gd2UgaGF2ZSB0byBtYWtlIG9uZVxuICAgICAgICAgICAgZXZ0ID0gbmV3IEV2ZW50KCBldnRPYmosIHtcbiAgICAgICAgICAgICAgY3lUYXJnZXQ6IHRyaWdnZXJlcixcbiAgICAgICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dE9iai5uYW1lc3BhY2VcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBhIGxheW91dCB3YXMgc3BlY2lmaWVkLCB0aGVuIHB1dCBpdCBpbiB0aGUgdHlwZWQgZXZlbnRcbiAgICAgICAgICBpZiggZXZ0T2JqLmxheW91dCApe1xuICAgICAgICAgICAgZXZ0LmxheW91dCA9IGV2dE9iai5sYXlvdXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdHJpZ2dlcmVkIGJ5IGxheW91dCwgcHV0IGluIGV2ZW50XG4gICAgICAgICAgaWYoIHBhcmFtcy5sYXlvdXQgKXtcbiAgICAgICAgICAgIGV2dC5sYXlvdXQgPSB0cmlnZ2VyZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gY3JlYXRlIGEgcmVuZGVyZWQgcG9zaXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBwb3NpdGlvblxuICAgICAgICAgIGlmKCBldnQuY3lQb3NpdGlvbiApe1xuICAgICAgICAgICAgdmFyIHBvcyA9IGV2dC5jeVBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgICAgIGV2dC5jeVJlbmRlcmVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZm5Ub1RyaWdnZXIgKXsgLy8gdGhlbiBvdmVycmlkZSB0aGUgbGlzdGVuZXJzIGxpc3Qgd2l0aCBqdXN0IHRoZSBvbmUgd2Ugc3BlY2lmaWVkXG4gICAgICAgICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dC5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgIHR5cGU6IGV2dC50eXBlLFxuICAgICAgICAgICAgICBjYWxsYmFjazogZm5Ub1RyaWdnZXJcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgbGlzdGVuZXJzLmxlbmd0aDsgaysrICl7IC8vIGNoZWNrIGVhY2ggbGlzdGVuZXJcbiAgICAgICAgICAgIHZhciBsaXMgPSBsaXN0ZW5lcnNba107XG4gICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIWxpcy5uYW1lc3BhY2UgfHwgbGlzLm5hbWVzcGFjZSA9PT0gZXZ0Lm5hbWVzcGFjZTtcbiAgICAgICAgICAgIHZhciB0eXBlTWF0Y2hlcyA9IGxpcy50eXBlID09PSBldnQudHlwZTtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNYXRjaGVzID0gbGlzLmRlbGVnYXRlZCA/ICggdHJpZ2dlcmVyICE9PSBldnQuY3lUYXJnZXQgJiYgaXMuZWxlbWVudChldnQuY3lUYXJnZXQpICYmIGxpcy5zZWxPYmoubWF0Y2hlcyhldnQuY3lUYXJnZXQpICkgOiAodHJ1ZSk7IC8vIHdlJ3JlIG5vdCBnb2luZyB0byB2YWxpZGF0ZSB0aGUgaGllcmFyY2h5OyB0aGF0J3MgdG9vIGV4cGVuc2l2ZVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyTWF0Y2hlcyA9IG5zTWF0Y2hlcyAmJiB0eXBlTWF0Y2hlcyAmJiB0YXJnZXRNYXRjaGVzO1xuXG4gICAgICAgICAgICBpZiggbGlzdGVuZXJNYXRjaGVzICl7IC8vIHRoZW4gdHJpZ2dlciBpdFxuICAgICAgICAgICAgICB2YXIgYXJncyA9IFsgZXZ0IF07XG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdCggZXh0cmFQYXJhbXMgKTsgLy8gYWRkIGV4dHJhIHBhcmFtcyB0byBhcmdzIGxpc3RcblxuICAgICAgICAgICAgICBpZiggbGlzLmRhdGEgKXsgLy8gYWRkIG9uIGRhdGEgcGx1Z2dlZCBpbnRvIGJpbmRpbmdcbiAgICAgICAgICAgICAgICBldnQuZGF0YSA9IGxpcy5kYXRhO1xuICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBvciBjbGVhciBpdCBpbiBjYXNlIHRoZSBldmVudCBvYmogaXMgcmV1c2VkXG4gICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiggbGlzLnVuYmluZFNlbGZPblRyaWdnZXIgfHwgbGlzLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIgKXsgLy8gdGhlbiByZW1vdmUgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgICAgIGstLTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCBsaXMudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlciApeyAvLyB0aGVuIGRlbGV0ZSB0aGUgbGlzdGVuZXIgZm9yIGFsbCBiaW5kZXJzXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRlcnMgPSBsaXMuYmluZGVycztcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGJpbmRlcnMubGVuZ3RoOyBsKysgKXtcbiAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXIgPSBiaW5kZXJzW2xdO1xuICAgICAgICAgICAgICAgICAgaWYoICFiaW5kZXIgfHwgYmluZGVyID09PSB0cmlnZ2VyZXIgKXsgY29udGludWU7IH0gLy8gYWxyZWFkeSBoYW5kbGVkIHRyaWdnZXJlciBvciB3ZSBjYW4ndCBoYW5kbGUgaXRcblxuICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlckxpc3RlbmVycyA9IGJpbmRlci5fcHJpdmF0ZS5saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICBmb3IoIHZhciBtID0gMDsgbSA8IGJpbmRlckxpc3RlbmVycy5sZW5ndGg7IG0rKyApe1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluZGVyTGlzdGVuZXIgPSBiaW5kZXJMaXN0ZW5lcnNbbV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIGJpbmRlckxpc3RlbmVyID09PSBsaXMgKXsgLy8gZGVsZXRlIGxpc3RlbmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgIGJpbmRlckxpc3RlbmVycy5zcGxpY2UobSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgbS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gcnVuIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IGxpcy5kZWxlZ2F0ZWQgPyBldnQuY3lUYXJnZXQgOiB0cmlnZ2VyZXI7XG4gICAgICAgICAgICAgIHZhciByZXQgPSBsaXMuY2FsbGJhY2suYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcblxuICAgICAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSB8fCBldnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApe1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gZG9uJ3QgYnViYmxlXG4gICAgICAgICAgICAgICAgYnViYmxlVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgaXMgYSBzaG9ydGhhbmQgZm9yIHN0b3BwaW5nIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50aW5nIHRoZSBkZWYuIGFjdGlvblxuICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcbiAgICAgICAgICB9IC8vIGZvciBlYWNoIGxpc3RlbmVyXG5cbiAgICAgICAgICAvLyBidWJibGUgdXAgZXZlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgaWYoIGJ1YmJsZVVwICl7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmRzID8gdHJpZ2dlcmVyLl9wcml2YXRlLnBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lmxlbmd0aCAhPT0gMDtcblxuICAgICAgICAgICAgaWYoIGhhc1BhcmVudCApeyAvLyB0aGVuIGJ1YmJsZSB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgICBwYXJlbnQudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBidWJibGUgdXAgdG8gdGhlIGNvcmVcbiAgICAgICAgICAgICAgY3kudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IC8vIGZvciBlYWNoIG9mIGFsbFxuICAgICAgfSAvLyBmb3IgZWFjaCBldmVudFxuXG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9LCAvLyB0cmlnZ2VyXG5cbiAgYW5pbWF0ZWQ6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZWRJbXBsKCl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50Lmxlbmd0aCA+IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgLy8gYW5pbWF0ZWRcblxuICBjbGVhclF1ZXVlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyUXVldWVJbXBsKCl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0sIC8vIGNsZWFyUXVldWVcblxuICBkZWxheTogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgZm5QYXJhbXMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwoIHRpbWUsIGNvbXBsZXRlICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LCAvLyBkZWxheVxuXG4gIGRlbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5QW5pbWF0aW9uSW1wbCggdGltZSwgY29tcGxldGUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24oe1xuICAgICAgICBkZWxheTogdGltZSxcbiAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgLy8gZGVsYXlcblxuICBhbmltYXRpb246IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0aW9uSW1wbCggcHJvcGVydGllcywgcGFyYW1zICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIHZhciBpc0NvcmUgPSAhc2VsZklzQXJyYXlMaWtlO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICAgICAgcHJvcGVydGllcyA9IHV0aWwuZXh0ZW5kKCB7fSwgcHJvcGVydGllcywgcGFyYW1zICk7XG5cbiAgICAgIGlmKCBwcm9wZXJ0aWVzLmR1cmF0aW9uID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoKCBwcm9wZXJ0aWVzLmR1cmF0aW9uICl7XG4gICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDYwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDIwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wZXJ0aWVzRW1wdHkgPSB0cnVlO1xuICAgICAgaWYoIHByb3BlcnRpZXMgKXsgZm9yKCB2YXIgaSBpbiBwcm9wZXJ0aWVzICl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICBwcm9wZXJ0aWVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IH1cblxuICAgICAgaWYoIHByb3BlcnRpZXNFbXB0eSApe1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbiggYWxsWzBdLCBwcm9wZXJ0aWVzICk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgfVxuXG4gICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgIHByb3BlcnRpZXMuc3R5bGUgPSBzdHlsZS5nZXRQcm9wc0xpc3QoIHByb3BlcnRpZXMuc3R5bGUgfHwgcHJvcGVydGllcy5jc3MgKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYoIHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbiAmJiBpc0VsZXMgKXtcbiAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgICAgcHJvcGVydGllcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiAoIHJwb3MueCAtIHBhbi54ICkgL3pvb20sXG4gICAgICAgICAgeTogKCBycG9zLnkgLSBwYW4ueSApIC96b29tXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBwYW5CeSBpZiBzZXRcbiAgICAgIGlmKCBwcm9wZXJ0aWVzLnBhbkJ5ICYmIGlzQ29yZSApe1xuICAgICAgICB2YXIgcGFuQnkgPSBwcm9wZXJ0aWVzLnBhbkJ5O1xuICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IHtcbiAgICAgICAgICB4OiBjeVBhbi54ICsgcGFuQnkueCxcbiAgICAgICAgICB5OiBjeVBhbi55ICsgcGFuQnkueVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gdy8gY2VudGVyIGlmIHNldFxuICAgICAgdmFyIGNlbnRlciA9IHByb3BlcnRpZXMuY2VudGVyIHx8IHByb3BlcnRpZXMuY2VudHJlO1xuICAgICAgaWYoIGNlbnRlciAmJiBpc0NvcmUgKXtcbiAgICAgICAgdmFyIGNlbnRlclBhbiA9IGN5LmdldENlbnRlclBhbiggY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSApO1xuXG4gICAgICAgIGlmKCBjZW50ZXJQYW4gKXtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGNlbnRlclBhbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gJiB6b29tIHcvIGZpdCBpZiBzZXRcbiAgICAgIGlmKCBwcm9wZXJ0aWVzLmZpdCAmJiBpc0NvcmUgKXtcbiAgICAgICAgdmFyIGZpdCA9IHByb3BlcnRpZXMuZml0O1xuICAgICAgICB2YXIgZml0VnAgPSBjeS5nZXRGaXRWaWV3cG9ydCggZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyApO1xuXG4gICAgICAgIGlmKCBmaXRWcCApe1xuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gZml0VnAucGFuO1xuICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IGZpdFZwLnpvb207XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oIGFsbFswXSwgcHJvcGVydGllcyApO1xuICAgIH07XG4gIH0sIC8vIGFuaW1hdGVcblxuICBhbmltYXRlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICBmblBhcmFtcyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKCBwcm9wZXJ0aWVzLCBwYXJhbXMgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIGlmKCBwYXJhbXMgKXtcbiAgICAgICAgcHJvcGVydGllcyA9IHV0aWwuZXh0ZW5kKCB7fSwgcHJvcGVydGllcywgcGFyYW1zICk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hbnVhbGx5IGhvb2sgYW5kIHJ1biB0aGUgYW5pbWF0aW9uXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICB2YXIgcXVldWUgPSBlbGUuYW5pbWF0ZWQoKSAmJiAocHJvcGVydGllcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BlcnRpZXMucXVldWUpO1xuXG4gICAgICAgIHZhciBhbmkgPSBlbGUuYW5pbWF0aW9uKCBwcm9wZXJ0aWVzLCAocXVldWUgPyB7IHF1ZXVlOiB0cnVlIH0gOiB1bmRlZmluZWQpICk7XG5cbiAgICAgICAgYW5pLnBsYXkoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfTtcbiAgfSwgLy8gYW5pbWF0ZVxuXG4gIHN0b3A6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgIGZuUGFyYW1zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoIGNsZWFyUXVldWUsIGp1bXBUb0VuZCApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgYW5pcyA9IF9wLmFuaW1hdGlvbi5jdXJyZW50O1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYW5pcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBhbmkgPSBhbmlzW2pdO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcblxuICAgICAgICAgIGlmKCBqdW1wVG9FbmQgKXtcbiAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBnbyBzdHJhaWdodCB0byB0aGUgZW5kIGFuZCBiZSByZW1vdmVkXG4gICAgICAgICAgICBhbmlfcC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgIGlmKCBjbGVhclF1ZXVlICl7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWp1bXBUb0VuZCApe1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG4gICAgICBjeS5ub3RpZnkoe1xuICAgICAgICBjb2xsZWN0aW9uOiB0aGlzLFxuICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9IC8vIHN0b3BcblxufTsgLy8gZGVmaW5lXG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyByZWZcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuXG52YXIgRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcbiAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gIGlmICggISh0aGlzIGluc3RhbmNlb2YgRXZlbnQpICkge1xuICAgIHJldHVybiBuZXcgRXZlbnQoIHNyYywgcHJvcHMgKTtcbiAgfVxuXG4gIC8vIEV2ZW50IG9iamVjdFxuICBpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcbiAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG4gICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gKCBzcmMuZGVmYXVsdFByZXZlbnRlZCApID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlO1xuXG4gIC8vIEV2ZW50IHR5cGVcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnR5cGUgPSBzcmM7XG4gIH1cblxuICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICBpZiAoIHByb3BzICkge1xuICAgIC8vIHV0aWwuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXG4gICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gbWFudWFsbHkgY29weSBmaWVsZHMgd2UgdXNlXG4gICAgdGhpcy50eXBlID0gcHJvcHMudHlwZSAhPT0gdW5kZWZpbmVkID8gcHJvcHMudHlwZSA6IHRoaXMudHlwZTtcbiAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgdGhpcy5jeVRhcmdldCA9IHByb3BzLmN5VGFyZ2V0O1xuICAgIHRoaXMuY3lQb3NpdGlvbiA9IHByb3BzLmN5UG9zaXRpb247XG4gICAgdGhpcy5jeVJlbmRlcmVkUG9zaXRpb24gPSBwcm9wcy5jeVJlbmRlcmVkUG9zaXRpb247XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgdGhpcy5sYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgdGhpcy5kYXRhID0gcHJvcHMuZGF0YTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBwcm9wcy5tZXNzYWdlO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcbiAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xufTtcblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuRXZlbnQucHJvdG90eXBlID0ge1xuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gJ2V2ZW50JztcbiAgfSxcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG4gICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgaWYgKCAhZSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmICggZS5wcmV2ZW50RGVmYXVsdCApIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgIGlmICggIWUgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgaWYgKCBlLnN0b3BQcm9wYWdhdGlvbiApIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBkZWZpbmUgPSByZXF1aXJlKCcuL2RlZmluZScpO1xudmFyIENvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2NvbGxlY3Rpb24nKTtcbnZhciBDb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG52YXIgaW5jRXh0cyA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9ucycpO1xudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xuXG4vLyByZWdpc3RlcmVkIGV4dGVuc2lvbnMgdG8gY3l0b3NjYXBlLCBpbmRleGVkIGJ5IG5hbWVcbnZhciBleHRlbnNpb25zID0ge307XG5cbi8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG52YXIgbW9kdWxlcyA9IHt9O1xuXG5mdW5jdGlvbiBzZXRFeHRlbnNpb24oIHR5cGUsIG5hbWUsIHJlZ2lzdHJhbnQgKXtcblxuICB2YXIgZXh0ID0gcmVnaXN0cmFudDtcblxuICBpZiggdHlwZSA9PT0gJ2NvcmUnICl7XG4gICAgQ29yZS5wcm90b3R5cGVbIG5hbWUgXSA9IHJlZ2lzdHJhbnQ7XG5cbiAgfSBlbHNlIGlmKCB0eXBlID09PSAnY29sbGVjdGlvbicgKXtcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVsgbmFtZSBdID0gcmVnaXN0cmFudDtcblxuICB9IGVsc2UgaWYoIHR5cGUgPT09ICdsYXlvdXQnICl7XG4gICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuXG4gICAgdmFyIExheW91dCA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICByZWdpc3RyYW50LmNhbGwoIHRoaXMsIG9wdGlvbnMgKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG4gICAgICBpZiggIWlzLnBsYWluT2JqZWN0KHRoaXMuX3ByaXZhdGUpICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJpdmF0ZS5jeSA9IG9wdGlvbnMuY3k7XG4gICAgICB0aGlzLl9wcml2YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgIH07XG5cbiAgICB2YXIgbGF5b3V0UHJvdG8gPSBMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggcmVnaXN0cmFudC5wcm90b3R5cGUgKTtcblxuICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3B0TGF5b3V0Rm5zLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZm5OYW1lID0gb3B0TGF5b3V0Rm5zW2ldO1xuXG4gICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcbiAgICB9XG5cbiAgICAvLyBlaXRoZXIgLnN0YXJ0KCkgb3IgLnJ1bigpIGlzIGRlZmluZWQsIHNvIGF1dG9nZW4gdGhlIG90aGVyXG4gICAgaWYoIGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4gKXtcbiAgICAgIGxheW91dFByb3RvLnJ1biA9IGZ1bmN0aW9uKCl7IHRoaXMuc3RhcnQoKTsgcmV0dXJuIHRoaXM7IH07XG4gICAgfSBlbHNlIGlmKCAhbGF5b3V0UHJvdG8uc3RhcnQgJiYgbGF5b3V0UHJvdG8ucnVuICl7XG4gICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uKCl7IHRoaXMucnVuKCk7IHJldHVybiB0aGlzOyB9O1xuICAgIH1cblxuICAgIGlmKCAhbGF5b3V0UHJvdG8uc3RvcCApe1xuICAgICAgbGF5b3V0UHJvdG8uc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgICAgIGlmKCBvcHRzICYmIG9wdHMuYW5pbWF0ZSApe1xuICAgICAgICAgIHZhciBhbmlzID0gdGhpcy5hbmltYXRpb25zO1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYW5pcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgYW5pc1tpXS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdsYXlvdXRzdG9wJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmKCAhbGF5b3V0UHJvdG8uZGVzdHJveSApe1xuICAgICAgbGF5b3V0UHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBsYXlvdXRQcm90by5vbiA9IGRlZmluZS5vbih7IGxheW91dDogdHJ1ZSB9KTtcbiAgICBsYXlvdXRQcm90by5vbmUgPSBkZWZpbmUub24oeyBsYXlvdXQ6IHRydWUsIHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSk7XG4gICAgbGF5b3V0UHJvdG8ub25jZSA9IGRlZmluZS5vbih7IGxheW91dDogdHJ1ZSwgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICBsYXlvdXRQcm90by5vZmYgPSBkZWZpbmUub2ZmKHsgbGF5b3V0OiB0cnVlIH0pO1xuICAgIGxheW91dFByb3RvLnRyaWdnZXIgPSBkZWZpbmUudHJpZ2dlcih7IGxheW91dDogdHJ1ZSB9KTtcblxuICAgIGRlZmluZS5ldmVudEFsaWFzZXNPbiggbGF5b3V0UHJvdG8gKTtcblxuICAgIGV4dCA9IExheW91dDsgLy8gcmVwbGFjZSB3aXRoIG91ciB3cmFwcGVkIGxheW91dFxuXG4gIH0gZWxzZSBpZiggdHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnICl7XG4gICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuXG4gICAgdmFyIGJQcm90byA9IGdldEV4dGVuc2lvbiggJ3JlbmRlcmVyJywgJ2Jhc2UnICkucHJvdG90eXBlO1xuICAgIHZhciByUHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcblxuICAgIGZvciggdmFyIHBOYW1lIGluIGJQcm90byApe1xuICAgICAgdmFyIHBWYWwgPSBiUHJvdG9bIHBOYW1lIF07XG4gICAgICB2YXIgZXhpc3RzSW5SID0gclByb3RvWyBwTmFtZSBdICE9IG51bGw7XG5cbiAgICAgIGlmKCBleGlzdHNJblIgKXtcbiAgICAgICAgdXRpbC5lcnJvcignQ2FuIG5vdCByZWdpc3RlciByZW5kZXJlciBgJyArIG5hbWUgKyAnYCBzaW5jZSBpdCBvdmVycmlkZXMgYCcgKyBwTmFtZSArICdgIGluIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByUHJvdG9bIHBOYW1lIF0gPSBwVmFsOyAvLyB0YWtlIGltcGwgZnJvbSBiYXNlXG4gICAgfVxuXG4gICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKCBuYW1lICl7XG4gICAgICByUHJvdG9bIG5hbWUgXSA9IHJQcm90b1sgbmFtZSBdIHx8IGZ1bmN0aW9uKCl7XG4gICAgICAgIHV0aWwuZXJyb3IoJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgfVxuXG4gIHJldHVybiB1dGlsLnNldE1hcCh7XG4gICAgbWFwOiBleHRlbnNpb25zLFxuICAgIGtleXM6IFsgdHlwZSwgbmFtZSBdLFxuICAgIHZhbHVlOiBleHRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKXtcbiAgcmV0dXJuIHV0aWwuZ2V0TWFwKHtcbiAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lIF1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50KXtcbiAgcmV0dXJuIHV0aWwuc2V0TWFwKHtcbiAgICBtYXA6IG1vZHVsZXMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF0sXG4gICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKXtcbiAgcmV0dXJuIHV0aWwuZ2V0TWFwKHtcbiAgICBtYXA6IG1vZHVsZXMsXG4gICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF1cbiAgfSk7XG59XG5cbnZhciBleHRlbnNpb24gPSBmdW5jdGlvbigpe1xuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgKXtcbiAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMyApe1xuICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnKVxuICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSA0ICl7XG4gICAgcmV0dXJuIGdldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDUgKXtcbiAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBlbHNlIHtcbiAgICB1dGlsLmVycm9yKCdJbnZhbGlkIGV4dGVuc2lvbiBhY2Nlc3Mgc3ludGF4Jyk7XG4gIH1cblxufTtcblxuLy8gYWxsb3dzIGEgY29yZSBpbnN0YW5jZSB0byBhY2Nlc3MgZXh0ZW5zaW9ucyBpbnRlcm5hbGx5XG5Db3JlLnByb3RvdHlwZS5leHRlbnNpb24gPSBleHRlbnNpb247XG5cbi8vIGluY2x1ZGVkIGV4dGVuc2lvbnNcbmluY0V4dHMuZm9yRWFjaChmdW5jdGlvbiggZ3JvdXAgKXtcbiAgZ3JvdXAuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKCBleHQgKXtcbiAgICBzZXRFeHRlbnNpb24oIGdyb3VwLnR5cGUsIGV4dC5uYW1lLCBleHQuaW1wbCApO1xuICB9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4dGVuc2lvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIHtcbiAgICB0eXBlOiAnbGF5b3V0JyxcbiAgICBleHRlbnNpb25zOiByZXF1aXJlKCcuL2xheW91dCcpXG4gIH0sXG5cbiAge1xuICAgIHR5cGU6ICdyZW5kZXJlcicsXG4gICAgZXh0ZW5zaW9uczogcmVxdWlyZSgnLi9yZW5kZXJlcicpXG4gIH1cbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIG1hdGggPSByZXF1aXJlKCcuLi8uLi9tYXRoJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi8uLi9pcycpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBkaXJlY3RlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gIGNpcmNsZTogZmFsc2UsIC8vIHB1dCBkZXB0aHMgaW4gY29uY2VudHJpYyBjaXJjbGVzIGlmIHRydWUsIHB1dCBkZXB0aHMgdG9wIGRvd24gaWYgZmFsc2VcbiAgc3BhY2luZ0ZhY3RvcjogMS43NSwgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gIHJvb3RzOiB1bmRlZmluZWQsIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgbWF4aW1hbEFkanVzdG1lbnRzOiAwLCAvLyBob3cgbWFueSB0aW1lcyB0byB0cnkgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGluIGEgbWF4aW1hbCB3YXkgKGkuZS4gbm8gYmFja3RyYWNraW5nKVxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBCcmVhZHRoRmlyc3RMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gIHZhciBncmFwaCA9IGVsZXM7XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIHZhciByb290cztcbiAgaWYoIGlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0aW9ucy5yb290cykgKXtcbiAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gIH0gZWxzZSBpZiggaXMuYXJyYXkob3B0aW9ucy5yb290cykgKXtcbiAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgaWQgPSBvcHRpb25zLnJvb3RzW2ldO1xuICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuICAgICAgcm9vdHNBcnJheS5wdXNoKCBlbGUgKTtcbiAgICB9XG5cbiAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oIHJvb3RzQXJyYXkgKTtcbiAgfSBlbHNlIGlmKCBpcy5zdHJpbmcob3B0aW9ucy5yb290cykgKXtcbiAgICByb290cyA9IGN5LiQoIG9wdGlvbnMucm9vdHMgKTtcblxuICB9IGVsc2Uge1xuICAgIGlmKCBvcHRpb25zLmRpcmVjdGVkICl7XG4gICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgICB2YXIgdW5oYW5kbGVkTm9kZXMgPSBub2RlcztcblxuICAgICAgd2hpbGUoIHVuaGFuZGxlZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgdmFyIGN1cnJDb21wID0gY3kuY29sbGVjdGlvbigpO1xuXG4gICAgICAgIGVsZXMuYmZzKHtcbiAgICAgICAgICByb290czogdW5oYW5kbGVkTm9kZXNbMF0sXG4gICAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uKGksIGRlcHRoLCBub2RlLCBlZGdlLCBwTm9kZSl7XG4gICAgICAgICAgICBjdXJyQ29tcCA9IGN1cnJDb21wLmFkZCggbm9kZSApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlyZWN0ZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVuaGFuZGxlZE5vZGVzID0gdW5oYW5kbGVkTm9kZXMubm90KCBjdXJyQ29tcCApO1xuICAgICAgICBjb21wb25lbnRzLnB1c2goIGN1cnJDb21wICk7XG4gICAgICB9XG5cbiAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjb21wID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKCBmYWxzZSApO1xuICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWdyZWUoZmFsc2UpID09PSBtYXhEZWdyZWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJvb3RzID0gcm9vdHMuYWRkKCBjb21wUm9vdHMgKTtcbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG5cbiAgdmFyIGRlcHRocyA9IFtdO1xuICB2YXIgZm91bmRCeUJmcyA9IHt9O1xuICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgdmFyIHByZXZOb2RlID0ge307XG4gIHZhciBwcmV2RWRnZSA9IHt9O1xuICB2YXIgc3VjY2Vzc29ycyA9IHt9O1xuXG4gIC8vIGZpbmQgdGhlIGRlcHRocyBvZiB0aGUgbm9kZXNcbiAgZ3JhcGguYmZzKHtcbiAgICByb290czogcm9vdHMsXG4gICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgdmlzaXQ6IGZ1bmN0aW9uKGksIGRlcHRoLCBub2RlLCBlZGdlLCBwTm9kZSl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICBpZiggIWRlcHRoc1tkZXB0aF0gKXtcbiAgICAgICAgZGVwdGhzW2RlcHRoXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIGVsZSApO1xuICAgICAgZm91bmRCeUJmc1sgaWQgXSA9IHRydWU7XG4gICAgICBpZDJkZXB0aFsgaWQgXSA9IGRlcHRoO1xuICAgICAgcHJldk5vZGVbIGlkIF0gPSBwTm9kZTtcbiAgICAgIHByZXZFZGdlWyBpZCBdID0gZWRnZTtcblxuICAgICAgaWYoIHBOb2RlICl7XG4gICAgICAgIHZhciBwcmV2SWQgPSBwTm9kZS5pZCgpO1xuICAgICAgICB2YXIgc3VjYyA9IHN1Y2Nlc3NvcnNbIHByZXZJZCBdID0gc3VjY2Vzc29yc1sgcHJldklkIF0gfHwgW107XG5cbiAgICAgICAgc3VjYy5wdXNoKCBub2RlICk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuICB2YXIgb3JwaGFuTm9kZXMgPSBbXTtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcblxuICAgIGlmKCBmb3VuZEJ5QmZzWyBlbGUuaWQoKSBdICl7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JwaGFuTm9kZXMucHVzaCggZWxlICk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyBhIGRlcHRoIGZyb20gdGhlaXIgbmVpZ2hib3Job29kXG4gIHZhciBtYXhDaGVja3MgPSBvcnBoYW5Ob2Rlcy5sZW5ndGggKiAzO1xuICB2YXIgY2hlY2tzID0gMDtcbiAgd2hpbGUoIG9ycGhhbk5vZGVzLmxlbmd0aCAhPT0gMCAmJiBjaGVja3MgPCBtYXhDaGVja3MgKXtcbiAgICB2YXIgbm9kZSA9IG9ycGhhbk5vZGVzLnNoaWZ0KCk7XG4gICAgdmFyIG5laWdoYm9ycyA9IG5vZGUubmVpZ2hib3Job29kKCkubm9kZXMoKTtcbiAgICB2YXIgYXNzaWduZWREZXB0aCA9IGZhbHNlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyBuZWlnaGJvcnNbaV0uaWQoKSBdO1xuXG4gICAgICBpZiggZGVwdGggIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIG5vZGUgKTtcbiAgICAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhYXNzaWduZWREZXB0aCApe1xuICAgICAgb3JwaGFuTm9kZXMucHVzaCggbm9kZSApO1xuICAgIH1cblxuICAgIGNoZWNrcysrO1xuICB9XG5cbiAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0aGF0IGFyZSBzdGlsbCBsZWZ0IHRvIHRoZSBkZXB0aCBvZiB0aGVpciBzdWJncmFwaFxuICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICl7XG4gICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgIC8vdmFyIHN1YmdyYXBoID0gZ3JhcGguYmZzKCBub2RlICkucGF0aDtcbiAgICB2YXIgYXNzaWduZWREZXB0aCA9IGZhbHNlO1xuXG4gICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCBzdWJncmFwaC5sZW5ndGg7IGkrKyApe1xuICAgIC8vICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHN1YmdyYXBoW2ldLmlkKCkgXTtcblxuICAgIC8vICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAvLyAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBub2RlICk7XG4gICAgLy8gICAgIGFzc2lnbmVkRGVwdGggPSB0cnVlO1xuICAgIC8vICAgICBicmVhaztcbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBpZiggIWFzc2lnbmVkRGVwdGggKXsgLy8gd29yc3QgY2FzZSBpZiB0aGUgZ3JhcGggcmVhbGx5IGlzbid0IHRyZWUgZnJpZW5kbHksIHRoZW4ganVzdCBkdW1wIGl0IGluIDBcbiAgICAgIGlmKCBkZXB0aHMubGVuZ3RoID09PSAwICl7XG4gICAgICAgIGRlcHRocy5wdXNoKFtdKTtcbiAgICAgIH1cblxuICAgICAgZGVwdGhzWzBdLnB1c2goIG5vZGUgKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3NpZ24gdGhlIG5vZGVzIGEgZGVwdGggYW5kIGluZGV4XG4gIHZhciBhc3NpZ25EZXB0aHNUb0VsZXMgPSBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuXG4gICAgICAgIGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdCA9IHtcbiAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICBpbmRleDogalxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG5cblxuICB2YXIgaW50ZXJzZWN0c0RlcHRoID0gZnVuY3Rpb24oIG5vZGUgKXsgLy8gcmV0dXJucyB0cnVlIGlmIGhhcyBlZGdlcyBwb2ludGluZyBpbiBmcm9tIGEgaGlnaGVyIGRlcHRoXG4gICAgdmFyIGVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcyhmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YSgndGFyZ2V0JykgPT09IG5vZGUuaWQoKTtcbiAgICB9KTtcbiAgICB2YXIgdGhpc0luZm8gPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgIHZhciBoaWdoZXN0RGVwdGhPZk90aGVyID0gMDtcbiAgICB2YXIgaGlnaGVzdE90aGVyO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgIHZhciBvdGhlckluZm8gPSBvdGhlck5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgIGlmKCB0aGlzSW5mby5kZXB0aCA8PSBvdGhlckluZm8uZGVwdGggJiYgaGlnaGVzdERlcHRoT2ZPdGhlciA8IG90aGVySW5mby5kZXB0aCApe1xuICAgICAgICBoaWdoZXN0RGVwdGhPZk90aGVyID0gb3RoZXJJbmZvLmRlcHRoO1xuICAgICAgICBoaWdoZXN0T3RoZXIgPSBvdGhlck5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhpZ2hlc3RPdGhlcjtcbiAgfTtcblxuICAgLy8gbWFrZSBtYXhpbWFsIGlmIHNvIHNldCBieSBhZGp1c3RpbmcgZGVwdGhzXG4gIGZvciggdmFyIGFkaiA9IDA7IGFkaiA8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzOyBhZGorKyApe1xuXG4gICAgdmFyIG5EZXB0aHMgPSBkZXB0aHMubGVuZ3RoO1xuICAgIHZhciBlbGVzVG9Nb3ZlID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuRGVwdGhzOyBpKysgKXtcbiAgICAgIHZhciBkZXB0aCA9IGRlcHRoc1tpXTtcblxuICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoLmxlbmd0aDtcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbkRlcHRoOyBqKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGRlcHRoW2pdO1xuICAgICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgdmFyIGludEVsZSA9IGludGVyc2VjdHNEZXB0aChlbGUpO1xuXG4gICAgICAgIGlmKCBpbnRFbGUgKXtcbiAgICAgICAgICBpbmZvLmludEVsZSA9IGludEVsZTtcbiAgICAgICAgICBlbGVzVG9Nb3ZlLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9Nb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1RvTW92ZVtpXTtcbiAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGludEVsZSA9IGluZm8uaW50RWxlO1xuICAgICAgdmFyIGludEluZm8gPSBpbnRFbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgIGRlcHRoc1sgaW5mby5kZXB0aCBdLnNwbGljZSggaW5mby5pbmRleCwgMSApOyAvLyByZW1vdmUgZnJvbSBvbGQgZGVwdGggJiBpbmRleFxuXG4gICAgICAvLyBhZGQgdG8gZW5kIG9mIG5ldyBkZXB0aFxuICAgICAgdmFyIG5ld0RlcHRoID0gaW50SW5mby5kZXB0aCArIDE7XG4gICAgICB3aGlsZSggbmV3RGVwdGggPiBkZXB0aHMubGVuZ3RoIC0gMSApe1xuICAgICAgICBkZXB0aHMucHVzaChbXSk7XG4gICAgICB9XG4gICAgICBkZXB0aHNbIG5ld0RlcHRoIF0ucHVzaCggZWxlICk7XG5cbiAgICAgIGluZm8uZGVwdGggPSBuZXdEZXB0aDtcbiAgICAgIGluZm8uaW5kZXggPSBkZXB0aHNbbmV3RGVwdGhdLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG4gIH1cblxuICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgaWYoIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICAgIHZhciBuYmIgPSBuLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgdyA9IG5iYi53O1xuICAgICAgdmFyIGggPSBuYmIuaDtcblxuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgfVxuICAgIG1pbkRpc3RhbmNlICo9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvcjsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG4gIH1cblxuICAvLyBnZXQgdGhlIHdlaWdodGVkIHBlcmNlbnQgZm9yIGFuIGVsZW1lbnQgYmFzZWQgb24gaXRzIGNvbm5lY3Rpdml0eSB0byBvdGhlciBsZXZlbHNcbiAgdmFyIGNhY2hlZFdlaWdodGVkUGVyY2VudCA9IHt9O1xuICB2YXIgZ2V0V2VpZ2h0ZWRQZXJjZW50ID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIGlmKCBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF0gKXtcbiAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF07XG4gICAgfVxuXG4gICAgdmFyIGVsZURlcHRoID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0LmRlcHRoO1xuICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCkubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICB2YXIgcGVyY2VudCA9IDA7XG4gICAgdmFyIHNhbXBsZXMgPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcbiAgICAgIHZhciBiZiA9IG5laWdoYm9yLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDtcbiAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgaWYoIGVsZURlcHRoID4gZGVwdGggfHwgZWxlRGVwdGggPT09IDAgKXsgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICBzYW1wbGVzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2FtcGxlcyA9IE1hdGgubWF4KDEsIHNhbXBsZXMpO1xuICAgIHBlcmNlbnQgPSBwZXJjZW50IC8gc2FtcGxlcztcblxuICAgIGlmKCBzYW1wbGVzID09PSAwICl7IC8vIHNvIGxvbmUgbm9kZXMgaGF2ZSBhIFwiZG9uJ3QgY2FyZVwiIHN0YXRlIGluIHNvcnRpbmdcbiAgICAgIHBlcmNlbnQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdID0gcGVyY2VudDtcbiAgICByZXR1cm4gcGVyY2VudDtcbiAgfTtcblxuXG4gIC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuXG4gIHZhciBzb3J0Rm4gPSBmdW5jdGlvbihhLCBiKXtcbiAgICB2YXIgYXBjdCA9IGdldFdlaWdodGVkUGVyY2VudCggYSApO1xuICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KCBiICk7XG5cbiAgICByZXR1cm4gYXBjdCAtIGJwY3Q7XG4gIH07XG5cbiAgZm9yKCB2YXIgdGltZXMgPSAwOyB0aW1lcyA8IDM7IHRpbWVzKysgKXsgLy8gZG8gaXQgYSBmZXcgdGltZXMgYi9jIHRoZSBkZXB0aHMgYXJlIGR5bmFtaWMgYW5kIHdlIHdhbnQgYSBtb3JlIHN0YWJsZSByZXN1bHRcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICBkZXB0aHNbaV0gPSBkZXB0aHNbaV0uc29ydCggc29ydEZuICk7XG4gICAgfVxuICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpOyAvLyBhbmQgdXBkYXRlXG5cbiAgfVxuXG4gIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICBiaWdnZXN0RGVwdGhTaXplID0gTWF0aC5tYXgoIGRlcHRoc1tpXS5sZW5ndGgsIGJpZ2dlc3REZXB0aFNpemUgKTtcbiAgfVxuXG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgeTogYmIueDEgKyBiYi5oLzJcbiAgfTtcblxuICB2YXIgZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiggZWxlLCBpc0JvdHRvbURlcHRoICl7XG4gICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgdmFyIGRlcHRoID0gaW5mby5kZXB0aDtcbiAgICB2YXIgaW5kZXggPSBpbmZvLmluZGV4O1xuICAgIHZhciBkZXB0aFNpemUgPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heCggYmIudyAvIChkZXB0aFNpemUgKyAxKSwgbWluRGlzdGFuY2UgKTtcbiAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoIGJiLmggLyAoZGVwdGhzLmxlbmd0aCArIDEpLCBtaW5EaXN0YW5jZSApO1xuICAgIHZhciByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWluKCBiYi53IC8gMiAvIGRlcHRocy5sZW5ndGgsIGJiLmggLyAyIC8gZGVwdGhzLmxlbmd0aCApO1xuICAgIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5tYXgoIHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSApO1xuXG4gICAgaWYoICFvcHRpb25zLmNpcmNsZSApe1xuXG4gICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpLzIpICogZGlzdGFuY2VYLFxuICAgICAgICB5OiAoZGVwdGggKyAxKSAqIGRpc3RhbmNlWVxuICAgICAgfTtcblxuICAgICAgaWYoIGlzQm90dG9tRGVwdGggKXtcbiAgICAgICAgcmV0dXJuIGVwb3M7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhciBzdWNjcyA9IHN1Y2Nlc3NvcnNbIGVsZS5pZCgpIF07XG4gICAgICAvLyBpZiggc3VjY3MgKXtcbiAgICAgIC8vICAgZXBvcy54ID0gMDtcbiAgICAgIC8vXG4gICAgICAvLyAgIGZvciggdmFyIGkgPSAwIDsgaSA8IHN1Y2NzLmxlbmd0aDsgaSsrICl7XG4gICAgICAvLyAgICAgdmFyIHNwb3MgPSBwb3NbIHN1Y2NzW2ldLmlkKCkgXTtcbiAgICAgIC8vXG4gICAgICAvLyAgICAgZXBvcy54ICs9IHNwb3MueDtcbiAgICAgIC8vICAgfVxuICAgICAgLy9cbiAgICAgIC8vICAgZXBvcy54IC89IHN1Y2NzLmxlbmd0aDtcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIC8vZGVidWdnZXI7XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybiBlcG9zO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBvcHRpb25zLmNpcmNsZSApe1xuICAgICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplLzIgOiAwKTtcbiAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuXG4gICAgICAgIGlmKCBkZXB0aCA9PT0gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoID09PSAxICl7XG4gICAgICAgICAgcmFkaXVzID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkvMikgKiBkaXN0YW5jZVgsXG4gICAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvLyBnZXQgcG9zaXRpb25zIGluIHJldmVyc2UgZGVwdGggb3JkZXJcbiAgdmFyIHBvcyA9IHt9O1xuICBmb3IoIHZhciBpID0gZGVwdGhzLmxlbmd0aCAtIDE7IGkgPj0wOyBpLS0gKXtcbiAgICB2YXIgZGVwdGggPSBkZXB0aHNbaV07XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGRlcHRoLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgbm9kZSA9IGRlcHRoW2pdO1xuXG4gICAgICBwb3NbIG5vZGUuaWQoKSBdID0gZ2V0UG9zaXRpb24oIG5vZGUsIGkgPT09IGRlcHRocy5sZW5ndGggLSAxICk7XG4gICAgfVxuICB9XG5cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHBvc1sgdGhpcy5pZCgpIF07XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcmVhZHRoRmlyc3RMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIG1hdGggPSByZXF1aXJlKCcuLi8uLi9tYXRoJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi8uLi9pcycpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCwgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICByYWRpdXM6IHVuZGVmaW5lZCwgLy8gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gIHN0YXJ0QW5nbGU6IDMvMiAqIE1hdGguUEksIC8vIHdoZXJlIG5vZGVzIHN0YXJ0IGluIHJhZGlhbnNcbiAgc3dlZXA6IHVuZGVmaW5lZCwgLy8gaG93IG1hbnkgcmFkaWFucyBzaG91bGQgYmUgYmV0d2VlbiB0aGUgZmlyc3QgYW5kIGxhc3Qgbm9kZSAoZGVmYXVsdHMgdG8gZnVsbCBjaXJjbGUpXG4gIGNsb2Nrd2lzZTogdHJ1ZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjbG9ja3dpc2UgKHRydWUpIG9yIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAoZmFsc2UpXG4gIHNvcnQ6IHVuZGVmaW5lZCwgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5cbkNpcmNsZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG5cbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gIGlmKCBvcHRpb25zLnNvcnQgKXtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQoIG9wdGlvbnMuc29ydCApO1xuICB9XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIHZhciBjZW50ZXIgPSB7XG4gICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgeTogYmIueTEgKyBiYi5oLzJcbiAgfTtcblxuICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyKk1hdGguUEkgLSAyKk1hdGguUEkvbm9kZXMubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcblxuICB2YXIgZFRoZXRhID0gc3dlZXAgLyAoIE1hdGgubWF4KDEsIG5vZGVzLmxlbmd0aCAtIDEpICk7XG4gIHZhciByO1xuXG4gIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgIHZhciBuYmIgPSBuLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSBuYmIudztcbiAgICB2YXIgaCA9IG5iYi5oO1xuXG4gICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gIH1cblxuICBpZiggaXMubnVtYmVyKG9wdGlvbnMucmFkaXVzKSApe1xuICAgIHIgPSBvcHRpb25zLnJhZGl1cztcbiAgfSBlbHNlIGlmKCBub2Rlcy5sZW5ndGggPD0gMSApe1xuICAgIHIgPSAwO1xuICB9IGVsc2Uge1xuICAgIHIgPSBNYXRoLm1pbiggYmIuaCwgYmIudyApLzIgLSBtaW5EaXN0YW5jZTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gIGlmKCBub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICBtaW5EaXN0YW5jZSAqPSAxLjc1OyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcblxuICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgIHZhciByTWluID0gTWF0aC5zcXJ0KCBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlIC8gKCBkY29zKmRjb3MgKyBkc2luKmRzaW4gKSApOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG4gICAgciA9IE1hdGgubWF4KCByTWluLCByICk7XG4gIH1cblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oIGksIGVsZSApe1xuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIGkgKiBkVGhldGEgKiAoIGNsb2Nrd2lzZSA/IDEgOiAtMSApO1xuXG4gICAgdmFyIHJ4ID0gciAqIE1hdGguY29zKCB0aGV0YSApO1xuICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbiggdGhldGEgKTtcbiAgICB2YXIgcG9zID0ge1xuICAgICAgeDogY2VudGVyLnggKyByeCxcbiAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHBvcztcbiAgfTtcblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaXJjbGVMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIG1hdGggPSByZXF1aXJlKCcuLi8uLi9tYXRoJyk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgc3RhcnRBbmdsZTogMy8yICogTWF0aC5QSSwgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLCAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLCAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgZXF1aWRpc3RhbnQ6IGZhbHNlLCAvLyB3aGV0aGVyIGxldmVscyBoYXZlIGFuIGVxdWFsIHJhZGlhbCBkaXN0YW5jZSBiZXR3ZW4gdGhlbSwgbWF5IGNhdXNlIGJvdW5kaW5nIGJveCBvdmVyZmxvd1xuICBtaW5Ob2RlU3BhY2luZzogMTAsIC8vIG1pbiBzcGFjaW5nIGJldHdlZW4gb3V0c2lkZSBvZiBub2RlcyAodXNlZCBmb3IgcmFkaXVzIGFkanVzdG1lbnQpXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgaGVpZ2h0OiB1bmRlZmluZWQsIC8vIGhlaWdodCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciBoZWlnaHQpXG4gIHdpZHRoOiB1bmRlZmluZWQsIC8vIHdpZHRoIG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIHdpZHRoKVxuICBjb25jZW50cmljOiBmdW5jdGlvbihub2RlKXsgLy8gcmV0dXJucyBudW1lcmljIHZhbHVlIGZvciBlYWNoIG5vZGUsIHBsYWNpbmcgaGlnaGVyIG5vZGVzIGluIGxldmVscyB0b3dhcmRzIHRoZSBjZW50cmVcbiAgICByZXR1cm4gbm9kZS5kZWdyZWUoKTtcbiAgfSxcbiAgbGV2ZWxXaWR0aDogZnVuY3Rpb24obm9kZXMpeyAvLyB0aGUgdmFyaWF0aW9uIG9mIGNvbmNlbnRyaWMgdmFsdWVzIGluIGVhY2ggbGV2ZWxcbiAgICByZXR1cm4gbm9kZXMubWF4RGVncmVlKCkgLyA0O1xuICB9LFxuICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCwgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG59O1xuXG5mdW5jdGlvbiBDb25jZW50cmljTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5cbkNvbmNlbnRyaWNMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuXG4gIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcblxuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG5cbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICB2YXIgYmIgPSBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICB9ICk7XG5cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncvMixcbiAgICB5OiBiYi55MSArIGJiLmgvMlxuICB9O1xuXG4gIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGU7XG4gIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHZhbHVlXG4gICAgdmFsdWUgPSBvcHRpb25zLmNvbmNlbnRyaWMuYXBwbHkobm9kZSwgWyBub2RlIF0pO1xuICAgIG5vZGVWYWx1ZXMucHVzaCh7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBub2RlOiBub2RlXG4gICAgfSk7XG5cbiAgICAvLyBmb3Igc3R5bGUgbWFwcGluZ1xuICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb25jZW50cmljID0gdmFsdWU7XG4gIH1cblxuICAvLyBpbiBjYXNlIHdlIHVzZWQgdGhlIGBjb25jZW50cmljYCBpbiBzdHlsZVxuICBub2Rlcy51cGRhdGVTdHlsZSgpO1xuXG4gIC8vIGNhbGN1bGF0ZSBtYXggc2l6ZSBub3cgYmFzZWQgb24gcG90ZW50aWFsbHkgdXBkYXRlZCBtYXBwZXJzXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciBuYmIgPSBub2RlLmJvdW5kaW5nQm94KCk7XG5cbiAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KCBtYXhOb2RlU2l6ZSwgbmJiLncsIG5iYi5oICk7XG4gIH1cblxuICAvLyBzb3J0IG5vZGUgdmFsdWVzIGluIGRlc2NyZWFzaW5nIG9yZGVyXG4gIG5vZGVWYWx1ZXMuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH0pO1xuXG4gIHZhciBsZXZlbFdpZHRoID0gb3B0aW9ucy5sZXZlbFdpZHRoKCBub2RlcyApO1xuXG4gIC8vIHB1dCB0aGUgdmFsdWVzIGludG8gbGV2ZWxzXG4gIHZhciBsZXZlbHMgPSBbIFtdIF07XG4gIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbMF07XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZVZhbHVlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciB2YWwgPSBub2RlVmFsdWVzW2ldO1xuXG4gICAgaWYoIGN1cnJlbnRMZXZlbC5sZW5ndGggPiAwICl7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKCBjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUgKTtcblxuICAgICAgaWYoIGRpZmYgPj0gbGV2ZWxXaWR0aCApe1xuICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgbGV2ZWxzLnB1c2goIGN1cnJlbnRMZXZlbCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRMZXZlbC5wdXNoKCB2YWwgKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuICB2YXIgbWluRGlzdCA9IG1heE5vZGVTaXplICsgb3B0aW9ucy5taW5Ob2RlU3BhY2luZzsgLy8gbWluIGRpc3QgYmV0d2VlbiBub2Rlc1xuXG4gIGlmKCAhb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgIHZhciBtYXhSID0gKCBNYXRoLm1pbihiYi53LCBiYi5oKSAvIDIgLSBtaW5EaXN0ICk7XG4gICAgdmFyIHJTdGVwID0gbWF4UiAvICggbGV2ZWxzLmxlbmd0aCArIGZpcnN0THZsSGFzTXVsdGkgPyAxIDogMCApO1xuXG4gICAgbWluRGlzdCA9IE1hdGgubWluKCBtaW5EaXN0LCByU3RlcCApO1xuICB9XG5cbiAgLy8gZmluZCB0aGUgbWV0cmljcyBmb3IgZWFjaCBsZXZlbFxuICB2YXIgciA9IDA7XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGxldmVsID0gbGV2ZWxzW2ldO1xuICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIqTWF0aC5QSSAtIDIqTWF0aC5QSS9sZXZlbC5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGEgPSBzd2VlcCAvICggTWF0aC5tYXgoMSwgbGV2ZWwubGVuZ3RoIC0gMSkgKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gICAgaWYoIGxldmVsLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgIHZhciByTWluID0gTWF0aC5zcXJ0KCBtaW5EaXN0ICogbWluRGlzdCAvICggZGNvcypkY29zICsgZHNpbipkc2luICkgKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuXG4gICAgICByID0gTWF0aC5tYXgoIHJNaW4sIHIgKTtcbiAgICB9XG5cbiAgICBsZXZlbC5yID0gcjtcblxuICAgIHIgKz0gbWluRGlzdDtcbiAgfVxuXG4gIGlmKCBvcHRpb25zLmVxdWlkaXN0YW50ICl7XG4gICAgdmFyIHJEZWx0YU1heCA9IDA7XG4gICAgdmFyIHIgPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgIHZhciByRGVsdGEgPSBsZXZlbC5yIC0gcjtcblxuICAgICAgckRlbHRhTWF4ID0gTWF0aC5tYXgoIHJEZWx0YU1heCwgckRlbHRhICk7XG4gICAgfVxuXG4gICAgciA9IDA7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcblxuICAgICAgaWYoIGkgPT09IDAgKXtcbiAgICAgICAgciA9IGxldmVsLnI7XG4gICAgICB9XG5cbiAgICAgIGxldmVsLnIgPSByO1xuXG4gICAgICByICs9IHJEZWx0YU1heDtcbiAgICB9XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgcG9zaXRpb25zXG4gIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgdmFyIGRUaGV0YSA9IGxldmVsLmRUaGV0YTtcbiAgICB2YXIgciA9IGxldmVsLnI7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGxldmVsLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgdmFsID0gbGV2ZWxbal07XG4gICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAoY2xvY2t3aXNlID8gMSA6IC0xKSAqIGRUaGV0YSAqIGo7XG5cbiAgICAgIHZhciBwID0ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgIHk6IGNlbnRlci55ICsgciAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcblxuICAgICAgcG9zWyB2YWwubm9kZS5pZCgpIF0gPSBwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICB2YXIgaWQgPSB0aGlzLmlkKCk7XG5cbiAgICByZXR1cm4gcG9zW2lkXTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbmNlbnRyaWNMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qXG5UaGUgQ29TRSBsYXlvdXQgd2FzIHdyaXR0ZW4gYnkgR2VyYXJkbyBIdWNrLlxuaHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2dlcmFyZG9odWNrL1xuXG5CYXNlZCBvbiB0aGUgZm9sbG93aW5nIGFydGljbGU6XG5odHRwOi8vZGwuYWNtLm9yZy9jaXRhdGlvbi5jZm0/aWQ9MTQ5ODA0N1xuXG5Nb2RpZmljYXRpb25zIHRyYWNrZWQgb24gR2l0aHViLlxuKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJy4uLy4uL21hdGgnKTtcbnZhciBUaHJlYWQgPSByZXF1aXJlKCcuLi8uLi90aHJlYWQnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4uLy4uL2lzJyk7XG5cbnZhciBERUJVRztcblxuLyoqXG4gKiBAYnJpZWYgOiAgZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICovXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gIHJlYWR5ICAgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHt9LFxuXG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgc3RvcCAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uKCkge30sXG5cbiAgLy8gV2hldGhlciB0byBhbmltYXRlIHdoaWxlIHJ1bm5pbmcgdGhlIGxheW91dFxuICBhbmltYXRlICAgICAgICAgICAgIDogdHJ1ZSxcblxuICAvLyBUaGUgbGF5b3V0IGFuaW1hdGVzIG9ubHkgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kc1xuICAvLyAocHJldmVudHMgZmxhc2hpbmcgb24gZmFzdCBydW5zKVxuICBhbmltYXRpb25UaHJlc2hvbGQgIDogMjUwLFxuXG4gIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGVcbiAgLy8gKDAgLT4gb25seSB1cGRhdGVkIG9uIHRoZSBlbmQpXG4gIHJlZnJlc2ggICAgICAgICAgICAgOiAyMCxcblxuICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICBmaXQgICAgICAgICAgICAgICAgIDogdHJ1ZSxcblxuICAvLyBQYWRkaW5nIG9uIGZpdFxuICBwYWRkaW5nICAgICAgICAgICAgIDogMzAsXG5cbiAgLy8gQ29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGJvdW5kaW5nQm94ICAgICAgICAgOiB1bmRlZmluZWQsXG5cbiAgLy8gRXh0cmEgc3BhY2luZyBiZXR3ZWVuIGNvbXBvbmVudHMgaW4gbm9uLWNvbXBvdW5kIGdyYXBoc1xuICBjb21wb25lbnRTcGFjaW5nICAgIDogMTAwLFxuXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbiAgICAgICA6IGZ1bmN0aW9uKCBub2RlICl7IHJldHVybiA0MDAwMDA7IH0sXG5cbiAgLy8gTm9kZSByZXB1bHNpb24gKG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVPdmVybGFwICAgICAgICAgOiAxMCxcblxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoICAgICA6IGZ1bmN0aW9uKCBlZGdlICl7IHJldHVybiAxMDsgfSxcblxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHkgICAgICA6IGZ1bmN0aW9uKCBlZGdlICl7IHJldHVybiAxMDA7IH0sXG5cbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yICAgICAgIDogNSxcblxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eSAgICAgICAgICAgICA6IDgwLFxuXG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICBudW1JdGVyICAgICAgICAgICAgIDogMTAwMCxcblxuICAvLyBJbml0aWFsIHRlbXBlcmF0dXJlIChtYXhpbXVtIG5vZGUgZGlzcGxhY2VtZW50KVxuICBpbml0aWFsVGVtcCAgICAgICAgIDogMjAwLFxuXG4gIC8vIENvb2xpbmcgZmFjdG9yIChob3cgdGhlIHRlbXBlcmF0dXJlIGlzIHJlZHVjZWQgYmV0d2VlbiBjb25zZWN1dGl2ZSBpdGVyYXRpb25zXG4gIGNvb2xpbmdGYWN0b3IgICAgICAgOiAwLjk1LFxuXG4gIC8vIExvd2VyIHRlbXBlcmF0dXJlIHRocmVzaG9sZCAoYmVsb3cgdGhpcyBwb2ludCB0aGUgbGF5b3V0IHdpbGwgZW5kKVxuICBtaW5UZW1wICAgICAgICAgICAgIDogMS4wLFxuXG4gIC8vIFdoZXRoZXIgdG8gdXNlIHRocmVhZGluZyB0byBzcGVlZCB1cCB0aGUgbGF5b3V0XG4gIHVzZU11bHRpdGFza2luZyAgICAgOiB0cnVlXG59O1xuXG5cbi8qKlxuICogQGJyaWVmICAgICAgIDogY29uc3RydWN0b3JcbiAqIEBhcmcgb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIENvc2VMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gIHRoaXMub3B0aW9ucy5sYXlvdXQgPSB0aGlzO1xufVxuXG5cbi8qKlxuICogQGJyaWVmIDogcnVucyB0aGUgbGF5b3V0XG4gKi9cbkNvc2VMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ICAgICAgPSBvcHRpb25zLmN5O1xuICB2YXIgbGF5b3V0ICA9IHRoaXM7XG4gIHZhciB0aHJlYWQgID0gdGhpcy50aHJlYWQ7XG5cbiAgaWYoICF0aHJlYWQgfHwgdGhyZWFkLnN0b3BwZWQoKSApe1xuICAgIHRocmVhZCA9IHRoaXMudGhyZWFkID0gVGhyZWFkKHsgZGlzYWJsZWQ6ICFvcHRpb25zLnVzZU11bHRpdGFza2luZyB9KTtcbiAgfVxuXG4gIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAvLyBTZXQgREVCVUcgLSBHbG9iYWwgdmFyaWFibGVcbiAgaWYgKHRydWUgPT09IG9wdGlvbnMuZGVidWcpIHtcbiAgICBERUJVRyA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgREVCVUcgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgbGF5b3V0IGluZm9cbiAgdmFyIGxheW91dEluZm8gPSBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpO1xuXG4gIC8vIFNob3cgTGF5b3V0SW5mbyBjb250ZW50cyBpZiBkZWJ1Z2dpbmdcbiAgaWYgKERFQlVHKSB7XG4gICAgcHJpbnRMYXlvdXRJbmZvKGxheW91dEluZm8pO1xuICB9XG5cbiAgLy8gSWYgcmVxdWlyZWQsIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9uc1xuICAvLyBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3kpO1xuICAvLyB9XG5cbiAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIHZhciByZWZyZXNoUmVxdWVzdGVkID0gZmFsc2U7XG4gIHZhciByZWZyZXNoID0gZnVuY3Rpb24oIHJPcHRzICl7XG4gICAgck9wdHMgPSByT3B0cyB8fCB7fTtcblxuICAgIGlmKCByZWZyZXNoUmVxdWVzdGVkICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoICFyT3B0cy5mb3JjZSAmJiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgb3B0aW9ucy5hbmltYXRpb25UaHJlc2hvbGQgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWZyZXNoUmVxdWVzdGVkID0gdHJ1ZTtcblxuICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcblxuICAgICAgLy8gRml0IHRoZSBncmFwaCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICh0cnVlID09PSBvcHRpb25zLmZpdCkge1xuICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgfVxuXG4gICAgICByZWZyZXNoUmVxdWVzdGVkID0gZmFsc2U7XG5cbiAgICAgIGlmKCByT3B0cy5uZXh0ICl7IHJPcHRzLm5leHQoKTsgfVxuICAgIH0pO1xuICB9O1xuXG4gIHRocmVhZC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKCBlICl7XG4gICAgdmFyIGxheW91dE5vZGVzID0gZS5tZXNzYWdlO1xuXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2RlcyA9IGxheW91dE5vZGVzO1xuICAgIHJlZnJlc2goKTtcbiAgfSk7XG5cbiAgdGhyZWFkLnBhc3Moe1xuICAgIGxheW91dEluZm86IGxheW91dEluZm8sXG4gICAgb3B0aW9uczoge1xuICAgICAgYW5pbWF0ZTogb3B0aW9ucy5hbmltYXRlLFxuICAgICAgcmVmcmVzaDogb3B0aW9ucy5yZWZyZXNoLFxuICAgICAgY29tcG9uZW50U3BhY2luZzogb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nLFxuICAgICAgbm9kZU92ZXJsYXA6IG9wdGlvbnMubm9kZU92ZXJsYXAsXG4gICAgICBuZXN0aW5nRmFjdG9yOiBvcHRpb25zLm5lc3RpbmdGYWN0b3IsXG4gICAgICBncmF2aXR5OiBvcHRpb25zLmdyYXZpdHksXG4gICAgICBudW1JdGVyOiBvcHRpb25zLm51bUl0ZXIsXG4gICAgICBpbml0aWFsVGVtcDogb3B0aW9ucy5pbml0aWFsVGVtcCxcbiAgICAgIGNvb2xpbmdGYWN0b3I6IG9wdGlvbnMuY29vbGluZ0ZhY3RvcixcbiAgICAgIG1pblRlbXA6IG9wdGlvbnMubWluVGVtcFxuICAgIH1cbiAgfSkucnVuKGZ1bmN0aW9uKCBwYXNzICl7XG4gICAgdmFyIGxheW91dEluZm8gPSBwYXNzLmxheW91dEluZm87XG4gICAgdmFyIG9wdGlvbnMgPSBwYXNzLm9wdGlvbnM7XG4gICAgdmFyIHN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiAgICAgICAgICA6IFBlcmZvcm1zIG9uZSBpdGVyYXRpb24gb2YgdGhlIHBoeXNpY2FsIHNpbXVsYXRpb25cbiAgICAgKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICAgICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAgICovXG4gICAgdmFyIHN0ZXAgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBvcHRpb25zLCBzdGVwKSB7XG4gICAgICAvLyB2YXIgcyA9IFwiXFxuXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1wiO1xuICAgICAgLy8gcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgICAgIC8vIHMgKz0gXCJcXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXFxuXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIG5vZGUgcmVwdWxzaW9uc1xuICAgICAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIC8vIENhbGN1bGF0ZSBlZGdlIGZvcmNlc1xuICAgICAgY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIC8vIENhbGN1bGF0ZSBncmF2aXR5IGZvcmNlc1xuICAgICAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIC8vIFByb3BhZ2F0ZSBmb3JjZXMgZnJvbSBwYXJlbnQgdG8gY2hpbGRcbiAgICAgIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gY2FsY3VsYXRlZCBmb3JjZXNcbiAgICAgIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogQ29tcHV0ZXMgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlc1xuICAgICAqL1xuICAgIHZhciBjYWxjdWxhdGVOb2RlRm9yY2VzID0gZnVuY3Rpb24obGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgICAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgICAgIC8vIE5vZGVzIG9ubHkgcmVwZWwgZWFjaCBvdGhlciBpZiB0aGV5IGJlbG9uZyB0byB0aGUgc2FtZSBncmFwaFxuICAgICAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlTm9kZUZvcmNlcyc7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGdyYXBoICAgID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXNcbiAgICAgICAgLy8gT25seSBnZXQgZWFjaCBwYWlyIG9uY2UsIChBLCBCKSA9IChCLCBBKVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICB2YXIgbm9kZTEgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZTIgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2tdXV07XG5cbiAgICAgICAgICAgIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogQ29tcHV0ZSB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gYSBwYWlyIG9mIG5vZGVzXG4gICAgICovXG4gICAgdmFyIG5vZGVSZXB1bHNpb24gPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAgIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcblxuICAgICAgdmFyIGNtcHRJZDEgPSBub2RlMS5jbXB0SWQ7XG4gICAgICB2YXIgY21wdElkMiA9IG5vZGUyLmNtcHRJZDtcblxuICAgICAgaWYoIGNtcHRJZDEgIT09IGNtcHRJZDIgJiYgIWxheW91dEluZm8uaXNDb21wb3VuZCApeyByZXR1cm47IH1cblxuICAgICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICAgIHZhciBkaXJlY3Rpb25YID0gbm9kZTIucG9zaXRpb25YIC0gbm9kZTEucG9zaXRpb25YO1xuICAgICAgdmFyIGRpcmVjdGlvblkgPSBub2RlMi5wb3NpdGlvblkgLSBub2RlMS5wb3NpdGlvblk7XG4gICAgICAvLyBzICs9IFwiXFxuZGlyZWN0aW9uWDogXCIgKyBkaXJlY3Rpb25YICsgXCIsIGRpcmVjdGlvblk6IFwiICsgZGlyZWN0aW9uWTtcblxuICAgICAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgYXBwbHkgYSByYW5kb20gZm9yY2VcbiAgICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIGhhdmUgdGhlIHNhbWUgcG9zaXRpb24uXCI7XG4gICAgICAgIHJldHVybjsgLy8gVE9ETyBjb3VsZCBiZSBpbXByb3ZlZCB3aXRoIHJhbmRvbSBmb3JjZVxuICAgICAgfVxuXG4gICAgICB2YXIgb3ZlcmxhcCA9IG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuXG4gICAgICBpZiAob3ZlcmxhcCA+IDApIHtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5PdmVybGFwOiBcIiArIG92ZXJsYXA7XG4gICAgICAgIC8vIElmIG5vZGVzIG92ZXJsYXAsIHJlcHVsc2lvbiBmb3JjZSBpcyBwcm9wb3J0aW9uYWxcbiAgICAgICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICAgICAgdmFyIGZvcmNlICAgID0gb3B0aW9ucy5ub2RlT3ZlcmxhcCAqIG92ZXJsYXA7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpcmVjdGlvblggKiBkaXJlY3Rpb25YICsgZGlyZWN0aW9uWSAqIGRpcmVjdGlvblkpO1xuICAgICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgICAgIHZhciBmb3JjZVggICA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgICAgICB2YXIgZm9yY2VZICAgPSBmb3JjZSAqIGRpcmVjdGlvblkgLyBkaXN0YW5jZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5vZGVzIGRvIE5PVCBvdmVybGFwLlwiO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG92ZXJsYXAsIGZvcmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWxcbiAgICAgICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuXG4gICAgICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUxLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUyLCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cbiAgICAgICAgLy8gVXNlIGNsaXBwaW5nIHBvaW50cyB0byBjb21wdXRlIGRpc3RhbmNlXG4gICAgICAgIHZhciBkaXN0YW5jZVggICA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgICAgIHZhciBkaXN0YW5jZVkgICA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICAgIHZhciBkaXN0YW5jZVNxciA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICAgICAgdmFyIGRpc3RhbmNlICAgID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3FyKTtcbiAgICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgICAgIHZhciBmb3JjZSAgPSAoIG5vZGUxLm5vZGVSZXB1bHNpb24gKyBub2RlMi5ub2RlUmVwdWxzaW9uICkgLyBkaXN0YW5jZVNxcjtcbiAgICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBmb3JjZVxuICAgICAgaWYoICFub2RlMS5pc0xvY2tlZCApe1xuICAgICAgICBub2RlMS5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgICAgbm9kZTEub2Zmc2V0WSAtPSBmb3JjZVk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhbm9kZTIuaXNMb2NrZWQgKXtcbiAgICAgICAgbm9kZTIub2Zmc2V0WCArPSBmb3JjZVg7XG4gICAgICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgICAgfVxuXG4gICAgICAvLyBzICs9IFwiXFxuRm9yY2VYOiBcIiArIGZvcmNlWCArIFwiIEZvcmNlWTogXCIgKyBmb3JjZVk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICAgICAqIEByZXR1cm4gOiBBbW91bnQgb2Ygb3ZlcmxhcHBpbmcgKDAgPT4gbm8gb3ZlcmxhcClcbiAgICAgKi9cbiAgICB2YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBkWCwgZFkpIHtcblxuICAgICAgaWYgKGRYID4gMCkge1xuICAgICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMS5tYXhYIC0gbm9kZTIubWluWDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUyLm1heFggLSBub2RlMS5taW5YO1xuICAgICAgfVxuXG4gICAgICBpZiAoZFkgPiAwKSB7XG4gICAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUxLm1heFkgLSBub2RlMi5taW5ZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdmVybGFwWCA+PSAwICYmIG92ZXJsYXBZID49IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogRmluZHMgdGhlIHBvaW50IGluIHdoaWNoIGFuIGVkZ2UgKGRpcmVjdGlvbiBkWCwgZFkpIGludGVyc2VjdHNcbiAgICAgKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gICAgICovXG4gICAgdmFyIGZpbmRDbGlwcGluZ1BvaW50ID0gZnVuY3Rpb24obm9kZSwgZFgsIGRZKSB7XG5cbiAgICAgIC8vIFNob3JjdXRzXG4gICAgICB2YXIgWCA9IG5vZGUucG9zaXRpb25YO1xuICAgICAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgICAgIHZhciBIID0gbm9kZS5oZWlnaHQgfHwgMTtcbiAgICAgIHZhciBXID0gbm9kZS53aWR0aCB8fCAxO1xuICAgICAgdmFyIGRpclNsb3BlICAgICA9IGRZIC8gZFg7XG4gICAgICB2YXIgbm9kZVNsb3BlICAgID0gSCAvIFc7XG5cbiAgICAgIC8vIHZhciBzID0gJ0NvbXB1dGluZyBjbGlwcGluZyBwb2ludCBvZiBub2RlICcgKyBub2RlLmlkICtcbiAgICAgIC8vICAgXCIgLiBIZWlnaHQ6ICBcIiArIEggKyBcIiwgV2lkdGg6IFwiICsgVyArXG4gICAgICAvLyAgIFwiXFxuRGlyZWN0aW9uIFwiICsgZFggKyBcIiwgXCIgKyBkWTtcbiAgICAgIC8vXG4gICAgICAvLyBDb21wdXRlIGludGVyc2VjdGlvblxuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgZG8ge1xuICAgICAgICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKHVwKVxuICAgICAgICBpZiAoMCA9PT0gZFggJiYgMCA8IGRZKSB7XG4gICAgICAgICAgcmVzLnggPSBYO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5VcCBkaXJlY3Rpb25cIjtcbiAgICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAoZG93bilcbiAgICAgICAgaWYgKDAgPT09IGRYICYmIDAgPiBkWSkge1xuICAgICAgICAgIHJlcy54ID0gWDtcbiAgICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuRG93biBkaXJlY3Rpb25cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHJpZ2h0IGJvcmRlclxuICAgICAgICBpZiAoMCA8IGRYICYmXG4gICAgICAgIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmXG4gICAgICAgIGRpclNsb3BlIDw9IG5vZGVTbG9wZSkge1xuICAgICAgICAgIHJlcy54ID0gWCArIFcgLyAyO1xuICAgICAgICAgIHJlcy55ID0gWSArIChXICogZFkgLyAyIC8gZFgpO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5SaWdodGJvcmRlclwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgbGVmdCBib3JkZXJcbiAgICAgICAgaWYgKDAgPiBkWCAmJlxuICAgICAgICAtMSAqIG5vZGVTbG9wZSA8PSBkaXJTbG9wZSAmJlxuICAgICAgICBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICAgICAgICByZXMueCA9IFggLSBXIC8gMjtcbiAgICAgICAgICByZXMueSA9IFkgLSAoVyAqIGRZIC8gMiAvIGRYKTtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgdG9wIGJvcmRlclxuICAgICAgICBpZiAoMCA8IGRZICYmXG4gICAgICAgICggZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHxcbiAgICAgICAgICBkaXJTbG9wZSA+PSBub2RlU2xvcGUgKSkge1xuICAgICAgICAgIHJlcy54ID0gWCArIChIICogZFggLyAyIC8gZFkpO1xuICAgICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5Ub3AgYm9yZGVyXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBib3R0b20gYm9yZGVyXG4gICAgICAgIGlmICgwID4gZFkgJiZcbiAgICAgICAgKCBkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fFxuICAgICAgICAgIGRpclNsb3BlID49IG5vZGVTbG9wZSApKSB7XG4gICAgICAgICAgcmVzLnggPSBYIC0gKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgICAgcmVzLnkgPSBZIC0gSCAvIDI7XG4gICAgICAgICAgLy8gcyArPSBcIlxcbkJvdHRvbSBib3JkZXJcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICB9IHdoaWxlIChmYWxzZSk7XG5cbiAgICAgIC8vIHMgKz0gXCJcXG5DbGlwcGluZyBwb2ludCBmb3VuZCBhdCBcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBicmllZiA6IENhbGN1bGF0ZXMgYWxsIGVkZ2UgZm9yY2VzXG4gICAgICovXG4gICAgdmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgICAgICAvLyBHZXQgZWRnZSwgc291cmNlICYgdGFyZ2V0IG5vZGVzXG4gICAgICAgIHZhciBlZGdlICAgICA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2Uuc291cmNlSWRdO1xuICAgICAgICB2YXIgc291cmNlICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICAgICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS50YXJnZXRJZF07XG4gICAgICAgIHZhciB0YXJnZXQgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdO1xuXG4gICAgICAgIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gICAgICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGFyZ2V0LnBvc2l0aW9uWSAtIHNvdXJjZS5wb3NpdGlvblk7XG5cbiAgICAgICAgLy8gSWYgYm90aCBjZW50ZXJzIGFyZSB0aGUgc2FtZSwgZG8gbm90aGluZy5cbiAgICAgICAgLy8gQSByYW5kb20gZm9yY2UgaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIGFzIG5vZGUgcmVwdWxzaW9uXG4gICAgICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgICAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQoc291cmNlLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KHRhcmdldCwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpO1xuXG5cbiAgICAgICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgICAgdmFyIGx5ID0gcG9pbnQyLnkgLSBwb2ludDEueTtcbiAgICAgICAgdmFyIGwgID0gTWF0aC5zcXJ0KGx4ICogbHggKyBseSAqIGx5KTtcblxuICAgICAgICB2YXIgZm9yY2UgID0gTWF0aC5wb3coZWRnZS5pZGVhbExlbmd0aCAtIGwsIDIpIC8gZWRnZS5lbGFzdGljaXR5O1xuXG4gICAgICAgIGlmICgwICE9PSBsKSB7XG4gICAgICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGx5IC8gbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgICAgICB2YXIgZm9yY2VZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGlzIGZvcmNlIHRvIHRhcmdldCBhbmQgc291cmNlIG5vZGVzXG4gICAgICAgIGlmKCAhc291cmNlLmlzTG9ja2VkICl7XG4gICAgICAgICAgc291cmNlLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhdGFyZ2V0LmlzTG9ja2VkICl7XG4gICAgICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgICAgIHRhcmdldC5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhciBzID0gJ0VkZ2UgZm9yY2UgYmV0d2VlbiBub2RlcyAnICsgc291cmNlLmlkICsgJyBhbmQgJyArIHRhcmdldC5pZDtcbiAgICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGwgKyBcIiBGb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpXCI7XG4gICAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBDb21wdXRlcyBncmF2aXR5IGZvcmNlcyBmb3IgYWxsIG5vZGVzXG4gICAgICovXG4gICAgdmFyIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE7XG5cbiAgICAgIC8vIHZhciBzID0gJ2NhbGN1bGF0ZUdyYXZpdHlGb3JjZXMnO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBncmFwaCAgICA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgICAgICAvLyBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSBncmFwaCBjZW50ZXJcbiAgICAgICAgaWYgKDAgPT09IGkpIHtcbiAgICAgICAgICB2YXIgY2VudGVyWCAgID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICAgIHZhciBjZW50ZXJZICAgPSBsYXlvdXRJbmZvLmNsaWVudFdpZHRoICAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR2V0IFBhcmVudCBub2RlIGZvciB0aGlzIGdyYXBoLCBhbmQgdXNlIGl0cyBwb3NpdGlvbiBhcyBjZW50ZXJcbiAgICAgICAgICB2YXIgdGVtcCAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbMF1dXTtcbiAgICAgICAgICB2YXIgcGFyZW50ICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcC5wYXJlbnRJZF1dO1xuICAgICAgICAgIHZhciBjZW50ZXJYID0gcGFyZW50LnBvc2l0aW9uWDtcbiAgICAgICAgICB2YXIgY2VudGVyWSA9IHBhcmVudC5wb3NpdGlvblk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcyA9IFwiQ2VudGVyIGZvdW5kIGF0OiBcIiArIGNlbnRlclggKyBcIiwgXCIgKyBjZW50ZXJZO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgICAvLyBBcHBseSBmb3JjZSB0byBhbGwgbm9kZXMgaW4gZ3JhcGhcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG4gICAgICAgICAgLy8gcyA9IFwiTm9kZTogXCIgKyBub2RlLmlkO1xuXG4gICAgICAgICAgaWYoIG5vZGUuaXNMb2NrZWQgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciBkeCA9IGNlbnRlclggLSBub2RlLnBvc2l0aW9uWDtcbiAgICAgICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICAgICAgdmFyIGQgID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgICBpZiAoZCA+IGRpc3RUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHZhciBmeCA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR4IC8gZDtcbiAgICAgICAgICAgIHZhciBmeSA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR5IC8gZDtcbiAgICAgICAgICAgIG5vZGUub2Zmc2V0WCArPSBmeDtcbiAgICAgICAgICAgIG5vZGUub2Zmc2V0WSArPSBmeTtcbiAgICAgICAgICAgIC8vIHMgKz0gXCI6IEFwcGxpZWQgZm9yY2U6IFwiICsgZnggKyBcIiwgXCIgKyBmeTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcyArPSBcIjogc2t5cHBlZCBzaW5jZSBpdCdzIHRvbyBjbG9zZSB0byBjZW50ZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmICAgICAgICAgIDogVGhpcyBmdW5jdGlvbiBwcm9wYWdhdGVzIHRoZSBleGlzdGluZyBvZmZzZXRzIGZyb21cbiAgICAgKiAgICAgICAgICAgICAgICAgICBwYXJlbnQgbm9kZXMgdG8gaXRzIGRlc2NlbmRlbnRzLlxuICAgICAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gT2JqZWN0XG4gICAgICogQGFyZyBjeSAgICAgICAgIDogY3l0b3NjYXBlIE9iamVjdFxuICAgICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAgICovXG4gICAgdmFyIHByb3BhZ2F0ZUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgICAgIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICAgICAgdmFyIGVuZCAgID0gLTE7ICAvLyBQb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWVcblxuICAgICAgLy8gbG9nRGVidWcoJ3Byb3BhZ2F0ZUZvcmNlcycpO1xuXG4gICAgICAvLyBTdGFydCBieSB2aXNpdGluZyB0aGUgbm9kZXMgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHF1ZXVlLnB1c2guYXBwbHkocXVldWUsIGxheW91dEluZm8uZ3JhcGhTZXRbMF0pO1xuICAgICAgZW5kICs9IGxheW91dEluZm8uZ3JhcGhTZXRbMF0ubGVuZ3RoO1xuXG4gICAgICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLFxuICAgICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgICAgIHZhciBub2RlSWQgICAgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICAgICAgdmFyIG5vZGVJbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgICAgIHZhciBub2RlICAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJbmRleF07XG4gICAgICAgIHZhciBjaGlsZHJlbiAgPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBub2RlIGlmIGl0J3MgY29tcG91bmRcbiAgICAgICAgaWYgKDAgPCBjaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuaXNMb2NrZWQpIHtcbiAgICAgICAgICB2YXIgb2ZmWCA9IG5vZGUub2Zmc2V0WDtcbiAgICAgICAgICB2YXIgb2ZmWSA9IG5vZGUub2Zmc2V0WTtcblxuICAgICAgICAgIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBvZmZzZXQgZnJvbSBwYXJlbnQgbm9kZSA6IFwiICsgbm9kZS5pZCArXG4gICAgICAgICAgLy8gICBcIi4gT2Zmc2V0WDogXCIgKyBvZmZYICsgXCIuIE9mZnNldFk6IFwiICsgb2ZmWTtcbiAgICAgICAgICAvLyBzICs9IFwiXFxuIENoaWxkcmVuOiBcIiArIGNoaWxkcmVuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlbltpXV1dO1xuICAgICAgICAgICAgLy8gUHJvcGFnYXRlIG9mZnNldFxuICAgICAgICAgICAgY2hpbGROb2RlLm9mZnNldFggKz0gb2ZmWDtcbiAgICAgICAgICAgIGNoaWxkTm9kZS5vZmZzZXRZICs9IG9mZlk7XG4gICAgICAgICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgICAgICAgcXVldWVbKytlbmRdID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVzZXQgcGFyZW50IG9mZnNldHNcbiAgICAgICAgICBub2RlLm9mZnNldFggPSAwO1xuICAgICAgICAgIG5vZGUub2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBVcGRhdGVzIHRoZSBsYXlvdXQgbW9kZWwgcG9zaXRpb25zLCBiYXNlZCBvblxuICAgICAqICAgICAgICAgIHRoZSBhY2N1bXVsYXRlZCBmb3JjZXNcbiAgICAgKi9cbiAgICB2YXIgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAgICAgLy8gdmFyIHMgPSAnVXBkYXRpbmcgcG9zaXRpb25zJztcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJSZXNldHRpbmcgYm91bmRhcmllcyBvZiBjb21wb3VuZCBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuLm1pblggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbi5tYXhZID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGggfHwgbi5pc0xvY2tlZCkge1xuICAgICAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG9yIGxvY2tlZCBub2RlIHBvc2l0aW9uXG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJTa2lwcGluZyBwb3NpdGlvbiB1cGRhdGUgb2Ygbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzID0gXCJOb2RlOiBcIiArIG4uaWQgKyBcIiBQcmV2aW91cyBwb3NpdGlvbjogKFwiICtcbiAgICAgICAgLy8gbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcblxuICAgICAgICAvLyBMaW1pdCBkaXNwbGFjZW1lbnQgaW4gb3JkZXIgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAgICAgICAgdmFyIHRlbXBGb3JjZSA9IGxpbWl0Rm9yY2Uobi5vZmZzZXRYLCBuLm9mZnNldFksIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuICAgICAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDtcbiAgICAgICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgICAgIG4ub2Zmc2V0WCA9IDA7XG4gICAgICAgIG4ub2Zmc2V0WSA9IDA7XG4gICAgICAgIG4ubWluWCAgICA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDtcbiAgICAgICAgbi5tYXhYICAgID0gbi5wb3NpdGlvblggKyBuLndpZHRoO1xuICAgICAgICBuLm1pblkgICAgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0O1xuICAgICAgICBuLm1heFkgICAgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0O1xuICAgICAgICAvLyBzICs9IFwiIE5ldyBQb3NpdGlvbjogKFwiICsgbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuICAgICAgICB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobiwgbGF5b3V0SW5mbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICAgIGlmICggMCA8IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkICkge1xuICAgICAgICAgIG4ucG9zaXRpb25YID0gKG4ubWF4WCArIG4ubWluWCkgLyAyO1xuICAgICAgICAgIG4ucG9zaXRpb25ZID0gKG4ubWF4WSArIG4ubWluWSkgLyAyO1xuICAgICAgICAgIG4ud2lkdGggICAgID0gbi5tYXhYIC0gbi5taW5YO1xuICAgICAgICAgIG4uaGVpZ2h0ICAgID0gbi5tYXhZIC0gbi5taW5ZO1xuICAgICAgICAgIC8vIHMgPSBcIlVwZGF0aW5nIHBvc2l0aW9uLCBzaXplIG9mIGNvbXBvdW5kIG5vZGUgXCIgKyBuLmlkO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5Qb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcIiwgUG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZO1xuICAgICAgICAgIC8vIHMgKz0gXCJcXG5XaWR0aDogXCIgKyBuLndpZHRoICsgXCIsIEhlaWdodDogXCIgKyBuLmhlaWdodDtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdFxuICAgICAqICAgICAgICAgIGdyZWF0ZXIgKGluIG1vZHVsbykgdGhhbiBtYXguXG4gICAgIDggICAgICAgICAgUHJlc2VydmVzIGZvcmNlIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbGltaXRGb3JjZSA9IGZ1bmN0aW9uKGZvcmNlWCwgZm9yY2VZLCBtYXgpIHtcbiAgICAgIC8vIHZhciBzID0gXCJMaW1pdGluZyBmb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpLiBNYXg6IFwiICsgbWF4O1xuICAgICAgdmFyIGZvcmNlID0gTWF0aC5zcXJ0KGZvcmNlWCAqIGZvcmNlWCArIGZvcmNlWSAqIGZvcmNlWSk7XG5cbiAgICAgIGlmIChmb3JjZSA+IG1heCkge1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICB4IDogbWF4ICogZm9yY2VYIC8gZm9yY2UsXG4gICAgICAgIHkgOiBtYXggKiBmb3JjZVkgLyBmb3JjZVxuICAgICAgICB9O1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0ge1xuICAgICAgICB4IDogZm9yY2VYLFxuICAgICAgICB5IDogZm9yY2VZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIHMgKz0gXCIuXFxuUmVzdWx0OiAoXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55ICsgXCIpXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGJyaWVmIDogRnVuY3Rpb24gdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiBjb21wb3VuZCBub2RlXG4gICAgICogICAgICAgICAgc2l6ZXMsIHNpbmNlIHRoZXkgc2hvdWxkIGJvdW5kIGFsbCB0aGVpciBzdWJub2Rlcy5cbiAgICAgKi9cbiAgICB2YXIgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24obm9kZSwgbGF5b3V0SW5mbykge1xuICAgICAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICAgICAgdmFyIHBhcmVudElkID0gbm9kZS5wYXJlbnRJZDtcbiAgICAgIGlmIChudWxsID09IHBhcmVudElkKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSBhcmUgZG9uZVxuICAgICAgICAvLyBzICs9IFwiLiBObyBwYXJlbnQgbm9kZS5cIjtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IFBhcmVudCBOb2RlXG4gICAgICB2YXIgcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcGFyZW50SWRdXTtcbiAgICAgIHZhciBmbGFnID0gZmFsc2U7XG5cbiAgICAgIC8vIE1heFhcbiAgICAgIGlmIChudWxsID09IHAubWF4WCB8fCBub2RlLm1heFggKyBwLnBhZFJpZ2h0ID4gcC5tYXhYKSB7XG4gICAgICAgIHAubWF4WCA9IG5vZGUubWF4WCArIHAucGFkUmlnaHQ7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBzICs9IFwiXFxuTmV3IG1heFggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WDtcbiAgICAgIH1cblxuICAgICAgLy8gTWluWFxuICAgICAgaWYgKG51bGwgPT0gcC5taW5YIHx8IG5vZGUubWluWCAtIHAucGFkTGVmdCA8IHAubWluWCkge1xuICAgICAgICBwLm1pblggPSBub2RlLm1pblggLSBwLnBhZExlZnQ7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAvLyBzICs9IFwiXFxuTmV3IG1pblggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWDtcbiAgICAgIH1cblxuICAgICAgLy8gTWF4WVxuICAgICAgaWYgKG51bGwgPT0gcC5tYXhZIHx8IG5vZGUubWF4WSArIHAucGFkQm90dG9tID4gcC5tYXhZKSB7XG4gICAgICAgIHAubWF4WSA9IG5vZGUubWF4WSArIHAucGFkQm90dG9tO1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgLy8gcyArPSBcIlxcbk5ldyBtYXhZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1pbllcbiAgICAgIGlmIChudWxsID09IHAubWluWSB8fCBub2RlLm1pblkgLSBwLnBhZFRvcCA8IHAubWluWSkge1xuICAgICAgICBwLm1pblkgPSBub2RlLm1pblkgLSBwLnBhZFRvcDtcbiAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5ZO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB1cGRhdGVkIGJvdW5kYXJpZXMsIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwd2FyZFxuICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMocCwgbGF5b3V0SW5mbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHMgKz0gXCIuIE5vIGNoYW5nZXMgaW4gYm91bmRhcmllcy9wb3NpdGlvbiBvZiBwYXJlbnQgbm9kZSBcIiArIHAuaWQ7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgdmFyIHNlcGFyYXRlQ29tcG9uZW50cyA9IGZ1bmN0aW9uKGxheXV0SW5mbywgb3B0aW9ucyl7XG4gICAgICB2YXIgbm9kZXMgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzO1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgY2lkID0gbm9kZS5jbXB0SWQ7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzWyBjaWQgXSA9IGNvbXBvbmVudHNbIGNpZCBdIHx8IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudC5wdXNoKCBub2RlICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbEEgPSAwO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGMgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICBjLngxID0gSW5maW5pdHk7XG4gICAgICAgIGMueDIgPSAtSW5maW5pdHk7XG4gICAgICAgIGMueTEgPSBJbmZpbml0eTtcbiAgICAgICAgYy55MiA9IC1JbmZpbml0eTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgbiA9IGNbal07XG5cbiAgICAgICAgICBjLngxID0gTWF0aC5taW4oIGMueDEsIG4ucG9zaXRpb25YIC0gbi53aWR0aC8yICk7XG4gICAgICAgICAgYy54MiA9IE1hdGgubWF4KCBjLngyLCBuLnBvc2l0aW9uWCArIG4ud2lkdGgvMiApO1xuICAgICAgICAgIGMueTEgPSBNYXRoLm1pbiggYy55MSwgbi5wb3NpdGlvblkgLSBuLmhlaWdodC8yICk7XG4gICAgICAgICAgYy55MiA9IE1hdGgubWF4KCBjLnkyLCBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0LzIgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGMudyA9IGMueDIgLSBjLngxO1xuICAgICAgICBjLmggPSBjLnkyIC0gYy55MTtcblxuICAgICAgICB0b3RhbEEgKz0gYy53ICogYy5oO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRzLnNvcnQoZnVuY3Rpb24oIGMxLCBjMiApe1xuICAgICAgICByZXR1cm4gYzIudypjMi5oIC0gYzEudypjMS5oO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciB4ID0gMDtcbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHZhciB1c2VkVyA9IDA7XG4gICAgICB2YXIgcm93SCA9IDA7XG4gICAgICB2YXIgbWF4Um93VyA9IE1hdGguc3FydCggdG90YWxBICkgKiBsYXlvdXRJbmZvLmNsaWVudFdpZHRoIC8gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIG4gPSBjW2pdO1xuXG4gICAgICAgICAgaWYoICFuLmlzTG9ja2VkICl7XG4gICAgICAgICAgICBuLnBvc2l0aW9uWCArPSB4O1xuICAgICAgICAgICAgbi5wb3NpdGlvblkgKz0geTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4ICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICAgICAgdXNlZFcgKz0gYy53ICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgICByb3dIID0gTWF0aC5tYXgoIHJvd0gsIGMuaCApO1xuXG4gICAgICAgIGlmKCB1c2VkVyA+IG1heFJvd1cgKXtcbiAgICAgICAgICB5ICs9IHJvd0ggKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgdXNlZFcgPSAwO1xuICAgICAgICAgIHJvd0ggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBtYWluTG9vcCA9IGZ1bmN0aW9uKGkpe1xuICAgICAgaWYoIHN0b3BwZWQgKXtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJMYXlvdXQgbWFudWFsbHkgc3RvcHBlZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG9uZSBzdGVwIGluIHRoZSBwaGlzaWNhbCBzaW11bGF0aW9uXG4gICAgICBzdGVwKGxheW91dEluZm8sIG9wdGlvbnMsIGkpO1xuXG4gICAgICAvLyBVcGRhdGUgdGVtcGVyYXR1cmVcbiAgICAgIGxheW91dEluZm8udGVtcGVyYXR1cmUgPSBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICogb3B0aW9ucy5jb29saW5nRmFjdG9yO1xuICAgICAgLy8gbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICAgIGlmIChsYXlvdXRJbmZvLnRlbXBlcmF0dXJlIDwgb3B0aW9ucy5taW5UZW1wKSB7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiVGVtcGVyYXR1cmUgZHJvcCBiZWxvdyBtaW5pbXVtIHRocmVzaG9sZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxvb3BSZXQ7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgZiA9IDA7XG5cbiAgICAgIHdoaWxlKCBmIDwgb3B0aW9ucy5yZWZyZXNoICYmIGkgPCBvcHRpb25zLm51bUl0ZXIgKXtcbiAgICAgICAgdmFyIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgICAgaWYoICFsb29wUmV0ICl7IGJyZWFrOyB9XG5cbiAgICAgICAgZisrO1xuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgYnJvYWRjYXN0KCBsYXlvdXRJbmZvLmxheW91dE5vZGVzICk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgfVxuXG4gICAgfSB3aGlsZSAoIGxvb3BSZXQgJiYgaSArIDEgPCBvcHRpb25zLm51bUl0ZXIgKTtcblxuICAgIHNlcGFyYXRlQ29tcG9uZW50cyggbGF5b3V0SW5mbywgb3B0aW9ucyApO1xuXG4gICAgcmV0dXJuIGxheW91dEluZm87XG4gIH0pLnRoZW4oZnVuY3Rpb24oIGxheW91dEluZm9VcGRhdGVkICl7XG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2RlcyA9IGxheW91dEluZm9VcGRhdGVkLmxheW91dE5vZGVzOyAvLyBnZXQgdGhlIHBvc2l0aW9uc1xuXG4gICAgdGhyZWFkLnN0b3AoKTtcbiAgICBkb25lKCk7XG4gIH0pO1xuXG4gIHZhciBkb25lID0gZnVuY3Rpb24oKXtcbiAgICByZWZyZXNoKHsgXG4gICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIExheW91dCBoYXMgZmluaXNoZWRcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgaWYoIHRoaXMudGhyZWFkICl7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG5cbiAgdGhpcy50cmlnZ2VyKCdsYXlvdXRzdG9wJyk7XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgaWYoIHRoaXMudGhyZWFkICl7XG4gICAgdGhpcy50aHJlYWQuc3RvcCgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5cbi8qKlxuICogQGJyaWVmICAgICA6IENyZWF0ZXMgYW4gb2JqZWN0IHdoaWNoIGlzIGNvbnRhaW5zIGFsbCB0aGUgZGF0YVxuICogICAgICAgICAgICAgIHVzZWQgaW4gdGhlIGxheW91dCBwcm9jZXNzXG4gKiBAYXJnIGN5ICAgIDogY3l0b3NjYXBlLmpzIG9iamVjdFxuICogQHJldHVybiAgICA6IGxheW91dEluZm8gb2JqZWN0IGluaXRpYWxpemVkXG4gKi9cbnZhciBjcmVhdGVMYXlvdXRJbmZvID0gZnVuY3Rpb24oY3ksIGxheW91dCwgb3B0aW9ucykge1xuICAvLyBTaG9ydGN1dFxuICB2YXIgZWRnZXMgPSBvcHRpb25zLmVsZXMuZWRnZXMoKTtcbiAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG5cbiAgdmFyIGxheW91dEluZm8gICA9IHtcbiAgICBpc0NvbXBvdW5kICAgOiBjeS5oYXNDb21wb3VuZE5vZGVzKCksXG4gICAgbGF5b3V0Tm9kZXMgIDogW10sXG4gICAgaWRUb0luZGV4ICAgIDoge30sXG4gICAgbm9kZVNpemUgICAgIDogbm9kZXMuc2l6ZSgpLFxuICAgIGdyYXBoU2V0ICAgICA6IFtdLFxuICAgIGluZGV4VG9HcmFwaCA6IFtdLFxuICAgIGxheW91dEVkZ2VzICA6IFtdLFxuICAgIGVkZ2VTaXplICAgICA6IGVkZ2VzLnNpemUoKSxcbiAgICB0ZW1wZXJhdHVyZSAgOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgIGNsaWVudFdpZHRoICA6IGN5LndpZHRoKCksXG4gICAgY2xpZW50SGVpZ2h0IDogY3kud2lkdGgoKSxcbiAgICBib3VuZGluZ0JveCAgOiBtYXRoLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgICAgICAgICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICAgICAgICAgICAgICAgfSApXG4gIH07XG5cbiAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmVsZXMuY29tcG9uZW50cygpO1xuICB2YXIgaWQyY21wdElkID0ge307XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRbal07XG5cbiAgICAgIGlkMmNtcHRJZFsgbm9kZS5pZCgpIF0gPSBpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgbm9kZXMsIGNyZWF0aW5nIGxheW91dCBub2Rlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbm9kZXNbaV07XG4gICAgdmFyIG5iYiA9IG4uYm91bmRpbmdCb3goKTtcblxuICAgIHZhciB0ZW1wTm9kZSAgICAgICAgPSB7fTtcbiAgICB0ZW1wTm9kZS5pc0xvY2tlZCAgID0gbi5sb2NrZWQoKTtcbiAgICB0ZW1wTm9kZS5pZCAgICAgICAgID0gbi5kYXRhKCdpZCcpO1xuICAgIHRlbXBOb2RlLnBhcmVudElkICAgPSBuLmRhdGEoJ3BhcmVudCcpO1xuICAgIHRlbXBOb2RlLmNtcHRJZCAgICAgPSBpZDJjbXB0SWRbIG4uaWQoKSBdO1xuICAgIHRlbXBOb2RlLmNoaWxkcmVuICAgPSBbXTtcbiAgICB0ZW1wTm9kZS5wb3NpdGlvblggID0gbi5wb3NpdGlvbigneCcpO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWSAgPSBuLnBvc2l0aW9uKCd5Jyk7XG4gICAgdGVtcE5vZGUub2Zmc2V0WCAgICA9IDA7XG4gICAgdGVtcE5vZGUub2Zmc2V0WSAgICA9IDA7XG4gICAgdGVtcE5vZGUuaGVpZ2h0ICAgICA9IG5iYi53O1xuICAgIHRlbXBOb2RlLndpZHRoICAgICAgPSBuYmIuaDtcbiAgICB0ZW1wTm9kZS5tYXhYICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25YICsgdGVtcE5vZGUud2lkdGggIC8gMjtcbiAgICB0ZW1wTm9kZS5taW5YICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25YIC0gdGVtcE5vZGUud2lkdGggIC8gMjtcbiAgICB0ZW1wTm9kZS5tYXhZICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5taW5ZICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25ZIC0gdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICB0ZW1wTm9kZS5wYWRMZWZ0ICAgID0gcGFyc2VGbG9hdCggbi5zdHlsZSgncGFkZGluZy1sZWZ0JykgKTtcbiAgICB0ZW1wTm9kZS5wYWRSaWdodCAgID0gcGFyc2VGbG9hdCggbi5zdHlsZSgncGFkZGluZy1yaWdodCcpICk7XG4gICAgdGVtcE5vZGUucGFkVG9wICAgICA9IHBhcnNlRmxvYXQoIG4uc3R5bGUoJ3BhZGRpbmctdG9wJykgKTtcbiAgICB0ZW1wTm9kZS5wYWRCb3R0b20gID0gcGFyc2VGbG9hdCggbi5zdHlsZSgncGFkZGluZy1ib3R0b20nKSApO1xuXG4gICAgLy8gZm9yY2VzXG4gICAgdGVtcE5vZGUubm9kZVJlcHVsc2lvbiA9IGlzLmZuKCBvcHRpb25zLm5vZGVSZXB1bHNpb24gKSA/IG9wdGlvbnMubm9kZVJlcHVsc2lvbi5jYWxsKCBuLCBuICkgOiBvcHRpb25zLm5vZGVSZXB1bHNpb247XG5cbiAgICAvLyBBZGQgbmV3IG5vZGVcbiAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzLnB1c2godGVtcE5vZGUpO1xuICAgIC8vIEFkZCBlbnRyeSB0byBpZC1pbmRleCBtYXBcbiAgICBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5pZF0gPSBpO1xuICB9XG5cbiAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICB2YXIgcXVldWUgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gIHZhciB0ZW1wR3JhcGggPSBbXTtcblxuICAvLyBTZWNvbmQgcGFzcyB0byBhZGQgY2hpbGQgaW5mb3JtYXRpb24gYW5kXG4gIC8vIGluaXRpYWxpemUgcXVldWUgZm9yIGhpZXJhcmNoaWNhbCB0cmF2ZXJzYWxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgdmFyIHBfaWQgPSBuLnBhcmVudElkO1xuICAgIC8vIENoZWNrIGlmIG5vZGUgbiBoYXMgYSBwYXJlbnQgbm9kZVxuICAgIGlmIChudWxsICE9IHBfaWQpIHtcbiAgICAvLyBBZGQgbm9kZSBJZCB0byBwYXJlbnQncyBsaXN0IG9mIGNoaWxkcmVuXG4gICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwX2lkXV0uY2hpbGRyZW4ucHVzaChuLmlkKTtcbiAgICB9IGVsc2Uge1xuICAgIC8vIElmIGEgbm9kZSBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHRoZW4gaXQncyBpbiB0aGUgcm9vdCBncmFwaFxuICAgIHF1ZXVlWysrZW5kXSA9IG4uaWQ7XG4gICAgdGVtcEdyYXBoLnB1c2gobi5pZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcbiAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKHRlbXBHcmFwaCk7XG5cbiAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCxcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICB2YXIgbm9kZV9pZCAgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICB2YXIgbm9kZV9peCAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlX2lkXTtcbiAgICB2YXIgbm9kZSAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVfaXhdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAvLyBBZGQgY2hpbGRyZW4gbm9kZXMgYXMgYSBuZXcgZ3JhcGggdG8gZ3JhcGggc2V0XG4gICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKGNoaWxkcmVuKTtcbiAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVlIHF1ZXVlIHRvIGJlIHZpc2l0ZWRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGluZGV4VG9HcmFwaCBtYXBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyYXBoLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dO1xuICAgIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2luZGV4XSA9IGk7XG4gICAgfVxuICB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlcywgY3JlYXRpbmcgTGF5b3V0IEVkZ2VzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICB2YXIgdGVtcEVkZ2UgPSB7fTtcbiAgICB0ZW1wRWRnZS5pZCAgICAgICA9IGUuZGF0YSgnaWQnKTtcbiAgICB0ZW1wRWRnZS5zb3VyY2VJZCA9IGUuZGF0YSgnc291cmNlJyk7XG4gICAgdGVtcEVkZ2UudGFyZ2V0SWQgPSBlLmRhdGEoJ3RhcmdldCcpO1xuXG4gICAgLy8gQ29tcHV0ZSBpZGVhbCBsZW5ndGhcbiAgICB2YXIgaWRlYWxMZW5ndGggPSBpcy5mbiggb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGggKSA/IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoLmNhbGwoIGUsIGUgKSA6IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuICAgIHZhciBlbGFzdGljaXR5ID0gaXMuZm4oIG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkgKSA/IG9wdGlvbnMuZWRnZUVsYXN0aWNpdHkuY2FsbCggZSwgZSApIDogb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTtcblxuICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gaW50ZXIgZ3JhcGggZWRnZVxuICAgIHZhciBzb3VyY2VJeCAgICA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnNvdXJjZUlkXTtcbiAgICB2YXIgdGFyZ2V0SXggICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS50YXJnZXRJZF07XG4gICAgdmFyIHNvdXJjZUdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbc291cmNlSXhdO1xuICAgIHZhciB0YXJnZXRHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3RhcmdldEl4XTtcblxuICAgIGlmIChzb3VyY2VHcmFwaCAhPSB0YXJnZXRHcmFwaCkge1xuICAgICAgLy8gRmluZCBsb3dlc3QgY29tbW9uIGdyYXBoIGFuY2VzdG9yXG4gICAgICB2YXIgbGNhID0gZmluZExDQSh0ZW1wRWRnZS5zb3VyY2VJZCwgdGVtcEVkZ2UudGFyZ2V0SWQsIGxheW91dEluZm8pO1xuXG4gICAgICAvLyBDb21wdXRlIHN1bSBvZiBub2RlIGRlcHRocywgcmVsYXRpdmUgdG8gbGNhIGdyYXBoXG4gICAgICB2YXIgbGNhR3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2xjYV07XG4gICAgICB2YXIgZGVwdGggICAgPSAwO1xuXG4gICAgICAvLyBTb3VyY2UgZGVwdGhcbiAgICAgIHZhciB0ZW1wTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgICAgd2hpbGUgKCAtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkgKSB7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBUYXJnZXQgZGVwdGhcbiAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG4gICAgICB3aGlsZSAoIC0xID09PSBsY2FHcmFwaC5pbmRleE9mKHRlbXBOb2RlLmlkKSApIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICtcbiAgICAgICAgLy8gIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICtcbiAgICAgICAgLy8gIFwiLiBEZXB0aDogXCIgKyBkZXB0aCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBpZGVhbExlbmd0aFxuICAgICAgaWRlYWxMZW5ndGggKj0gZGVwdGggKiBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gICAgfVxuXG4gICAgdGVtcEVkZ2UuaWRlYWxMZW5ndGggPSBpZGVhbExlbmd0aDtcbiAgICB0ZW1wRWRnZS5lbGFzdGljaXR5ID0gZWxhc3RpY2l0eTtcblxuICAgIGxheW91dEluZm8ubGF5b3V0RWRnZXMucHVzaCh0ZW1wRWRnZSk7XG4gIH1cblxuICAvLyBGaW5hbGx5LCByZXR1cm4gbGF5b3V0SW5mbyBvYmplY3RcbiAgcmV0dXJuIGxheW91dEluZm87XG59O1xuXG5cbi8qKlxuICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb25cbiAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZVxuICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gKiAgICAgICAgICByb290IGlzIGdyYXBoSXhcbiAqXG4gKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gKiBAYXJnIG5vZGUyOiBub2RlMidzIElEXG4gKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gKlxuICovXG52YXIgZmluZExDQSA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbykge1xuICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICB2YXIgcmVzID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCAwLCBsYXlvdXRJbmZvKTtcbiAgaWYgKDIgPiByZXMuY291bnQpIHtcbiAgICAvLyBJZiBhdXggZnVuY3Rpb24gY291bGRuJ3QgZmluZCB0aGUgY29tbW9uIGFuY2VzdGVyLFxuICAgIC8vIHRoZW4gaXQgaXMgdGhlIHJvb3QgZ3JhcGhcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzLmdyYXBoO1xuICB9XG59O1xuXG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogQXV4aWxpYXJ5IGZ1bmN0aW9uIHVzZWQgZm9yIExDQSBjb21wdXRhdGlvblxuICpcbiAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAqIEBhcmcgZ3JhcGhJeCAgICA6IHN1YmdyYXBoIGluZGV4XG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqIEByZXR1cm4gICAgICAgICA6IG9iamVjdCBvZiB0aGUgZm9ybSB7Y291bnQ6IFgsIGdyYXBoOiBZfSwgd2hlcmU6XG4gKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0ZXJzIChtYXg6IDIpIGZvdW5kIGluXG4gKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICovXG52YXIgZmluZExDQV9hdXggPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGdyYXBoSXgsIGxheW91dEluZm8pIHtcbiAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtncmFwaEl4XTtcbiAgLy8gSWYgYm90aCBub2RlcyBiZWxvbmdzIHRvIGdyYXBoSXhcbiAgaWYgKC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMSkgJiYgLTEgPCBncmFwaC5pbmRleE9mKG5vZGUyKSkge1xuICAgIHJldHVybiB7Y291bnQ6MiwgZ3JhcGg6Z3JhcGhJeH07XG4gIH1cblxuICAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuICB2YXIgYyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZUlkICAgPSBncmFwaFtpXTtcbiAgICB2YXIgbm9kZUl4ICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgIHZhciBjaGlsZHJlbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbm9kZUl4XS5jaGlsZHJlbjtcblxuICAgIC8vIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgc2tpcCBpdFxuICAgIGlmICgwID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRHcmFwaEl4ID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5bMF1dXTtcbiAgICB2YXIgcmVzdWx0ID0gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBjaGlsZEdyYXBoSXgsIGxheW91dEluZm8pO1xuICAgIGlmICgwID09PSByZXN1bHQuY291bnQpIHtcbiAgICAvLyBOZWl0aGVyIG5vZGUxIG5vciBub2RlMiBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAvLyBPbmUgb2YgKG5vZGUxLCBub2RlMikgaXMgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgYysrO1xuICAgIGlmICgyID09PSBjKSB7XG4gICAgICAvLyBXZSd2ZSBhbHJlYWR5IGZvdW5kIGJvdGggbm9kZXMsIG5vIG5lZWQgdG8ga2VlcCBzZWFyY2hpbmdcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB9IGVsc2Uge1xuICAgIC8vIEJvdGggbm9kZXMgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtjb3VudDpjLCBncmFwaDpncmFwaEl4fTtcbn07XG5cblxuLyoqXG4gKiBAYnJpZWY6IHByaW50c0xheW91dEluZm8gaW50byBqcyBjb25zb2xlXG4gKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nXG4gKi9cbnZhciBwcmludExheW91dEluZm8gPSBmdW5jdGlvbihsYXlvdXRJbmZvKSB7XG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuICBpZiAoIURFQlVHKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUuZGVidWcoXCJsYXlvdXROb2RlczpcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgIHZhciBzID1cbiAgICBcIlxcbmluZGV4OiBcIiAgICAgKyBpICtcbiAgICBcIlxcbklkOiBcIiAgICAgICAgKyBuLmlkICtcbiAgICBcIlxcbkNoaWxkcmVuOiBcIiAgKyBuLmNoaWxkcmVuLnRvU3RyaW5nKCkgK1xuICAgIFwiXFxucGFyZW50SWQ6IFwiICArIG4ucGFyZW50SWQgICtcbiAgICBcIlxcbnBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArXG4gICAgXCJcXG5wb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblkgK1xuICAgIFwiXFxuT2Zmc2V0WDogXCIgKyBuLm9mZnNldFggK1xuICAgIFwiXFxuT2Zmc2V0WTogXCIgKyBuLm9mZnNldFkgK1xuICAgIFwiXFxucGFkTGVmdDogXCIgKyBuLnBhZExlZnQgK1xuICAgIFwiXFxucGFkUmlnaHQ6IFwiICsgbi5wYWRSaWdodCArXG4gICAgXCJcXG5wYWRUb3A6IFwiICsgbi5wYWRUb3AgK1xuICAgIFwiXFxucGFkQm90dG9tOiBcIiArIG4ucGFkQm90dG9tO1xuXG4gICAgY29uc29sZS5kZWJ1ZyhzKTtcbiAgfVxuXG4gIGNvbnNvbGUuZGVidWcoJ2lkVG9JbmRleCcpO1xuICBmb3IgKHZhciBpIGluIGxheW91dEluZm8uaWRUb0luZGV4KSB7XG4gICAgY29uc29sZS5kZWJ1ZyhcIklkOiBcIiArIGkgKyBcIlxcbkluZGV4OiBcIiArIGxheW91dEluZm8uaWRUb0luZGV4W2ldKTtcbiAgfVxuXG4gIGNvbnNvbGUuZGVidWcoJ0dyYXBoIFNldCcpO1xuICB2YXIgc2V0ID0gbGF5b3V0SW5mby5ncmFwaFNldDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICsrKSB7XG4gICAgY29uc29sZS5kZWJ1ZyhcIlNldCA6IFwiICsgaSArIFwiOiBcIiArIHNldFtpXS50b1N0cmluZygpKTtcbiAgfVxuXG4gIHZhciBzID0gJ0luZGV4VG9HcmFwaCc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5pbmRleFRvR3JhcGgubGVuZ3RoOyBpICsrKSB7XG4gICAgcyArPSBcIlxcbkluZGV4IDogXCIgKyBpICsgXCIgR3JhcGg6IFwiKyBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpXTtcbiAgfVxuICBjb25zb2xlLmRlYnVnKHMpO1xuXG4gIHMgPSAnTGF5b3V0IEVkZ2VzJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGUgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzW2ldO1xuICAgIHMgKz0gXCJcXG5FZGdlIEluZGV4OiBcIiArIGkgKyBcIiBJRDogXCIgKyBlLmlkICtcbiAgICBcIiBTb3VjZUlEOiBcIiArIGUuc291cmNlSWQgKyBcIiBUYXJnZXRJZDogXCIgKyBlLnRhcmdldElkICtcbiAgICBcIiBJZGVhbCBMZW5ndGg6IFwiICsgZS5pZGVhbExlbmd0aDtcbiAgfVxuICBjb25zb2xlLmRlYnVnKHMpO1xuXG4gIHMgPSAgXCJub2RlU2l6ZTogXCIgKyBsYXlvdXRJbmZvLm5vZGVTaXplO1xuICBzICs9IFwiXFxuZWRnZVNpemU6IFwiICsgbGF5b3V0SW5mby5lZGdlU2l6ZTtcbiAgcyArPSBcIlxcbnRlbXBlcmF0dXJlOiBcIiArIGxheW91dEluZm8udGVtcGVyYXR1cmU7XG4gIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgcmV0dXJuO1xuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xufTtcblxuXG4vKipcbiAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICovXG52YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3kpIHtcbiAgdmFyIHdpZHRoICAgICA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgICAgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcblxuICAgIC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzIG9yIGxvY2tlZCBub2Rlc1xuICAgIGlmICggMCA9PT0gbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQgKSB7XG4gICAgICBuLnBvc2l0aW9uWCA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDtcbiAgICAgIG4ucG9zaXRpb25ZID0gTWF0aC5yYW5kb20oKSAqIGhlaWdodDtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgaW4gdGhlIG5ldHdvcmtcbiAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0XG4gKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG52YXIgcmVmcmVzaFBvc2l0aW9ucyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgdmFyIGxheW91dCA9IG9wdGlvbnMubGF5b3V0O1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGJiID0gbGF5b3V0SW5mby5ib3VuZGluZ0JveDtcbiAgdmFyIGNvc2VCQiA9IHsgeDE6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MTogSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfTtcblxuICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApe1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZS5kYXRhKCdpZCcpXV07XG5cbiAgICAgIGNvc2VCQi54MSA9IE1hdGgubWluKCBjb3NlQkIueDEsIGxub2RlLnBvc2l0aW9uWCApO1xuICAgICAgY29zZUJCLngyID0gTWF0aC5tYXgoIGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YICk7XG5cbiAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKCBjb3NlQkIueTEsIGxub2RlLnBvc2l0aW9uWSApO1xuICAgICAgY29zZUJCLnkyID0gTWF0aC5tYXgoIGNvc2VCQi55MiwgbG5vZGUucG9zaXRpb25ZICk7XG4gICAgfSk7XG5cbiAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICBjb3NlQkIuaCA9IGNvc2VCQi55MiAtIGNvc2VCQi55MTtcbiAgfVxuXG4gIG5vZGVzLnBvc2l0aW9ucyhmdW5jdGlvbihpLCBlbGUpIHtcbiAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2VsZS5kYXRhKCdpZCcpXV07XG4gICAgLy8gcyA9IFwiTm9kZTogXCIgKyBsbm9kZS5pZCArIFwiLiBSZWZyZXNoZWQgcG9zaXRpb246IChcIiArXG4gICAgLy8gbG5vZGUucG9zaXRpb25YICsgXCIsIFwiICsgbG5vZGUucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXsgLy8gdGhlbiBhZGQgZXh0cmEgYm91bmRpbmcgYm94IGNvbnN0cmFpbnRcbiAgICAgIHZhciBwY3RYID0gKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgIHZhciBwY3RZID0gKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmIueDEgKyBwY3RYICogYmIudyxcbiAgICAgICAgeTogYmIueTEgKyBwY3RZICogYmIuaFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbG5vZGUucG9zaXRpb25YLFxuICAgICAgICB5OiBsbm9kZS5wb3NpdGlvbllcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBUcmlnZ2VyIGxheW91dFJlYWR5IG9ubHkgb24gZmlyc3QgY2FsbFxuICBpZiAodHJ1ZSAhPT0gbGF5b3V0SW5mby5yZWFkeSkge1xuICAgIC8vIHMgPSAnVHJpZ2dlcmluZyBsYXlvdXRyZWFkeSc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgbGF5b3V0SW5mby5yZWFkeSA9IHRydWU7XG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogdGhpcyB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBMb2dzIGEgZGVidWcgbWVzc2FnZSBpbiBKUyBjb25zb2xlLCBpZiBERUJVRyBpcyBPTlxuICovXG4vLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbih0ZXh0KSB7XG4vLyAgIGlmIChERUJVRykge1xuLy8gICAgIGNvbnNvbGUuZGVidWcodGV4dCk7XG4vLyAgIH1cbi8vIH07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29zZUxheW91dDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG52YXIgbWF0aCA9IHJlcXVpcmUoJy4uLy4uL21hdGgnKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCwgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgY29uZGVuc2U6IGZhbHNlLCAvLyB1c2VzIGFsbCBhdmFpbGFibGUgc3BhY2Ugb24gZmFsc2UsIHVzZXMgbWluaW1hbCBzcGFjZSBvbiB0cnVlXG4gIHJvd3M6IHVuZGVmaW5lZCwgLy8gZm9yY2UgbnVtIG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgY29sczogdW5kZWZpbmVkLCAvLyBmb3JjZSBudW0gb2YgY29sdW1ucyBpbiB0aGUgZ3JpZFxuICBwb3NpdGlvbjogZnVuY3Rpb24oIG5vZGUgKXt9LCAvLyByZXR1cm5zIHsgcm93LCBjb2wgfSBmb3IgZWxlbWVudFxuICBzb3J0OiB1bmRlZmluZWQsIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLCAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3Bcbn07XG5cbmZ1bmN0aW9uIEdyaWRMYXlvdXQoIG9wdGlvbnMgKXtcbiAgdGhpcy5vcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblxuR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG5cbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gIGlmKCBvcHRpb25zLnNvcnQgKXtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQoIG9wdGlvbnMuc29ydCApO1xuICB9XG5cbiAgdmFyIGJiID0gbWF0aC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgfSApO1xuXG4gIGlmKCBiYi5oID09PSAwIHx8IGJiLncgPT09IDApe1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHsgeDogYmIueDEsIHk6IGJiLnkxIH07XG4gICAgfSk7XG5cbiAgfSBlbHNlIHtcblxuICAgIC8vIHdpZHRoL2hlaWdodCAqIHNwbGl0c14yID0gY2VsbHMgd2hlcmUgc3BsaXRzIGlzIG51bWJlciBvZiB0aW1lcyB0byBzcGxpdCB3aWR0aFxuICAgIHZhciBjZWxscyA9IG5vZGVzLnNpemUoKTtcbiAgICB2YXIgc3BsaXRzID0gTWF0aC5zcXJ0KCBjZWxscyAqIGJiLmgvYmIudyApO1xuICAgIHZhciByb3dzID0gTWF0aC5yb3VuZCggc3BsaXRzICk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKCBiYi53L2JiLmggKiBzcGxpdHMgKTtcblxuICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uKHZhbCl7XG4gICAgICBpZiggdmFsID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICBpZiggbWluID09IHJvd3MgKXtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGxhcmdlID0gZnVuY3Rpb24odmFsKXtcbiAgICAgIGlmKCB2YWwgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICAgIGlmKCBtYXggPT0gcm93cyApe1xuICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb1Jvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgdmFyIG9Db2xzID0gb3B0aW9ucy5jb2xzICE9IG51bGwgPyBvcHRpb25zLmNvbHMgOiBvcHRpb25zLmNvbHVtbnM7XG5cbiAgICAvLyBpZiByb3dzIG9yIGNvbHVtbnMgd2VyZSBzZXQgaW4gb3B0aW9ucywgdXNlIHRob3NlIHZhbHVlc1xuICAgIGlmKCBvUm93cyAhPSBudWxsICYmIG9Db2xzICE9IG51bGwgKXtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICB9IGVsc2UgaWYoIG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgPT0gbnVsbCApe1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IE1hdGguY2VpbCggY2VsbHMgLyByb3dzICk7XG4gICAgfSBlbHNlIGlmKCBvUm93cyA9PSBudWxsICYmIG9Db2xzICE9IG51bGwgKXtcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICAgIHJvd3MgPSBNYXRoLmNlaWwoIGNlbGxzIC8gY29scyApO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGF1dG9tYXRpYyB2YWx1ZXMgYW5kIGFkanVzdCBhY2NvcmRpbmdseVxuXG4gICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICBlbHNlIGlmKCBjb2xzICogcm93cyA+IGNlbGxzICl7XG4gICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcblxuICAgICAgLy8gcmVkdWNpbmcgdGhlIHNtYWxsIHNpZGUgdGFrZXMgYXdheSB0aGUgbW9zdCBjZWxscywgc28gdHJ5IGl0IGZpcnN0XG4gICAgICBpZiggKHNtIC0gMSkgKiBsZyA+PSBjZWxscyApe1xuICAgICAgICBzbWFsbChzbSAtIDEpO1xuICAgICAgfSBlbHNlIGlmKCAobGcgLSAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgIGxhcmdlKGxnIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgIHdoaWxlKCBjb2xzICogcm93cyA8IGNlbGxzICl7XG4gICAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGFkZCB0byBsYXJnZXIgc2lkZSBmaXJzdCAoYWRkcyBsZXNzIGluIG11bHRpcGxpY2F0aW9uKVxuICAgICAgICBpZiggKGxnICsgMSkgKiBzbSA+PSBjZWxscyApe1xuICAgICAgICAgIGxhcmdlKGxnICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc21hbGwoc20gKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZWxsV2lkdGggPSBiYi53IC8gY29scztcbiAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgaWYoIG9wdGlvbnMuY29uZGVuc2UgKXtcbiAgICAgIGNlbGxXaWR0aCA9IDA7XG4gICAgICBjZWxsSGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgaWYoIHBvcy54ID09IG51bGwgfHwgcG9zLnkgPT0gbnVsbCApeyAvLyBmb3IgYmJcbiAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5iYiA9IG5vZGUuYm91bmRpbmdCb3goKTtcbiAgICAgICAgdmFyIHAgPSBvcHRpb25zLmF2b2lkT3ZlcmxhcFBhZGRpbmc7XG5cbiAgICAgICAgdmFyIHcgPSBuYmIudyArIHA7XG4gICAgICAgIHZhciBoID0gbmJiLmggKyBwO1xuXG4gICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KCBjZWxsV2lkdGgsIHcgKTtcbiAgICAgICAgY2VsbEhlaWdodCA9IE1hdGgubWF4KCBjZWxsSGVpZ2h0LCBoICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG5cbiAgICB2YXIgdXNlZCA9IGZ1bmN0aW9uKHJvdywgY29sKXtcbiAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIHVzZSA9IGZ1bmN0aW9uKHJvdywgY29sKXtcbiAgICAgIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gdG8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGNlbGwgcG9zaXRpb25cbiAgICB2YXIgcm93ID0gMDtcbiAgICB2YXIgY29sID0gMDtcbiAgICB2YXIgbW92ZVRvTmV4dENlbGwgPSBmdW5jdGlvbigpe1xuICAgICAgY29sKys7XG4gICAgICBpZiggY29sID49IGNvbHMgKXtcbiAgICAgICAgY29sID0gMDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIHJjUG9zID0gb3B0aW9ucy5wb3NpdGlvbiggbm9kZSApO1xuXG4gICAgICBpZiggcmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSApeyAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICB2YXIgcG9zID0ge1xuICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgIGNvbDogcmNQb3MuY29sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIHBvcy5jb2wgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICBwb3MuY29sID0gMDtcblxuICAgICAgICAgIHdoaWxlKCB1c2VkKHBvcy5yb3csIHBvcy5jb2wpICl7XG4gICAgICAgICAgICBwb3MuY29sKys7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIHBvcy5yb3cgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICBwb3Mucm93ID0gMDtcblxuICAgICAgICAgIHdoaWxlKCB1c2VkKHBvcy5yb3csIHBvcy5jb2wpICl7XG4gICAgICAgICAgICBwb3Mucm93Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWQybWFuUG9zWyBub2RlLmlkKCkgXSA9IHBvcztcbiAgICAgICAgdXNlKCBwb3Mucm93LCBwb3MuY29sICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgdmFyIHgsIHk7XG5cbiAgICAgIGlmKCBlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNGdWxsQXV0b1BhcmVudCgpICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG4gICAgICB2YXIgcmNQb3MgPSBpZDJtYW5Qb3NbIGVsZW1lbnQuaWQoKSBdO1xuICAgICAgaWYoIHJjUG9zICl7XG4gICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGgvMiArIGJiLngxO1xuICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQvMiArIGJiLnkxO1xuXG4gICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2V0IGF1dG9tYXRpY2FsbHlcblxuICAgICAgICB3aGlsZSggdXNlZChyb3csIGNvbCkgKXtcbiAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgeCA9IGNvbCAqIGNlbGxXaWR0aCArIGNlbGxXaWR0aC8yICsgYmIueDE7XG4gICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodC8yICsgYmIueTE7XG4gICAgICAgIHVzZSggcm93LCBjb2wgKTtcblxuICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG5cbiAgICB9O1xuXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyaWRMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICB7IG5hbWU6ICdicmVhZHRoZmlyc3QnLCBpbXBsOiByZXF1aXJlKCcuL2JyZWFkdGhmaXJzdCcpIH0sXG4gIHsgbmFtZTogJ2NpcmNsZScsIGltcGw6IHJlcXVpcmUoJy4vY2lyY2xlJykgfSxcbiAgeyBuYW1lOiAnY29uY2VudHJpYycsaW1wbDogcmVxdWlyZSgnLi9jb25jZW50cmljJykgfSxcbiAgeyBuYW1lOiAnY29zZScsIGltcGw6IHJlcXVpcmUoJy4vY29zZScpIH0sXG4gIHsgbmFtZTogJ2dyaWQnLCBpbXBsOiByZXF1aXJlKCcuL2dyaWQnKSB9LFxuICB7IG5hbWU6ICdudWxsJywgaW1wbDogcmVxdWlyZSgnLi9udWxsJykgfSxcbiAgeyBuYW1lOiAncHJlc2V0JywgaW1wbDogcmVxdWlyZSgnLi9wcmVzZXQnKSB9LFxuICB7IG5hbWU6ICdyYW5kb20nLCBpbXBsOiByZXF1aXJlKCcuL3JhbmRvbScpIH1cbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG4vLyBkZWZhdWx0IGxheW91dCBvcHRpb25zXG52YXIgZGVmYXVsdHMgPSB7XG4gIHJlYWR5OiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uKCl7fSAvLyBvbiBsYXlvdXRzdG9wXG59O1xuXG4vLyBjb25zdHJ1Y3RvclxuLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG5mdW5jdGlvbiBOdWxsTGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5cbi8vIHJ1bnMgdGhlIGxheW91dFxuTnVsbExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG4gIHZhciBsYXlvdXQgPSB0aGlzO1xuXG4gIC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgbGF5b3V0LnRyaWdnZXIoJ2xheW91dHN0YXJ0Jyk7XG5cbiAgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9KTtcblxuICAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG4gIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gIGxheW91dC50cmlnZ2VyKCdsYXlvdXRyZWFkeScpO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG4gIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICBsYXlvdXQudHJpZ2dlcignbGF5b3V0c3RvcCcpO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG5OdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE51bGxMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vaXMnKTtcblxudmFyIGRlZmF1bHRzID0ge1xuICBwb3NpdGlvbnM6IHVuZGVmaW5lZCwgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgem9vbTogdW5kZWZpbmVkLCAvLyB0aGUgem9vbSBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIHBhbjogdW5kZWZpbmVkLCAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBvbiBmaXRcbiAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxufTtcblxuZnVuY3Rpb24gUHJlc2V0TGF5b3V0KCBvcHRpb25zICl7XG4gIHRoaXMub3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG59XG5cblByZXNldExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgdmFyIHBvc0lzRm4gPSBpcy5mbiggb3B0aW9ucy5wb3NpdGlvbnMgKTtcblxuICBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKXtcbiAgICBpZiggb3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYoIHBvc0lzRm4gKXtcbiAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucy5hcHBseSggbm9kZSwgWyBub2RlIF0gKTtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcblxuICAgIGlmKCBwb3MgPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvcztcbiAgfVxuXG4gIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbihpLCBub2RlKXtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlKTtcblxuICAgIGlmKCBub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcmVzZXRMYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIG1hdGggPSByZXF1aXJlKCcuLi8uLi9tYXRoJyk7XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCwgLy8gZml0IHBhZGRpbmdcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLCAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3Bcbn07XG5cbmZ1bmN0aW9uIFJhbmRvbUxheW91dCggb3B0aW9ucyApe1xuICB0aGlzLm9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xufVxuXG5SYW5kb21MYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gIHZhciBiYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gIH0gKTtcblxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oIGksIG5vZGUgKXtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIudyApLFxuICAgICAgeTogYmIueTEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIuaCApXG4gICAgfTtcbiAgfTtcblxuICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21MYXlvdXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vLi4vaXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpO1xuXG52YXIgQlJwID0ge307XG5cbkJScC5hcnJvd1NoYXBlSGVpZ2h0ID0gMC4zO1xuXG5CUnAucmVnaXN0ZXJBcnJvd1NoYXBlcyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcnJvd1NoYXBlcyA9IHRoaXMuYXJyb3dTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgLy9cbiAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIHBhZGRpbmcgKXtcbiAgICB2YXIgeDEgPSB0cmFuc2xhdGlvbi54IC0gc2l6ZS8yIC0gcGFkZGluZztcbiAgICB2YXIgeDIgPSB0cmFuc2xhdGlvbi54ICsgc2l6ZS8yICsgcGFkZGluZztcbiAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZS8yIC0gcGFkZGluZztcbiAgICB2YXIgeTIgPSB0cmFuc2xhdGlvbi55ICsgc2l6ZS8yICsgcGFkZGluZztcblxuICAgIHZhciBpbnNpZGUgPSAoeDEgPD0geCAmJiB4IDw9IHgyKSAmJiAoeTEgPD0geSAmJiB5IDw9IHkyKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uKCB4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICB2YXIgeFJvdGF0ZWQgPSB4ICogTWF0aC5jb3MoYW5nbGUpIC0geSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgeVJvdGF0ZWQgPSB4ICogTWF0aC5zaW4oYW5nbGUpICsgeSAqIE1hdGguY29zKGFuZ2xlKTtcblxuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuXG4gICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeFRyYW5zbGF0ZWQsXG4gICAgICB5OiB5VHJhbnNsYXRlZFxuICAgIH07XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uKCBwdHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgIHZhciByZXRQdHMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSArPSAyICl7XG4gICAgICB2YXIgeCA9IHB0c1tpXTtcbiAgICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcblxuICAgICAgcmV0UHRzLnB1c2goIHRyYW5zZm9ybSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFB0cztcbiAgfTtcblxuICB2YXIgcG9pbnRzVG9BcnIgPSBmdW5jdGlvbiggcHRzICl7XG4gICAgdmFyIHJldCA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwID0gcHRzW2ldO1xuXG4gICAgICByZXQucHVzaCggcC54LCBwLnkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHZhciBkZWZpbmVBcnJvd1NoYXBlID0gZnVuY3Rpb24oIG5hbWUsIGRlZm4gKXtcbiAgICBpZiggaXMuc3RyaW5nKGRlZm4pICl7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbIGRlZm4gXTtcbiAgICB9XG5cbiAgICBhcnJvd1NoYXBlc1sgbmFtZSBdID0gdXRpbC5leHRlbmQoIHtcbiAgICAgIG5hbWU6IG5hbWUsXG5cbiAgICAgIHBvaW50czogW1xuICAgICAgICAtMC4xNSwgLTAuMyxcbiAgICAgICAgMC4xNSwgLTAuMyxcbiAgICAgICAgMC4xNSwgMC4zLFxuICAgICAgICAtMC4xNSwgMC4zXG4gICAgICBdLFxuXG4gICAgICBjb2xsaWRlOiBmdW5jdGlvbiggeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nICl7XG4gICAgICAgIHZhciBwb2ludHMgPSBwb2ludHNUb0FyciggdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSArIDIqcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uICkgKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCBwb2ludHMgKTtcblxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgfSxcblxuICAgICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG5cbiAgICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCdwb2x5Z29uJykoIGNvbnRleHQsIHBvaW50cyApO1xuICAgICAgfSxcblxuICAgICAgc3BhY2luZzogZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuXG4gICAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnBmVmFsdWUgKiAyO1xuICAgICAgfVxuICAgIH0sIGRlZm4gKTtcbiAgfTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnbm9uZScsIHtcbiAgICBjb2xsaWRlOiB1dGlsLmZhbHNpZnksXG5cbiAgICByb3VnaENvbGxpZGU6IHV0aWwuZmFsc2lmeSxcblxuICAgIGRyYXc6IHV0aWwubm9vcCxcblxuICAgIHNwYWNpbmc6IHV0aWwuemVyb2lmeSxcblxuICAgIGdhcDogdXRpbC56ZXJvaWZ5XG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAndHJpYW5nbGUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zXG4gICAgXVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ2Fycm93JywgJ3RyaWFuZ2xlJyApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICd0cmlhbmdsZS1iYWNrY3VydmUnLCB7XG4gICAgcG9pbnRzOiBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMsXG5cbiAgICBjb250cm9sUG9pbnQ6IFsgMCwgLTAuMTUgXSxcblxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgICAgdmFyIHB0c1RyYW5zID0gdHJhbnNmb3JtUG9pbnRzKCB0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5jb250cm9sUG9pbnQ7XG4gICAgICB2YXIgY3RybFB0VHJhbnMgPSB0cmFuc2Zvcm0oIGN0cmxQdFswXSwgY3RybFB0WzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgcmVuZGVyZXIuYXJyb3dTaGFwZUltcGwoIHRoaXMubmFtZSApKCBjb250ZXh0LCBwdHNUcmFucywgY3RybFB0VHJhbnMgKTtcbiAgICB9LFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZTtcbiAgICB9XG4gIH0gKTtcblxuXG4gIGRlZmluZUFycm93U2hhcGUoICd0cmlhbmdsZS10ZWUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdLFxuXG4gICAgcG9pbnRzVGVlOiBbXG4gICAgICAtMC4xNSwgLTAuNCxcbiAgICAgIC0wLjE1LCAtMC41LFxuICAgICAgMC4xNSwgLTAuNSxcbiAgICAgIDAuMTUsIC0wLjRcbiAgICBdLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZyApe1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKCB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMucG9pbnRzLCBzaXplICsgMipwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKCB0cmFuc2Zvcm1Qb2ludHMoIHRoaXMucG9pbnRzVGVlLCBzaXplICsgMipwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24gKSApO1xuXG4gICAgICB2YXIgaW5zaWRlID0gbWF0aC5wb2ludEluc2lkZVBvbHlnb25Qb2ludHMoIHgsIHksIHRyaVB0cyApIHx8IG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCB0ZWVQdHMgKTtcblxuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oIGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApe1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgdmFyIHRlZVB0cyA9IHRyYW5zZm9ybVBvaW50cyggdGhpcy5wb2ludHNUZWUsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIHRyaVB0cywgdGVlUHRzICk7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ3ZlZScsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4zLFxuICAgICAgMCwgMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAwLCAtMC4xNVxuICAgIF0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5wZlZhbHVlO1xuICAgIH1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdoYWxmLXRyaWFuZ2xlLW92ZXJzaG90Jywge1xuICAgIHBvaW50czogW1xuICAgICAgMCwgLTAuMjUsXG4gICAgICAtMC41LCAtMC4yNSxcbiAgICAgIDAuNSwgMC4yNVxuICAgIF0sXG5cbiAgICBsZWF2ZVBhdGhPcGVuOiB0cnVlLFxuXG4gICAgbWF0Y2hFZGdlV2lkdGg6IHRydWVcbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdjaXJjbGUnLCB7XG4gICAgcmFkaXVzOiAwLjE1LFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oIHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgcGFkZGluZyApe1xuICAgICAgdmFyIHQgPSB0cmFuc2xhdGlvbjtcbiAgICAgIHZhciBpbnNpZGUgPSAoIE1hdGgucG93KHQueCAtIHgsIDIpICsgTWF0aC5wb3codC55IC0geSwgMikgPD0gTWF0aC5wb3coKHNpemUgKyAyKnBhZGRpbmcpICogdGhpcy5yYWRpdXMsIDIpICk7XG5cbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKXtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCB0aGlzLm5hbWUgKSggY29udGV4dCwgdHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgdGhpcy5yYWRpdXMgKiBzaXplICk7XG4gICAgfSxcblxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aChlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnBmVmFsdWUpXG4gICAgICAgICogdGhpcy5yYWRpdXM7XG4gICAgfVxuICB9ICk7XG5cbiAgZGVmaW5lQXJyb3dTaGFwZSggJ2luaGliaXRvcicsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjI1LCAwLFxuICAgICAgLTAuMjUsIC0wLjEsXG4gICAgICAwLjI1LCAtMC4xLFxuICAgICAgMC4yNSwgMFxuICAgIF0sXG5cbiAgICBzcGFjaW5nOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIGdhcDogZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICd0ZWUnLCAnaW5oaWJpdG9yJyApO1xuXG4gIGRlZmluZUFycm93U2hhcGUoICdzcXVhcmUnLCB7XG4gICAgcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgMC4wMCxcbiAgICAgIDAuMTUsIDAuMDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdXG4gIH0gKTtcblxuICBkZWZpbmVBcnJvd1NoYXBlKCAnZGlhbW9uZCcsIHtcbiAgICBwb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4xNSxcbiAgICAgIDAsIC0wLjMsXG4gICAgICAwLjE1LCAtMC4xNSxcbiAgICAgIDAsIDBcbiAgICBdLFxuXG4gICAgZ2FwOiBmdW5jdGlvbiggZWRnZSApe1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZTtcbiAgICB9XG4gIH0gKTtcblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCUnAgPSB7fTtcblxudmFyIGRlbEVsZUNhY2hlID0gZnVuY3Rpb24oIHIgKXtcbiAgci5lbGVFYWNoZSA9IG51bGw7XG59O1xuXG52YXIgZ2V0RWxlQ2FjaGUgPSBmdW5jdGlvbiggciApe1xuICBpZiggIXIuZWxlRWFjaGUgKXtcbiAgICByLmVsZUVhY2hlID0ge1xuICAgICAgbm9kZXM6IHIuY3kubm9kZXMoKSxcbiAgICAgIGVkZ2VzOiByLmN5LmVkZ2VzKClcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHIuZWxlRWFjaGU7XG59O1xuXG5CUnAuZ2V0Q2FjaGVkRWxlbWVudHMgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gZ2V0RWxlQ2FjaGUoIHRoaXMgKTtcbn07XG5cbkJScC5nZXRDYWNoZWROb2RlcyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBnZXRFbGVDYWNoZSggdGhpcyApLm5vZGVzO1xufTtcblxuQlJwLmdldENhY2hlZEVkZ2VzID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIGdldEVsZUNhY2hlKCB0aGlzICkuZWRnZXM7XG59O1xuXG5CUnAudXBkYXRlRWxlbWVudHNDYWNoZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciByID0gdGhpcztcblxuICBkZWxFbGVDYWNoZSggciApO1xuXG4gIHJldHVybiBnZXRFbGVDYWNoZSggciApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYXRoID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vLi4vaXMnKTtcbnZhciB6SW5kZXhTb3J0ID0gcmVxdWlyZSgnLi4vLi4vLi4vY29sbGVjdGlvbi96c29ydCcpO1xuXG52YXIgQlJwID0ge307XG5cbi8vIFByb2plY3QgbW91c2VcbkJScC5wcm9qZWN0SW50b1ZpZXdwb3J0ID0gZnVuY3Rpb24oY2xpZW50WCwgY2xpZW50WSkge1xuICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gIHZhciBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuXG4gIHZhciB4ID0gY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gIHZhciB5ID0gY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICB4IC09IHRoaXMuY3kucGFuKCkueDsgeSAtPSB0aGlzLmN5LnBhbigpLnk7IHggLz0gdGhpcy5jeS56b29tKCk7IHkgLz0gdGhpcy5jeS56b29tKCk7XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG5CUnAuZmluZENvbnRhaW5lckNsaWVudENvb3JkcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG5cbiAgdmFyIGJiID0gdGhpcy5jb250YWluZXJCQiA9IHRoaXMuY29udGFpbmVyQkIgfHwgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIHJldHVybiBbYmIubGVmdCwgYmIudG9wLCBiYi5yaWdodCAtIGJiLmxlZnQsIGJiLmJvdHRvbSAtIGJiLnRvcF07XG59O1xuXG5CUnAuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG59O1xuXG4vLyBGaW5kIG5lYXJlc3QgZWxlbWVudFxuQlJwLmZpbmROZWFyZXN0RWxlbWVudCA9IGZ1bmN0aW9uKHgsIHksIHZpc2libGVFbGVtZW50c09ubHksIGlzVG91Y2gpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIHZhciBuZWFyID0gW107XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSByLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI0IDogOCkgLyB6b29tO1xuICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIGxhYmVsVGhyZXNob2xkID0gKGlzVG91Y2ggPyA4IDogMikgLyB6b29tO1xuXG4gIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlKXtcbiAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLnN0eWxlWydldmVudHMnXS5zdHJWYWx1ZSA9PT0gJ25vJyApeyByZXR1cm47IH1cblxuICAgIHZhciB3aWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpICsgMipub2RlVGhyZXNob2xkO1xuICAgIHZhciBoZWlnaHQgPSBub2RlLm91dGVySGVpZ2h0KCkgKyAyKm5vZGVUaHJlc2hvbGQ7XG4gICAgdmFyIGh3ID0gd2lkdGgvMjtcbiAgICB2YXIgaGggPSBoZWlnaHQvMjtcbiAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgICBpZihcbiAgICAgIHBvcy54IC0gaHcgPD0geCAmJiB4IDw9IHBvcy54ICsgaHcgLy8gYmIgY2hlY2sgeFxuICAgICAgICAmJlxuICAgICAgcG9zLnkgLSBoaCA8PSB5ICYmIHkgPD0gcG9zLnkgKyBoaCAvLyBiYiBjaGVjayB5XG4gICAgKXtcbiAgICAgIHZhciB2aXNpYmxlID0gIXZpc2libGVFbGVtZW50c09ubHkgfHwgKCBub2RlLnZpc2libGUoKSAmJiAhbm9kZS50cmFuc3BhcmVudCgpICk7XG5cbiAgICAgIC8vIGV4aXQgZWFybHkgaWYgaW52aXNpYmxlIGVkZ2UgYW5kIG11c3QgYmUgdmlzaWJsZVxuICAgICAgaWYoIHZpc2libGVFbGVtZW50c09ubHkgJiYgIXZpc2libGUgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2hhcGUgPSByLm5vZGVTaGFwZXNbIHNlbGYuZ2V0Tm9kZVNoYXBlKG5vZGUpIF07XG5cbiAgICAgIGlmKFxuICAgICAgICBzaGFwZS5jaGVja1BvaW50KHgsIHksIDAsIHdpZHRoLCBoZWlnaHQsIHBvcy54LCBwb3MueSlcbiAgICAgICl7XG4gICAgICAgIG5lYXIucHVzaCggbm9kZSApO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFZGdlKGVkZ2Upe1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG5cbiAgICBpZiggX3Auc3R5bGVbJ2V2ZW50cyddLnN0clZhbHVlID09PSAnbm8nICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgdmFyIHdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZS8yICsgZWRnZVRocmVzaG9sZDsgLy8gbW9yZSBsaWtlIGEgZGlzdGFuY2UgcmFkaXVzIGZyb20gY2VudHJlXG4gICAgdmFyIHdpZHRoU3EgPSB3aWR0aCAqIHdpZHRoO1xuICAgIHZhciB3aWR0aDIgPSB3aWR0aCAqIDI7XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBpbkVkZ2VCQiA9IGZhbHNlO1xuICAgIHZhciBzcURpc3Q7XG5cbiAgICAvLyBleGl0IGVhcmx5IGlmIGludmlzaWJsZSBlZGdlIGFuZCBtdXN0IGJlIHZpc2libGVcbiAgICB2YXIgcGFzc2VkVmlzaWJpbGl0eUNoZWNrO1xuICAgIHZhciBwYXNzZXNWaXNpYmlsaXR5Q2hlY2sgPSBmdW5jdGlvbigpe1xuICAgICAgaWYoIHBhc3NlZFZpc2liaWxpdHlDaGVjayAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiBwYXNzZWRWaXNpYmlsaXR5Q2hlY2s7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdmlzaWJsZUVsZW1lbnRzT25seSApe1xuICAgICAgICBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHZpc2libGUgPSBlZGdlLnZpc2libGUoKSAmJiAhZWRnZS50cmFuc3BhcmVudCgpO1xuICAgICAgaWYoIHZpc2libGUgKXtcbiAgICAgICAgcGFzc2VkVmlzaWJpbGl0eUNoZWNrID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHBhc3NlZFZpc2liaWxpdHlDaGVjayA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgfHwgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpICsgMyA8IHB0cy5sZW5ndGg7IGkgKz0gMiApe1xuICAgICAgICBpZihcbiAgICAgICAgICAoaW5FZGdlQkIgPSBtYXRoLmluTGluZVZpY2luaXR5KHgsIHksIHB0c1tpXSwgcHRzW2krMV0sIHB0c1tpKzJdLCBwdHNbaSszXSwgd2lkdGgyKSlcbiAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgd2lkdGhTcSA+ICggc3FEaXN0ID0gbWF0aC5zcURpc3RhbmNlVG9GaW5pdGVMaW5lKHgsIHksIHB0c1tpXSwgcHRzW2krMV0sIHB0c1tpKzJdLCBwdHNbaSszXSkgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnICl7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0ICl7XG4gICAgICAgIGlmKFxuICAgICAgICAgIChpbkVkZ2VCQiA9IG1hdGguaW5CZXppZXJWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpKzFdLCBwdHNbaSsyXSwgcHRzW2krM10sIHB0c1tpKzRdLCBwdHNbaSs1XSwgd2lkdGgyKSlcbiAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgKHdpZHRoU3EgPiAoc3FEaXN0ID0gbWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcHRzW2ldLCBwdHNbaSsxXSwgcHRzW2krMl0sIHB0c1tpKzNdLCBwdHNbaSs0XSwgcHRzW2krNV0pKSApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBjbG9zZSB0byB0aGUgZWRnZSBidXQgZGlkbid0IGhpdCBpdCwgbWF5YmUgd2UgaGl0IGl0cyBhcnJvd3NcbiAgICBpZiggaW5FZGdlQkIgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiYgbmVhci5sZW5ndGggPT09IDAgfHwgbmVhcltuZWFyLmxlbmd0aCAtIDFdICE9PSBlZGdlICl7XG4gICAgICB2YXIgc3JjID0gc3JjIHx8IF9wLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSB0Z3QgfHwgX3AudGFyZ2V0O1xuXG4gICAgICB2YXIgZVdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZTtcbiAgICAgIHZhciBhclNpemUgPSBzZWxmLmdldEFycm93V2lkdGgoIGVXaWR0aCApO1xuXG4gICAgICB2YXIgYXJyb3dzID0gW1xuICAgICAgICB7IG5hbWU6ICdzb3VyY2UnLCB4OiBycy5hcnJvd1N0YXJ0WCwgeTogcnMuYXJyb3dTdGFydFksIGFuZ2xlOiBycy5zcmNBcnJvd0FuZ2xlIH0sXG4gICAgICAgIHsgbmFtZTogJ3RhcmdldCcsIHg6IHJzLmFycm93RW5kWCwgeTogcnMuYXJyb3dFbmRZLCBhbmdsZTogcnMudGd0QXJyb3dBbmdsZSB9LFxuICAgICAgICB7IG5hbWU6ICdtaWQtc291cmNlJywgeDogcnMubWlkWCwgeTogcnMubWlkWSwgYW5nbGU6IHJzLm1pZHNyY0Fycm93QW5nbGUgfSxcbiAgICAgICAgeyBuYW1lOiAnbWlkLXRhcmdldCcsIHg6IHJzLm1pZFgsIHk6IHJzLm1pZFksIGFuZ2xlOiBycy5taWR0Z3RBcnJvd0FuZ2xlIH1cbiAgICAgIF07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYXJyb3dzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBhciA9IGFycm93c1tpXTtcbiAgICAgICAgdmFyIHNoYXBlID0gci5hcnJvd1NoYXBlc1sgc3R5bGVbYXIubmFtZSsnLWFycm93LXNoYXBlJ10udmFsdWUgXTtcblxuICAgICAgICBpZihcbiAgICAgICAgICBzaGFwZS5yb3VnaENvbGxpZGUoeCwgeSwgYXJTaXplLCBhci5hbmdsZSwgeyB4OiBhci54LCB5OiBhci55IH0sIGVkZ2VUaHJlc2hvbGQpXG4gICAgICAgICAgICYmXG4gICAgICAgICAgc2hhcGUuY29sbGlkZSh4LCB5LCBhclNpemUsIGFyLmFuZ2xlLCB7IHg6IGFyLngsIHk6IGFyLnkgfSwgZWRnZVRocmVzaG9sZClcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZvciBjb21wb3VuZCBncmFwaHMsIGhpdHRpbmcgZWRnZSBtYXkgYWN0dWFsbHkgd2FudCBhIGNvbm5lY3RlZCBub2RlIGluc3RlYWQgKGIvYyBlZGdlIG1heSBoYXZlIGdyZWF0ZXIgei1pbmRleCBwcmVjZWRlbmNlKVxuICAgIGlmKCBoYXNDb21wb3VuZHMgJiYgIG5lYXIubGVuZ3RoID4gMCAmJiBuZWFyWyBuZWFyLmxlbmd0aCAtIDEgXSA9PT0gZWRnZSApe1xuICAgICAgY2hlY2tOb2RlKCBzcmMgKTtcbiAgICAgIGNoZWNrTm9kZSggdGd0ICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tMYWJlbChlbGUpe1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcblxuICAgIGlmKCBfcC5zdHlsZVsndGV4dC1ldmVudHMnXS5zdHJWYWx1ZSA9PT0gJ25vJyApeyByZXR1cm47IH1cblxuICAgIC8vIGFkanVzdCBiYiB3LyBhbmdsZVxuICAgIGlmKCBfcC5ncm91cCA9PT0gJ2VkZ2VzJyAmJiBfcC5zdHlsZVsnZWRnZS10ZXh0LXJvdGF0aW9uJ10uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJyApe1xuXG4gICAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgICAgdmFyIGx3ID0gcnN0eWxlLmxhYmVsV2lkdGggKyAyKnRoO1xuICAgICAgdmFyIGxoID0gcnN0eWxlLmxhYmVsSGVpZ2h0ICsgMip0aDtcbiAgICAgIHZhciBseCA9IHJzdHlsZS5sYWJlbFg7XG4gICAgICB2YXIgbHkgPSByc3R5bGUubGFiZWxZO1xuXG4gICAgICB2YXIgdGhldGEgPSBfcC5yc2NyYXRjaC5sYWJlbEFuZ2xlO1xuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKCB0aGV0YSApO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgICB2YXIgcm90YXRlID0gZnVuY3Rpb24oIHgsIHkgKXtcbiAgICAgICAgeCA9IHggLSBseDtcbiAgICAgICAgeSA9IHkgLSBseTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHgqY29zIC0geSpzaW4gKyBseCxcbiAgICAgICAgICB5OiB4KnNpbiArIHkqY29zICsgbHlcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBseDEgPSBseCAtIGx3LzI7XG4gICAgICB2YXIgbHgyID0gbHggKyBsdy8yO1xuICAgICAgdmFyIGx5MSA9IGx5IC0gbGgvMjtcbiAgICAgIHZhciBseTIgPSBseSArIGxoLzI7XG5cbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZSggbHgxLCBseTEgKTtcbiAgICAgIHZhciBweDF5MiA9IHJvdGF0ZSggbHgxLCBseTIgKTtcbiAgICAgIHZhciBweDJ5MSA9IHJvdGF0ZSggbHgyLCBseTEgKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZSggbHgyLCBseTIgKTtcblxuICAgICAgdmFyIHBvaW50cyA9IFtcbiAgICAgICAgcHgxeTEueCwgcHgxeTEueSxcbiAgICAgICAgcHgyeTEueCwgcHgyeTEueSxcbiAgICAgICAgcHgyeTIueCwgcHgyeTIueSxcbiAgICAgICAgcHgxeTIueCwgcHgxeTIueVxuICAgICAgXTtcblxuICAgICAgaWYoIG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKCB4LCB5LCBwb2ludHMgKSApe1xuICAgICAgICBuZWFyLnB1c2goIGVsZSApO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBiYiA9IGVsZS5ib3VuZGluZ0JveCh7XG4gICAgICAgIGluY2x1ZGVMYWJlbHM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVOb2RlczogZmFsc2UsXG4gICAgICAgIGluY2x1ZGVFZGdlczogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhZGp1c3QgYmIgdy8gdGhyZXNob2xkXG4gICAgICBiYi54MSAtPSB0aDtcbiAgICAgIGJiLnkxIC09IHRoO1xuICAgICAgYmIueDIgKz0gdGg7XG4gICAgICBiYi55MiArPSB0aDtcbiAgICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG5cbiAgICAgIGlmKCBtYXRoLmluQm91bmRpbmdCb3goIGJiLCB4LCB5ICkgKXtcbiAgICAgICAgbmVhci5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGZvciggdmFyIGkgPSBlbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICl7IC8vIHJldmVyc2Ugb3JkZXIgZm9yIHByZWNlZGVuY2VcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICBpZiggbmVhci5sZW5ndGggPiAwICl7IGJyZWFrOyB9IC8vIHNpbmNlIHdlIGNoZWNrIGluIHotb3JkZXIsIGZpcnN0IGZvdW5kIGlzIHRvcCBhbmQgYmVzdCByZXN1bHQgPT4gZXhpdCBlYXJseVxuXG4gICAgaWYoIF9wLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICBjaGVja05vZGUoIGVsZSApO1xuXG4gICAgfSBlbHNlICB7IC8vIHRoZW4gZWRnZVxuICAgICAgY2hlY2tFZGdlKCBlbGUgKTtcbiAgICB9XG5cbiAgICBjaGVja0xhYmVsKCBlbGUgKTtcblxuICB9XG5cblxuICBpZiggbmVhci5sZW5ndGggPiAwICl7XG4gICAgcmV0dXJuIG5lYXJbIG5lYXIubGVuZ3RoIC0gMSBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyAnR2l2ZSBtZSBldmVyeXRoaW5nIGZyb20gdGhpcyBib3gnXG5CUnAuZ2V0QWxsSW5Cb3ggPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgbm9kZXMgPSB0aGlzLmdldENhY2hlZE5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgdmFyIGJveCA9IFtdO1xuXG4gIHZhciB4MWMgPSBNYXRoLm1pbih4MSwgeDIpO1xuICB2YXIgeDJjID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgdmFyIHkxYyA9IE1hdGgubWluKHkxLCB5Mik7XG4gIHZhciB5MmMgPSBNYXRoLm1heCh5MSwgeTIpO1xuXG4gIHgxID0geDFjO1xuICB4MiA9IHgyYztcbiAgeTEgPSB5MWM7XG4gIHkyID0geTJjO1xuXG4gIHZhciBib3hCYiA9IG1hdGgubWFrZUJvdW5kaW5nQm94KHtcbiAgICB4MTogeDEsIHkxOiB5MSxcbiAgICB4MjogeDIsIHkyOiB5MlxuICB9KTtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIG5vZGVCYiA9IG5vZGUuYm91bmRpbmdCb3goe1xuICAgICAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICAgICAgaW5jbHVkZUVkZ2VzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVMYWJlbHM6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBpZiggbWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJveEJiLCBub2RlQmIpICl7XG4gICAgICBib3gucHVzaChub2Rlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKyApe1xuICAgIHZhciBlZGdlID0gZWRnZXNbZV07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcblxuICAgIGlmKCBycy5zdGFydFggIT0gbnVsbCAmJiBycy5zdGFydFkgIT0gbnVsbCAmJiAhbWF0aC5pbkJvdW5kaW5nQm94KCBib3hCYiwgcnMuc3RhcnRYLCBycy5zdGFydFkgKSApeyBjb250aW51ZTsgfVxuICAgIGlmKCBycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsICYmICFtYXRoLmluQm91bmRpbmdCb3goIGJveEJiLCBycy5lbmRYLCBycy5lbmRZICkgKXsgY29udGludWU7IH1cblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyApe1xuXG4gICAgICB2YXIgcHRzID0gX3AucnN0eWxlLmJlemllclB0cyB8fCBfcC5yc3R5bGUubGluZVB0cyB8fCBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICB2YXIgYWxsSW5zaWRlID0gdHJ1ZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoICFtYXRoLnBvaW50SW5Cb3VuZGluZ0JveCggYm94QmIsIHB0c1tpXSApICl7XG4gICAgICAgICAgYWxsSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGFsbEluc2lkZSApe1xuICAgICAgICBib3gucHVzaCggZWRnZSApO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyApe1xuICAgICAgYm94LnB1c2goIGVkZ2UgKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBib3g7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2hhcGUgb2YgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIGdpdmVuIG5vZGVcbiAqIGlzIHNldCB0byBhdXRvLCB0aGUgbm9kZSBpcyBjb25zaWRlcmVkIHRvIGJlIGEgY29tcG91bmQuXG4gKlxuICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBzaGFwZSBvZiB0aGUgbm9kZVxuICovXG5CUnAuZ2V0Tm9kZVNoYXBlID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgc3R5bGUgPSBub2RlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgc2hhcGUgPSBzdHlsZVsnc2hhcGUnXS52YWx1ZTtcblxuICBpZiggbm9kZS5pc1BhcmVudCgpICl7XG4gICAgaWYoIHNoYXBlID09PSAncmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kcmVjdGFuZ2xlJyApe1xuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICB9XG5cbiAgaWYoIHNoYXBlID09PSAncG9seWdvbicgKXtcbiAgICB2YXIgcG9pbnRzID0gc3R5bGVbJ3NoYXBlLXBvbHlnb24tcG9pbnRzJ10udmFsdWU7XG5cbiAgICByZXR1cm4gci5ub2RlU2hhcGVzLm1ha2VQb2x5Z29uKCBwb2ludHMgKS5uYW1lO1xuICB9XG5cbiAgcmV0dXJuIHNoYXBlO1xufTtcblxuQlJwLnVwZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcyggdHJ1ZSApO1xufTtcblxuQlJwLmdldENhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24oIGZvcmNlUmVjYWxjICl7XG4gIHZhciBsYXN0Tm9kZXMgPSB0aGlzLmxhc3RaT3JkZXJDYWNoZWROb2RlcztcbiAgdmFyIGxhc3RFZGdlcyA9IHRoaXMubGFzdFpPcmRlckNhY2hlZEVkZ2VzO1xuICB2YXIgbm9kZXMgPSB0aGlzLmdldENhY2hlZE5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgdmFyIGVsZXMgPSBbXTtcblxuICBpZiggZm9yY2VSZWNhbGMgfHwgIWxhc3ROb2RlcyB8fCAhbGFzdEVkZ2VzIHx8IGxhc3ROb2RlcyAhPT0gbm9kZXMgfHwgbGFzdEVkZ2VzICE9PSBlZGdlcyApe1xuICAgIC8vY29uc29sZS50aW1lKCdjYWNoZXpvcmRlcicpXG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbiA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiggbi5hbmltYXRlZCgpIHx8IChuLnZpc2libGUoKSAmJiAhbi50cmFuc3BhcmVudCgpKSApe1xuICAgICAgICBlbGVzLnB1c2goIG4gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuXG4gICAgICBpZiggZS5hbmltYXRlZCgpIHx8IChlLnZpc2libGUoKSAmJiAhZS50cmFuc3BhcmVudCgpKSApe1xuICAgICAgICBlbGVzLnB1c2goIGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVzLnNvcnQoIHpJbmRleFNvcnQgKTtcbiAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcbiAgICAvL2NvbnNvbGUubG9nKCdtYWtlIGNhY2hlJylcblxuICAgIC8vY29uc29sZS50aW1lRW5kKCdjYWNoZXpvcmRlcicpXG4gIH0gZWxzZSB7XG4gICAgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG4gICAgLy9jb25zb2xlLmxvZygncmVhZCBjYWNoZScpXG4gIH1cblxuICB0aGlzLmxhc3RaT3JkZXJDYWNoZWROb2RlcyA9IG5vZGVzO1xuICB0aGlzLmxhc3RaT3JkZXJDYWNoZWRFZGdlcyA9IGVkZ2VzO1xuXG4gIHJldHVybiBlbGVzO1xufTtcblxuZnVuY3Rpb24gcHVzaEJlemllclB0cyhlZGdlLCBwdHMpe1xuICB2YXIgcWJlemllckF0ID0gZnVuY3Rpb24oIHAxLCBwMiwgcDMsIHQgKXsgcmV0dXJuIG1hdGgucWJlemllckF0KHAxLCBwMiwgcDMsIHQpOyB9O1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG5cbiAgYnB0cy5wdXNoKHtcbiAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuMDUgKSxcbiAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuMDUgKVxuICB9KTtcblxuICBicHRzLnB1c2goe1xuICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4yNSApLFxuICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4yNSApXG4gIH0pO1xuXG4gIGJwdHMucHVzaCh7XG4gICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjQgKSxcbiAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNCApXG4gIH0pO1xuXG4gIGJwdHMucHVzaCh7XG4gICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjUgKSxcbiAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNSApXG4gIH0pO1xuXG4gIGJwdHMucHVzaCh7XG4gICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjYgKSxcbiAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNiApXG4gIH0pO1xuXG4gIGJwdHMucHVzaCh7XG4gICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjc1ICksXG4gICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjc1IClcbiAgfSk7XG5cbiAgYnB0cy5wdXNoKHtcbiAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuOTUgKSxcbiAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuOTUgKVxuICB9KTtcbn1cblxuQlJwLnByb2plY3RMaW5lcyA9IGZ1bmN0aW9uKCBlZGdlICl7XG4gIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgZXQgPSBycy5lZGdlVHlwZTtcblxuICBpZiggZXQgPT09ICdtdWx0aWJlemllcicgfHwgIGV0ID09PSAnYmV6aWVyJyB8fCAgZXQgPT09ICdzZWxmJyB8fCAgZXQgPT09ICdjb21wb3VuZCcgKXtcbiAgICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHMgPSBbXTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQgKXtcbiAgICAgIHB1c2hCZXppZXJQdHMoIGVkZ2UsIHJzLmFsbHB0cy5zbGljZShpLCBpKzYpICk7XG4gICAgfVxuICB9IGVsc2UgaWYoICBldCA9PT0gJ3NlZ21lbnRzJyApe1xuICAgIHZhciBscHRzID0gX3AucnN0eWxlLmxpbmVQdHMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpICsgMSA8IHJzLmFsbHB0cy5sZW5ndGg7IGkgKz0gMiApe1xuICAgICAgbHB0cy5wdXNoKHtcbiAgICAgICAgeDogcnMuYWxscHRzW2ldLFxuICAgICAgICB5OiBycy5hbGxwdHNbaSsxXVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYoIGV0ID09PSAnaGF5c3RhY2snICl7XG4gICAgdmFyIGhwdHMgPSBycy5oYXlzdGFja1B0cztcblxuICAgIF9wLnJzdHlsZS5oYXlzdGFja1B0cyA9IFtcbiAgICAgIHsgeDogaHB0c1swXSwgeTogaHB0c1sxXSB9LFxuICAgICAgeyB4OiBocHRzWzJdLCB5OiBocHRzWzNdIH1cbiAgICBdO1xuICB9XG59O1xuXG5CUnAucHJvamVjdEJlemllciA9IEJScC5wcm9qZWN0TGluZXM7XG5cbkJScC5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiggbm9kZSApe1xuICB2YXIgY29udGVudCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2xhYmVsJ10uc3RyVmFsdWU7XG4gIGlmKCAhY29udGVudCB8fCBjb250ZW50Lm1hdGNoKC9eXFxzKyQvKSApeyByZXR1cm47IH1cblxuICB2YXIgdGV4dFgsIHRleHRZO1xuICB2YXIgbm9kZVdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpO1xuICB2YXIgbm9kZVBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG4gIHZhciB0ZXh0SGFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC1oYWxpZ24nXS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRWYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LXZhbGlnbiddLnN0clZhbHVlO1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgcnN0eWxlID0gbm9kZS5fcHJpdmF0ZS5yc3R5bGU7XG5cbiAgc3dpdGNoKCB0ZXh0SGFsaWduICl7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCAtIG5vZGVXaWR0aCAvIDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHRleHRYID0gbm9kZVBvcy54ICsgbm9kZVdpZHRoIC8gMjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgIHRleHRYID0gbm9kZVBvcy54O1xuICB9XG5cbiAgc3dpdGNoKCB0ZXh0VmFsaWduICl7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHRleHRZID0gbm9kZVBvcy55IC0gbm9kZUhlaWdodCAvIDI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICB0ZXh0WSA9IG5vZGVQb3MueSArIG5vZGVIZWlnaHQgLyAyO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OiAvLyBlLmcuIG1pZGRsZVxuICAgICAgdGV4dFkgPSBub2RlUG9zLnk7XG4gIH1cblxuICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgcnMubGFiZWxZID0gdGV4dFk7XG4gIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuXG4gIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoIG5vZGUgKTtcbn07XG5cbkJScC5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiggZWRnZSApe1xuICB2YXIgY29udGVudCA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ2xhYmVsJ10uc3RyVmFsdWU7XG4gIGlmKCAhY29udGVudCB8fCBjb250ZW50Lm1hdGNoKC9eXFxzKyQvKSApeyByZXR1cm47IH1cblxuICB2YXIgdGV4dFgsIHRleHRZO1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgLy92YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcblxuICB0ZXh0WCA9IHJzLm1pZFg7XG4gIHRleHRZID0gcnMubWlkWTtcblxuICAvLyBhZGQgY2VudGVyIHBvaW50IHRvIHN0eWxlIHNvIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMgY2FuIHVzZSBpdFxuICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgcnMubGFiZWxZID0gdGV4dFk7XG4gIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuXG4gIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoIGVkZ2UgKTtcbn07XG5cbkJScC5hcHBseUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcblxuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KCBlbGUgKTtcbiAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIHRleHQgKTtcblxuICByc3R5bGUubGFiZWxXaWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiAgcnMubGFiZWxXaWR0aCA9IGxhYmVsRGltcy53aWR0aDtcblxuICByc3R5bGUubGFiZWxIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0O1xuICBycy5sYWJlbEhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQ7XG59O1xuXG5CUnAuZ2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24oIGVsZSApe1xuICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciB0ZXh0ID0gZWxlLl9wcml2YXRlLnN0eWxlWydsYWJlbCddLnN0clZhbHVlO1xuICB2YXIgdGV4dFRyYW5zZm9ybSA9IHN0eWxlWyd0ZXh0LXRyYW5zZm9ybSddLnZhbHVlO1xuICB2YXIgcnNjcmF0Y2ggPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnKSB7XG4gIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAndXBwZXJjYXNlJykge1xuICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xuICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBpZiggc3R5bGVbJ3RleHQtd3JhcCddLnZhbHVlID09PSAnd3JhcCcgKXtcbiAgICAvL2NvbnNvbGUubG9nKCd3cmFwJyk7XG5cbiAgICAvLyBzYXZlIHJlY2FsYyBpZiB0aGUgbGFiZWwgaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG4gICAgaWYoIHJzY3JhdGNoLmxhYmVsV3JhcEtleSA9PT0gcnNjcmF0Y2gubGFiZWxLZXkgKXtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd3cmFwIGNhY2hlIGhpdCcpO1xuICAgICAgcmV0dXJuIHJzY3JhdGNoLmxhYmVsV3JhcENhY2hlZFRleHQ7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd3cmFwIGNhY2hlIG1pc3MnKTtcblxuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBtYXhXID0gc3R5bGVbJ3RleHQtbWF4LXdpZHRoJ10ucGZWYWx1ZTtcbiAgICB2YXIgd3JhcHBlZExpbmVzID0gW107XG5cbiAgICBmb3IoIHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrICl7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgbGluZSwgJ2xpbmU9JyArIGxpbmUgKTtcbiAgICAgIHZhciBsaW5lVyA9IGxpbmVEaW1zLndpZHRoO1xuXG4gICAgICBpZiggbGluZVcgPiBtYXhXICl7IC8vIGxpbmUgaXMgdG9vIGxvbmdcbiAgICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCgvXFxzKy8pOyAvLyBOQjogYXNzdW1lIGNvbGxhcHNlZCB3aGl0ZXNwYWNlIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgIHZhciBzdWJsaW5lID0gJyc7XG5cbiAgICAgICAgZm9yKCB2YXIgdyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKyApe1xuICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbd107XG4gICAgICAgICAgdmFyIHRlc3RMaW5lID0gc3VibGluZS5sZW5ndGggPT09IDAgPyB3b3JkIDogc3VibGluZSArICcgJyArIHdvcmQ7XG4gICAgICAgICAgdmFyIHRlc3REaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgdGVzdExpbmUsICd0ZXN0TGluZT0nICsgdGVzdExpbmUgKTtcbiAgICAgICAgICB2YXIgdGVzdFcgPSB0ZXN0RGltcy53aWR0aDtcblxuICAgICAgICAgIGlmKCB0ZXN0VyA8PSBtYXhXICl7IC8vIHdvcmQgZml0cyBvbiBjdXJyZW50IGxpbmVcbiAgICAgICAgICAgIHN1YmxpbmUgKz0gd29yZCArICcgJztcbiAgICAgICAgICB9IGVsc2UgeyAvLyB3b3JkIHN0YXJ0cyBuZXcgbGluZVxuICAgICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIHN1YmxpbmUgKTtcbiAgICAgICAgICAgIHN1YmxpbmUgPSB3b3JkICsgJyAnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHRleHQsIHB1dCBpdCBpbiBhIHdyYXBwZWQgbGluZVxuICAgICAgICBpZiggIXN1YmxpbmUubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goIHN1YmxpbmUgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gbGluZSBpcyBhbHJlYWR5IHNob3J0IGVub3VnaFxuICAgICAgICB3cmFwcGVkTGluZXMucHVzaCggbGluZSApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG5cbiAgICByc2NyYXRjaC5sYWJlbFdyYXBDYWNoZWRMaW5lcyA9IHdyYXBwZWRMaW5lcztcbiAgICByc2NyYXRjaC5sYWJlbFdyYXBDYWNoZWRUZXh0ID0gdGV4dCA9IHdyYXBwZWRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICByc2NyYXRjaC5sYWJlbFdyYXBLZXkgPSByc2NyYXRjaC5sYWJlbEtleTtcblxuICAgIC8vIGNvbnNvbGUubG9nKHRleHQpXG4gIH0gLy8gaWYgd3JhcFxuXG4gIHJldHVybiB0ZXh0O1xufTtcblxuQlJwLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyA9IGZ1bmN0aW9uKCBlbGUsIHRleHQsIGV4dHJhS2V5ICl7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgZlN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgdmFyIHNpemUgPSBzdHlsZVsnZm9udC1zaXplJ10ucGZWYWx1ZSArICdweCc7XG4gIHZhciBmYW1pbHkgPSBzdHlsZVsnZm9udC1mYW1pbHknXS5zdHJWYWx1ZTtcbiAgLy8gdmFyIHZhcmlhbnQgPSBzdHlsZVsnZm9udC12YXJpYW50J10uc3RyVmFsdWU7XG4gIHZhciB3ZWlnaHQgPSBzdHlsZVsnZm9udC13ZWlnaHQnXS5zdHJWYWx1ZTtcblxuICB2YXIgY2FjaGVLZXkgPSBlbGUuX3ByaXZhdGUubGFiZWxLZXk7XG5cbiAgaWYoIGV4dHJhS2V5ICl7XG4gICAgY2FjaGVLZXkgKz0gJyRAJCcgKyBleHRyYUtleTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IHIubGFiZWxEaW1DYWNoZSB8fCAoci5sYWJlbERpbUNhY2hlID0ge30pO1xuXG4gIGlmKCBjYWNoZVtjYWNoZUtleV0gKXtcbiAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xuICB9XG5cbiAgdmFyIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2O1xuXG4gIGlmKCAhZGl2ICl7XG4gICAgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBkaXYgKTtcbiAgfVxuXG4gIHZhciBkcyA9IGRpdi5zdHlsZTtcblxuICAvLyBmcm9tIGVsZSBzdHlsZVxuICBkcy5mb250RmFtaWx5ID0gZmFtaWx5O1xuICBkcy5mb250U3R5bGUgPSBmU3R5bGU7XG4gIGRzLmZvbnRTaXplID0gc2l6ZTtcbiAgLy8gZHMuZm9udFZhcmlhbnQgPSB2YXJpYW50O1xuICBkcy5mb250V2VpZ2h0ID0gd2VpZ2h0O1xuXG4gIC8vIGZvcmNlZCBzdHlsZVxuICBkcy5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGRzLmxlZnQgPSAnLTk5OTlweCc7XG4gIGRzLnRvcCA9ICctOTk5OXB4JztcbiAgZHMuekluZGV4ID0gJy0xJztcbiAgZHMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICBkcy5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICBkcy5wYWRkaW5nID0gJzAnO1xuICBkcy5saW5lSGVpZ2h0ID0gJzEnO1xuXG4gIGlmKCBzdHlsZVsndGV4dC13cmFwJ10udmFsdWUgPT09ICd3cmFwJyApe1xuICAgIGRzLndoaXRlU3BhY2UgPSAncHJlJzsgLy8gc28gbmV3bGluZXMgYXJlIHRha2VuIGludG8gYWNjb3VudFxuICB9IGVsc2Uge1xuICAgIGRzLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcbiAgfVxuXG4gIC8vIHB1dCBsYWJlbCBjb250ZW50IGluIGRpdlxuICBkaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuXG4gIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICB3aWR0aDogZGl2LmNsaWVudFdpZHRoLFxuICAgIGhlaWdodDogZGl2LmNsaWVudEhlaWdodFxuICB9O1xuXG4gIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG59O1xuXG5CUnAucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgdmFyIGVkZ2VzID0gW107XG4gIHZhciBub2RlcyA9IFtdO1xuICB2YXIgaGFuZGxlZEVkZ2UgPSB7fTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgaWQgPSBfcC5kYXRhLmlkO1xuICAgIHZhciBiYlN0eWxlU2FtZSA9IHJzLmJvdW5kaW5nQm94S2V5ICE9IG51bGwgJiYgX3AuYm91bmRpbmdCb3hLZXkgPT09IHJzLmJvdW5kaW5nQm94S2V5O1xuICAgIHZhciBsYWJlbFN0eWxlU2FtZSA9IHJzLmxhYmVsS2V5ICE9IG51bGwgJiYgX3AubGFiZWxLZXkgPT09IHJzLmxhYmVsS2V5O1xuICAgIHZhciBzdHlsZVNhbWUgPSBiYlN0eWxlU2FtZSAmJiBsYWJlbFN0eWxlU2FtZTtcblxuICAgIGlmKCBfcC5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuICAgICAgdmFyIHBvc1NhbWUgPSByc3R5bGUubm9kZVggIT0gbnVsbCAmJiByc3R5bGUubm9kZVkgIT0gbnVsbCAmJiBwb3MueCA9PT0gcnN0eWxlLm5vZGVYICYmIHBvcy55ID09PSByc3R5bGUubm9kZVk7XG4gICAgICB2YXIgd1NhbWUgPSByc3R5bGUubm9kZVcgIT0gbnVsbCAmJiByc3R5bGUubm9kZVcgPT09IHN0eWxlWyd3aWR0aCddLnBmVmFsdWU7XG4gICAgICB2YXIgaFNhbWUgPSByc3R5bGUubm9kZUggIT0gbnVsbCAmJiByc3R5bGUubm9kZUggPT09IHN0eWxlWydoZWlnaHQnXS5wZlZhbHVlO1xuXG4gICAgICBpZiggIXBvc1NhbWUgfHwgIXN0eWxlU2FtZSB8fCAhd1NhbWUgfHwgIWhTYW1lICl7XG4gICAgICAgIG5vZGVzLnB1c2goIGVsZSApO1xuICAgICAgfVxuXG4gICAgICByc3R5bGUubm9kZVggPSBwb3MueDtcbiAgICAgIHJzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgICAgcnN0eWxlLm5vZGVXID0gc3R5bGVbJ3dpZHRoJ10ucGZWYWx1ZTtcbiAgICAgIHJzdHlsZS5ub2RlSCA9IHN0eWxlWydoZWlnaHQnXS5wZlZhbHVlO1xuICAgIH0gZWxzZSB7IC8vIGVkZ2VzXG5cbiAgICAgIHZhciBzcmNQb3MgPSBfcC5zb3VyY2UuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgdGd0UG9zID0gX3AudGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIHNyY1NhbWUgPSByc3R5bGUuc3JjWCAhPSBudWxsICYmIHJzdHlsZS5zcmNZICE9IG51bGwgJiYgc3JjUG9zLnggPT09IHJzdHlsZS5zcmNYICYmIHNyY1Bvcy55ID09PSByc3R5bGUuc3JjWTtcbiAgICAgIHZhciB0Z3RTYW1lID0gcnN0eWxlLnRndFggIT0gbnVsbCAmJiByc3R5bGUudGd0WSAhPSBudWxsICYmIHRndFBvcy54ID09PSByc3R5bGUudGd0WCAmJiB0Z3RQb3MueSA9PT0gcnN0eWxlLnRndFk7XG4gICAgICB2YXIgcG9zaXRpb25zU2FtZSA9IHNyY1NhbWUgJiYgdGd0U2FtZTtcblxuICAgICAgaWYoICFwb3NpdGlvbnNTYW1lIHx8ICFzdHlsZVNhbWUgKXtcbiAgICAgICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnICl7XG4gICAgICAgICAgaWYoICFoYW5kbGVkRWRnZVsgaWQgXSApe1xuICAgICAgICAgICAgZWRnZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgICBoYW5kbGVkRWRnZVsgaWQgXSA9IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBwYXJhbGxlbEVkZ2VzID0gZWxlLnBhcmFsbGVsRWRnZXMoKTtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFyYWxsZWxFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICB2YXIgcEVkZ2UgPSBwYXJhbGxlbEVkZ2VzW2ldO1xuICAgICAgICAgICAgICB2YXIgcElkID0gcEVkZ2UuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgICAgICAgICAgICBpZiggIWhhbmRsZWRFZGdlWyBwSWQgXSApe1xuICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goIHBFZGdlICk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZEVkZ2VbIHBJZCBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9IC8vIGlmIHBvc2l0aW9ucyBkaWZmXG5cbiAgICAgIC8vIHVwZGF0ZSByc3R5bGUgcG9zaXRpb25zXG4gICAgICByc3R5bGUuc3JjWCA9IHNyY1Bvcy54O1xuICAgICAgcnN0eWxlLnNyY1kgPSBzcmNQb3MueTtcbiAgICAgIHJzdHlsZS50Z3RYID0gdGd0UG9zLng7XG4gICAgICByc3R5bGUudGd0WSA9IHRndFBvcy55O1xuXG4gICAgfSAvLyBpZiBlZGdlc1xuXG4gICAgcnMuYm91bmRpbmdCb3hLZXkgPSBfcC5ib3VuZGluZ0JveEtleTtcbiAgICBycy5sYWJlbEtleSA9IF9wLmxhYmVsS2V5O1xuICB9XG5cbiAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyggZWRnZXMgKTtcbiAgdGhpcy5yZWNhbGN1bGF0ZUxhYmVsUHJvamVjdGlvbnMoIG5vZGVzLCBlZGdlcyApO1xufTtcblxuQlJwLnJlY2FsY3VsYXRlTGFiZWxQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uKCBub2RlcywgZWRnZXMgKXtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKCBub2Rlc1tpXSApO1xuICB9XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uKCBlZGdlc1tpXSApO1xuICB9XG59O1xuXG5CUnAucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiggZWRnZXMgKXtcbiAgdGhpcy5maW5kRWRnZUNvbnRyb2xQb2ludHMoIGVkZ2VzICk7XG59O1xuXG5cbi8vIEZpbmQgZWRnZSBjb250cm9sIHBvaW50c1xuQlJwLmZpbmRFZGdlQ29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKGVkZ2VzKSB7XG4gIGlmKCAhZWRnZXMgfHwgZWRnZXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGhhc2hUYWJsZSA9IHt9O1xuICB2YXIgcGFpcklkcyA9IFtdO1xuICB2YXIgaGF5c3RhY2tFZGdlcyA9IFtdO1xuICB2YXIgYXV0b3JvdGF0ZUVkZ2VzID0gW107XG5cbiAgLy8gY3JlYXRlIGEgdGFibGUgb2YgZWRnZSAoc3JjLCB0Z3QpID0+IGxpc3Qgb2YgZWRnZXMgYmV0d2VlbiB0aGVtXG4gIHZhciBwYWlySWQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspe1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgZGF0YSA9IF9wLmRhdGE7XG4gICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgdmFyIGN1cnZlU3R5bGUgPSBzdHlsZVsnY3VydmUtc3R5bGUnXS52YWx1ZTtcbiAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cyc7XG5cbiAgICAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuICAgIGlmKCBzdHlsZS5kaXNwbGF5LnZhbHVlID09PSAnbm9uZScgKXtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmKCBzdHlsZVsnZWRnZS10ZXh0LXJvdGF0aW9uJ10uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJyApe1xuICAgICAgYXV0b3JvdGF0ZUVkZ2VzLnB1c2goIGVkZ2UgKTtcbiAgICB9XG5cbiAgICBpZiggY3VydmVTdHlsZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgaGF5c3RhY2tFZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgc3JjSWQgPSBkYXRhLnNvdXJjZTtcbiAgICB2YXIgdGd0SWQgPSBkYXRhLnRhcmdldDtcblxuICAgIHBhaXJJZCA9IHNyY0lkID4gdGd0SWQgP1xuICAgICAgdGd0SWQgKyAnJC0kJyArIHNyY0lkIDpcbiAgICAgIHNyY0lkICsgJyQtJCcgKyB0Z3RJZCA7XG5cbiAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICBwYWlySWQgPSAndW5idW5kbGVkJyArICckLSQnICsgZGF0YS5pZDtcbiAgICB9XG5cbiAgICBpZiggaGFzaFRhYmxlW3BhaXJJZF0gPT0gbnVsbCApe1xuICAgICAgaGFzaFRhYmxlW3BhaXJJZF0gPSBbXTtcbiAgICAgIHBhaXJJZHMucHVzaCggcGFpcklkICk7XG4gICAgfVxuXG4gICAgaGFzaFRhYmxlW3BhaXJJZF0ucHVzaCggZWRnZSApO1xuXG4gICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgaGFzaFRhYmxlW3BhaXJJZF0uaGFzVW5idW5kbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3JjLCB0Z3QsIHNyY19wLCB0Z3RfcCwgc3JjUG9zLCB0Z3RQb3MsIHNyY1csIHNyY0gsIHRndFcsIHRndEgsIHNyY1NoYXBlLCB0Z3RTaGFwZTtcbiAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlO1xuICB2YXIgYmFkQmV6aWVyO1xuXG4gIC8vIGZvciBlYWNoIHBhaXIgKHNyYywgdGd0KSwgY3JlYXRlIHRoZSBjdHJsIHB0c1xuICAvLyBOZXN0ZWQgZm9yIGxvb3AgaXMgT0s7IHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciBib3RoIGxvb3BzID0gZWRnZUNvdW50XG4gIGZvciAodmFyIHAgPSAwOyBwIDwgcGFpcklkcy5sZW5ndGg7IHArKykge1xuICAgIHBhaXJJZCA9IHBhaXJJZHNbcF07XG4gICAgdmFyIHBhaXJFZGdlcyA9IGhhc2hUYWJsZVtwYWlySWRdO1xuXG4gICAgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcbiAgICBwYWlyRWRnZXMuc29ydChmdW5jdGlvbihlZGdlMSwgZWRnZTIpe1xuICAgICAgcmV0dXJuIGVkZ2UxLl9wcml2YXRlLmluZGV4IC0gZWRnZTIuX3ByaXZhdGUuaW5kZXg7XG4gICAgfSk7XG5cbiAgICBzcmMgPSBwYWlyRWRnZXNbMF0uX3ByaXZhdGUuc291cmNlO1xuICAgIHRndCA9IHBhaXJFZGdlc1swXS5fcHJpdmF0ZS50YXJnZXQ7XG5cbiAgICBzcmNfcCA9IHNyYy5fcHJpdmF0ZTtcbiAgICB0Z3RfcCA9IHRndC5fcHJpdmF0ZTtcblxuICAgIC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnRcbiAgICAvLyAoc3JjL3RndCBpbiB0aGlzIGNhc2UgYXJlIGp1c3QgZm9yIGN0cmxwdHMgYW5kIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gYmUgdHJ1ZSBzcmMvdGd0KVxuICAgIGlmKCBzcmNfcC5kYXRhLmlkID4gdGd0X3AuZGF0YS5pZCApe1xuICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICBzcmMgPSB0Z3Q7XG4gICAgICB0Z3QgPSB0ZW1wO1xuICAgIH1cblxuICAgIHNyY1BvcyA9IHNyY19wLnBvc2l0aW9uO1xuICAgIHRndFBvcyA9IHRndF9wLnBvc2l0aW9uO1xuXG4gICAgc3JjVyA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgc3JjSCA9IHNyYy5vdXRlckhlaWdodCgpO1xuXG4gICAgdGd0VyA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgdGd0SCA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgc3JjU2hhcGUgPSByLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKHNyYykgXTtcbiAgICB0Z3RTaGFwZSA9IHIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUodGd0KSBdO1xuXG4gICAgYmFkQmV6aWVyID0gZmFsc2U7XG5cblxuICAgIGlmKCAocGFpckVkZ2VzLmxlbmd0aCA+IDEgJiYgc3JjICE9PSB0Z3QpIHx8IHBhaXJFZGdlcy5oYXNVbmJ1bmRsZWQgKXtcblxuICAgICAgLy8gcHQgb3V0c2lkZSBzcmMgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgIHNyY1Bvcy54LFxuICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgc3JjVyxcbiAgICAgICAgc3JjSCxcbiAgICAgICAgdGd0UG9zLngsXG4gICAgICAgIHRndFBvcy55LFxuICAgICAgICAwXG4gICAgICApO1xuXG4gICAgICAvLyBwdCBvdXRzaWRlIHRndCBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgIHZhciB0Z3RPdXRzaWRlID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgdGd0UG9zLngsXG4gICAgICAgIHRndFBvcy55LFxuICAgICAgICB0Z3RXLFxuICAgICAgICB0Z3RILFxuICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgc3JjUG9zLnksXG4gICAgICAgIDBcbiAgICAgICk7XG5cbiAgICAgIHZhciBtaWRwdFNyY1B0cyA9IHtcbiAgICAgICAgeDE6IHNyY091dHNpZGVbMF0sXG4gICAgICAgIHgyOiB0Z3RPdXRzaWRlWzBdLFxuICAgICAgICB5MTogc3JjT3V0c2lkZVsxXSxcbiAgICAgICAgeTI6IHRndE91dHNpZGVbMV1cbiAgICAgIH07XG5cbiAgICAgIHZhciBkeSA9ICggdGd0T3V0c2lkZVsxXSAtIHNyY091dHNpZGVbMV0gKTtcbiAgICAgIHZhciBkeCA9ICggdGd0T3V0c2lkZVswXSAtIHNyY091dHNpZGVbMF0gKTtcbiAgICAgIHZhciBsID0gTWF0aC5zcXJ0KCBkeCpkeCArIGR5KmR5ICk7XG5cbiAgICAgIHZhciB2ZWN0b3IgPSB7XG4gICAgICAgIHg6IGR4LFxuICAgICAgICB5OiBkeVxuICAgICAgfTtcblxuICAgICAgdmFyIHZlY3Rvck5vcm0gPSB7XG4gICAgICAgIHg6IHZlY3Rvci54L2wsXG4gICAgICAgIHk6IHZlY3Rvci55L2xcbiAgICAgIH07XG4gICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IHtcbiAgICAgICAgeDogLXZlY3Rvck5vcm0ueSxcbiAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIGlmIHNyYyBpbnRlcnNlY3Rpb24gaXMgaW5zaWRlIHRndCBvciB0Z3QgaW50ZXJzZWN0aW9uIGlzIGluc2lkZSBzcmMsIHRoZW4gbm8gY3RybCBwdHMgdG8gZHJhd1xuICAgICAgaWYoXG4gICAgICAgIHRndFNoYXBlLmNoZWNrUG9pbnQoIHNyY091dHNpZGVbMF0sIHNyY091dHNpZGVbMV0sIDAsIHRndFcsIHRndEgsIHRndFBvcy54LCB0Z3RQb3MueSApICB8fFxuICAgICAgICBzcmNTaGFwZS5jaGVja1BvaW50KCB0Z3RPdXRzaWRlWzBdLCB0Z3RPdXRzaWRlWzFdLCAwLCBzcmNXLCBzcmNILCBzcmNQb3MueCwgc3JjUG9zLnkgKVxuICAgICAgKXtcbiAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSB7fTtcbiAgICAgICAgYmFkQmV6aWVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBlZGdlO1xuICAgIHZhciBlZGdlX3A7XG4gICAgdmFyIHJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlyRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBwYWlyRWRnZXNbaV07XG4gICAgICBlZGdlX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgcnMgPSBlZGdlX3AucnNjcmF0Y2g7XG5cbiAgICAgIHZhciBlZGdlSW5kZXgxID0gcnMubGFzdEVkZ2VJbmRleDtcbiAgICAgIHZhciBlZGdlSW5kZXgyID0gaTtcblxuICAgICAgdmFyIG51bUVkZ2VzMSA9IHJzLmxhc3ROdW1FZGdlcztcbiAgICAgIHZhciBudW1FZGdlczIgPSBwYWlyRWRnZXMubGVuZ3RoO1xuXG4gICAgICB2YXIgZVN0eWxlID0gZWRnZV9wLnN0eWxlO1xuICAgICAgdmFyIHN0eWxlID0gZVN0eWxlO1xuICAgICAgdmFyIGN1cnZlU3R5bGUgPSBlU3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWU7XG4gICAgICB2YXIgY3RybHB0RGlzdHMgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJ107XG4gICAgICB2YXIgY3RybHB0V3MgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cyddO1xuICAgICAgdmFyIGJlemllck4gPSBjdHJscHREaXN0cyAmJiBjdHJscHRXcyA/IE1hdGgubWluKCBjdHJscHREaXN0cy52YWx1ZS5sZW5ndGgsIGN0cmxwdFdzLnZhbHVlLmxlbmd0aCApIDogMTtcbiAgICAgIHZhciBzdGVwU2l6ZSA9IGVTdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5wZlZhbHVlO1xuICAgICAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyAhPT0gdW5kZWZpbmVkID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVswXTtcbiAgICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgY3VydmVTdHlsZSA9PT0gJ3NlZ21lbnRzJztcblxuICAgICAgdmFyIHN3YXBwZWREaXJlY3Rpb24gPSBlZGdlX3Auc291cmNlICE9PSBzcmM7XG5cbiAgICAgIGlmKCBzd2FwcGVkRGlyZWN0aW9uICYmIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICBjdHJscHREaXN0ICo9IC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3JjWDEgPSBycy5sYXN0U3JjQ3RsUHRYO1xuICAgICAgdmFyIHNyY1gyID0gc3JjUG9zLng7XG4gICAgICB2YXIgc3JjWTEgPSBycy5sYXN0U3JjQ3RsUHRZO1xuICAgICAgdmFyIHNyY1kyID0gc3JjUG9zLnk7XG4gICAgICB2YXIgc3JjVzEgPSBycy5sYXN0U3JjQ3RsUHRXO1xuICAgICAgdmFyIHNyY1cyID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBzcmNIMSA9IHJzLmxhc3RTcmNDdGxQdEg7XG4gICAgICB2YXIgc3JjSDIgPSBzcmMub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgdmFyIHRndFgxID0gcnMubGFzdFRndEN0bFB0WDtcbiAgICAgIHZhciB0Z3RYMiA9IHRndFBvcy54O1xuICAgICAgdmFyIHRndFkxID0gcnMubGFzdFRndEN0bFB0WTtcbiAgICAgIHZhciB0Z3RZMiA9IHRndFBvcy55O1xuICAgICAgdmFyIHRndFcxID0gcnMubGFzdFRndEN0bFB0VztcbiAgICAgIHZhciB0Z3RXMiA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgdGd0SDEgPSBycy5sYXN0VGd0Q3RsUHRIO1xuICAgICAgdmFyIHRndEgyID0gdGd0Lm91dGVySGVpZ2h0KCk7XG5cbiAgICAgIHZhciB3aWR0aDEgPSBycy5sYXN0VztcbiAgICAgIHZhciB3aWR0aDIgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJ10ucGZWYWx1ZTtcblxuICAgICAgaWYoIGJhZEJlemllciApe1xuICAgICAgICBycy5iYWRCZXppZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMuYmFkQmV6aWVyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmKCBzcmNYMSA9PT0gc3JjWDIgJiYgc3JjWTEgPT09IHNyY1kyICYmIHNyY1cxID09PSBzcmNXMiAmJiBzcmNIMSA9PT0gc3JjSDJcbiAgICAgICYmICB0Z3RYMSA9PT0gdGd0WDIgJiYgdGd0WTEgPT09IHRndFkyICYmIHRndFcxID09PSB0Z3RXMiAmJiB0Z3RIMSA9PT0gdGd0SDJcbiAgICAgICYmICB3aWR0aDEgPT09IHdpZHRoMlxuICAgICAgJiYgICgoZWRnZUluZGV4MSA9PT0gZWRnZUluZGV4MiAmJiBudW1FZGdlczEgPT09IG51bUVkZ2VzMikgfHwgZWRnZUlzVW5idW5kbGVkKSApe1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnZWRnZSBjdHJsIHB0IGNhY2hlIEhJVCcpXG4gICAgICAgIGNvbnRpbnVlOyAvLyB0aGVuIHRoZSBjb250cm9sIHBvaW50cyBoYXZlbid0IGNoYW5nZWQgYW5kIHdlIGNhbiBza2lwIGNhbGN1bGF0aW5nIHRoZW1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmxhc3RTcmNDdGxQdFggPSBzcmNYMjtcbiAgICAgICAgcnMubGFzdFNyY0N0bFB0WSA9IHNyY1kyO1xuICAgICAgICBycy5sYXN0U3JjQ3RsUHRXID0gc3JjVzI7XG4gICAgICAgIHJzLmxhc3RTcmNDdGxQdEggPSBzcmNIMjtcbiAgICAgICAgcnMubGFzdFRndEN0bFB0WCA9IHRndFgyO1xuICAgICAgICBycy5sYXN0VGd0Q3RsUHRZID0gdGd0WTI7XG4gICAgICAgIHJzLmxhc3RUZ3RDdGxQdFcgPSB0Z3RXMjtcbiAgICAgICAgcnMubGFzdFRndEN0bFB0SCA9IHRndEgyO1xuICAgICAgICBycy5sYXN0RWRnZUluZGV4ID0gZWRnZUluZGV4MjtcbiAgICAgICAgcnMubGFzdE51bUVkZ2VzID0gbnVtRWRnZXMyO1xuICAgICAgICBycy5sYXN0V2lkdGggPSB3aWR0aDI7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdlZGdlIGN0cmwgcHQgY2FjaGUgTUlTUycpXG4gICAgICB9XG5cbiAgICAgIGlmKCBzcmMgPT09IHRndCApe1xuICAgICAgICAvLyBTZWxmLWVkZ2VcblxuICAgICAgICBycy5lZGdlVHlwZSA9ICdzZWxmJztcblxuICAgICAgICB2YXIgaiA9IGk7XG4gICAgICAgIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gICAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgICBqID0gMDtcbiAgICAgICAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICBycy5jdHJscHRzID0gW1xuICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgIHNyY1Bvcy55IC0gKDEgKyBNYXRoLnBvdyhzcmNILCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpLFxuXG4gICAgICAgICAgc3JjUG9zLnggLSAoMSArIE1hdGgucG93KHNyY1csIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksXG4gICAgICAgICAgc3JjUG9zLnlcbiAgICAgICAgXTtcblxuICAgICAgfSBlbHNlIGlmKFxuICAgICAgICBoYXNDb21wb3VuZHMgJiZcbiAgICAgICAgKCBzcmMuaXNQYXJlbnQoKSB8fCBzcmMuaXNDaGlsZCgpIHx8IHRndC5pc1BhcmVudCgpIHx8IHRndC5pc0NoaWxkKCkgKSAmJlxuICAgICAgICAoIHNyYy5wYXJlbnRzKCkuYW55U2FtZSh0Z3QpIHx8IHRndC5wYXJlbnRzKCkuYW55U2FtZShzcmMpIClcbiAgICAgICl7XG4gICAgICAgIC8vIENvbXBvdW5kIGVkZ2VcblxuICAgICAgICBycy5lZGdlVHlwZSA9ICdjb21wb3VuZCc7XG5cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgbGluZSBhcHByb3hpbWF0aW9uIGRvZXNuJ3QgYXBwbHkgZm9yIGNvbXBvdW5kIGJlemllcnNcbiAgICAgICAgLy8gKGxvb3Avc2VsZiBlZGdlcyBhcmUgYWxyZWFkeSBlbGlkZWQgYi9jIG9mIGNoZWFwIHNyYz09dGd0IGNoZWNrKVxuICAgICAgICBycy5iYWRCZXppZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgaiA9IGk7XG4gICAgICAgIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gICAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgICBqID0gMDtcbiAgICAgICAgICBsb29wRGlzdCA9IGN0cmxwdERpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9vcFcgPSA1MDtcblxuICAgICAgICB2YXIgbG9vcGFQb3MgPSB7XG4gICAgICAgICAgeDogc3JjUG9zLnggLSBzcmNXLzIsXG4gICAgICAgICAgeTogc3JjUG9zLnkgLSBzcmNILzJcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9vcGJQb3MgPSB7XG4gICAgICAgICAgeDogdGd0UG9zLnggLSB0Z3RXLzIsXG4gICAgICAgICAgeTogdGd0UG9zLnkgLSB0Z3RILzJcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9vcFBvcyA9IHtcbiAgICAgICAgICB4OiBNYXRoLm1pbiggbG9vcGFQb3MueCwgbG9vcGJQb3MueCApLFxuICAgICAgICAgIHk6IE1hdGgubWluKCBsb29wYVBvcy55LCBsb29wYlBvcy55IClcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhdm9pZHMgY2FzZXMgd2l0aCBpbXBvc3NpYmxlIGJlemllcnNcbiAgICAgICAgdmFyIG1pbkNvbXBvdW5kU3RyZXRjaCA9IDAuNTtcbiAgICAgICAgdmFyIGNvbXBvdW5kU3RyZXRjaEEgPSBNYXRoLm1heCggbWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyhzcmNXICogMC4wMSkgKTtcbiAgICAgICAgdmFyIGNvbXBvdW5kU3RyZXRjaEIgPSBNYXRoLm1heCggbWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyh0Z3RXICogMC4wMSkgKTtcblxuICAgICAgICBycy5jdHJscHRzID0gW1xuICAgICAgICAgIGxvb3BQb3MueCxcbiAgICAgICAgICBsb29wUG9zLnkgLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogY29tcG91bmRTdHJldGNoQSxcblxuICAgICAgICAgIGxvb3BQb3MueCAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hCLFxuICAgICAgICAgIGxvb3BQb3MueVxuICAgICAgICBdO1xuXG4gICAgICB9IGVsc2UgaWYoIGN1cnZlU3R5bGUgPT09ICdzZWdtZW50cycgKXtcbiAgICAgICAgLy8gU2VnbWVudHMgKG11bHRpcGxlIHN0cmFpZ2h0IGxpbmVzKVxuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgICAgICAgcnMuc2VncHRzID0gW107XG5cbiAgICAgICAgdmFyIHNlZ21lbnRXcyA9IGVTdHlsZVsnc2VnbWVudC13ZWlnaHRzJ10ucGZWYWx1ZTtcbiAgICAgICAgdmFyIHNlZ21lbnREcyA9IGVTdHlsZVsnc2VnbWVudC1kaXN0YW5jZXMnXS5wZlZhbHVlO1xuICAgICAgICB2YXIgc2VnbWVudHNOID0gTWF0aC5taW4oIHNlZ21lbnRXcy5sZW5ndGgsIHNlZ21lbnREcy5sZW5ndGggKTtcblxuICAgICAgICBmb3IoIHZhciBzID0gMDsgcyA8IHNlZ21lbnRzTjsgcysrICl7XG4gICAgICAgICAgdmFyIHcgPSBzZWdtZW50V3Nbc107XG4gICAgICAgICAgdmFyIGQgPSBzZWdtZW50RHNbc107XG5cbiAgICAgICAgICAvLyBkID0gc3dhcHBlZERpcmVjdGlvbiA/IC1kIDogZDtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGQgPSBNYXRoLmFicyhkKTtcblxuICAgICAgICAgIC8vIHZhciB3MSA9ICFzd2FwcGVkRGlyZWN0aW9uID8gKDEgLSB3KSA6IHc7XG4gICAgICAgICAgLy8gdmFyIHcyID0gIXN3YXBwZWREaXJlY3Rpb24gPyB3IDogKDEgLSB3KTtcblxuICAgICAgICAgIHZhciB3MSA9ICgxIC0gdyk7XG4gICAgICAgICAgdmFyIHcyID0gdztcblxuICAgICAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICAgICAgeDogbWlkcHRTcmNQdHMueDEgKiB3MSArIG1pZHB0U3JjUHRzLngyICogdzIsXG4gICAgICAgICAgICB5OiBtaWRwdFNyY1B0cy55MSAqIHcxICsgbWlkcHRTcmNQdHMueTIgKiB3MlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBycy5zZWdwdHMucHVzaChcbiAgICAgICAgICAgIGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkLFxuICAgICAgICAgICAgYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgIC8vIFN0cmFpZ2h0IGVkZ2VcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHBhaXJFZGdlcy5sZW5ndGggJSAyID09PSAxXG4gICAgICAgICYmIGkgPT09IE1hdGguZmxvb3IocGFpckVkZ2VzLmxlbmd0aCAvIDIpXG4gICAgICAgICYmICFlZGdlSXNVbmJ1bmRsZWRcbiAgICAgICl7XG5cbiAgICAgICAgcnMuZWRnZVR5cGUgPSAnc3RyYWlnaHQnO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAoTXVsdGkpYmV6aWVyXG5cbiAgICAgICAgdmFyIG11bHRpID0gZWRnZUlzVW5idW5kbGVkO1xuXG4gICAgICAgIHJzLmVkZ2VUeXBlID0gbXVsdGkgPyAnbXVsdGliZXppZXInIDogJ2Jlemllcic7XG4gICAgICAgIHJzLmN0cmxwdHMgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBiID0gMDsgYiA8IGJlemllck47IGIrKyApe1xuICAgICAgICAgIHZhciBub3JtY3RybHB0RGlzdCA9ICgwLjUgLSBwYWlyRWRnZXMubGVuZ3RoIC8gMiArIGkpICogc3RlcFNpemU7XG4gICAgICAgICAgdmFyIG1hbmN0cmxwdERpc3Q7XG4gICAgICAgICAgdmFyIHNpZ24gPSBtYXRoLnNpZ251bSggbm9ybWN0cmxwdERpc3QgKTtcblxuICAgICAgICAgIGlmKCBtdWx0aSApe1xuICAgICAgICAgICAgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVtiXSA6IHN0ZXBTaXplOyAvLyBmYWxsIGJhY2sgb24gc3RlcCBzaXplXG4gICAgICAgICAgICBjdHJscHRXZWlnaHQgPSBjdHJscHRXcy52YWx1ZVtiXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7IC8vIG11bHRpIG9yIHNpbmdsZSB1bmJ1bmRsZWRcbiAgICAgICAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIGN0cmxwdERpc3QgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuY3RybHB0RGlzdCA6IG5vcm1jdHJscHREaXN0O1xuXG4gICAgICAgICAgdmFyIHcxID0gIXN3YXBwZWREaXJlY3Rpb24gfHwgZWRnZUlzVW5idW5kbGVkID8gKDEgLSBjdHJscHRXZWlnaHQpIDogY3RybHB0V2VpZ2h0O1xuICAgICAgICAgIHZhciB3MiA9ICFzd2FwcGVkRGlyZWN0aW9uIHx8IGVkZ2VJc1VuYnVuZGxlZCA/IGN0cmxwdFdlaWdodCA6ICgxIC0gY3RybHB0V2VpZ2h0KTtcblxuICAgICAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICAgICAgeDogbWlkcHRTcmNQdHMueDEgKiB3MSArIG1pZHB0U3JjUHRzLngyICogdzIsXG4gICAgICAgICAgICB5OiBtaWRwdFNyY1B0cy55MSAqIHcxICsgbWlkcHRTcmNQdHMueTIgKiB3MlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBycy5jdHJscHRzLnB1c2goXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQsXG4gICAgICAgICAgICBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZGlzdGFuY2VGcm9tTWlkcG9pbnRcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gZmluZCBlbmRwdHMgZm9yIGVkZ2VcbiAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuXG4gICAgICB2YXIgYmFkU3RhcnQgPSAhaXMubnVtYmVyKCBycy5zdGFydFggKSB8fCAhaXMubnVtYmVyKCBycy5zdGFydFkgKTtcbiAgICAgIHZhciBiYWRBU3RhcnQgPSAhaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WCApIHx8ICFpcy5udW1iZXIoIHJzLmFycm93U3RhcnRZICk7XG4gICAgICB2YXIgYmFkRW5kID0gIWlzLm51bWJlciggcnMuZW5kWCApIHx8ICFpcy5udW1iZXIoIHJzLmVuZFkgKTtcbiAgICAgIHZhciBiYWRBRW5kID0gIWlzLm51bWJlciggcnMuYXJyb3dFbmRYICkgfHwgIWlzLm51bWJlciggcnMuYXJyb3dFbmRZICk7XG5cbiAgICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoIGVTdHlsZVsnd2lkdGgnXS5wZlZhbHVlICkgKiB0aGlzLmFycm93U2hhcGVIZWlnaHQ7XG4gICAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG5cbiAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgKXtcbiAgICAgICAgdmFyIHN0YXJ0QUNwRGlzdCA9IG1hdGguZGlzdGFuY2UoIHsgeDogcnMuY3RybHB0c1swXSwgeTogcnMuY3RybHB0c1sxXSB9LCB7IHg6IHJzLnN0YXJ0WCwgeTogcnMuc3RhcnRZIH0gKTtcbiAgICAgICAgdmFyIGNsb3NlU3RhcnRBQ3AgPSBzdGFydEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgICAgICB2YXIgZW5kQUNwRGlzdCA9IG1hdGguZGlzdGFuY2UoIHsgeDogcnMuY3RybHB0c1swXSwgeTogcnMuY3RybHB0c1sxXSB9LCB7IHg6IHJzLmVuZFgsIHk6IHJzLmVuZFkgfSApO1xuICAgICAgICB2YXIgY2xvc2VFbmRBQ3AgPSBlbmRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcblxuICAgICAgICB2YXIgb3ZlcmxhcHBpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiggYmFkU3RhcnQgfHwgYmFkQVN0YXJ0IHx8IGNsb3NlU3RhcnRBQ3AgKXtcbiAgICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHNyYyBjZW50cmUgdG8gb3V0c2lkZSB0aGUgc3JjIHNoYXBlXG4gICAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgICAgIHZhciBjcEQgPSB7IC8vIGRlbHRhXG4gICAgICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gc3JjUG9zLngsXG4gICAgICAgICAgICB5OiBycy5jdHJscHRzWzFdIC0gc3JjUG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoIGNwRC54KmNwRC54ICsgY3BELnkqY3BELnkgKTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgICAgICB2YXIgY3BNID0geyAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICAgICAgdmFyIGNwUHJvaiA9IHsgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgICAgeDogcnMuY3RybHB0c1swXSArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHNyY0N0cmxQdEludG4gPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgICAgc3JjUG9zLngsXG4gICAgICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgICAgIHNyY1csXG4gICAgICAgICAgICBzcmNILFxuICAgICAgICAgICAgY3BQcm9qLngsXG4gICAgICAgICAgICBjcFByb2oueSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYoIGNsb3NlU3RhcnRBQ3AgKXtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMF0gPSBycy5jdHJscHRzWzBdICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7XG4gICAgICAgICAgICBycy5jdHJscHRzWzFdID0gcnMuY3RybHB0c1sxXSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBycy5jdHJscHRzWzBdID0gc3JjQ3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMV0gPSBzcmNDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBiYWRFbmQgfHwgYmFkQUVuZCB8fCBjbG9zZUVuZEFDcCApe1xuICAgICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gdGd0IGNlbnRyZSB0byBvdXRzaWRlIHRoZSB0Z3Qgc2hhcGVcbiAgICAgICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG4gICAgICAgICAgdmFyIGNwRCA9IHsgLy8gZGVsdGFcbiAgICAgICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gLSB0Z3RQb3MueCxcbiAgICAgICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSB0Z3RQb3MueVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGNwTCA9IE1hdGguc3FydCggY3BELngqY3BELnggKyBjcEQueSpjcEQueSApOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgIHZhciBjcE0gPSB7IC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgICAgICB2YXIgY3BQcm9qID0geyAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgICB4OiBycy5jdHJscHRzWzBdICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgdGd0Q3RybFB0SW50biA9IHRndFNoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgICAgIHRndFBvcy55LFxuICAgICAgICAgICAgdGd0VyxcbiAgICAgICAgICAgIHRndEgsXG4gICAgICAgICAgICBjcFByb2oueCxcbiAgICAgICAgICAgIGNwUHJvai55LFxuICAgICAgICAgICAgMFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiggY2xvc2VFbmRBQ3AgKXtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMF0gPSBycy5jdHJscHRzWzBdICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJzLmN0cmxwdHNbMF0gPSB0Z3RDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICAgICAgcnMuY3RybHB0c1sxXSA9IHRndEN0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3ZlcmxhcHBpbmcgKXtcbiAgICAgICAgICAvLyByZWNhbGMgZW5kcHRzXG4gICAgICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKCBlZGdlICk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcgKXtcbiAgICAgICAgcnMuYWxscHRzID0gW107XG5cbiAgICAgICAgcnMuYWxscHRzLnB1c2goIHJzLnN0YXJ0WCwgcnMuc3RhcnRZICk7XG5cbiAgICAgICAgZm9yKCB2YXIgYiA9IDA7IGIrMSA8IHJzLmN0cmxwdHMubGVuZ3RoOyBiICs9IDIgKXtcbiAgICAgICAgICAvLyBjdHJsIHB0IGl0c2VsZlxuICAgICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5jdHJscHRzW2JdLCBycy5jdHJscHRzW2IrMV0gKTtcblxuICAgICAgICAgIC8vIHRoZSBtaWRwdCBiZXR3ZWVuIGN0cmxwdHMgYXMgaW50ZXJtZWRpYXRlIGRlc3RpbmF0aW9uIHB0c1xuICAgICAgICAgIGlmKCBiICsgMyA8IHJzLmN0cmxwdHMubGVuZ3RoICl7XG4gICAgICAgICAgICBycy5hbGxwdHMucHVzaCggKHJzLmN0cmxwdHNbYl0gKyBycy5jdHJscHRzW2IrMl0pLzIsIChycy5jdHJscHRzW2IrMV0gKyBycy5jdHJscHRzW2IrM10pLzIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBycy5hbGxwdHMucHVzaCggcnMuZW5kWCwgcnMuZW5kWSApO1xuXG4gICAgICAgIHZhciBtLCBtdDtcbiAgICAgICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyApe1xuICAgICAgICAgIHJzLm1pZFggPSBtYXRoLnFiZXppZXJBdCggcnMuYXJyb3dTdGFydFgsIHJzLmN0cmxwdHNbMF0sIHJzLmFycm93RW5kWCwgMC41ICk7XG4gICAgICAgICAgcnMubWlkWSA9IG1hdGgucWJlemllckF0KCBycy5hcnJvd1N0YXJ0WSwgcnMuY3RybHB0c1sxXSwgcnMuYXJyb3dFbmRZLCAwLjUgKTtcbiAgICAgICAgfSBlbHNlIGlmKCBycy5jdHJscHRzLmxlbmd0aC8yICUgMiA9PT0gMCApe1xuICAgICAgICAgIG0gPSBycy5hbGxwdHMubGVuZ3RoLzIgLSAxO1xuXG4gICAgICAgICAgcnMubWlkWCA9IHJzLmFsbHB0c1ttXTtcbiAgICAgICAgICBycy5taWRZID0gcnMuYWxscHRzW20rMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9IHJzLmFsbHB0cy5sZW5ndGgvMiAtIDM7XG4gICAgICAgICAgbXQgPSAwLjU7XG5cbiAgICAgICAgICBycy5taWRYID0gbWF0aC5xYmV6aWVyQXQoIHJzLmFsbHB0c1ttXSwgcnMuYWxscHRzW20rMl0sIHJzLmFsbHB0c1ttKzRdLCBtdCApO1xuICAgICAgICAgIHJzLm1pZFkgPSBtYXRoLnFiZXppZXJBdCggcnMuYWxscHRzW20rMV0sIHJzLmFsbHB0c1ttKzNdLCBycy5hbGxwdHNbbSs1XSwgbXQgKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnICl7XG4gICAgICAgIC8vIG5lZWQgdG8gY2FsYyB0aGVzZSBhZnRlciBlbmRwdHNcbiAgICAgICAgcnMuYWxscHRzID0gWyBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWSBdO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgbWlkcHQgZm9yIGxhYmVscyBldGNcbiAgICAgICAgcnMubWlkWCA9ICggcnMuYXJyb3dTdGFydFggKyBycy5hcnJvd0VuZFggKS8yO1xuICAgICAgICBycy5taWRZID0gKCBycy5hcnJvd1N0YXJ0WSArIHJzLmFycm93RW5kWSApLzI7XG5cbiAgICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cycgKXtcbiAgICAgICAgcnMuYWxscHRzID0gW107XG4gICAgICAgIHJzLmFsbHB0cy5wdXNoKCBycy5zdGFydFgsIHJzLnN0YXJ0WSApO1xuICAgICAgICBycy5hbGxwdHMucHVzaC5hcHBseSggcnMuYWxscHRzLCBycy5zZWdwdHMgKTtcbiAgICAgICAgcnMuYWxscHRzLnB1c2goIHJzLmVuZFgsIHJzLmVuZFkgKTtcblxuICAgICAgICBpZiggcnMuc2VncHRzLmxlbmd0aCAlIDQgPT09IDAgKXtcbiAgICAgICAgICB2YXIgaTIgPSBycy5zZWdwdHMubGVuZ3RoIC8gMjtcbiAgICAgICAgICB2YXIgaTEgPSBpMiAtIDI7XG5cbiAgICAgICAgICBycy5taWRYID0gKCBycy5zZWdwdHNbaTFdICsgcnMuc2VncHRzW2kyXSApIC8gMjtcbiAgICAgICAgICBycy5taWRZID0gKCBycy5zZWdwdHNbaTErMV0gKyBycy5zZWdwdHNbaTIrMV0gKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGkxID0gcnMuc2VncHRzLmxlbmd0aCAvIDIgLSAxO1xuXG4gICAgICAgICAgcnMubWlkWCA9IHJzLnNlZ3B0c1tpMV07XG4gICAgICAgICAgcnMubWlkWSA9IHJzLnNlZ3B0c1tpMSsxXTtcbiAgICAgICAgfVxuXG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5wcm9qZWN0TGluZXMoIGVkZ2UgKTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoIGVkZ2UgKTtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uKCBlZGdlICk7XG5cbiAgICB9XG4gIH1cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGhheXN0YWNrRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWRnZSA9IGhheXN0YWNrRWRnZXNbaV07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgcnMgPSByc2NyYXRjaDtcblxuICAgIGlmKCAhcnNjcmF0Y2guaGF5c3RhY2sgKXtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgcnNjcmF0Y2guc291cmNlID0ge1xuICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgfTtcblxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuXG4gICAgICByc2NyYXRjaC50YXJnZXQgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuXG4gICAgfVxuXG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG4gICAgdmFyIHRndFBvcyA9IHRndC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG4gICAgdmFyIHRndEggPSB0Z3QuaGVpZ2h0KCk7XG4gICAgdmFyIHJhZGl1cyA9IHN0eWxlWydoYXlzdGFjay1yYWRpdXMnXS52YWx1ZTtcbiAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cy8yOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgcnMuaGF5c3RhY2tQdHMgPSBycy5hbGxwdHMgPSBbXG4gICAgICBycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzICsgc3JjUG9zLngsXG4gICAgICBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzICsgc3JjUG9zLnksXG4gICAgICBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzICsgdGd0UG9zLngsXG4gICAgICBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzICsgdGd0UG9zLnlcbiAgICBdO1xuXG4gICAgcnMubWlkWCA9IChycy5hbGxwdHNbMF0gKyBycy5hbGxwdHNbMl0pLzI7XG4gICAgcnMubWlkWSA9IChycy5hbGxwdHNbMV0gKyBycy5hbGxwdHNbM10pLzI7XG5cbiAgICAvLyBhbHdheXMgb3ZlcnJpZGUgYXMgaGF5c3RhY2sgaW4gY2FzZSBzZXQgdG8gZGlmZmVyZW50IHR5cGUgcHJldmlvdXNseVxuICAgIHJzY3JhdGNoLmVkZ2VUeXBlID0gJ2hheXN0YWNrJztcbiAgICByc2NyYXRjaC5oYXlzdGFjayA9IHRydWU7XG5cbiAgICB0aGlzLnByb2plY3RMaW5lcyggZWRnZSApO1xuICAgIHRoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoIGVkZ2UgKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbiggZWRnZSApO1xuICB9XG5cbiAgZm9yKCB2YXIgaSA9IDAgOyBpIDwgYXV0b3JvdGF0ZUVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGVkZ2UgPSBhdXRvcm90YXRlRWRnZXNbaV07XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIHJzLmxhYmVsQW5nbGUgPSBNYXRoLmF0YW4oIHJzLm1pZERpc3BZIC8gcnMubWlkRGlzcFggKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoVGFibGU7XG59O1xuXG52YXIgZ2V0QW5nbGVGcm9tRGlzcCA9IGZ1bmN0aW9uKCBkaXNwWCwgZGlzcFkgKXtcbiAgcmV0dXJuIE1hdGguYXRhbjIoIGRpc3BZLCBkaXNwWCApIC0gTWF0aC5QSS8yO1xufTtcblxuQlJwLmNhbGN1bGF0ZUFycm93QW5nbGVzID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcbiAgdmFyIGlzTXVsdGliZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ211bHRpYmV6aWVyJztcbiAgdmFyIGlzU2VnbWVudHMgPSBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIGlzQ29tcG91bmQgPSBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIGlzU2VsZiA9IHJzLmVkZ2VUeXBlID09PSAnc2VsZic7XG5cbiAgLy8gRGlzcGxhY2VtZW50IGdpdmVzIGRpcmVjdGlvbiBmb3IgYXJyb3doZWFkIG9yaWVudGF0aW9uXG4gIHZhciBkaXNwWCwgZGlzcFk7XG4gIHZhciBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWTtcblxuICB2YXIgc3JjUG9zID0gZWRnZS5zb3VyY2UoKS5wb3NpdGlvbigpO1xuICB2YXIgdGd0UG9zID0gZWRnZS50YXJnZXQoKS5wb3NpdGlvbigpO1xuXG4gIGlmKCBpc0hheXN0YWNrICl7XG4gICAgc3RhcnRYID0gcnMuaGF5c3RhY2tQdHNbMF07XG4gICAgc3RhcnRZID0gcnMuaGF5c3RhY2tQdHNbMV07XG4gICAgZW5kWCA9IHJzLmhheXN0YWNrUHRzWzJdO1xuICAgIGVuZFkgPSBycy5oYXlzdGFja1B0c1szXTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydFggPSBycy5hcnJvd1N0YXJ0WDtcbiAgICBzdGFydFkgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICBlbmRYID0gcnMuYXJyb3dFbmRYO1xuICAgIGVuZFkgPSBycy5hcnJvd0VuZFk7XG4gIH1cblxuICAvLyBzb3VyY2VcbiAgLy9cblxuICBkaXNwWCA9IHNyY1Bvcy54IC0gc3RhcnRYO1xuICBkaXNwWSA9IHNyY1Bvcy55IC0gc3RhcnRZO1xuXG4gIHJzLnNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICAvLyBtaWQgdGFyZ2V0XG4gIC8vXG5cbiAgdmFyIG1pZFggPSBycy5taWRYO1xuICB2YXIgbWlkWSA9IHJzLm1pZFk7XG5cbiAgaWYoIGlzSGF5c3RhY2sgKXtcbiAgICBtaWRYID0gKCBzdGFydFggKyBlbmRYICkvMjtcbiAgICBtaWRZID0gKCBzdGFydFkgKyBlbmRZICkvMjtcbiAgfVxuXG4gIGRpc3BYID0gZW5kWCAtIHN0YXJ0WDtcbiAgZGlzcFkgPSBlbmRZIC0gc3RhcnRZO1xuXG4gIGlmKCBpc1NlbGYgKXtcbiAgICBkaXNwWCA9IC0xO1xuICAgIGRpc3BZID0gMTtcbiAgfSBlbHNlIGlmKCBpc1NlZ21lbnRzICl7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcblxuICAgIGlmKCBwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDAgKXtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuXG4gICAgICBkaXNwWCA9ICggcHRzW2kyXSAtIHB0c1tpMV0gKTtcbiAgICAgIGRpc3BZID0gKCBwdHNbaTIrMV0gLSBwdHNbaTErMV0gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgdmFyIGkzID0gaTIgKyAyO1xuXG4gICAgICBkaXNwWCA9ICggcHRzW2kyXSAtIHB0c1tpMV0gKTtcbiAgICAgIGRpc3BZID0gKCBwdHNbaTIrMV0gLSBwdHNbaTErMV0gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiggaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kICl7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICB2YXIgY3B0cyA9IHJzLmN0cmxwdHM7XG4gICAgdmFyIGJwMHgsIGJwMHk7XG4gICAgdmFyIGJwMXgsIGJwMXk7XG5cbiAgICBpZiggY3B0cy5sZW5ndGggLyAyICUgMiA9PT0gMCApe1xuICAgICAgdmFyIHAwID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBzdGFydHB0XG4gICAgICB2YXIgaWMgPSBwMCArIDI7XG4gICAgICB2YXIgcDEgPSBpYyArIDI7XG5cbiAgICAgIGJwMHggPSBtYXRoLnFiZXppZXJBdCggcHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wICk7XG4gICAgICBicDB5ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1twMCsxXSwgcHRzW2ljKzFdLCBwdHNbcDErMV0sIDAuMCApO1xuXG4gICAgICBicDF4ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuMDAwMSApO1xuICAgICAgYnAxeSA9IG1hdGgucWJlemllckF0KCBwdHNbcDArMV0sIHB0c1tpYysxXSwgcHRzW3AxKzFdLCAwLjAwMDEgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGljID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBjdHJwdFxuICAgICAgdmFyIHAwID0gaWMgLSAyOyAvLyBzdGFydHB0XG4gICAgICB2YXIgcDEgPSBpYyArIDI7IC8vIGVuZHB0XG5cbiAgICAgIGJwMHggPSBtYXRoLnFiZXppZXJBdCggcHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC40OTk5ICk7XG4gICAgICBicDB5ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1twMCsxXSwgcHRzW2ljKzFdLCBwdHNbcDErMV0sIDAuNDk5OSApO1xuXG4gICAgICBicDF4ID0gbWF0aC5xYmV6aWVyQXQoIHB0c1twMF0sIHB0c1tpY10sIHB0c1twMV0sIDAuNSApO1xuICAgICAgYnAxeSA9IG1hdGgucWJlemllckF0KCBwdHNbcDArMV0sIHB0c1tpYysxXSwgcHRzW3AxKzFdLCAwLjUgKTtcbiAgICB9XG5cbiAgICBkaXNwWCA9ICggYnAxeCAtIGJwMHggKTtcbiAgICBkaXNwWSA9ICggYnAxeSAtIGJwMHkgKTtcbiAgfVxuXG4gIHJzLm1pZHRndEFycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKCBkaXNwWCwgZGlzcFkgKTtcblxuICBycy5taWREaXNwWCA9IGRpc3BYO1xuICBycy5taWREaXNwWSA9IGRpc3BZO1xuXG4gIC8vIG1pZCBzb3VyY2VcbiAgLy9cblxuICBkaXNwWCAqPSAtMTtcbiAgZGlzcFkgKj0gLTE7XG5cbiAgaWYoIGlzU2VnbWVudHMgKXtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuXG4gICAgaWYoIHB0cy5sZW5ndGggLyAyICUgMiA9PT0gMCApe1xuICAgICAgLy8gYWxyZWFkeSBva1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMiAtIDE7XG4gICAgICB2YXIgaTMgPSBpMiArIDI7XG5cbiAgICAgIGRpc3BYID0gLSggcHRzW2kzXSAtIHB0c1tpMl0gKTtcbiAgICAgIGRpc3BZID0gLSggcHRzW2kzKzFdIC0gcHRzW2kyKzFdICk7XG4gICAgfVxuICB9XG5cbiAgcnMubWlkc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoIGRpc3BYLCBkaXNwWSApO1xuXG4gIC8vIHRhcmdldFxuICAvL1xuXG4gIGRpc3BYID0gdGd0UG9zLnggLSBlbmRYO1xuICBkaXNwWSA9IHRndFBvcy55IC0gZW5kWTtcblxuICBycy50Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcCggZGlzcFgsIGRpc3BZICk7XG59O1xuXG5cbkJScC5maW5kRW5kcG9pbnRzID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW50ZXJzZWN0O1xuXG4gIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKVswXTtcblxuICB2YXIgc3JjX3AgPSBzb3VyY2UuX3ByaXZhdGU7XG4gIHZhciB0Z3RfcCA9IHRhcmdldC5fcHJpdmF0ZTtcblxuICB2YXIgc3JjUG9zID0gc3JjX3AucG9zaXRpb247XG4gIHZhciB0Z3RQb3MgPSB0Z3RfcC5wb3NpdGlvbjtcblxuICB2YXIgdGd0QXJTaGFwZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3RhcmdldC1hcnJvdy1zaGFwZSddLnZhbHVlO1xuICB2YXIgc3JjQXJTaGFwZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3NvdXJjZS1hcnJvdy1zaGFwZSddLnZhbHVlO1xuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG4gIHZhciBiZXppZXIgPSBldCA9PT0gJ2JlemllcicgfHwgZXQgPT09ICdtdWx0aWJlemllcicgfHwgZXQgPT09ICdzZWxmJyB8fCBldCA9PT0gJ2NvbXBvdW5kJztcbiAgdmFyIG11bHRpID0gZXQgIT09ICdiZXppZXInO1xuICB2YXIgbGluZXMgPSBldCA9PT0gJ3N0cmFpZ2h0JyB8fCBldCA9PT0gJ3NlZ21lbnRzJztcbiAgdmFyIHNlZ21lbnRzID0gZXQgPT09ICdzZWdtZW50cyc7XG5cbiAgdmFyIHAxLCBwMjtcblxuICBpZiggYmV6aWVyICl7XG4gICAgdmFyIGNwU3RhcnQgPSBbIHJzLmN0cmxwdHNbMF0sIHJzLmN0cmxwdHNbMV0gXTtcbiAgICB2YXIgY3BFbmQgPSBtdWx0aSA/IFsgcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDJdLCBycy5jdHJscHRzW3JzLmN0cmxwdHMubGVuZ3RoIC0gMV0gXSA6IGNwU3RhcnQ7XG5cbiAgICBwMSA9IGNwRW5kO1xuICAgIHAyID0gY3BTdGFydDtcbiAgfSBlbHNlIGlmKCBsaW5lcyApe1xuICAgIHZhciBzcmNBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFsgdGd0UG9zLngsIHRndFBvcy55IF0gOiBycy5zZWdwdHMuc2xpY2UoIDAsIDIgKTtcbiAgICB2YXIgdGd0QXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbIHNyY1Bvcy54LCBzcmNQb3MueSBdIDogcnMuc2VncHRzLnNsaWNlKCBycy5zZWdwdHMubGVuZ3RoIC0gMiApO1xuXG4gICAgcDEgPSB0Z3RBcnJvd0Zyb21QdDtcbiAgICBwMiA9IHNyY0Fycm93RnJvbVB0O1xuICB9XG5cbiAgaW50ZXJzZWN0ID0gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUoXG4gICAgdGd0UG9zLngsXG4gICAgdGd0UG9zLnksXG4gICAgdGFyZ2V0Lm91dGVyV2lkdGgoKSxcbiAgICB0YXJnZXQub3V0ZXJIZWlnaHQoKSxcbiAgICBwMVswXSxcbiAgICBwMVsxXSxcbiAgICAwXG4gICk7XG5cbiAgdmFyIGFycm93RW5kID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDEsXG4gICAgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgdmFyIGVkZ2VFbmQgPSBtYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSxcbiAgICByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSk7XG5cbiAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuXG4gIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcblxuICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShcbiAgICBzcmNQb3MueCxcbiAgICBzcmNQb3MueSxcbiAgICBzb3VyY2Uub3V0ZXJXaWR0aCgpLFxuICAgIHNvdXJjZS5vdXRlckhlaWdodCgpLFxuICAgIHAyWzBdLFxuICAgIHAyWzFdLFxuICAgIDBcbiAgKTtcblxuICB2YXIgYXJyb3dTdGFydCA9IG1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICBpbnRlcnNlY3QsIHAyLFxuICAgIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKVxuICApO1xuICB2YXIgZWRnZVN0YXJ0ID0gbWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKFxuICAgIGludGVyc2VjdCwgcDIsXG4gICAgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSlcbiAgKTtcblxuICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcblxuICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcblxuICBpZiggbGluZXMgKXtcbiAgICBpZiggIWlzLm51bWJlcihycy5zdGFydFgpIHx8ICFpcy5udW1iZXIocnMuc3RhcnRZKSB8fCAhaXMubnVtYmVyKHJzLmVuZFgpIHx8ICFpcy5udW1iZXIocnMuZW5kWSkgKXtcbiAgICAgIHJzLmJhZExpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBycy5iYWRMaW5lID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG5CUnAuZ2V0QXJyb3dXaWR0aCA9IEJScC5nZXRBcnJvd0hlaWdodCA9IGZ1bmN0aW9uKGVkZ2VXaWR0aCkge1xuICB2YXIgY2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlIHx8IHt9O1xuXG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtlZGdlV2lkdGhdO1xuICBpZiggY2FjaGVkVmFsICl7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfVxuXG4gIGNhY2hlZFZhbCA9ICBNYXRoLm1heChNYXRoLnBvdyhlZGdlV2lkdGggKiAxMy4zNywgMC45KSwgMjkpO1xuICBjYWNoZVtlZGdlV2lkdGhdID0gY2FjaGVkVmFsO1xuXG4gIHJldHVybiBjYWNoZWRWYWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJScCA9IHt9O1xuXG5CUnAuZ2V0Q2FjaGVkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIG9uTG9hZCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlID0gci5pbWFnZUNhY2hlIHx8IHt9O1xuXG4gIGlmKCBpbWFnZUNhY2hlW3VybF0gJiYgaW1hZ2VDYWNoZVt1cmxdLmltYWdlICl7XG4gICAgcmV0dXJuIGltYWdlQ2FjaGVbdXJsXS5pbWFnZTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IGltYWdlQ2FjaGVbdXJsXSA9IGltYWdlQ2FjaGVbdXJsXSB8fCB7fTtcblxuICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgaW1hZ2Uuc3JjID0gdXJsO1xuXG4gIHJldHVybiBpbWFnZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQlJwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi8uLi8uLi9pcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJyk7XG5cbnZhciBCYXNlUmVuZGVyZXIgPSBmdW5jdGlvbigpe307XG52YXIgQlIgPSBCYXNlUmVuZGVyZXI7XG52YXIgQlJwID0gQlIucHJvdG90eXBlO1xuXG5CUnAuY2xpZW50RnVuY3Rpb25zID0gWyAncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnIF07XG5cbkJScC5pbml0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHIub3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgci5jeSA9IG9wdGlvbnMuY3k7XG5cbiAgci5jb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuXG4gIHIuc2VsZWN0aW9uID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF07IC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZ1xuXG4gIC8vLS1Qb2ludGVyLXJlbGF0ZWQgZGF0YVxuICByLmhvdmVyRGF0YSA9IHtkb3duOiBudWxsLCBsYXN0OiBudWxsLFxuICAgICAgZG93blRpbWU6IG51bGwsIHRyaWdnZXJNb2RlOiBudWxsLFxuICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgaW5pdGlhbFBhbjogW251bGwsIG51bGxdLCBjYXB0dXJlOiBmYWxzZX07XG5cbiAgci5kcmFnRGF0YSA9IHtwb3NzaWJsZURyYWdFbGVtZW50czogW119O1xuXG4gIHIudG91Y2hEYXRhID0ge1xuICAgICAgc3RhcnQ6IG51bGwsIGNhcHR1cmU6IGZhbHNlLFxuXG4gICAgICAvLyBUaGVzZSAzIGZpZWxkcyByZWxhdGVkIHRvIHRhcCwgdGFwaG9sZCBldmVudHNcbiAgICAgIHN0YXJ0UG9zaXRpb246IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgICAgc2luZ2xlVG91Y2hNb3ZlZDogdHJ1ZSxcblxuICAgICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgICBlYXJsaWVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgfTtcblxuICByLnJlZHJhd3MgPSAwO1xuICByLnNob3dGcHMgPSBvcHRpb25zLnNob3dGcHM7XG5cbiAgci5oaWRlRWRnZXNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICByLmhpZGVMYWJlbHNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlTGFiZWxzT25WaWV3cG9ydDtcbiAgci50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gIHIud2hlZWxTZW5zaXRpdml0eSA9IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgci5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuICByLmZvcmNlZFBpeGVsUmF0aW8gPSBvcHRpb25zLnBpeGVsUmF0aW87XG4gIHIubW90aW9uQmx1ciA9IHRydWU7IC8vIGZvciBpbml0aWFsIGtpY2sgb2ZmXG4gIHIubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gci5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIHIubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcbiAgci5taW5NYkxvd1F1YWxGcmFtZXMgPSA0O1xuICByLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgci5jbGVhcmVkRm9yTW90aW9uQmx1ciA9IFtdO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQgKiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQgKiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICByLnRhcGhvbGREdXJhdGlvbiA9IDUwMDtcblxuICByLmJpbmRpbmdzID0gW107XG5cbiAgci5yZWdpc3Rlck5vZGVTaGFwZXMoKTtcbiAgci5yZWdpc3RlckFycm93U2hhcGVzKCk7XG4gIHIubG9hZCgpO1xufTtcblxuQlJwLm5vdGlmeSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgdHlwZXM7XG4gIHZhciByID0gdGhpcztcblxuICBpZiggaXMuYXJyYXkoIHBhcmFtcy50eXBlICkgKXtcbiAgICB0eXBlcyA9IHBhcmFtcy50eXBlO1xuXG4gIH0gZWxzZSB7XG4gICAgdHlwZXMgPSBbIHBhcmFtcy50eXBlIF07XG4gIH1cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcblxuICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgY2FzZSAnZGVzdHJveSc6XG4gICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgY2FzZSAnbG9hZCc6XG4gICAgICAgIHIudXBkYXRlRWxlbWVudHNDYWNoZSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndmlld3BvcnQnOlxuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICByLnVwZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmKCB0eXBlID09PSAnbG9hZCcgfHwgdHlwZSA9PT0gJ3Jlc2l6ZScgKXtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG4gICAgfVxuICB9IC8vIGZvclxuXG4gIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICB0aGlzLnN0YXJ0UmVuZGVyTG9vcCgpO1xuXG4gIHRoaXMucmVkcmF3KCk7XG59O1xuXG5CUnAuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcblxuICB0aGlzLmN5LnN0b3BBbmltYXRpb25Mb29wKCk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJpbmRpbmdzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW2ldO1xuICAgIHZhciBiID0gYmluZGluZztcblxuICAgIGIudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoYi5ldmVudCwgYi5oYW5kbGVyLCBiLnVzZUNhcHR1cmUpO1xuICB9XG5cbiAgaWYoIHRoaXMucmVtb3ZlT2JzZXJ2ZXIgKXtcbiAgICB0aGlzLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIGlmKCB0aGlzLmxhYmVsQ2FsY0RpdiApe1xuICAgIHRyeXtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5sYWJlbENhbGNEaXYpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAvLyBpZTEwIGlzc3VlICMxMDE0XG4gICAgfVxuICB9XG59O1xuXG5bXG4gIHJlcXVpcmUoJy4vYXJyb3ctc2hhcGVzJyksXG4gIHJlcXVpcmUoJy4vY2FjaGVkLWVsZXMnKSxcbiAgcmVxdWlyZSgnLi9jb29yZC1lbGUtbWF0aCcpLFxuICByZXF1aXJlKCcuL2ltYWdlcycpLFxuICByZXF1aXJlKCcuL2xvYWQtbGlzdGVuZXJzJyksXG4gIHJlcXVpcmUoJy4vbm9kZS1zaGFwZXMnKSxcbiAgcmVxdWlyZSgnLi9yZWRyYXcnKVxuXS5mb3JFYWNoKGZ1bmN0aW9uKCBwcm9wcyApe1xuICB1dGlsLmV4dGVuZCggQlJwLCBwcm9wcyApO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQlI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2lzJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKTtcbnZhciBFdmVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2V2ZW50Jyk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbGxlY3Rpb24nKTtcblxudmFyIEJScCA9IHt9O1xuXG5CUnAucmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSl7XG4gIHRoaXMuYmluZGluZ3MucHVzaCh7XG4gICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZVxuICB9KTtcblxuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG59O1xuXG5CUnAubm9kZUlzRHJhZ2dhYmxlID0gZnVuY3Rpb24obm9kZSkge1xuICBpZiAobm9kZS5fcHJpdmF0ZS5zdHlsZVsnb3BhY2l0eSddLnZhbHVlICE9PSAwXG4gICAgJiYgbm9kZS5fcHJpdmF0ZS5zdHlsZVsndmlzaWJpbGl0eSddLnZhbHVlID09ICd2aXNpYmxlJ1xuICAgICYmIG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2Rpc3BsYXknXS52YWx1ZSA9PSAnZWxlbWVudCdcbiAgICAmJiAhbm9kZS5sb2NrZWQoKVxuICAgICYmIG5vZGUuZ3JhYmJhYmxlKCkgKSB7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkJScC5sb2FkID0gZnVuY3Rpb24oKSB7XG4gIHZhciByID0gdGhpcztcblxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKCB0YXJnZXQsIG5hbWVzLCBlLCBwcm9wcyApe1xuICAgIGlmKCB0YXJnZXQgPT0gbnVsbCApe1xuICAgICAgdGFyZ2V0ID0gci5jeTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuXG4gICAgICB2YXIgZXZlbnQgPSBFdmVudCggZSwgdXRpbC5leHRlbmQoeyB0eXBlOiBuYW1lIH0sIHByb3BzKSApO1xuICAgICAgdGFyZ2V0LnRyaWdnZXIoIGV2ZW50ICk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc011bHRTZWxLZXlEb3duID0gZnVuY3Rpb24oIGUgKXtcbiAgICByZXR1cm4gZS5zaGlmdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5OyAvLyBtYXliZSBlLmFsdEtleVxuICB9O1xuXG4gIHZhciBnZXREcmFnTGlzdElkcyA9IGZ1bmN0aW9uKG9wdHMpe1xuICAgIHZhciBsaXN0SGFzSWQ7XG5cbiAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgci5jeS5oYXNDb21wb3VuZE5vZGVzKCkgKXsgLy8gb25seSBuZWVkZWQgZm9yIGNvbXBvdW5kIGdyYXBoc1xuICAgICAgaWYoICFvcHRzLmFkZFRvTGlzdC5oYXNJZCApeyAvLyBidWlsZCBpZHMgbG9va3VwIGlmIGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgICBvcHRzLmFkZFRvTGlzdC5oYXNJZCA9IHt9O1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3B0cy5hZGRUb0xpc3QubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gb3B0cy5hZGRUb0xpc3RbaV07XG5cbiAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5oYXNJZFsgZWxlLmlkKCkgXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdEhhc0lkID0gb3B0cy5hZGRUb0xpc3QuaGFzSWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RIYXNJZCB8fCB7fTtcbiAgfTtcblxuICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGNoaWxkIG5vZGVzIGFuZCBpbm5lciBlZGdlc1xuICAvLyBvZiBhIGNvbXBvdW5kIG5vZGUgdG8gYmUgZHJhZ2dlZCBhcyB3ZWxsIGFzIHRoZSBncmFiYmVkIGFuZCBzZWxlY3RlZCBub2Rlc1xuICB2YXIgYWRkRGVzY2VuZGFudHNUb0RyYWcgPSBmdW5jdGlvbihub2RlLCBvcHRzKXtcbiAgICBpZiggIW5vZGUuX3ByaXZhdGUuY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsICl7IHJldHVybjsgfSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICB2YXIgbGlzdEhhc0lkID0gZ2V0RHJhZ0xpc3RJZHMoIG9wdHMgKTtcblxuICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBpbm5lck5vZGVzLnNpemUoKTsgaSsrICl7XG4gICAgICB2YXIgaU5vZGUgPSBpbm5lck5vZGVzW2ldO1xuICAgICAgdmFyIF9wID0gaU5vZGUuX3ByaXZhdGU7XG5cbiAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICl7XG4gICAgICAgIF9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmICFsaXN0SGFzSWRbIGlOb2RlLmlkKCkgXSApe1xuICAgICAgICBvcHRzLmFkZFRvTGlzdC5wdXNoKCBpTm9kZSApO1xuICAgICAgICBsaXN0SGFzSWRbIGlOb2RlLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgX3AuZ3JhYmJlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IF9wLmVkZ2VzO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IG9wdHMuaW5EcmFnTGF5ZXIgJiYgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIGVkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMsIGFuZCBpdHMgZWRnZXMgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgdmFyIGFkZE5vZGVUb0RyYWcgPSBmdW5jdGlvbihub2RlLCBvcHRzKXtcblxuICAgIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICBpZiggb3B0cy5pbkRyYWdMYXllciApe1xuICAgICAgX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBub2RlLmlkKCkgXSApe1xuICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggbm9kZSApO1xuICAgICAgbGlzdEhhc0lkWyBub2RlLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgIF9wLmdyYWJiZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBlZGdlcyA9IF9wLmVkZ2VzO1xuICAgIGZvciggdmFyIGkgPSAwOyBvcHRzLmluRHJhZ0xheWVyICYmIGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgZWRnZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGFkZERlc2NlbmRhbnRzVG9EcmFnKCBub2RlLCBvcHRzICk7IC8vIGFsd2F5cyBhZGQgdG8gZHJhZ1xuXG4gICAgLy8gYWxzbyBhZGQgbm9kZXMgYW5kIGVkZ2VzIHJlbGF0ZWQgdG8gdGhlIHRvcG1vc3QgYW5jZXN0b3JcbiAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciggbm9kZSwge1xuICAgICAgaW5EcmFnTGF5ZXI6IG9wdHMuaW5EcmFnTGF5ZXJcbiAgICB9ICk7XG4gIH07XG5cbiAgdmFyIGZyZWVEcmFnZ2VkRWxlbWVudHMgPSBmdW5jdGlvbiggZHJhZ2dlZEVsZW1lbnRzICl7XG4gICAgaWYoICFkcmFnZ2VkRWxlbWVudHMgKXsgcmV0dXJuOyB9XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgdmFyIGRFaV9wID0gZHJhZ2dlZEVsZW1lbnRzW2ldLl9wcml2YXRlO1xuXG4gICAgICBpZihkRWlfcC5ncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgICBkRWlfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICBkRWlfcC5ncmFiYmVkID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHNFZGdlcyA9IGRFaV9wLmVkZ2VzO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNFZGdlcy5sZW5ndGg7IGorKyApeyBzRWRnZXNbal0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTsgfVxuXG4gICAgICAgIC8vIGZvciBjb21wb3VuZCBub2RlcywgYWxzbyByZW1vdmUgcmVsYXRlZCBub2RlcyBhbmQgZWRnZXMgZnJvbSB0aGUgZHJhZyBsYXllclxuICAgICAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihkcmFnZ2VkRWxlbWVudHNbaV0sIHsgaW5EcmFnTGF5ZXI6IGZhbHNlIH0pO1xuXG4gICAgICB9IGVsc2UgaWYoIGRFaV9wLmdyb3VwID09PSAnZWRnZXMnICl7XG4gICAgICAgIGRFaV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuICB2YXIgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIgPSBmdW5jdGlvbihub2RlLCBvcHRzKSB7XG5cbiAgICBpZiggb3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwgKXsgcmV0dXJuOyB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSBub2RlO1xuXG4gICAgaWYoICFub2RlLl9wcml2YXRlLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlKCBwYXJlbnQucGFyZW50KCkubm9uZW1wdHkoKSApe1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpWzBdO1xuICAgIH1cblxuICAgIC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICBpZiggcGFyZW50ID09IG5vZGUgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBwYXJlbnQuZGVzY2VuZGFudHMoKVxuICAgICAgLm1lcmdlKCBwYXJlbnQgKVxuICAgICAgLnVubWVyZ2UoIG5vZGUgKVxuICAgICAgLnVubWVyZ2UoIG5vZGUuZGVzY2VuZGFudHMoKSApXG4gICAgO1xuXG4gICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5zaXplKCk7IGkrKyApe1xuICAgICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBub2Rlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IG9wdHMuaW5EcmFnTGF5ZXI7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBub2Rlc1tpXS5pZCgpIF0gKXtcbiAgICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggbm9kZXNbaV0gKTtcbiAgICAgICAgbGlzdEhhc0lkWyBub2Rlc1tpXS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgIG5vZGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciggdmFyIGogPSAwOyBvcHRzLmluRHJhZ0xheWVyICE9PSB1bmRlZmluZWQgJiYgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICkge1xuICAgICAgZWRnZXNbal0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBvcHRzLmluRHJhZ0xheWVyO1xuICAgIH1cbiAgfTtcblxuICBpZiggdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICl7XG4gICAgci5yZW1vdmVPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCBtdXRucyApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBtdXRucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbXV0biA9IG11dG5zW2ldO1xuICAgICAgICB2YXIgck5vZGVzID0gbXV0bi5yZW1vdmVkTm9kZXM7XG5cbiAgICAgICAgaWYoIHJOb2RlcyApeyBmb3IoIHZhciBqID0gMDsgaiA8IHJOb2Rlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciByTm9kZSA9IHJOb2Rlc1tqXTtcblxuICAgICAgICAgIGlmKCByTm9kZSA9PT0gci5jb250YWluZXIgKXtcbiAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmKCByLmNvbnRhaW5lci5wYXJlbnROb2RlICl7XG4gICAgICByLnJlbW92ZU9ic2VydmVyLm9ic2VydmUoIHIuY29udGFpbmVyLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgci5kZXN0cm95KCk7XG4gICAgfSk7XG4gIH1cblxuXG5cbiAgLy8gYXV0byByZXNpemVcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAncmVzaXplJywgdXRpbC5kZWJvdW5jZSggZnVuY3Rpb24oZSkge1xuICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG5cbiAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG4gICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgci5yZWRyYXcoKTtcbiAgfSwgMTAwICkgKTtcblxuICB2YXIgaW52YWxDdG5yQkJPblNjcm9sbCA9IGZ1bmN0aW9uKGRvbUVsZSl7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnc2Nyb2xsJywgZnVuY3Rpb24oZSl7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgIH0gKTtcbiAgfTtcblxuICB2YXIgYmJDdG5yID0gci5jeS5jb250YWluZXIoKTtcblxuICBmb3IoIDs7ICl7XG5cbiAgICBpbnZhbEN0bnJCQk9uU2Nyb2xsKCBiYkN0bnIgKTtcblxuICAgIGlmKCBiYkN0bnIucGFyZW50Tm9kZSApe1xuICAgICAgYmJDdG5yID0gYmJDdG5yLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICB9XG5cbiAgLy8gc3RvcCByaWdodCBjbGljayBtZW51IGZyb20gYXBwZWFyaW5nIG9uIGN5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKXtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xuXG4gIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHIuc2VsZWN0aW9uWzRdICE9PSAwO1xuICB9O1xuXG4gIC8vIFByaW1hcnkga2V5XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICByLmhvdmVyRGF0YS53aGljaCA9IGUud2hpY2g7XG5cbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG5cbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IHBvcztcblxuICAgIHZhciBjaGVja0ZvclRhcGhvbGQgPSBmdW5jdGlvbigpe1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgICBjbGVhclRpbWVvdXQoIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ICk7XG5cbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgIGlmKCByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkICl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICAgICAgaWYoIGVsZSApe1xuICAgICAgICAgICAgZWxlLnRyaWdnZXIoIEV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIEV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICB9O1xuXG4gICAgLy8gUmlnaHQgY2xpY2sgYnV0dG9uXG4gICAgaWYoIGUud2hpY2ggPT0gMyApe1xuXG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgdmFyIGN4dEV2dCA9IEV2ZW50KGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9KTtcblxuICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICBuZWFyLnRyaWdnZXIoIGN4dEV2dCApO1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcblxuICAgIC8vIFByaW1hcnkgYnV0dG9uXG4gICAgfSBlbHNlIGlmIChlLndoaWNoID09IDEpIHtcblxuICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBFbGVtZW50IGRyYWdnaW5nXG4gICAgICB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyBpcyB1bmRlciB0aGUgY3Vyc29yIGFuZCBpdCBpcyBkcmFnZ2FibGUsIHByZXBhcmUgdG8gZ3JhYiBpdFxuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG5cbiAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUobmVhcikgKXtcblxuICAgICAgICAgICAgdmFyIGdyYWJFdmVudCA9IEV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dyYWInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIG5lYXIuaXNOb2RlKCkgJiYgIW5lYXIuc2VsZWN0ZWQoKSApe1xuXG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggbmVhciwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9ICk7XG5cbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKGdyYWJFdmVudCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIG5lYXIuaXNOb2RlKCkgJiYgbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbICBdO1xuXG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5pc05vZGUoKSAmJiB0aGlzLnNlbGVjdGVkKCk7IH0pO1xuXG4gICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKyApe1xuXG4gICAgICAgICAgICAgICAgLy8gT25seSBhZGQgdGhpcyBzZWxlY3RlZCBub2RlIHRvIGRyYWcgaWYgaXQgaXMgZHJhZ2dhYmxlLCBlZy4gaGFzIG5vbnplcm8gb3BhY2l0eVxuICAgICAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZSggc2VsZWN0ZWROb2Rlc1tpXSApICl7XG4gICAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBzZWxlY3RlZE5vZGVzW2ldLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzIH0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIGdyYWJFdmVudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnRzKCBuZWFyLCBbJ21vdXNlZG93bicsICd0YXBzdGFydCcsICd2bW91c2Vkb3duJ10sIGUsIHtcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9ICk7XG5cbiAgICAgIGlmICggbmVhciA9PSBudWxsICkge1xuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSBlbHNlIGlmKCBuZWFyLmlzRWRnZSgpICl7XG4gICAgICAgIHNlbGVjdFs0XSA9IDE7IC8vIGZvciBmdXR1cmUgcGFuXG4gICAgICB9XG5cbiAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuXG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG4gICAgc2VsZWN0WzBdID0gc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgIHNlbGVjdFsxXSA9IHNlbGVjdFszXSA9IHBvc1sxXTtcblxuICB9LCBmYWxzZSk7XG5cbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcblxuICAgIC8vIHNhdmUgY3ljbGVzIGlmIG1vdXNlIGV2ZW50cyBhcmVuJ3QgdG8gYmUgY2FwdHVyZWRcbiAgICBpZiAoICFjYXB0dXJlICl7XG4gICAgICB2YXIgY29udGFpbmVyUGFnZUNvb3JkcyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuXG4gICAgICBpZiAoZS5jbGllbnRYID4gY29udGFpbmVyUGFnZUNvb3Jkc1swXSAmJiBlLmNsaWVudFggPCBjb250YWluZXJQYWdlQ29vcmRzWzBdICsgci5jYW52YXNXaWR0aFxuICAgICAgICAmJiBlLmNsaWVudFkgPiBjb250YWluZXJQYWdlQ29vcmRzWzFdICYmIGUuY2xpZW50WSA8IGNvbnRhaW5lclBhZ2VDb29yZHNbMV0gKyByLmNhbnZhc0hlaWdodFxuICAgICAgKSB7XG4gICAgICAgIC8vIGluc2lkZSBjb250YWluZXIgYm91bmRzIHNvIE9LXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjeUNvbnRhaW5lciA9IHIuY29udGFpbmVyO1xuICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgdmFyIHRQYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIHZhciBjb250YWluZXJJc1RhcmdldCA9IGZhbHNlO1xuXG4gICAgICB3aGlsZSggdFBhcmVudCApe1xuICAgICAgICBpZiggdFBhcmVudCA9PT0gY3lDb250YWluZXIgKXtcbiAgICAgICAgICBjb250YWluZXJJc1RhcmdldCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiggIWNvbnRhaW5lcklzVGFyZ2V0ICl7IHJldHVybjsgfSAvLyBpZiB0YXJnZXQgaXMgb3V0aXNkZSBjeSBjb250YWluZXIsIHRoZW4gdGhpcyBldmVudCBpcyBub3QgZm9yIHVzXG4gICAgfVxuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG5cbiAgICB2YXIgbmVhciA9IG51bGw7XG4gICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgKXtcbiAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IHIuaG92ZXJEYXRhLmxhc3Q7XG4gICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuXG4gICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG5cbiAgICB2YXIgZHggPSBzZWxlY3RbMl0gLSBzZWxlY3RbMF07XG4gICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgdmFyIGR5ID0gc2VsZWN0WzNdIC0gc2VsZWN0WzFdO1xuICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oIGUgKTtcblxuICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuXG4gICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFswXSApO1xuICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFsxXSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsnbW91c2Vtb3ZlJywgJ3Ztb3VzZW1vdmUnLCAndGFwZHJhZyddLCBlLCB7XG4gICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICB9ICk7XG5cbiAgICAvLyB0cmlnZ2VyIGNvbnRleHQgZHJhZyBpZiBybW91c2UgZG93blxuICAgIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMyApe1xuICAgICAgdmFyIGN4dEV2dCA9IEV2ZW50KGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiggZG93biApe1xuICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICBpZiggIXIuaG92ZXJEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci5ob3ZlckRhdGEuY3h0T3ZlciApe1xuXG4gICAgICAgIGlmKCByLmhvdmVyRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3Zlci50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICB9KSApO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICBuZWFyLnRyaWdnZXIoIEV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICB9KSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkcmFnIHBhbm5pbmcgdGhlIGVudGlyZSBncmFwaFxuICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgaWYoIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKXtcbiAgICAgICAgdmFyIGRlbHRhUDtcblxuICAgICAgICBpZiggci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gKXtcbiAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcblxuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6ICggcG9zWzBdIC0gbWRQb3NbMF0gKSAqIHpvb20sXG4gICAgICAgICAgICB5OiAoIHBvc1sxXSAtIG1kUG9zWzFdICkgKiB6b29tXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgfTtcblxuICAgICAgICB9XG5cbiAgICAgICAgY3kucGFuQnkoIGRlbHRhUCApO1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWVkcyByZXByb2plY3QgZHVlIHRvIHBhbiBjaGFuZ2luZyB2aWV3cG9ydFxuICAgICAgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgIC8vIENoZWNrcyBwcmltYXJ5IGJ1dHRvbiBkb3duICYgb3V0IG9mIHRpbWUgJiBtb3VzZSBub3QgbW92ZWQgbXVjaFxuICAgIH0gZWxzZSBpZihcbiAgICAgICAgc2VsZWN0WzRdID09IDEgJiYgKGRvd24gPT0gbnVsbCB8fCBkb3duLmlzRWRnZSgpKVxuICAgICl7XG5cbiAgICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmICggbXVsdFNlbEtleURvd24gfHwgIWN5LnBhbm5pbmdFbmFibGVkKCkgfHwgIWN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICkgKXtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgIH0gZWxzZSBpZiggIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICl7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSB0cnVlO1xuICAgICAgICBzZWxlY3RbNF0gPSAwO1xuXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH07XG5cbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIGRvd24gJiYgZG93bi5pc0VkZ2UoKSAmJiBkb3duLmFjdGl2ZSgpICl7IGRvd24udW5hY3RpdmF0ZSgpOyB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIGRvd24gJiYgZG93bi5pc0VkZ2UoKSAmJiBkb3duLmFjdGl2ZSgpICl7IGRvd24udW5hY3RpdmF0ZSgpOyB9XG5cbiAgICAgIGlmIChuZWFyICE9IGxhc3QpIHtcblxuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoIGxhc3QsIFsnbW91c2VvdXQnLCAndGFwZHJhZ291dCddLCBlLCB7XG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsnbW91c2VvdmVyJywgJ3RhcGRyYWdvdmVyJ10sIGUsIHtcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgIH0gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuXG4gICAgICBpZiggZG93biAmJiBkb3duLmlzTm9kZSgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKGRvd24pICl7XG5cbiAgICAgICAgaWYoIHJkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyICl7IC8vIHRoZW4gZHJhZ1xuXG4gICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICkge1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTsgLy8gaW5kaWNhdGUgdGhhdCB3ZSBhY3R1YWxseSBkaWQgZHJhZyB0aGUgbm9kZVxuXG4gICAgICAgICAgdmFyIHRvVHJpZ2dlciA9IFtdO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBkRWxlID0gZHJhZ2dlZEVsZW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAvLyBub3csIGFkZCB0aGUgZWxlbWVudHMgdG8gdGhlIGRyYWcgbGF5ZXIgaWYgbm90IGRvbmUgYWxyZWFkeVxuICAgICAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgKXtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggZEVsZSwgeyBpbkRyYWdMYXllcjogdHJ1ZSB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIExvY2tlZCBub2RlcyBub3QgZHJhZ2dhYmxlLCBhcyB3ZWxsIGFzIG5vbi12aXNpYmxlIG5vZGVzXG4gICAgICAgICAgICBpZiggZEVsZS5pc05vZGUoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkRWxlKSAmJiBkRWxlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRFbGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgdG9UcmlnZ2VyLnB1c2goIGRFbGUgKTtcblxuICAgICAgICAgICAgICBpZiggaXMubnVtYmVyKGRpc3BbMF0pICYmIGlzLm51bWJlcihkaXNwWzFdKSApe1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVQb3MgPSAhZEVsZS5pc1BhcmVudCgpO1xuXG4gICAgICAgICAgICAgICAgaWYoIHVwZGF0ZVBvcyApe1xuICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgICBpZiggdXBkYXRlUG9zICYmIGlzLm51bWJlcihkcmFnRGVsdGFbMF0pICYmIGlzLm51bWJlcihkcmFnRGVsdGFbMV0pICl7XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHRjb2wgPSAoQ29sbGVjdGlvbihjeSwgdG9UcmlnZ2VyKSk7XG5cbiAgICAgICAgICB0Y29sLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgdGNvbC50cmlnZ2VyKCdwb3NpdGlvbiBkcmFnJyk7XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBzYXZlIGRyYWcgZGVsdGEgZm9yIHdoZW4gd2UgYWN0dWFsbHkgc3RhcnQgZHJhZ2dpbmcgc28gdGhlIHJlbGF0aXZlIGdyYWIgcG9zIGlzIGNvbnN0YW50XG4gICAgICAgICAgdXBkYXRlRHJhZ0RlbHRhKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcHJldmVudCB0aGUgZHJhZ2dpbmcgZnJvbSB0cmlnZ2VyaW5nIHRleHQgc2VsZWN0aW9uIG9uIHRoZSBwYWdlXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG4gICAgfVxuXG4gICAgc2VsZWN0WzJdID0gcG9zWzBdOyBzZWxlY3RbM10gPSBwb3NbMV07XG5cbiAgICBpZiggcHJldmVudERlZmF1bHQgKXtcbiAgICAgIGlmKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZihlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfSwgZmFsc2UpO1xuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuICAgIGlmICghY2FwdHVyZSkgeyByZXR1cm47IH1cbiAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICB2YXIgY3kgPSByLmN5OyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTsgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50czsgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oIGUgKTtcblxuICAgIGlmKCByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gKXtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuXG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkOyAvLyBub3QgYWN0aXZlIGJnIG5vd1xuXG4gICAgaWYoIGRvd24gKXtcbiAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMyApe1xuICAgICAgdmFyIGN4dEV2dCA9IEV2ZW50KGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSk7XG5cbiAgICAgIGlmKCBkb3duICl7XG4gICAgICAgIGRvd24udHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgIHZhciBjeHRUYXAgPSBFdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCBkb3duICl7XG4gICAgICAgICAgZG93bi50cmlnZ2VyKCBjeHRUYXAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRUYXAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG5cbiAgICB9IGVsc2UgaWYoIHIuaG92ZXJEYXRhLndoaWNoID09PSAxICkge1xuXG4gICAgICAvLyBEZXNlbGVjdCBhbGwgZWxlbWVudHMgaWYgbm90aGluZyBpcyBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBhbmQgd2UgYXJlbid0IGRyYWdnaW5nIHNvbWV0aGluZ1xuICAgICAgaWYgKCAoZG93biA9PSBudWxsKSAvLyBub3QgbW91c2Vkb3duIG9uIG5vZGVcbiAgICAgICAgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0aGUgbm9kZSBhcm91bmRcbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dlZCAvLyBkaWRuJ3QgcGFuXG4gICAgICAgICYmICFpc011bHRTZWxLZXlEb3duKCBlIClcbiAgICAgICkge1xuXG4gICAgICAgIGN5LiQoZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCgpO1xuICAgICAgICB9KS51bnNlbGVjdCgpO1xuXG4gICAgICAgIGlmIChkcmFnZ2VkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGRyYWdnZWRFbGVtZW50cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyRXZlbnRzKCBuZWFyLCBbJ21vdXNldXAnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJ10sIGUsIHtcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9ICk7XG5cbiAgICAgIGlmKFxuICAgICAgICAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIGEgbm9kZSBhcm91bmRcbiAgICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgKXtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWydjbGljaycsICd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5nbGUgc2VsZWN0aW9uXG4gICAgICBpZiggbmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICBpZiggbmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSApe1xuXG4gICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nICl7XG4gICAgICAgICAgICAvLyBpZiBwYW5uaW5nLCBkb24ndCBjaGFuZ2Ugc2VsZWN0aW9uIHN0YXRlXG4gICAgICAgICAgfSBlbHNlIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgbXVsdFNlbEtleURvd24gKXtcbiAgICAgICAgICAgIGlmKCBuZWFyLnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgICAgbmVhci51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoICFtdWx0U2VsS2V5RG93biApe1xuICAgICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bm1lcmdlKCBuZWFyICkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIHIuaG92ZXJEYXRhLnNlbGVjdGluZyApIHtcbiAgICAgICAgdmFyIG5ld2x5U2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgdmFyIGJveCA9IHIuZ2V0QWxsSW5Cb3goIHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSApO1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgICAgaWYoIGJveC5sZW5ndGggPiAwICkge1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBib3gubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICBpZiggYm94W2ldLl9wcml2YXRlLnNlbGVjdGFibGUgKXtcbiAgICAgICAgICAgIG5ld2x5U2VsZWN0ZWQucHVzaCggYm94W2ldICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld2x5U2VsQ29sID0gQ29sbGVjdGlvbiggY3ksIG5ld2x5U2VsZWN0ZWQgKTtcblxuICAgICAgICBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnICl7XG4gICAgICAgICAgbmV3bHlTZWxDb2wuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoICFtdWx0U2VsS2V5RG93biApe1xuICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5tZXJnZSggbmV3bHlTZWxDb2wgKS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld2x5U2VsQ29sLnNlbGVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWx3YXlzIG5lZWQgcmVkcmF3IGluIGNhc2UgZWxlcyB1bnNlbGVjdGFibGVcbiAgICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBDYW5jZWwgZHJhZyBwYW5cbiAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZWN0WzRdKSB7XG5cblxuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG5cbiAgICAgICAgZnJlZURyYWdnZWRFbGVtZW50cyggZHJhZ2dlZEVsZW1lbnRzICk7XG5cbiAgICAgICAgaWYoIGRvd24gKXsgZG93bi50cmlnZ2VyKCdmcmVlJyk7IH1cbiAgICAgIH1cblxuICAgIH0gLy8gZWxzZSBub3QgcmlnaHQgbW91c2VcblxuICAgIHNlbGVjdFs0XSA9IDA7IHIuaG92ZXJEYXRhLmRvd24gPSBudWxsO1xuXG4gICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcblxuICB9LCBmYWxzZSk7XG5cbiAgdmFyIHdoZWVsSGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcblxuXG4gICAgaWYoIHIuc2Nyb2xsaW5nUGFnZSApeyByZXR1cm47IH0gLy8gd2hpbGUgc2Nyb2xsaW5nLCBpZ25vcmUgd2hlZWwtdG8tem9vbVxuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICB2YXIgcnBvcyA9IFtwb3NbMF0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS54LFxuICAgICAgICAgICAgICAgICAgcG9zWzFdICogY3kuem9vbSgpICsgY3kucGFuKCkueV07XG5cbiAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgfHwgaW5Cb3hTZWxlY3Rpb24oKSApeyAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSApe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICByLmRhdGEud2hlZWxab29taW5nID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dCggci5kYXRhLndoZWVsVGltZW91dCApO1xuICAgICAgci5kYXRhLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IGZhbHNlO1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSwgMTUwKTtcblxuICAgICAgdmFyIGRpZmYgPSBlLmRlbHRhWSAvIC0yNTAgfHwgZS53aGVlbERlbHRhWSAvIDEwMDAgfHwgZS53aGVlbERlbHRhIC8gMTAwMDtcbiAgICAgIGRpZmYgPSBkaWZmICogci53aGVlbFNlbnNpdGl2aXR5O1xuXG4gICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuICAgICAgaWYoIG5lZWRzV2hlZWxGaXggKXsgLy8gZml4ZXMgc2xvdyB3aGVlbCBldmVudHMgb24gZmYvbGludXggYW5kIGZmL3dpbmRvd3NcbiAgICAgICAgZGlmZiAqPSAzMztcbiAgICAgIH1cblxuICAgICAgY3kuem9vbSh7XG4gICAgICAgIGxldmVsOiBjeS56b29tKCkgKiBNYXRoLnBvdygxMCwgZGlmZiksXG4gICAgICAgIHJlbmRlcmVkUG9zaXRpb246IHsgeDogcnBvc1swXSwgeTogcnBvc1sxXSB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgfTtcblxuICAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIHdoZXRoZXIgbW91c2Ugd2hlZWwgc2hvdWxkIHRyaWdnZXIgem9vbWluZ1xuICAvLyAtLVxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3doZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcblxuICAvLyBkaXNhYmxlIG5vbnN0YW5kYXJkIHdoZWVsIGV2ZW50c1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU1vdXNlU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gb2xkZXIgZmlyZWZveFxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Njcm9sbCcsIGZ1bmN0aW9uKGUpe1xuICAgIHIuc2Nyb2xsaW5nUGFnZSA9IHRydWU7XG5cbiAgICBjbGVhclRpbWVvdXQoIHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQgKTtcbiAgICByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgfSwgMjUwKTtcbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgICAgICAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgIHIuY3kudHJpZ2dlcihFdmVudChlLCB7XG4gICAgICB0eXBlOiAnbW91c2VvdXQnLFxuICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgfSkpO1xuICB9LCBmYWxzZSk7XG5cbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdtb3VzZW92ZXInLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICByLmN5LnRyaWdnZXIoRXZlbnQoZSwge1xuICAgICAgdHlwZTogJ21vdXNlb3ZlcicsXG4gICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICB9KSk7XG4gIH0sIGZhbHNlKTtcblxuICB2YXIgZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MTsgLy8gc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gIHZhciBkaXN0YW5jZTEsIGRpc3RhbmNlMVNxOyAvLyBpbml0aWFsIGRpc3RhbmNlIGJldHdlZW4gZmluZ2VyIDEgYW5kIGZpbmdlciAyIGZvciBwaW5jaC10by16b29tXG4gIHZhciBjZW50ZXIxLCBtb2RlbENlbnRlcjE7IC8vIGNlbnRlciBwb2ludCBvbiBzdGFydCBwaW5jaCB0byB6b29tXG4gIHZhciBvZmZzZXRMZWZ0LCBvZmZzZXRUb3A7XG4gIHZhciBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0O1xuICB2YXIgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlO1xuXG4gIHZhciBkaXN0YW5jZSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKXtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCAoeDIteDEpKih4Mi14MSkgKyAoeTIteTEpKih5Mi15MSkgKTtcbiAgfTtcblxuICB2YXIgZGlzdGFuY2VTcSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKXtcbiAgICByZXR1cm4gKHgyLXgxKSooeDIteDEpICsgKHkyLXkxKSooeTIteTEpO1xuICB9O1xuXG4gIHZhciB0b3VjaHN0YXJ0SGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm9kZXMgPSByLmdldENhY2hlZE5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gci5nZXRDYWNoZWRFZGdlcygpO1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuXG4gICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgaWYgKGUudG91Y2hlc1syXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG5cblxuICAgIC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgICBpZiggZS50b3VjaGVzWzFdICl7XG5cbiAgICAgIC8vIGFueXRoaW5nIGluIHRoZSBzZXQgb2YgZHJhZ2dlZCBlbGVzIHNob3VsZCBiZSByZWxlYXNlZFxuICAgICAgdmFyIHJlbGVhc2UgPSBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICBlbGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICBlbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgaWYoIGVsZXNbaV0uYWN0aXZlKCkgKXsgZWxlc1tpXS51bmFjdGl2YXRlKCk7IH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJlbGVhc2Uobm9kZXMpO1xuICAgICAgcmVsZWFzZShlZGdlcyk7XG5cbiAgICAgIHZhciBvZmZzZXRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICBjb250YWluZXJXaWR0aCA9IG9mZnNldHNbMl07XG4gICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuXG4gICAgICBmMXgxID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjF5MSA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgZjJ5MSA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuXG4gICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPVxuICAgICAgICAgICAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aFxuICAgICAgICAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aFxuICAgICAgICAmJiAwIDw9IGYxeTEgJiYgZjF5MSA8PSBjb250YWluZXJIZWlnaHRcbiAgICAgICAgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICA7XG5cbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgZGlzdGFuY2UxU3EgPSBkaXN0YW5jZVNxKCBmMXgxLCBmMXkxLCBmMngxLCBmMnkxICk7XG4gICAgICBjZW50ZXIxID0gWyAoZjF4MSArIGYyeDEpLzIsIChmMXkxICsgZjJ5MSkvMiBdO1xuICAgICAgbW9kZWxDZW50ZXIxID0gW1xuICAgICAgICAoY2VudGVyMVswXSAtIHBhbi54KSAvIHpvb20sXG4gICAgICAgIChjZW50ZXIxWzFdIC0gcGFuLnkpIC8gem9vbVxuICAgICAgXTtcblxuICAgICAgLy8gY29uc2lkZXIgY29udGV4dCB0YXBcbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkID0gMjAwO1xuICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGRTcSA9IGN4dERpc3RUaHJlc2hvbGQgKiBjeHREaXN0VGhyZXNob2xkO1xuICAgICAgaWYoIGRpc3RhbmNlMVNxIDwgY3h0RGlzdFRocmVzaG9sZFNxICYmICFlLnRvdWNoZXNbMl0gKXtcblxuICAgICAgICB2YXIgbmVhcjEgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBuZWFyMiA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1syXSwgbm93WzNdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICBpZiggbmVhcjEgJiYgbmVhcjEuaXNOb2RlKCkgKXtcbiAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLnRyaWdnZXIoIEV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KSApO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjE7XG5cbiAgICAgICAgfSBlbHNlIGlmKCBuZWFyMiAmJiBuZWFyMi5pc05vZGUoKSApe1xuICAgICAgICAgIG5lYXIyLmFjdGl2YXRlKCkudHJpZ2dlciggRXZlbnQoZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0pICk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMjtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIEV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KSApO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gdHJ1ZTtcbiAgICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG5cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkge1xuXG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcblxuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXI7XG5cbiAgICAgICAgaWYoIG5lYXIuaXNOb2RlKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUobmVhcikgKXtcblxuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyA9IFtdO1xuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiggbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAvLyByZXNldCBkcmFnIGVsZW1lbnRzLCBzaW5jZSBuZWFyIHdpbGwgYmUgYWRkZWQgYWdhaW5cblxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzTm9kZSgpICYmIHRoaXMuc2VsZWN0ZWQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IHNlbGVjdGVkTm9kZXNba107XG5cbiAgICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKHNlbGVjdGVkTm9kZSkgKXtcbiAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBzZWxlY3RlZE5vZGUsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9ICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggbmVhciwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzIH0gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZWFyLnRyaWdnZXIoIEV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdncmFiJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0pICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJpZ2dlckV2ZW50cyggbmVhciwgWyd0b3VjaHN0YXJ0JywgJ3RhcHN0YXJ0JywgJ3Ztb3VzZWRvd24nXSwgZSwge1xuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0gKTtcblxuICAgICAgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9O1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cblxuICAgICAgLy8gVGFwLCB0YXBob2xkXG4gICAgICAvLyAtLS0tLVxuXG4gICAgICBmb3IgKHZhciBpPTA7IGk8bm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVhcmxpZXJbaV0gPSBub3dbaV07XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV0gPSBub3dbaV07XG4gICAgICB9XG5cbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAgIGNsZWFyVGltZW91dCggci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgKTtcbiAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZVxuICAgICAgICAgICAgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcbiAgICAgICAgKXtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKCByLnRvdWNoRGF0YS5zdGFydCwgWyd0YXBob2xkJ10sIGUsIHtcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0gKTtcblxuICAgICAgICAgIGlmICghci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICB9XG5cbiAgfSwgZmFsc2UpO1xuXG4gIHZhciB0b3VjaG1vdmVIYW5kbGVyO1xuICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaG1vdmUnLCB0b3VjaG1vdmVIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuXG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7IHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgdmFyIGRpc3AgPSBbXTsgZm9yICh2YXIgaj0wO2o8bm93Lmxlbmd0aDtqKyspIHsgZGlzcFtqXSA9IG5vd1tqXSAtIGVhcmxpZXJbal07IH1cbiAgICB2YXIgc3RhcnRQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uO1xuICAgIHZhciBkeCA9IG5vd1swXSAtIHN0YXJ0UG9zWzBdO1xuICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgIHZhciBkeSA9IG5vd1sxXSAtIHN0YXJ0UG9zWzFdO1xuICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgIC8vIGNvbnRleHQgc3dpcGUgY2FuY2VsbGluZ1xuICAgIGlmKCBjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIC8vIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgdmFyIGZhY3RvclNxID0gZGlzdGFuY2UyU3EgLyBkaXN0YW5jZTFTcTtcblxuICAgICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxNTA7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZFNxID0gZGlzdFRocmVzaG9sZCAqIGRpc3RUaHJlc2hvbGQ7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkID0gMS41O1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZFNxID0gZmFjdG9yVGhyZXNob2xkICogZmFjdG9yVGhyZXNob2xkO1xuXG4gICAgICAvLyBjYW5jZWwgY3R4IGdlc3R1cmVzIGlmIHRoZSBkaXN0YW5jZSBiL3QgdGhlIGZpbmdlcnMgaW5jcmVhc2VzXG4gICAgICBpZiggZmFjdG9yU3EgPj0gZmFjdG9yVGhyZXNob2xkU3EgfHwgZGlzdGFuY2UyU3EgPj0gZGlzdFRocmVzaG9sZFNxICl7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQudW5hY3RpdmF0ZSgpOyByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7IH1cbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICAgIHZhciBjeHRFdnQgPSBFdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY29udGV4dCBzd2lwZVxuICAgIGlmKCBjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgdmFyIGN4dEV2dCA9IEV2ZW50KGUsIHtcbiAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgIH0pO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgaWYoICFyLnRvdWNoRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIudG91Y2hEYXRhLmN4dE92ZXIgKXtcblxuICAgICAgICBpZiggci50b3VjaERhdGEuY3h0T3ZlciApe1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIudHJpZ2dlciggRXZlbnQoZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgbmVhci50cmlnZ2VyKCBFdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgfSkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIC8vIGJveCBzZWxlY3Rpb25cbiAgICB9IGVsc2UgaWYoIGNhcHR1cmUgJiYgZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSApe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMubGFzdFRocmVlVG91Y2ggPSArbmV3IERhdGUoKTtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgIGlmKCAhc2VsZWN0IHx8IHNlbGVjdC5sZW5ndGggPT09IDAgfHwgc2VsZWN0WzBdID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgc2VsZWN0WzBdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkvMztcbiAgICAgICAgc2VsZWN0WzFdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkvMztcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkvMyArIDE7XG4gICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pLzMgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkvMztcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkvMztcbiAgICAgIH1cblxuICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IHRydWU7XG5cbiAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAvLyBwaW5jaCB0byB6b29tXG4gICAgfSBlbHNlIGlmICggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICkgeyAvLyB0d28gZmluZ2VycyA9PiBwaW5jaCB0byB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG5cbiAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgIGlmKCBkcmFnZ2VkRWxlcyApe1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgIGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gKHgyLCB5MikgZm9yIGZpbmdlcnMgMSBhbmQgMlxuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG5cblxuICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAvLyB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuICAgICAgdmFyIGZhY3RvciA9IGRpc3RhbmNlMiAvIGRpc3RhbmNlMTtcblxuICAgICAgaWYoIGZhY3RvciAhPSAxICYmIHR3b0ZpbmdlcnNTdGFydEluc2lkZSl7XG4gICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgdmFyIGRmMXkgPSBmMXkyIC0gZjF5MTtcblxuICAgICAgICAvLyBkZWx0YSBmaW5nZXIgMlxuICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICB2YXIgZGYyeSA9IGYyeTIgLSBmMnkxO1xuXG4gICAgICAgIC8vIHRyYW5zbGF0aW9uIGlzIHRoZSBub3JtYWxpc2VkIHZlY3RvciBvZiB0aGUgdHdvIGZpbmdlcnMgbW92ZW1lbnRcbiAgICAgICAgLy8gaS5lLiBzbyBwaW5jaGluZyBjYW5jZWxzIG91dCBhbmQgbW92aW5nIHRvZ2V0aGVyIHBhbnNcbiAgICAgICAgdmFyIHR4ID0gKGRmMXggKyBkZjJ4KS8yO1xuICAgICAgICB2YXIgdHkgPSAoZGYxeSArIGRmMnkpLzI7XG5cbiAgICAgICAgLy8gYWRqdXN0IGZhY3RvciBieSB0aGUgc3BlZWQgbXVsdGlwbGllclxuICAgICAgICAvLyB2YXIgc3BlZWQgPSAxLjU7XG4gICAgICAgIC8vIGlmKCBmYWN0b3IgPiAxICl7XG4gICAgICAgIC8vICAgZmFjdG9yID0gKGZhY3RvciAtIDEpICogc3BlZWQgKyAxO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgIGZhY3RvciA9IDEgLSAoMSAtIGZhY3RvcikgKiBzcGVlZDtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIG5vdyBjYWxjdWxhdGUgdGhlIHpvb21cbiAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgdmFyIHBhbjEgPSBjeS5wYW4oKTtcblxuICAgICAgICAvLyB0aGUgbW9kZWwgY2VudGVyIHBvaW50IGNvbnZlcnRlZCB0byB0aGUgY3VycmVudCByZW5kZXJlZCBwb3NcbiAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgdmFyIGN0cnkgPSBtb2RlbENlbnRlcjFbMV0gKiB6b29tMSArIHBhbjEueTtcblxuICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICB4OiAtem9vbTIvem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgeTogLXpvb20yL3pvb20xICogKGN0cnkgLSBwYW4xLnkgLSB0eSkgKyBjdHJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgICBpZiggZHJhZ2dlZEVsZXMgKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGRFaV9wID0gZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGU7XG5cbiAgICAgICAgICAgIGRFaV9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRFaV9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgfSB9XG5cbiAgICAgICAgICB2YXIgc3RhcnRfcCA9IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlO1xuICAgICAgICAgIHN0YXJ0X3AuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgc3RhcnRfcC5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgc3RhcnRfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFxuICAgICAgICAgICAgLnRyaWdnZXIoJ2ZyZWUnKVxuICAgICAgICAgICAgLnRyaWdnZXIoJ3VuYWN0aXZhdGUnKVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5LnZpZXdwb3J0KHtcbiAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICBwYW46IHBhbjIsXG4gICAgICAgICAgY2FuY2VsT25GYWlsZWRab29tOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlMjtcbiAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgIGYxeTEgPSBmMXkyO1xuICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgZjJ5MSA9IGYyeTI7XG5cbiAgICAgICAgci5waW5jaGluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlLXByb2plY3RcbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgIHZhciBsYXN0ID0gci50b3VjaERhdGEubGFzdDtcbiAgICAgIHZhciBuZWFyID0gbmVhciB8fCByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmKCBzdGFydCAhPSBudWxsICl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZ2dpbmcgbm9kZXNcbiAgICAgIGlmKCBzdGFydCAhPSBudWxsICYmIHN0YXJ0Ll9wcml2YXRlLmdyb3VwID09ICdub2RlcycgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpICl7XG5cbiAgICAgICAgaWYoIHJkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMiApeyAvLyB0aGVuIGRyYWdnaW5nIGNhbiBoYXBwZW5cbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG5cbiAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZSA9IGRyYWdnZWRFbGVzW2tdO1xuXG4gICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIGRyYWdnZWRFbGUsIHsgaW5EcmFnTGF5ZXI6IHRydWUgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoZHJhZ2dlZEVsZSkgJiYgZHJhZ2dlZEVsZS5pc05vZGUoKSAmJiBkcmFnZ2VkRWxlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRyYWdnZWRFbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgICAgIHZhciB1cGRhdGVQb3MgPSAhZHJhZ2dlZEVsZS5pc1BhcmVudCgpO1xuXG4gICAgICAgICAgICAgIGlmKCB1cGRhdGVQb3MgJiYgaXMubnVtYmVyKGRpc3BbMF0pICYmIGlzLm51bWJlcihkaXNwWzFdKSApe1xuICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgIGRQb3MueSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApe1xuICAgICAgICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgIGlmKCB1cGRhdGVQb3MgJiYgaXMubnVtYmVyKGRyYWdEZWx0YVswXSkgJiYgaXMubnVtYmVyKGRyYWdEZWx0YVsxXSkgKXtcbiAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRjb2wgPSBDb2xsZWN0aW9uKGN5LCBkcmFnZ2VkRWxlcyk7XG5cbiAgICAgICAgICB0Y29sLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgdGNvbC50cmlnZ2VyKCdwb3NpdGlvbiBkcmFnJyk7XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuXG4gICAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG5cbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gPT0gZWFybGllclswXVxuICAgICAgICAgICAgJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSA9PSBlYXJsaWVyWzFdXG4gICAgICAgICAgKXtcblxuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMF0gKTtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzFdICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRvdWNobW92ZVxuICAgICAge1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKCAoc3RhcnQgfHwgbmVhciksIFsndG91Y2htb3ZlJywgJ3RhcGRyYWcnLCAndm1vdXNlbW92ZSddLCBlLCB7XG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0gKTtcblxuICAgICAgICBpZiAobmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgaWYgKGxhc3QpIHsgbGFzdC50cmlnZ2VyKEV2ZW50KGUsIHsgdHlwZTogJ3RhcGRyYWdvdXQnLCBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSkpOyB9XG4gICAgICAgICAgaWYgKG5lYXIpIHsgbmVhci50cmlnZ2VyKEV2ZW50KGUsIHsgdHlwZTogJ3RhcGRyYWdvdmVyJywgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9IH0pKTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgci50b3VjaERhdGEubGFzdCA9IG5lYXI7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIGNhbmNlbCB0YXBob2xkXG4gICAgICBmb3IgKHZhciBpPTA7aTxub3cubGVuZ3RoO2krKykge1xuICAgICAgICBpZiggbm93W2ldXG4gICAgICAgICAgJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXVxuICAgICAgICAgICYmIHJkaXN0MiA+IHIudG91Y2hUYXBUaHJlc2hvbGQyICl7XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwYW5uaW5nXG4gICAgICBpZihcbiAgICAgICAgICBjYXB0dXJlXG4gICAgICAgICAgJiYgKCBzdGFydCA9PSBudWxsIHx8IHN0YXJ0LmlzRWRnZSgpIClcbiAgICAgICAgICAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpXG4gICAgICApe1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiggci5zd2lwZVBhbm5pbmcgKXtcbiAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIGlmKCByZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDIgKXtcbiAgICAgICAgICByLnN3aXBlUGFubmluZyA9IHRydWU7XG5cbiAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICB5OiBkeSAqIHpvb21cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgICBpZiggIXIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiApe1xuICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgIG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGo9MDsgajxub3cubGVuZ3RoOyBqKyspIHsgZWFybGllcltqXSA9IG5vd1tqXTsgfVxuICAgIC8vci5yZWRyYXcoKTtcblxuICB9LCBmYWxzZSk7XG5cbiAgdmFyIHRvdWNoY2FuY2VsSGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2hjYW5jZWwnLCB0b3VjaGNhbmNlbEhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICBpZiggc3RhcnQgKXtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0b3VjaGVuZEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoZW5kJywgdG91Y2hlbmRIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuXG4gICAgaWYoIGNhcHR1cmUgKXtcbiAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuXG4gICAgci5zd2lwZVBhbm5pbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcblxuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuICAgIGlmKCBzdGFydCApe1xuICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBjdHhUYXBlbmQ7XG4gICAgaWYoIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgY3R4VGFwZW5kID0gRXZlbnQoZSwge1xuICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICB9KTtcblxuICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnRyaWdnZXIoIGN0eFRhcGVuZCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhci50b3VjaERhdGEuY3h0RHJhZ2dlZCApe1xuICAgICAgICB2YXIgY3R4VGFwID0gRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgICBzdGFydC50cmlnZ2VyKCBjdHhUYXAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjdHhUYXAgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuXG4gICAgICByLnJlZHJhdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcbiAgICBpZiggIWUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgci50b3VjaERhdGEuc2VsZWN0aW5nICl7XG4gICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcblxuICAgICAgdmFyIG5ld2x5U2VsZWN0ZWQgPSBbXTtcbiAgICAgIHZhciBib3ggPSByLmdldEFsbEluQm94KCBzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10gKTtcblxuICAgICAgc2VsZWN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzFdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzJdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzNdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzRdID0gMDtcblxuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGk8IGJveC5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYoIGJveFtpXS5fcHJpdmF0ZS5zZWxlY3RhYmxlICl7XG4gICAgICAgICAgbmV3bHlTZWxlY3RlZC5wdXNoKCBib3hbaV0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV3bHlTZWxDb2wgPSBDb2xsZWN0aW9uKCBjeSwgbmV3bHlTZWxlY3RlZCApO1xuXG4gICAgICBuZXdseVNlbENvbC5zZWxlY3QoKTtcblxuICAgICAgaWYoIG5ld2x5U2VsQ29sLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlU3RhcnRTdHlsZSA9IGZhbHNlO1xuXG4gICAgaWYoIHN0YXJ0ICE9IG51bGwgKXtcbiAgICAgIHN0YXJ0Ll9wcml2YXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgdXBkYXRlU3RhcnRTdHlsZSA9IHRydWU7XG4gICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1sxXSkge1xuXG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcblxuICAgIC8vIExhc3QgdG91Y2ggcmVsZWFzZWRcbiAgICB9IGVsc2UgaWYgKCFlLnRvdWNoZXNbMF0pIHtcblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcblxuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCApIHtcblxuICAgICAgICB2YXIgc3RhcnRXYXNHcmFiYmVkID0gc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZDtcblxuICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKCBkcmFnZ2VkRWxlcyApO1xuXG4gICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcblxuICAgICAgICBpZiggc3RhcnRXYXNHcmFiYmVkICl7XG4gICAgICAgICAgc3RhcnQudHJpZ2dlcignZnJlZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlckV2ZW50cyggc3RhcnQsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJ10sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcblxuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICAgIHRyaWdnZXJFdmVudHMoIG5lYXIsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJ10sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBkeCA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gLSBub3dbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gLSBub3dbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgICAvLyBQcmVwYXJlIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IHRvdWNoZWQgbm9kZSwgb25seSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmFnZ2VkIHBhc3QgYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbFxuICAgICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IGRyYWcgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgJiYgc3RhcnQuX3ByaXZhdGUuc2VsZWN0YWJsZVxuICAgICAgICAgICYmIHJkaXN0MiA8IHIudG91Y2hUYXBUaHJlc2hvbGQyXG4gICAgICAgICAgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICkge1xuXG4gICAgICAgIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnICl7XG4gICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5tZXJnZSggc3RhcnQgKS51bnNlbGVjdCgpO1xuICAgICAgICAgIHN0YXJ0LnNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCBzdGFydC5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICBzdGFydC51bnNlbGVjdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydC5zZWxlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVTdGFydFN0eWxlID0gdHJ1ZTtcblxuXG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBUYXAgZXZlbnQsIHJvdWdobHkgc2FtZSBhcyBtb3VzZSBjbGljayBldmVudCBmb3IgdG91Y2hcbiAgICAgIGlmKCAhci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCApe1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKCBzdGFydCwgWyd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKyApeyBlYXJsaWVyW2pdID0gbm93W2pdOyB9XG5cbiAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTsgLy8gcmVzZXQgZm9yIG5leHQgbW91c2Vkb3duXG5cbiAgICBpZiggZS50b3VjaGVzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgfVxuXG4gICAgaWYoIHVwZGF0ZVN0YXJ0U3R5bGUgJiYgc3RhcnQgKXtcbiAgICAgIHN0YXJ0LnVwZGF0ZVN0eWxlKGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiggZS50b3VjaGVzLmxlbmd0aCA8IDIgKXtcbiAgICAgIHIucGluY2hpbmcgPSBmYWxzZTtcbiAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvL3IucmVkcmF3KCk7XG5cbiAgfSwgZmFsc2UpO1xuXG4gIC8vIGZhbGxiYWNrIGNvbXBhdGliaWxpdHkgbGF5ZXIgZm9yIG1zIHBvaW50ZXIgZXZlbnRzXG4gIGlmKCB0eXBlb2YgVG91Y2hFdmVudCA9PT0gJ3VuZGVmaW5lZCcgKXtcblxuICAgIHZhciBwb2ludGVycyA9IFtdO1xuXG4gICAgdmFyIG1ha2VUb3VjaCA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnRYOiBlLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IGUuY2xpZW50WSxcbiAgICAgICAgZm9yY2U6IDEsXG4gICAgICAgIGlkZW50aWZpZXI6IGUucG9pbnRlcklkLFxuICAgICAgICBwYWdlWDogZS5wYWdlWCxcbiAgICAgICAgcGFnZVk6IGUucGFnZVksXG4gICAgICAgIHJhZGl1c1g6IGUud2lkdGgvMixcbiAgICAgICAgcmFkaXVzWTogZS5oZWlnaHQvMixcbiAgICAgICAgc2NyZWVuWDogZS5zY3JlZW5YLFxuICAgICAgICBzY3JlZW5ZOiBlLnNjcmVlblksXG4gICAgICAgIHRhcmdldDogZS50YXJnZXRcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBtYWtlUG9pbnRlciA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBldmVudDogZSxcbiAgICAgICAgdG91Y2g6IG1ha2VUb3VjaChlKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZFBvaW50ZXIgPSBmdW5jdGlvbiggZSApe1xuICAgICAgcG9pbnRlcnMucHVzaCggbWFrZVBvaW50ZXIoZSkgKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmdW5jdGlvbiggZSApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcCA9IHBvaW50ZXJzW2ldO1xuXG4gICAgICAgIGlmKCBwLmV2ZW50LnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQgKXtcbiAgICAgICAgICBwb2ludGVycy5zcGxpY2UoIGksIDEgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVBvaW50ZXIgPSBmdW5jdGlvbiggZSApe1xuICAgICAgdmFyIHAgPSBwb2ludGVycy5maWx0ZXIoZnVuY3Rpb24oIHAgKXtcbiAgICAgICAgcmV0dXJuIHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZDtcbiAgICAgIH0pWzBdO1xuXG4gICAgICBwLmV2ZW50ID0gZTtcbiAgICAgIHAudG91Y2ggPSBtYWtlVG91Y2goZSk7XG4gICAgfTtcblxuICAgIHZhciBhZGRUb3VjaGVzVG9FdmVudCA9IGZ1bmN0aW9uKCBlICl7XG4gICAgICBlLnRvdWNoZXMgPSBwb2ludGVycy5tYXAoZnVuY3Rpb24oIHAgKXtcbiAgICAgICAgcmV0dXJuIHAudG91Y2g7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHBvaW50ZXJJc01vdXNlID0gZnVuY3Rpb24oIGUgKXtcbiAgICAgIHJldHVybiBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGUucG9pbnRlclR5cGUgPT09IDQ7XG4gICAgfTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgIGlmKCBwb2ludGVySXNNb3VzZShlKSApeyByZXR1cm47IH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgYWRkUG9pbnRlciggZSApO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudCggZSApO1xuICAgICAgdG91Y2hzdGFydEhhbmRsZXIoIGUgKTtcbiAgICB9KTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcnVwJywgZnVuY3Rpb24oZSl7XG4gICAgICBpZiggcG9pbnRlcklzTW91c2UoZSkgKXsgcmV0dXJuOyB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICByZW1vdmVQb2ludGVyKCBlICk7XG5cbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KCBlICk7XG4gICAgICB0b3VjaGVuZEhhbmRsZXIoIGUgKTtcbiAgICB9KTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmNhbmNlbCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgaWYoIHBvaW50ZXJJc01vdXNlKGUpICl7IHJldHVybjsgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgcmVtb3ZlUG9pbnRlciggZSApO1xuXG4gICAgICBhZGRUb3VjaGVzVG9FdmVudCggZSApO1xuICAgICAgdG91Y2hjYW5jZWxIYW5kbGVyKCBlICk7XG4gICAgfSk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJtb3ZlJywgZnVuY3Rpb24oZSl7XG4gICAgICBpZiggcG9pbnRlcklzTW91c2UoZSkgKXsgcmV0dXJuOyB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHVwZGF0ZVBvaW50ZXIoIGUgKTtcblxuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoIGUgKTtcbiAgICAgIHRvdWNobW92ZUhhbmRsZXIoIGUgKTtcbiAgICB9KTtcblxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG1hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLnJlZ2lzdGVyTm9kZVNoYXBlcyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBub2RlU2hhcGVzID0gdGhpcy5ub2RlU2hhcGVzID0ge307XG4gIHZhciByZW5kZXJlciA9IHRoaXM7XG5cbiAgbm9kZVNoYXBlc1snZWxsaXBzZSddID0ge1xuICAgIG5hbWU6ICdlbGxpcHNlJyxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgICByZW5kZXJlci5ub2RlU2hhcGVJbXBsKCB0aGlzLm5hbWUgKSggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiggbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nICl7XG4gICAgICByZXR1cm4gbWF0aC5pbnRlcnNlY3RMaW5lRWxsaXBzZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCAvIDIgKyBwYWRkaW5nLFxuICAgICAgICBoZWlnaHQgLyAyICsgcGFkZGluZylcbiAgICAgIDtcbiAgICB9LFxuXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkgKXtcbiAgICAgIHggLT0gY2VudGVyWDtcbiAgICAgIHkgLT0gY2VudGVyWTtcblxuICAgICAgeCAvPSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB5IC89IChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG5cbiAgICAgIHJldHVybiB4KnggKyB5KnkgPD0gMTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQb2x5Z29uKCBuYW1lLCBwb2ludHMgKXtcbiAgICByZXR1cm4gKCBub2RlU2hhcGVzW25hbWVdID0ge1xuICAgICAgbmFtZTogbmFtZSxcblxuICAgICAgcG9pbnRzOiBwb2ludHMsXG5cbiAgICAgIGRyYXc6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgICAgIHJlbmRlcmVyLm5vZGVTaGFwZUltcGwoJ3BvbHlnb24nKSggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgdGhpcy5wb2ludHMgKTtcbiAgICAgIH0sXG5cbiAgICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcgKXtcbiAgICAgICAgcmV0dXJuIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoXG4gICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgdGhpcy5wb2ludHMsXG4gICAgICAgICAgICBub2RlWCxcbiAgICAgICAgICAgIG5vZGVZLFxuICAgICAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgcGFkZGluZylcbiAgICAgICAgICA7XG4gICAgICB9LFxuXG4gICAgICBjaGVja1BvaW50OiBmdW5jdGlvbiggeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSApe1xuICAgICAgICByZXR1cm4gbWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1tuYW1lXS5wb2ludHMsXG4gICAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZylcbiAgICAgICAgO1xuICAgICAgfVxuICAgIH0gKTtcbiAgfVxuXG4gIGdlbmVyYXRlUG9seWdvbiggJ3RyaWFuZ2xlJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkgKTtcblxuICBnZW5lcmF0ZVBvbHlnb24oICdzcXVhcmUnLCBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSApO1xuICBub2RlU2hhcGVzWydyZWN0YW5nbGUnXSA9IG5vZGVTaGFwZXNbJ3NxdWFyZSddO1xuXG4gIG5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgbmFtZTogJ3JvdW5kcmVjdGFuZ2xlJyxcblxuICAgIHBvaW50czogbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG5cbiAgICBkcmF3OiBmdW5jdGlvbiggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApe1xuICAgICAgcmVuZGVyZXIubm9kZVNoYXBlSW1wbCggdGhpcy5uYW1lICkoIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKTtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24oIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZyApe1xuICAgICAgcmV0dXJuIG1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIHBhZGRpbmcpXG4gICAgICA7XG4gICAgfSxcblxuICAgIC8vIExvb2tzIGxpa2UgdGhlIHdpZHRoIHBhc3NlZCBpbnRvIHRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgdGhlIHRvdGFsIHdpZHRoIC8gMlxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSApe1xuXG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gbWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKG1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGNvcm5lclJhZGl1cywgWzAsIC0xXSwgcGFkZGluZykgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIHZCb3hcbiAgICAgIGlmIChtYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogY29ybmVyUmFkaXVzLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbiggeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZyApe1xuICAgICAgICB4IC09IGNlbnRlclg7XG4gICAgICAgIHkgLT0gY2VudGVyWTtcblxuICAgICAgICB4IC89ICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgICAgeSAvPSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuXG4gICAgICAgIHJldHVybiAoeCp4ICsgeSp5IDw9IDEpO1xuICAgICAgfTtcblxuXG4gICAgICAvLyBDaGVjayB0b3AgbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nKSApe1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0b3AgcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykgKXtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpICl7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpICl7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgZ2VuZXJhdGVQb2x5Z29uKCAnZGlhbW9uZCcsIFtcbiAgICAwLCAxLFxuICAgIDEsIDAsXG4gICAgMCwgLTEsXG4gICAgLTEsIDBcbiAgXSApO1xuXG4gIGdlbmVyYXRlUG9seWdvbiggJ3BlbnRhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkgKTtcblxuICBnZW5lcmF0ZVBvbHlnb24oICdoZXhhZ29uJywgbWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCkgKTtcblxuICBnZW5lcmF0ZVBvbHlnb24oICdoZXB0YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApICk7XG5cbiAgZ2VuZXJhdGVQb2x5Z29uKCAnb2N0YWdvbicsIG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApICk7XG5cbiAgdmFyIHN0YXI1UG9pbnRzID0gbmV3IEFycmF5KDIwKTtcbiAge1xuICAgIHZhciBvdXRlclBvaW50cyA9IG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCAwKTtcbiAgICB2YXIgaW5uZXJQb2ludHMgPSBtYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgTWF0aC5QSSAvIDUpO1xuXG4gICAgLy8gT3V0ZXIgcmFkaXVzIGlzIDE7IGlubmVyIHJhZGl1cyBvZiBzdGFyIGlzIHNtYWxsZXJcbiAgICB2YXIgaW5uZXJSYWRpdXMgPSAwLjUgKiAoMyAtIE1hdGguc3FydCg1KSk7XG4gICAgaW5uZXJSYWRpdXMgKj0gMS41NztcblxuICAgIGZvciAodmFyIGk9MDtpPGlubmVyUG9pbnRzLmxlbmd0aC8yO2krKyApe1xuICAgICAgaW5uZXJQb2ludHNbaSoyXSAqPSBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUG9pbnRzW2kqMisxXSAqPSBpbm5lclJhZGl1cztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpPTA7aTwyMC80O2krKyApe1xuICAgICAgc3RhcjVQb2ludHNbaSo0XSA9IG91dGVyUG9pbnRzW2kqMl07XG4gICAgICBzdGFyNVBvaW50c1tpKjQrMV0gPSBvdXRlclBvaW50c1tpKjIrMV07XG5cbiAgICAgIHN0YXI1UG9pbnRzW2kqNCsyXSA9IGlubmVyUG9pbnRzW2kqMl07XG4gICAgICBzdGFyNVBvaW50c1tpKjQrM10gPSBpbm5lclBvaW50c1tpKjIrMV07XG4gICAgfVxuICB9XG5cbiAgc3RhcjVQb2ludHMgPSBtYXRoLmZpdFBvbHlnb25Ub1NxdWFyZSggc3RhcjVQb2ludHMgKTtcblxuICBnZW5lcmF0ZVBvbHlnb24oICdzdGFyJywgc3RhcjVQb2ludHMgKTtcblxuICBnZW5lcmF0ZVBvbHlnb24oICd2ZWUnLCBbXG4gICAgLTEsIC0xLFxuICAgIDAsIC0wLjMzMyxcbiAgICAxLCAtMSxcbiAgICAwLCAxXG4gIF0gKTtcblxuICBnZW5lcmF0ZVBvbHlnb24oICdyaG9tYm9pZCcsIFtcbiAgICAtMSwgLTEsXG4gICAgMC4zMzMsIC0xLFxuICAgIDEsIDEsXG4gICAgLTAuMzMzLCAxXG4gIF0gKTtcblxuICBub2RlU2hhcGVzLm1ha2VQb2x5Z29uID0gZnVuY3Rpb24oIHBvaW50cyApe1xuXG4gICAgLy8gdXNlIGNhY2hpbmcgb24gdXNlci1zcGVjaWZpZWQgcG9seWdvbnMgc28gdGhleSBhcmUgYXMgZmFzdCBhcyBuYXRpdmUgc2hhcGVzXG5cbiAgICB2YXIga2V5ID0gcG9pbnRzLmpvaW4oJyQnKTtcbiAgICB2YXIgbmFtZSA9ICdwb2x5Z29uLScgKyBrZXk7XG4gICAgdmFyIHNoYXBlO1xuXG4gICAgaWYoIChzaGFwZSA9IG5vZGVTaGFwZXNbbmFtZV0pICl7IC8vIGdvdCBjYWNoZWQgc2hhcGVcbiAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYW5kIGNhY2hlIG5ldyBzaGFwZVxuICAgIHJldHVybiBnZW5lcmF0ZVBvbHlnb24oIG5hbWUsIHBvaW50cyApO1xuICB9O1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJyk7XG5cbnZhciBCUnAgPSB7fTtcblxuQlJwLnRpbWVUb1JlbmRlciA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLnJlZHJhd1RvdGFsVGltZSAvIHRoaXMucmVkcmF3Q291bnQ7XG59O1xuXG52YXIgbWluUmVkcmF3TGltaXQgPSAxMDAwLzYwOyAvLyBwZW9wbGUgY2FuJ3Qgc2VlIG11Y2ggYmV0dGVyIHRoYW4gNjBmcHNcbnZhciBtYXhSZWRyYXdMaW1pdCA9IDEwMDA7ICAvLyBkb24ndCBjYXAgbWF4IGIvYyBpdCdzIG1vcmUgaW1wb3J0YW50IHRvIGJlIHJlc3BvbnNpdmUgdGhhbiBzbW9vdGhcblxuQlJwLnJlZHJhdyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHV0aWwuc3RhdGljRW1wdHlPYmplY3QoKTtcblxuICB2YXIgciA9IHRoaXM7XG4gIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuXG4gIGlmKCByLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXsgci5hdmVyYWdlUmVkcmF3VGltZSA9IDA7IH1cbiAgaWYoIHIubGFzdFJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyByLmxhc3RSZWRyYXdUaW1lID0gMDsgfVxuXG4gIHZhciByZWRyYXdMaW1pdCA9IHIubGFzdFJlZHJhd1RpbWU7IC8vIGVzdGltYXRlIHRoZSBpZGVhbCByZWRyYXcgbGltaXQgYmFzZWQgb24gaG93IGZhc3Qgd2UgY2FuIGRyYXdcbiAgcmVkcmF3TGltaXQgPSBtaW5SZWRyYXdMaW1pdCA+IHJlZHJhd0xpbWl0ID8gbWluUmVkcmF3TGltaXQgOiByZWRyYXdMaW1pdDtcbiAgcmVkcmF3TGltaXQgPSByZWRyYXdMaW1pdCA8IG1heFJlZHJhd0xpbWl0ID8gcmVkcmF3TGltaXQgOiBtYXhSZWRyYXdMaW1pdDtcblxuICBpZiggci5sYXN0RHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyByLmxhc3REcmF3VGltZSA9IDA7IH1cblxuICB2YXIgbm93VGltZSA9IERhdGUubm93KCk7XG4gIHZhciB0aW1lRWxhcHNlZCA9IG5vd1RpbWUgLSByLmxhc3REcmF3VGltZTtcbiAgdmFyIGNhbGxBZnRlckxpbWl0ID0gdGltZUVsYXBzZWQgPj0gcmVkcmF3TGltaXQ7XG5cbiAgaWYoICFmb3JjZWRDb250ZXh0ICl7XG4gICAgaWYoICFjYWxsQWZ0ZXJMaW1pdCB8fCByLmN1cnJlbnRseURyYXdpbmcgKXtcbiAgICAgIHIuc2tpcEZyYW1lID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICByLnJlcXVlc3RlZEZyYW1lID0gdHJ1ZTtcbiAgci5jdXJyZW50bHlEcmF3aW5nID0gdHJ1ZTtcbiAgci5yZW5kZXJPcHRpb25zID0gb3B0aW9ucztcbn07XG5cbkJScC5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbigpe1xuICB2YXIgciA9IHRoaXM7XG5cbiAgdmFyIHJlbmRlckZuID0gZnVuY3Rpb24oKXtcbiAgICBpZiggci5kZXN0cm95ZWQgKXsgcmV0dXJuOyB9XG5cbiAgICBpZiggci5yZXF1ZXN0ZWRGcmFtZSAmJiAhci5za2lwRnJhbWUgKXtcbiAgICAgIHZhciBzdGFydFRpbWUgPSB1dGlsLnBlcmZvcm1hbmNlTm93KCk7XG5cbiAgICAgIHIucmVuZGVyKCByLnJlbmRlck9wdGlvbnMgKTtcblxuICAgICAgdmFyIGVuZFRpbWUgPSByLmxhc3RSZWRyYXdUaW1lID0gdXRpbC5wZXJmb3JtYW5jZU5vdygpO1xuXG4gICAgICBpZiggci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiggci5yZWRyYXdDb3VudCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIucmVkcmF3Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd0NvdW50Kys7XG5cbiAgICAgIGlmKCByLnJlZHJhd1RvdGFsVGltZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIucmVkcmF3VG90YWxUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGR1cmF0aW9uID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgci5yZWRyYXdUb3RhbFRpbWUgKz0gZHVyYXRpb247XG4gICAgICByLmxhc3RSZWRyYXdUaW1lID0gZHVyYXRpb247XG5cbiAgICAgIC8vIHVzZSBhIHdlaWdodGVkIGF2ZXJhZ2Ugd2l0aCBhIGJpYXMgZnJvbSB0aGUgcHJldmlvdXMgYXZlcmFnZSBzbyB3ZSBkb24ndCBzcGlrZSBzbyBlYXNpbHlcbiAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lLzIgKyBkdXJhdGlvbi8yO1xuXG4gICAgICByLnJlcXVlc3RlZEZyYW1lID0gZmFsc2U7XG4gICAgfVxuXG4gICAgci5za2lwRnJhbWUgPSBmYWxzZTtcblxuICAgIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZW5kZXJGbiApO1xuICB9O1xuXG4gIHV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCByZW5kZXJGbiApO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENScCA9IHt9O1xuXG52YXIgaW1wbDtcblxuQ1JwLmFycm93U2hhcGVJbXBsID0gZnVuY3Rpb24oIG5hbWUgKXtcbiAgcmV0dXJuICggaW1wbCB8fCAoaW1wbCA9IHtcbiAgICAncG9seWdvbic6IGZ1bmN0aW9uKCBjb250ZXh0LCBwb2ludHMgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyggcHQueCwgcHQueSApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAndHJpYW5nbGUtYmFja2N1cnZlJzogZnVuY3Rpb24oIGNvbnRleHQsIHBvaW50cywgY29udHJvbFBvaW50ICl7XG4gICAgICB2YXIgZmlyc3RQdDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmKCBpID09PSAwICl7XG4gICAgICAgICAgZmlyc3RQdCA9IHB0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGZpcnN0UHQueCwgZmlyc3RQdC55ICk7XG4gICAgfSxcblxuICAgICd0cmlhbmdsZS10ZWUnOiBmdW5jdGlvbiggY29udGV4dCwgdHJpYW5nbGVQb2ludHMsIHRlZVBvaW50cyApe1xuICAgICAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHB0ID0gdHJpUHRzW2ldO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZWVQdHMgPSB0ZWVQb2ludHM7XG4gICAgICB2YXIgZmlyc3RUZWVQdCA9IHRlZVBvaW50c1swXTtcbiAgICAgIGNvbnRleHQubW92ZVRvKCBmaXJzdFRlZVB0LngsIGZpcnN0VGVlUHQueSApO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRlZVB0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHQgPSB0ZWVQdHNbaV07XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ2NpcmNsZSc6IGZ1bmN0aW9uKCBjb250ZXh0LCByeCwgcnksIHIgKXtcbiAgICAgIGNvbnRleHQuYXJjKHJ4LCByeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICB9XG4gIH0pIClbIG5hbWUgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbkNScC5kcmF3RWRnZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcbiAgaWYoIHJzLmJhZEJlemllciB8fCBycy5iYWRMaW5lIHx8IGlzTmFOKCBycy5hbGxwdHNbMF0gKSApeyAvLyBpTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG5cbiAgLy8gRWRnZSBsaW5lIHdpZHRoXG4gIGlmIChzdHlsZVsnd2lkdGgnXS5wZlZhbHVlIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgb3ZlcmxheVBhZGRpbmcgPSBzdHlsZVsnb3ZlcmxheS1wYWRkaW5nJ10ucGZWYWx1ZTtcbiAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gc3R5bGVbJ292ZXJsYXktb3BhY2l0eSddLnZhbHVlO1xuICB2YXIgb3ZlcmxheUNvbG9yID0gc3R5bGVbJ292ZXJsYXktY29sb3InXS52YWx1ZTtcblxuICAvLyBFZGdlIGNvbG9yICYgb3BhY2l0eVxuICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICl7XG5cbiAgICBpZiggb3ZlcmxheU9wYWNpdHkgPT09IDAgKXsgLy8gZXhpdCBlYXJseSBpZiBubyBvdmVybGF5XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSk7XG4gICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PSAnc2VsZicgJiYgIXVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgdmFyIGxpbmVDb2xvciA9IHN0eWxlWydsaW5lLWNvbG9yJ10udmFsdWU7XG5cbiAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIGxpbmVDb2xvclswXSwgbGluZUNvbG9yWzFdLCBsaW5lQ29sb3JbMl0sIHN0eWxlLm9wYWNpdHkudmFsdWUpO1xuXG4gICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICB9XG5cbiAgdmFyIGVkZ2VXaWR0aCA9IHN0eWxlWyd3aWR0aCddLnBmVmFsdWUgKyAoZHJhd092ZXJsYXlJbnN0ZWFkID8gMiAqIG92ZXJsYXlQYWRkaW5nIDogMCk7XG4gIHZhciBsaW5lU3R5bGUgPSBkcmF3T3ZlcmxheUluc3RlYWQgPyAnc29saWQnIDogc3R5bGVbJ2xpbmUtc3R5bGUnXS52YWx1ZTtcbiAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG5cbiAgdmFyIHNoYWRvd0JsdXIgPSBzdHlsZVsnc2hhZG93LWJsdXInXS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T3BhY2l0eSA9IHN0eWxlWydzaGFkb3ctb3BhY2l0eSddLnZhbHVlO1xuICB2YXIgc2hhZG93Q29sb3IgPSBzdHlsZVsnc2hhZG93LWNvbG9yJ10udmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteCddLnBmVmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteSddLnBmVmFsdWU7XG5cbiAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAgc2hhZG93Q29sb3IsIGRyYXdPdmVybGF5SW5zdGVhZCA/IDAgOiBzaGFkb3dPcGFjaXR5LCBzaGFkb3dCbHVyLCBzaGFkb3dPZmZzZXRYLCBzaGFkb3dPZmZzZXRZKTtcblxuICB0aGlzLmRyYXdFZGdlUGF0aChcbiAgICBlZGdlLFxuICAgIGNvbnRleHQsXG4gICAgcnMuYWxscHRzLFxuICAgIGxpbmVTdHlsZSxcbiAgICBlZGdlV2lkdGhcbiAgKTtcblxuICB0aGlzLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCk7XG5cbiAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAndHJhbnNwYXJlbnQnLCAwKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG5cbn07XG5cblxuQ1JwLmRyYXdFZGdlUGF0aCA9IGZ1bmN0aW9uKGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSwgd2lkdGgpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGNhbnZhc0N4dCA9IGNvbnRleHQ7XG4gIHZhciBwYXRoO1xuICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcblxuICBpZiggdXNlUGF0aHMgKXtcbiAgICB2YXIgcGF0aENhY2hlS2V5ID0gcHRzLmpvaW4oJyQnKTtcbiAgICB2YXIga2V5TWF0Y2hlcyA9IHJzLnBhdGhDYWNoZUtleSAmJiBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleTtcblxuICAgIGlmKCBrZXlNYXRjaGVzICl7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiggY2FudmFzQ3h0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIDYsIDMgXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiggIXBhdGhDYWNoZUhpdCApe1xuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG4gICAgY29udGV4dC5tb3ZlVG8oIHB0c1swXSwgcHRzWzFdICk7XG5cbiAgICBzd2l0Y2goIHJzLmVkZ2VUeXBlICl7XG4gICAgICBjYXNlICdiZXppZXInOlxuICAgICAgY2FzZSAnc2VsZic6XG4gICAgICBjYXNlICdjb21wb3VuZCc6XG4gICAgICBjYXNlICdtdWx0aWJlemllcic6XG4gICAgICAgIGlmKCAhcnMuYmFkQmV6aWVyICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDI7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSA0ICl7XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oIHB0c1tpXSwgcHRzW2krMV0sIHB0c1tpKzJdLCBwdHNbaSszXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyYWlnaHQnOlxuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgY2FzZSAnaGF5c3RhY2snOlxuICAgICAgICBpZiggIXJzLmJhZExpbmUgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMjsgaSArIDEgPCBwdHMubGVuZ3RoOyBpICs9IDIgKXtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKCBwdHNbaV0sIHB0c1tpKzFdICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbnRleHQgPSBjYW52YXNDeHQ7XG4gIGlmKCB1c2VQYXRocyApe1xuICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5zdHJva2UoKTtcbiAgfVxuXG4gIC8vIHJlc2V0IGFueSBsaW5lIGRhc2hlc1xuICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gIH1cblxufTtcblxuQ1JwLmRyYXdBcnJvd2hlYWRzID0gZnVuY3Rpb24oY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG4gIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgKXsgcmV0dXJuOyB9IC8vIGRvbid0IGRvIGFueXRoaW5nIGZvciBvdmVybGF5c1xuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBpc0hheXN0YWNrID0gcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjayc7XG5cbiAgaWYoICFpc0hheXN0YWNrICl7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKCBjb250ZXh0LCBlZGdlLCAnc291cmNlJywgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBycy5zcmNBcnJvd0FuZ2xlICk7XG4gIH1cblxuICB0aGlzLmRyYXdBcnJvd2hlYWQoIGNvbnRleHQsIGVkZ2UsICdtaWQtdGFyZ2V0JywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkdGd0QXJyb3dBbmdsZSApO1xuXG4gIHRoaXMuZHJhd0Fycm93aGVhZCggY29udGV4dCwgZWRnZSwgJ21pZC1zb3VyY2UnLCBycy5taWRYLCBycy5taWRZLCBycy5taWRzcmNBcnJvd0FuZ2xlICk7XG5cbiAgaWYoICFpc0hheXN0YWNrICl7XG4gICAgdGhpcy5kcmF3QXJyb3doZWFkKCBjb250ZXh0LCBlZGdlLCAndGFyZ2V0JywgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHJzLnRndEFycm93QW5nbGUgKTtcbiAgfVxufTtcblxuQ1JwLmRyYXdBcnJvd2hlYWQgPSBmdW5jdGlvbiggY29udGV4dCwgZWRnZSwgcHJlZml4LCB4LCB5LCBhbmdsZSApe1xuICBpZiggaXNOYU4oeCkgfHwgeCA9PSBudWxsIHx8IGlzTmFOKHkpIHx8IHkgPT0gbnVsbCB8fCBpc05hTihhbmdsZSkgfHwgYW5nbGUgPT0gbnVsbCApeyByZXR1cm47IH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gIHZhciBhcnJvd1NoYXBlID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1zaGFwZSddLnZhbHVlO1xuXG4gIGlmKCBhcnJvd1NoYXBlID09PSAnbm9uZScgKXtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgdmFyIGFycm93Q2xlYXJGaWxsID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1maWxsJ10udmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gIHZhciBhcnJvd0ZpbGwgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LWZpbGwnXS52YWx1ZTtcblxuICBpZiggYXJyb3dTaGFwZSA9PT0gJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnICl7XG4gICAgYXJyb3dGaWxsID0gJ2hvbGxvdyc7XG4gICAgYXJyb3dDbGVhckZpbGwgPSAnaG9sbG93JztcbiAgfVxuXG4gIGlmKCBzdHlsZS5vcGFjaXR5LnZhbHVlICE9PSAxIHx8IGFycm93RmlsbCA9PT0gJ2hvbGxvdycgKXsgLy8gdGhlbiBleHRyYSBjbGVhciBpcyBuZWVkZWRcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuXG4gICAgc2VsZi5maWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5zdHJva2VTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcblxuICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoIGVkZ2UsIHByZWZpeCwgY29udGV4dCxcbiAgICAgIGFycm93Q2xlYXJGaWxsLCBzdHlsZVsnd2lkdGgnXS5wZlZhbHVlLCBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWUsXG4gICAgICB4LCB5LCBhbmdsZVxuICAgICk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgfSAvLyBvdGhlcndpc2UsIHRoZSBvcGFxdWUgYXJyb3cgY2xlYXJzIGl0IGZvciBmcmVlIDopXG5cbiAgdmFyIGNvbG9yID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1jb2xvciddLnZhbHVlO1xuICBzZWxmLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBzdHlsZS5vcGFjaXR5LnZhbHVlKTtcbiAgc2VsZi5zdHJva2VTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBzdHlsZS5vcGFjaXR5LnZhbHVlKTtcblxuICBzZWxmLmRyYXdBcnJvd1NoYXBlKCBlZGdlLCBwcmVmaXgsIGNvbnRleHQsXG4gICAgYXJyb3dGaWxsLCBzdHlsZVsnd2lkdGgnXS5wZlZhbHVlLCBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWUsXG4gICAgeCwgeSwgYW5nbGVcbiAgKTtcbn07XG5cbkNScC5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uKGVkZ2UsIGFycm93VHlwZSwgY29udGV4dCwgZmlsbCwgZWRnZVdpZHRoLCBzaGFwZSwgeCwgeSwgYW5nbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHBhdGg7XG4gIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgdmFyIHRyYW5zbGF0aW9uID0geyB4OiB4LCB5OiB5IH07XG4gIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKCBlZGdlV2lkdGggKTtcbiAgdmFyIHNoYXBlSW1wbCA9IHIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuXG4gIGlmKCB1c2VQYXRocyApe1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBzaXplICsgJyQnICsgc2hhcGUgKyAnJCcgKyBhbmdsZSArICckJyArIHggKyAnJCcgKyB5O1xuICAgIHJzLmFycm93UGF0aENhY2hlS2V5ID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXkgfHwge307XG4gICAgcnMuYXJyb3dQYXRoQ2FjaGUgPSBycy5hcnJvd1BhdGhDYWNoZSB8fCB7fTtcblxuICAgIHZhciBhbHJlYWR5Q2FjaGVkID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXlbYXJyb3dUeXBlXSA9PT0gcGF0aENhY2hlS2V5O1xuICAgIGlmKCBhbHJlYWR5Q2FjaGVkICl7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLmFycm93UGF0aENhY2hlW2Fycm93VHlwZV07XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIHJzLmFycm93UGF0aENhY2hlS2V5W2Fycm93VHlwZV0gPSBwYXRoQ2FjaGVLZXk7XG4gICAgICBycy5hcnJvd1BhdGhDYWNoZVthcnJvd1R5cGVdID0gcGF0aDtcbiAgICB9XG4gIH1cblxuICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gIGlmKCAhcGF0aENhY2hlSGl0ICl7XG4gICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgfVxuXG4gIGlmKCAhc2hhcGVJbXBsLmxlYXZlUGF0aE9wZW4gJiYgY29udGV4dC5jbG9zZVBhdGggKXtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG5cbiAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgaWYoIGZpbGwgPT09ICdmaWxsZWQnIHx8IGZpbGwgPT09ICdib3RoJyApe1xuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmKCBmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcgKXtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9ICggc2hhcGVJbXBsLm1hdGNoRWRnZVdpZHRoID8gZWRnZVdpZHRoIDogMSApO1xuICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cblxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENScCA9IHt9O1xuXG5DUnAuc2FmZURyYXdJbWFnZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoICl7XG4gIHZhciByID0gdGhpcztcblxuICB0cnkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKCBpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoICk7XG4gIH0gY2F0Y2goZSl7XG4gICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tyLkRSQUddID0gdHJ1ZTtcblxuICAgIHIuZHJhd2luZ0ltYWdlID0gdHJ1ZTtcblxuICAgIHIucmVkcmF3KCk7XG4gIH1cbn07XG5cbkNScC5kcmF3SW5zY3JpYmVkSW1hZ2UgPSBmdW5jdGlvbihjb250ZXh0LCBpbWcsIG5vZGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbm9kZVggPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLng7XG4gIHZhciBub2RlWSA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueTtcbiAgdmFyIHN0eWxlID0gbm9kZS5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIGZpdCA9IHN0eWxlWydiYWNrZ3JvdW5kLWZpdCddLnZhbHVlO1xuICB2YXIgeFBvcyA9IHN0eWxlWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnXTtcbiAgdmFyIHlQb3MgPSBzdHlsZVsnYmFja2dyb3VuZC1wb3NpdGlvbi15J107XG4gIHZhciByZXBlYXQgPSBzdHlsZVsnYmFja2dyb3VuZC1yZXBlYXQnXS52YWx1ZTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgY2xpcCA9IHN0eWxlWydiYWNrZ3JvdW5kLWNsaXAnXS52YWx1ZTtcbiAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gIHZhciBpbWdPcGFjaXR5ID0gc3R5bGVbJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSddLnZhbHVlO1xuXG4gIHZhciBpbWdXID0gaW1nLndpZHRoIHx8IGltZy5jYWNoZWRXO1xuICB2YXIgaW1nSCA9IGltZy5oZWlnaHQgfHwgaW1nLmNhY2hlZEg7XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgYnJva2VuIGJyb3dzZXJzIGxpa2UgaWVcbiAgaWYoIG51bGwgPT0gaW1nVyB8fCBudWxsID09IGltZ0ggKXtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBpbWcgKTtcblxuICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCggaW1nICk7XG4gIH1cblxuICB2YXIgdyA9IGltZ1c7XG4gIHZhciBoID0gaW1nSDtcblxuICB2YXIgYmdXID0gc3R5bGVbJ2JhY2tncm91bmQtd2lkdGgnXTtcbiAgaWYoIGJnVy52YWx1ZSAhPT0gJ2F1dG8nICl7XG4gICAgaWYoIGJnVy51bml0cyA9PT0gJyUnICl7XG4gICAgICB3ID0gYmdXLnZhbHVlLzEwMCAqIG5vZGVXO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ID0gYmdXLnBmVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJnSCA9IHN0eWxlWydiYWNrZ3JvdW5kLWhlaWdodCddO1xuICBpZiggYmdILnZhbHVlICE9PSAnYXV0bycgKXtcbiAgICBpZiggYmdILnVuaXRzID09PSAnJScgKXtcbiAgICAgIGggPSBiZ0gudmFsdWUvMTAwICogbm9kZUg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSBiZ0gucGZWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiggdyA9PT0gMCB8fCBoID09PSAwICl7XG4gICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gIH1cblxuICBpZiggZml0ID09PSAnY29udGFpbicgKXtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbiggbm9kZVcvdywgbm9kZUgvaCApO1xuXG4gICAgdyAqPSBzY2FsZTtcbiAgICBoICo9IHNjYWxlO1xuXG4gIH0gZWxzZSBpZiggZml0ID09PSAnY292ZXInICl7XG4gICAgdmFyIHNjYWxlID0gTWF0aC5tYXgoIG5vZGVXL3csIG5vZGVIL2ggKTtcblxuICAgIHcgKj0gc2NhbGU7XG4gICAgaCAqPSBzY2FsZTtcbiAgfVxuXG4gIHZhciB4ID0gKG5vZGVYIC0gbm9kZVcvMik7IC8vIGxlZnRcbiAgaWYoIHhQb3MudW5pdHMgPT09ICclJyApe1xuICAgIHggKz0gKG5vZGVXIC0gdykgKiB4UG9zLnZhbHVlLzEwMDtcbiAgfSBlbHNlIHtcbiAgICB4ICs9IHhQb3MucGZWYWx1ZTtcbiAgfVxuXG4gIHZhciB5ID0gKG5vZGVZIC0gbm9kZUgvMik7IC8vIHRvcFxuICBpZiggeVBvcy51bml0cyA9PT0gJyUnICl7XG4gICAgeSArPSAobm9kZUggLSBoKSAqIHlQb3MudmFsdWUvMTAwO1xuICB9IGVsc2Uge1xuICAgIHkgKz0geVBvcy5wZlZhbHVlO1xuICB9XG5cbiAgaWYoIHJzLnBhdGhDYWNoZSApe1xuICAgIHggLT0gbm9kZVg7XG4gICAgeSAtPSBub2RlWTtcblxuICAgIG5vZGVYID0gMDtcbiAgICBub2RlWSA9IDA7XG4gIH1cblxuICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcblxuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW1nT3BhY2l0eTtcblxuICBpZiggcmVwZWF0ID09PSAnbm8tcmVwZWF0JyApe1xuXG4gICAgaWYoIHNob3VsZENsaXAgKXtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICBpZiggcnMucGF0aENhY2hlICl7XG4gICAgICAgIGNvbnRleHQuY2xpcCggcnMucGF0aENhY2hlICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBub2RlWCwgbm9kZVksXG4gICAgICAgICAgbm9kZVcsIG5vZGVIKTtcblxuICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByLnNhZmVEcmF3SW1hZ2UoIGNvbnRleHQsIGltZywgMCwgMCwgaW1nVywgaW1nSCwgeCwgeSwgdywgaCApO1xuXG4gICAgaWYoIHNob3VsZENsaXAgKXtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybiggaW1nLCByZXBlYXQgKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm47XG5cbiAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG5vZGVYLCBub2RlWSxcbiAgICAgICAgbm9kZVcsIG5vZGVIKTtcblxuICAgICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cblxuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZ0FscGhhO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENScDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vLi4vaXMnKTtcblxudmFyIENScCA9IHt9O1xuXG4vLyBEcmF3IGVkZ2UgdGV4dFxuQ1JwLmRyYXdFZGdlVGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGVkZ2UpIHtcbiAgdmFyIHRleHQgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydsYWJlbCddLnN0clZhbHVlO1xuXG4gIGlmKCAhdGV4dCB8fCB0ZXh0Lm1hdGNoKC9eXFxzKyQvKSApe1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKCB0aGlzLmhpZGVFZGdlc09uVmlld3BvcnQgJiYgKHRoaXMuZHJhZ0RhdGEuZGlkRHJhZyB8fCB0aGlzLnBpbmNoaW5nIHx8IHRoaXMuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHRoaXMuZGF0YS53aGVlbCB8fCB0aGlzLnN3aXBlUGFubmluZykgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzIG9uIHBpbmNoaW5nXG5cbiAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ2ZvbnQtc2l6ZSddLnBmVmFsdWUgKiBlZGdlLmN5KCkuem9vbSgpO1xuICB2YXIgbWluU2l6ZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ21pbi16b29tZWQtZm9udC1zaXplJ10ucGZWYWx1ZTtcblxuICBpZiggY29tcHV0ZWRTaXplIDwgbWluU2l6ZSApe1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSB0ZXh0IGRyYXcgcG9zaXRpb25cblxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIGlmKCAhaXMubnVtYmVyKCBycy5sYWJlbFggKSB8fCAhaXMubnVtYmVyKCBycy5sYWJlbFkgKSApeyByZXR1cm47IH0gLy8gbm8gcG9zID0+IGxhYmVsIGNhbid0IGJlIHJlbmRlcmVkXG5cbiAgdmFyIHN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIGF1dG9yb3RhdGUgPSBzdHlsZVsnZWRnZS10ZXh0LXJvdGF0aW9uJ10uc3RyVmFsdWUgPT09ICdhdXRvcm90YXRlJztcbiAgdmFyIHRoZXRhO1xuXG4gIGlmKCBhdXRvcm90YXRlICl7XG4gICAgdGhldGEgPSBycy5sYWJlbEFuZ2xlO1xuXG4gICAgY29udGV4dC50cmFuc2xhdGUocnMubGFiZWxYLCBycy5sYWJlbFkpO1xuICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcblxuICAgIHRoaXMuZHJhd1RleHQoY29udGV4dCwgZWRnZSwgMCwgMCk7XG5cbiAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1ycy5sYWJlbFgsIC1ycy5sYWJlbFkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZHJhd1RleHQoY29udGV4dCwgZWRnZSwgcnMubGFiZWxYLCBycy5sYWJlbFkpO1xuICB9XG5cbn07XG5cbi8vIERyYXcgbm9kZSB0ZXh0XG5DUnAuZHJhd05vZGVUZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgbm9kZSkge1xuICB2YXIgdGV4dCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2xhYmVsJ10uc3RyVmFsdWU7XG5cbiAgaWYgKCAhdGV4dCB8fCB0ZXh0Lm1hdGNoKC9eXFxzKyQvKSApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY29tcHV0ZWRTaXplID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnZm9udC1zaXplJ10ucGZWYWx1ZSAqIG5vZGUuY3koKS56b29tKCk7XG4gIHZhciBtaW5TaXplID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnbWluLXpvb21lZC1mb250LXNpemUnXS5wZlZhbHVlO1xuXG4gIGlmKCBjb21wdXRlZFNpemUgPCBtaW5TaXplICl7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gdGhpcy5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24oIG5vZGUgKTtcblxuICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtaGFsaWduJ10uc3RyVmFsdWU7XG4gIHZhciB0ZXh0VmFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgaWYoICFpcy5udW1iZXIoIHJzLmxhYmVsWCApIHx8ICFpcy5udW1iZXIoIHJzLmxhYmVsWSApICl7IHJldHVybjsgfSAvLyBubyBwb3MgPT4gbGFiZWwgY2FuJ3QgYmUgcmVuZGVyZWRcblxuICBzd2l0Y2goIHRleHRIYWxpZ24gKXtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6IC8vIGUuZy4gY2VudGVyXG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICB9XG5cbiAgc3dpdGNoKCB0ZXh0VmFsaWduICl7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgfVxuXG4gIHRoaXMuZHJhd1RleHQoY29udGV4dCwgbm9kZSwgcnMubGFiZWxYLCBycy5sYWJlbFkpO1xufTtcblxuQ1JwLmdldEZvbnRDYWNoZSA9IGZ1bmN0aW9uKGNvbnRleHQpe1xuICB2YXIgY2FjaGU7XG5cbiAgdGhpcy5mb250Q2FjaGVzID0gdGhpcy5mb250Q2FjaGVzIHx8IFtdO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrICl7XG4gICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbaV07XG5cbiAgICBpZiggY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCApe1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlID0ge1xuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdGhpcy5mb250Q2FjaGVzLnB1c2goY2FjaGUpO1xuXG4gIHJldHVybiBjYWNoZTtcbn07XG5cbi8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbi8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcbkNScC5zZXR1cFRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtZW50ICl7XG4gIC8vIEZvbnQgc3R5bGVcbiAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGVtZW50LmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgdmFyIHN0eWxlID0gZWxlbWVudC5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIGxhYmVsU3R5bGUgPSBzdHlsZVsnZm9udC1zdHlsZSddLnN0clZhbHVlO1xuICB2YXIgbGFiZWxTaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddLnBmVmFsdWUgKyAncHgnO1xuICB2YXIgbGFiZWxGYW1pbHkgPSBzdHlsZVsnZm9udC1mYW1pbHknXS5zdHJWYWx1ZTtcbiAgdmFyIGxhYmVsV2VpZ2h0ID0gc3R5bGVbJ2ZvbnQtd2VpZ2h0J10uc3RyVmFsdWU7XG4gIHZhciBvcGFjaXR5ID0gc3R5bGVbJ3RleHQtb3BhY2l0eSddLnZhbHVlICogc3R5bGVbJ29wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHk7XG4gIHZhciBvdXRsaW5lT3BhY2l0eSA9IHN0eWxlWyd0ZXh0LW91dGxpbmUtb3BhY2l0eSddLnZhbHVlICogb3BhY2l0eTtcbiAgdmFyIGNvbG9yID0gc3R5bGVbJ2NvbG9yJ10udmFsdWU7XG4gIHZhciBvdXRsaW5lQ29sb3IgPSBzdHlsZVsndGV4dC1vdXRsaW5lLWNvbG9yJ10udmFsdWU7XG4gIHZhciBzaGFkb3dCbHVyID0gc3R5bGVbJ3RleHQtc2hhZG93LWJsdXInXS5wZlZhbHVlO1xuICB2YXIgc2hhZG93T3BhY2l0eSA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1vcGFjaXR5J10udmFsdWU7XG4gIHZhciBzaGFkb3dDb2xvciA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1jb2xvciddLnZhbHVlO1xuICB2YXIgc2hhZG93T2Zmc2V0WCA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1vZmZzZXQteCddLnBmVmFsdWU7XG4gIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGVbJ3RleHQtc2hhZG93LW9mZnNldC15J10ucGZWYWx1ZTtcblxuICB2YXIgZm9udENhY2hlS2V5ID0gZWxlbWVudC5fcHJpdmF0ZS5mb250S2V5O1xuICB2YXIgY2FjaGUgPSB0aGlzLmdldEZvbnRDYWNoZShjb250ZXh0KTtcblxuICBpZiggY2FjaGUua2V5ICE9PSBmb250Q2FjaGVLZXkgKXtcbiAgICBjb250ZXh0LmZvbnQgPSBsYWJlbFN0eWxlICsgJyAnICsgbGFiZWxXZWlnaHQgKyAnICcgKyBsYWJlbFNpemUgKyAnICcgKyBsYWJlbEZhbWlseTtcblxuICAgIGNhY2hlLmtleSA9IGZvbnRDYWNoZUtleTtcbiAgfVxuXG4gIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoIGVsZW1lbnQgKTtcblxuICAvLyBDYWxjdWxhdGUgdGV4dCBkcmF3IHBvc2l0aW9uIGJhc2VkIG9uIHRleHQgYWxpZ25tZW50XG5cbiAgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuXG4gIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuXG4gIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3V0bGluZU9wYWNpdHkpO1xuXG4gIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgc2hhZG93Q29sb3IsIHNoYWRvd09wYWNpdHksIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFkpO1xuXG4gIHJldHVybiB0ZXh0O1xufTtcblxuZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIHZhciByYWRpdXMgPSByYWRpdXMgfHwgNTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHggKyByYWRpdXMsIHkpO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMpO1xuICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguZmlsbCgpO1xufVxuXG4vLyBEcmF3IHRleHRcbkNScC5kcmF3VGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGVsZW1lbnQsIHRleHRYLCB0ZXh0WSkge1xuICB2YXIgX3AgPSBlbGVtZW50Ll9wcml2YXRlO1xuICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlbWVudC5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIGlmKCBwYXJlbnRPcGFjaXR5ID09PSAwIHx8IHN0eWxlWyd0ZXh0LW9wYWNpdHknXS52YWx1ZSA9PT0gMCl7IHJldHVybjsgfVxuXG4gIHZhciB0ZXh0ID0gdGhpcy5zZXR1cFRleHRTdHlsZSggY29udGV4dCwgZWxlbWVudCApO1xuICB2YXIgaGFsaWduID0gc3R5bGVbJ3RleHQtaGFsaWduJ10udmFsdWU7XG4gIHZhciB2YWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXS52YWx1ZTtcblxuICBpZiggZWxlbWVudC5pc0VkZ2UoKSApe1xuICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgIHZhbGlnbiA9ICdjZW50ZXInO1xuICB9XG5cbiAgaWYoIGVsZW1lbnQuaXNOb2RlKCkgKXtcbiAgICB2YXIgcExlZnQgPSBzdHlsZVsncGFkZGluZy1sZWZ0J10ucGZWYWx1ZTtcbiAgICB2YXIgcFJpZ2h0ID0gc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5wZlZhbHVlO1xuICAgIHZhciBwVG9wID0gc3R5bGVbJ3BhZGRpbmctdG9wJ10ucGZWYWx1ZTtcbiAgICB2YXIgcEJvdHRvbSA9IHN0eWxlWydwYWRkaW5nLWJvdHRvbSddLnBmVmFsdWU7XG5cbiAgICB0ZXh0WCArPSBwTGVmdC8yO1xuICAgIHRleHRYIC09IHBSaWdodC8yO1xuXG4gICAgdGV4dFkgKz0gcFRvcC8yO1xuICAgIHRleHRZIC09IHBCb3R0b20vMjtcbiAgfVxuXG4gIGlmICggdGV4dCAhPSBudWxsICYmICFpc05hTih0ZXh0WCkgJiYgIWlzTmFOKHRleHRZKSkge1xuICAgIHZhciBiYWNrZ3JvdW5kT3BhY2l0eSA9IHN0eWxlWyd0ZXh0LWJhY2tncm91bmQtb3BhY2l0eSddLnZhbHVlO1xuICAgIHZhciBib3JkZXJPcGFjaXR5ID0gc3R5bGVbJ3RleHQtYm9yZGVyLW9wYWNpdHknXS52YWx1ZTtcbiAgICB2YXIgdGV4dEJvcmRlcldpZHRoID0gc3R5bGVbJ3RleHQtYm9yZGVyLXdpZHRoJ10ucGZWYWx1ZTtcblxuICAgIGlmKCBiYWNrZ3JvdW5kT3BhY2l0eSA+IDAgfHwgKHRleHRCb3JkZXJXaWR0aCA+IDAgJiYgYm9yZGVyT3BhY2l0eSA+IDApICl7XG4gICAgICB2YXIgbWFyZ2luID0gNCArIHRleHRCb3JkZXJXaWR0aC8yO1xuXG4gICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSkge1xuICAgICAgICAvL01vdmUgdGV4dFgsIHRleHRZIHRvIGluY2x1ZGUgdGhlIGJhY2tncm91bmQgbWFyZ2luc1xuICAgICAgICBpZiAodmFsaWduID09PSAndG9wJykge1xuICAgICAgICAgIHRleHRZIC09IG1hcmdpbjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgdGV4dFkgKz0gbWFyZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRleHRYIC09IG1hcmdpbjtcbiAgICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB0ZXh0WCArPSBtYXJnaW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJnV2lkdGggPSByc3R5bGUubGFiZWxXaWR0aDtcbiAgICAgIHZhciBiZ0hlaWdodCA9IHJzdHlsZS5sYWJlbEhlaWdodDtcbiAgICAgIHZhciBiZ1ggPSB0ZXh0WDtcblxuICAgICAgaWYgKGhhbGlnbikge1xuICAgICAgICBpZiAoaGFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgYmdYID0gYmdYIC0gYmdXaWR0aCAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09ICdsZWZ0Jykge1xuICAgICAgICAgIGJnWCA9IGJnWC0gYmdXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmdZID0gdGV4dFk7XG5cbiAgICAgIGlmIChlbGVtZW50LmlzTm9kZSgpKSB7XG4gICAgICAgIGlmICh2YWxpZ24gPT0gJ3RvcCcpIHtcbiAgICAgICAgICAgYmdZID0gYmdZIC0gYmdIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgYmdZID0gYmdZLSBiZ0hlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJnWSA9IGJnWSAtIGJnSGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlWydlZGdlLXRleHQtcm90YXRpb24nXS5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgICAgIHRleHRZID0gMDtcbiAgICAgICAgYmdXaWR0aCArPSA0O1xuICAgICAgICBiZ1ggPSB0ZXh0WCAtIGJnV2lkdGggLyAyO1xuICAgICAgICBiZ1kgPSB0ZXh0WSAtIGJnSGVpZ2h0IC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkanVzdCB3aXRoIGJvcmRlciB3aWR0aCAmIG1hcmdpblxuICAgICAgICBiZ1ggLT0gbWFyZ2luO1xuICAgICAgICBiZ1kgLT0gbWFyZ2luO1xuICAgICAgICBiZ0hlaWdodCArPSBtYXJnaW4qMjtcbiAgICAgICAgYmdXaWR0aCArPSBtYXJnaW4qMjtcbiAgICAgIH1cblxuICAgICAgaWYoIGJhY2tncm91bmRPcGFjaXR5ID4gMCApe1xuICAgICAgICB2YXIgdGV4dEZpbGwgPSBjb250ZXh0LmZpbGxTdHlsZTtcbiAgICAgICAgdmFyIHRleHRCYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZVsndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJ10udmFsdWU7XG5cbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgdGV4dEJhY2tncm91bmRDb2xvclswXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMV0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzJdICsgJywnICsgYmFja2dyb3VuZE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICB2YXIgc3R5bGVTaGFwZSA9IHN0eWxlWyd0ZXh0LWJhY2tncm91bmQtc2hhcGUnXS5zdHJWYWx1ZTtcbiAgICAgICAgaWYgKHN0eWxlU2hhcGUgPT0gJ3JvdW5kcmVjdGFuZ2xlJykge1xuICAgICAgICAgIHJvdW5kUmVjdChjb250ZXh0LCBiZ1gsIGJnWSwgYmdXaWR0aCwgYmdIZWlnaHQsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoYmdYLGJnWSxiZ1dpZHRoLGJnSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRleHRGaWxsO1xuICAgICAgfVxuXG4gICAgICBpZiggdGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCApe1xuICAgICAgICB2YXIgdGV4dFN0cm9rZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgICAgIHZhciB0ZXh0TGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGg7XG4gICAgICAgIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZVsndGV4dC1ib3JkZXItY29sb3InXS52YWx1ZTtcbiAgICAgICAgdmFyIHRleHRCb3JkZXJTdHlsZSA9IHN0eWxlWyd0ZXh0LWJvcmRlci1zdHlsZSddLnZhbHVlO1xuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgdGV4dEJvcmRlckNvbG9yWzBdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzFdICsgJywnICsgdGV4dEJvcmRlckNvbG9yWzJdICsgJywnICsgYm9yZGVyT3BhY2l0eSAqIHBhcmVudE9wYWNpdHkgKyAnKSc7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoO1xuXG4gICAgICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICAgIHN3aXRjaCggdGV4dEJvcmRlclN0eWxlICl7XG4gICAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgNCwgMiBdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aC80OyAvLyA1MCUgcmVzZXJ2ZWQgZm9yIHdoaXRlIGJldHdlZW4gdGhlIHR3byBib3JkZXJzXG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCxiZ1ksYmdXaWR0aCxiZ0hlaWdodCk7XG5cbiAgICAgICAgaWYoIHRleHRCb3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgICAgICB2YXIgd2hpdGVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aC8yO1xuXG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCt3aGl0ZVdpZHRoLGJnWSt3aGl0ZVdpZHRoLGJnV2lkdGgtd2hpdGVXaWR0aCoyLGJnSGVpZ2h0LXdoaXRlV2lkdGgqMik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSB0ZXh0TGluZVdpZHRoO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBsaW5lV2lkdGggPSAyICAqIHN0eWxlWyd0ZXh0LW91dGxpbmUtd2lkdGgnXS5wZlZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcblxuICAgIGlmKCBsaW5lV2lkdGggPiAwICl7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICB9XG5cbiAgICBpZiggc3R5bGVbJ3RleHQtd3JhcCddLnZhbHVlID09PSAnd3JhcCcgKXtcbiAgICAgIHZhciBsaW5lcyA9IHJzY3JhdGNoLmxhYmVsV3JhcENhY2hlZExpbmVzO1xuICAgICAgdmFyIGxpbmVIZWlnaHQgPSByc3R5bGUubGFiZWxIZWlnaHQgLyBsaW5lcy5sZW5ndGg7XG5cbiAgICAgIHN3aXRjaCggdmFsaWduICl7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIC8vIG5vdGhpbmcgcmVxdWlyZWRcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrICl7XG4gICAgICAgIGlmKCBsaW5lV2lkdGggPiAwICl7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KCBsaW5lc1tsXSwgdGV4dFgsIHRleHRZICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCBsaW5lc1tsXSwgdGV4dFgsIHRleHRZICk7XG5cbiAgICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggbGluZVdpZHRoID4gMCApe1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoIHRleHQsIHRleHRYLCB0ZXh0WSApO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KCB0ZXh0LCB0ZXh0WCwgdGV4dFkgKTtcbiAgICB9XG5cblxuICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgJ3RyYW5zcGFyZW50JywgMCk7IC8vIHJlc2V0IGZvciBuZXh0IGd1eVxuICB9XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi8uLi8uLi9pcycpO1xuXG52YXIgQ1JwID0ge307XG5cbi8vIERyYXcgbm9kZVxuQ1JwLmRyYXdOb2RlID0gZnVuY3Rpb24oY29udGV4dCwgbm9kZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG5cbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICB2YXIgc3R5bGUgPSBub2RlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgcG9zID0gX3AucG9zaXRpb247XG5cbiAgaWYoICFpcy5udW1iZXIocG9zLngpIHx8ICFpcy5udW1iZXIocG9zLnkpICl7XG4gICAgcmV0dXJuOyAvLyBjYW4ndCBkcmF3IG5vZGUgd2l0aCB1bmRlZmluZWQgcG9zaXRpb25cbiAgfVxuXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICB2YXIgcGF0aDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuXG4gIHZhciBvdmVybGF5UGFkZGluZyA9IHN0eWxlWydvdmVybGF5LXBhZGRpbmcnXS5wZlZhbHVlO1xuICB2YXIgb3ZlcmxheU9wYWNpdHkgPSBzdHlsZVsnb3ZlcmxheS1vcGFjaXR5J10udmFsdWU7XG4gIHZhciBvdmVybGF5Q29sb3IgPSBzdHlsZVsnb3ZlcmxheS1jb2xvciddLnZhbHVlO1xuXG4gIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgJiYgb3ZlcmxheU9wYWNpdHkgPT09IDAgKXsgLy8gZXhpdCBlYXJseSBpZiBkcmF3aW5nIG92ZXJsYXkgYnV0IG5vbmUgdG8gZHJhd1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJlbnRPcGFjaXR5ID0gbm9kZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gIGlmKCBwYXJlbnRPcGFjaXR5ID09PSAwICl7IHJldHVybjsgfVxuXG4gIG5vZGVXaWR0aCA9IG5vZGUud2lkdGgoKSArIHN0eWxlWydwYWRkaW5nLWxlZnQnXS5wZlZhbHVlICsgc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5wZlZhbHVlO1xuICBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKSArIHN0eWxlWydwYWRkaW5nLXRvcCddLnBmVmFsdWUgKyBzdHlsZVsncGFkZGluZy1ib3R0b20nXS5wZlZhbHVlO1xuXG4gIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnBmVmFsdWU7XG5cbiAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCA9PT0gdW5kZWZpbmVkIHx8ICFkcmF3T3ZlcmxheUluc3RlYWQgKXtcblxuICAgIHZhciB1cmwgPSBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddLnZhbHVlWzJdIHx8XG4gICAgICBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddLnZhbHVlWzFdO1xuICAgIHZhciBpbWFnZTtcblxuICAgIGlmICh1cmwgIT09IHVuZGVmaW5lZCkge1xuXG4gICAgICAvLyBnZXQgaW1hZ2UsIGFuZCBpZiBub3QgbG9hZGVkIHRoZW4gYXNrIHRvIHJlZHJhdyB3aGVuIGxhdGVyIGxvYWRlZFxuICAgICAgaW1hZ2UgPSB0aGlzLmdldENhY2hlZEltYWdlKHVybCwgZnVuY3Rpb24oKXtcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W3IuTk9ERV0gPSB0cnVlO1xuICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbci5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgci5kcmF3aW5nSW1hZ2UgPSB0cnVlO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHByZXZCZ2luZyA9IF9wLmJhY2tncm91bmRpbmc7XG4gICAgICBfcC5iYWNrZ3JvdW5kaW5nID0gIWltYWdlLmNvbXBsZXRlO1xuXG4gICAgICBpZiggcHJldkJnaW5nICE9PSBfcC5iYWNrZ3JvdW5kaW5nICl7IC8vIHVwZGF0ZSBzdHlsZSBiL2MgOmJhY2tncm91bmRpbmcgc3RhdGUgY2hhbmdlZFxuICAgICAgICBub2RlLnVwZGF0ZVN0eWxlKCBmYWxzZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vZGUgY29sb3IgJiBvcGFjaXR5XG5cbiAgICB2YXIgYmdDb2xvciA9IHN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10udmFsdWU7XG4gICAgdmFyIGJvcmRlckNvbG9yID0gc3R5bGVbJ2JvcmRlci1jb2xvciddLnZhbHVlO1xuICAgIHZhciBib3JkZXJTdHlsZSA9IHN0eWxlWydib3JkZXItc3R5bGUnXS52YWx1ZTtcblxuICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGJnQ29sb3JbMF0sIGJnQ29sb3JbMV0sIGJnQ29sb3JbMl0sIHN0eWxlWydiYWNrZ3JvdW5kLW9wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHkpO1xuXG4gICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBzdHlsZVsnYm9yZGVyLW9wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHkpO1xuXG4gICAgdmFyIHNoYWRvd0JsdXIgPSBzdHlsZVsnc2hhZG93LWJsdXInXS5wZlZhbHVlO1xuICAgIHZhciBzaGFkb3dPcGFjaXR5ID0gc3R5bGVbJ3NoYWRvdy1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIHNoYWRvd0NvbG9yID0gc3R5bGVbJ3NoYWRvdy1jb2xvciddLnZhbHVlO1xuICAgIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteCddLnBmVmFsdWU7XG4gICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZVsnc2hhZG93LW9mZnNldC15J10ucGZWYWx1ZTtcblxuICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgc2hhZG93Q29sb3IsIHNoYWRvd09wYWNpdHksIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFkpO1xuXG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7IC8vIHNvIGJvcmRlcnMgYXJlIHNxdWFyZSB3aXRoIHRoZSBub2RlIHNoYXBlXG5cbiAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIHN3aXRjaCggYm9yZGVyU3R5bGUgKXtcbiAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyA0LCAyIF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgc3R5bGVTaGFwZSA9IHN0eWxlWydzaGFwZSddLnN0clZhbHVlO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICB2YXIgcGF0aENhY2hlS2V5ID0gc3R5bGVTaGFwZSArICckJyArIG5vZGVXaWR0aCArJyQnICsgbm9kZUhlaWdodDtcblxuICAgICAgY29udGV4dC50cmFuc2xhdGUoIHBvcy54LCBwb3MueSApO1xuXG4gICAgICBpZiggcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXkgKXtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhcGF0aENhY2hlSGl0ICl7XG5cbiAgICAgIHZhciBucG9zID0gcG9zO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgbnBvcyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG5wb3MueCxcbiAgICAgICAgICAgIG5wb3MueSxcbiAgICAgICAgICAgIG5vZGVXaWR0aCxcbiAgICAgICAgICAgIG5vZGVIZWlnaHQpO1xuICAgIH1cblxuICAgIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAndHJhbnNwYXJlbnQnLCAwKTsgLy8gcmVzZXQgZm9yIG5leHQgZ3V5XG5cbiAgICBpZiAodXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmKCBpbWFnZS5jb21wbGV0ZSApe1xuICAgICAgICB0aGlzLmRyYXdJbnNjcmliZWRJbWFnZShjb250ZXh0LCBpbWFnZSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRhcmtuZXNzID0gc3R5bGVbJ2JhY2tncm91bmQtYmxhY2tlbiddLnZhbHVlO1xuICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5wZlZhbHVlO1xuXG4gICAgaWYoIHRoaXMuaGFzUGllKG5vZGUpICl7XG4gICAgICB0aGlzLmRyYXdQaWUoIGNvbnRleHQsIG5vZGUsIHBhcmVudE9wYWNpdHkgKTtcblxuICAgICAgLy8gcmVkcmF3IHBhdGggZm9yIGJsYWNrZW4gYW5kIGJvcmRlclxuICAgICAgaWYoIGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwICl7XG5cbiAgICAgICAgaWYoICF1c2VQYXRocyApe1xuICAgICAgICAgIHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uZHJhdyhcbiAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgcG9zLngsXG4gICAgICAgICAgICAgIHBvcy55LFxuICAgICAgICAgICAgICBub2RlV2lkdGgsXG4gICAgICAgICAgICAgIG5vZGVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGRhcmtuZXNzID4gMCApe1xuICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgMCwgMCwgMCwgZGFya25lc3MpO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggZGFya25lc3MgPCAwICl7XG4gICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAtZGFya25lc3MpO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCb3JkZXIgd2lkdGgsIGRyYXcgYm9yZGVyXG4gICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucGZWYWx1ZS8zO1xuXG4gICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIC1wb3MueCwgLXBvcy55ICk7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcbiAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICB9XG5cbiAgLy8gZHJhdyB0aGUgb3ZlcmxheVxuICB9IGVsc2Uge1xuXG4gICAgaWYoIG92ZXJsYXlPcGFjaXR5ID4gMCApe1xuICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuXG4gICAgICByLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10uZHJhdyhcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIG5vZGVXaWR0aCArIG92ZXJsYXlQYWRkaW5nICogMixcbiAgICAgICAgbm9kZUhlaWdodCArIG92ZXJsYXlQYWRkaW5nICogMlxuICAgICAgKTtcblxuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbi8vIGRvZXMgdGhlIG5vZGUgaGF2ZSBhdCBsZWFzdCBvbmUgcGllIHBpZWNlP1xuQ1JwLmhhc1BpZSA9IGZ1bmN0aW9uKG5vZGUpe1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNQaWU7XG59O1xuXG5DUnAuZHJhd1BpZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSApe1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICB2YXIgY3lTdHlsZSA9IG5vZGUuY3koKS5zdHlsZSgpO1xuICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgdmFyIHBpZVNpemUgPSBzdHlsZVsncGllLXNpemUnXTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgeCA9IF9wLnBvc2l0aW9uLng7XG4gIHZhciB5ID0gX3AucG9zaXRpb24ueTtcbiAgdmFyIHJhZGl1cyA9IE1hdGgubWluKCBub2RlVywgbm9kZUggKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcbiAgdmFyIGxhc3RQZXJjZW50ID0gMDsgLy8gd2hhdCAlIHRvIGNvbnRpbnVlIGRyYXdpbmcgcGllIHNsaWNlcyBmcm9tIG9uIFswLCAxXVxuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG5cbiAgaWYoIHVzZVBhdGhzICl7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gIH1cblxuICBpZiggcGllU2l6ZS51bml0cyA9PT0gJyUnICl7XG4gICAgcmFkaXVzID0gcmFkaXVzICogcGllU2l6ZS52YWx1ZSAvIDEwMDtcbiAgfSBlbHNlIGlmKCBwaWVTaXplLnBmVmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgIHJhZGl1cyA9IHBpZVNpemUucGZWYWx1ZSAvIDI7XG4gIH1cblxuICBmb3IoIHZhciBpID0gMTsgaSA8PSBjeVN0eWxlLnBpZUJhY2tncm91bmROOyBpKysgKXsgLy8gMS4uTlxuICAgIHZhciBzaXplID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJ10udmFsdWU7XG4gICAgdmFyIGNvbG9yID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvciddLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5J10udmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuXG4gICAgLy8gcGVyY2VudCBjYW4ndCBwdXNoIGJleW9uZCAxXG4gICAgaWYoIHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEgKXtcbiAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGFuZ2xlU3RhcnQgPSAxLjUgKiBNYXRoLlBJICsgMiAqIE1hdGguUEkgKiBsYXN0UGVyY2VudDsgLy8gc3RhcnQgYXQgMTIgbydjbG9jayBhbmQgZ28gY2xvY2t3aXNlXG4gICAgdmFyIGFuZ2xlRGVsdGEgPSAyICogTWF0aC5QSSAqIHBlcmNlbnQ7XG4gICAgdmFyIGFuZ2xlRW5kID0gYW5nbGVTdGFydCArIGFuZ2xlRGVsdGE7XG5cbiAgICAvLyBpZ25vcmUgaWZcbiAgICAvLyAtIHplcm8gc2l6ZVxuICAgIC8vIC0gd2UncmUgYWxyZWFkeSBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgLy8gLSBhZGRpbmcgdGhlIGN1cnJlbnQgc2xpY2Ugd291bGQgZ28gYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIGlmKCBzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSApe1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICBjb250ZXh0LmFyYyggeCwgeSwgcmFkaXVzLCBhbmdsZVN0YXJ0LCBhbmdsZUVuZCApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcblxuICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxuXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1JwID0ge307XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpO1xudmFyIG1hdGggPSByZXF1aXJlKCcuLi8uLi8uLi9tYXRoJyk7XG5cbnZhciBtb3Rpb25CbHVyRGVsYXkgPSAxMDA7XG5cbi8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG5DUnAuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5kYXRhLmNvbnRleHRzWzBdO1xuXG4gIGlmKCB0aGlzLmZvcmNlZFBpeGVsUmF0aW8gIT0gbnVsbCApe1xuICAgIHJldHVybiB0aGlzLmZvcmNlZFBpeGVsUmF0aW87XG4gIH1cblxuICB2YXIgYmFja2luZ1N0b3JlID0gY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgcmV0dXJuICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZTtcbn07XG5cbkNScC5wYWludENhY2hlID0gZnVuY3Rpb24oY29udGV4dCl7XG4gIHZhciBjYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzID0gdGhpcy5wYWludENhY2hlcyB8fCBbXTtcbiAgdmFyIG5lZWRUb0NyZWF0ZUNhY2hlID0gdHJ1ZTtcbiAgdmFyIGNhY2hlO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKysgKXtcbiAgICBjYWNoZSA9IGNhY2hlc1tpXTtcblxuICAgIGlmKCBjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0ICl7XG4gICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYoIG5lZWRUb0NyZWF0ZUNhY2hlICl7XG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICBjYWNoZXMucHVzaCggY2FjaGUgKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn07XG5cbkNScC5maWxsU3R5bGUgPSBmdW5jdGlvbihjb250ZXh0LCByLCBnLCBiLCBhKXtcbiAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuZmlsbFN0eWxlICE9PSBmaWxsU3R5bGUgKXtcbiAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgLy8gfVxufTtcblxuQ1JwLnN0cm9rZVN0eWxlID0gZnVuY3Rpb24oY29udGV4dCwgciwgZywgYiwgYSl7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIHZhciBzdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gIC8vIGlmKCBjYWNoZS5zdHJva2VTdHlsZSAhPT0gc3Ryb2tlU3R5bGUgKXtcbiAgLy8gICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY2FjaGUuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgLy8gfVxufTtcblxuQ1JwLnNoYWRvd1N0eWxlID0gZnVuY3Rpb24oY29udGV4dCwgY29sb3IsIG9wYWNpdHksIGJsdXIsIG9mZnNldFgsIG9mZnNldFkpe1xuICB2YXIgem9vbSA9IHRoaXMuY3kuem9vbSgpO1xuXG4gIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAvLyBkb24ndCBtYWtlIGV4cGVuc2l2ZSBjaGFuZ2VzIHRvIHRoZSBzaGFkb3cgc3R5bGUgaWYgaXQncyBub3QgdXNlZFxuICBpZiggY2FjaGUuc2hhZG93T3BhY2l0eSA9PT0gMCAmJiBvcGFjaXR5ID09PSAwICl7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY2FjaGUuc2hhZG93T3BhY2l0eSA9IG9wYWNpdHk7XG5cbiAgaWYgKG9wYWNpdHkgPiAwKSB7XG4gICAgY29udGV4dC5zaGFkb3dCbHVyID0gYmx1ciAqIHpvb207XG4gICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwicmdiYShcIiArIGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiLFwiICsgY29sb3JbMl0gKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIjtcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBvZmZzZXRYICogem9vbTtcbiAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBvZmZzZXRZICogem9vbTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gIH1cbn07XG5cbi8vIFJlc2l6ZSBjYW52YXNcbkNScC5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgdmFyIHdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG5cbiAgaWYoXG4gICAgY29udGFpbmVyID09PSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fFxuICAgIGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR11cbiAgKXtcbiAgICBwaXhlbFJhdGlvID0gbWJQeFJhdGlvO1xuICB9XG5cbiAgdmFyIGNhbnZhc1dpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuICB2YXIgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhcztcblxuICBpZiggY2FudmFzV2lkdGggPT09IHIuY2FudmFzV2lkdGggJiYgY2FudmFzSGVpZ2h0ID09PSByLmNhbnZhc0hlaWdodCApe1xuICAgIHJldHVybjsgLy8gc2F2ZSBjeWNsZXMgaWYgc2FtZVxuICB9XG5cbiAgci5mb250Q2FjaGVzID0gbnVsbDsgLy8gcmVzaXppbmcgcmVzZXRzIHRoZSBzdHlsZVxuXG4gIHZhciBjYW52YXNDb250YWluZXIgPSBkYXRhLmNhbnZhc0NvbnRhaW5lcjtcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuQ0FOVkFTX0xBWUVSUzsgaSsrKSB7XG5cbiAgICBjYW52YXMgPSBkYXRhLmNhbnZhc2VzW2ldO1xuXG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG5cbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG5cbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzW2ldO1xuXG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG5cbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuICB9XG5cbiAgci50ZXh0dXJlTXVsdCA9IDE7XG4gIGlmKCBwaXhlbFJhdGlvIDw9IDEgKXtcbiAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzWyByLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICByLnRleHR1cmVNdWx0ID0gMjtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQ7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHIudGV4dHVyZU11bHQ7XG4gIH1cblxuICByLmNhbnZhc1dpZHRoID0gY2FudmFzV2lkdGg7XG4gIHIuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG59O1xuXG5DUnAucmVuZGVyVG8gPSBmdW5jdGlvbiggY3h0LCB6b29tLCBwYW4sIHB4UmF0aW8gKXtcbiAgdGhpcy5yZW5kZXIoe1xuICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICBmb3JjZWRab29tOiB6b29tLFxuICAgIGZvcmNlZFBhbjogcGFuLFxuICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgZm9yY2VkUHhSYXRpbzogcHhSYXRpb1xuICB9KTtcbn07XG5cbkNScC5yZW5kZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdXRpbC5zdGF0aWNFbXB0eU9iamVjdCgpO1xuXG4gIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuICB2YXIgZHJhd0FsbExheWVycyA9IG9wdGlvbnMuZHJhd0FsbExheWVycztcbiAgdmFyIGRyYXdPbmx5Tm9kZUxheWVyID0gb3B0aW9ucy5kcmF3T25seU5vZGVMYXllcjtcbiAgdmFyIGZvcmNlZFpvb20gPSBvcHRpb25zLmZvcmNlZFpvb207XG4gIHZhciBmb3JjZWRQYW4gPSBvcHRpb25zLmZvcmNlZFBhbjtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgcGl4ZWxSYXRpbyA9IG9wdGlvbnMuZm9yY2VkUHhSYXRpbyA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRQaXhlbFJhdGlvKCkgOiBvcHRpb25zLmZvcmNlZFB4UmF0aW87XG4gIHZhciBjeSA9IHIuY3k7IHZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgbmVlZERyYXcgPSBkYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuICB2YXIgdGV4dHVyZURyYXcgPSByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICYmIChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcpO1xuICB2YXIgbW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1ciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3Rpb25CbHVyIDogci5tb3Rpb25CbHVyO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBpbk5vZGVEcmFnR2VzdHVyZSA9IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcztcbiAgdmFyIGluQm94U2VsZWN0aW9uID0gci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZyA/IHRydWUgOiBmYWxzZTtcbiAgbW90aW9uQmx1ciA9IG1vdGlvbkJsdXIgJiYgIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyRW5hYmxlZCAmJiAhaW5Cb3hTZWxlY3Rpb247XG4gIHZhciBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IG1vdGlvbkJsdXI7XG5cbiAgaWYoICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1clRpbWVvdXQgKXtcbiAgICBjbGVhclRpbWVvdXQoIHIubW90aW9uQmx1clRpbWVvdXQgKTtcbiAgfVxuXG4gIGlmKCBtb3Rpb25CbHVyICl7XG4gICAgaWYoIHIubWJGcmFtZXMgPT0gbnVsbCApe1xuICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgfVxuXG4gICAgaWYoICFyLmRyYXdpbmdJbWFnZSApeyAvLyBpbWFnZSBsb2FkaW5nIGZyYW1lcyBkb24ndCBjb3VudCB0b3dhcmRzIG1vdGlvbiBibHVyIGJsdXJyeSBmcmFtZXNcbiAgICAgIHIubWJGcmFtZXMrKztcbiAgICB9XG5cbiAgICBpZiggci5tYkZyYW1lcyA8IDMgKXsgLy8gbmVlZCBzZXZlcmFsIGZyYW1lcyBiZWZvcmUgZXZlbiBoaWdoIHF1YWxpdHkgbW90aW9uYmx1clxuICAgICAgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG4gICAgaWYoIHIubWJGcmFtZXMgPiByLm1pbk1iTG93UXVhbEZyYW1lcyApe1xuICAgICAgLy9yLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSByLm1iUHhSQmx1cnJ5O1xuICAgIH1cbiAgfVxuXG4gIGlmKCByLmNsZWFyaW5nTW90aW9uQmx1ciApe1xuICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSAxO1xuICB9XG5cbiAgLy8gYi9jIGRyYXdUb0NvbnRleHQoKSBtYXkgYmUgYXN5bmMgdy5yLnQuIHJlZHJhdygpLCBrZWVwIHRyYWNrIG9mIGxhc3QgdGV4dHVyZSBmcmFtZVxuICAvLyBiZWNhdXNlIGEgcm9ndWUgYXN5bmMgdGV4dHVyZSBmcmFtZSB3b3VsZCBjbGVhciBuZWVkRHJhd1xuICBpZiggci50ZXh0dXJlRHJhd0xhc3RGcmFtZSAmJiAhdGV4dHVyZURyYXcgKXtcbiAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBlZGdlcyA9IHIuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgdmFyIGNvcmVTdHlsZSA9IGN5LnN0eWxlKCkuX3ByaXZhdGUuY29yZVN0eWxlO1xuXG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgeDogcGFuLngsXG4gICAgeTogcGFuLnlcbiAgfTtcblxuICB2YXIgdnAgPSB7XG4gICAgem9vbTogem9vbSxcbiAgICBwYW46IHtcbiAgICAgIHg6IHBhbi54LFxuICAgICAgeTogcGFuLnlcbiAgICB9XG4gIH07XG4gIHZhciBwcmV2VnAgPSByLnByZXZWaWV3cG9ydDtcbiAgdmFyIHZpZXdwb3J0SXNEaWZmID0gcHJldlZwID09PSB1bmRlZmluZWQgfHwgdnAuem9vbSAhPT0gcHJldlZwLnpvb20gfHwgdnAucGFuLnggIT09IHByZXZWcC5wYW4ueCB8fCB2cC5wYW4ueSAhPT0gcHJldlZwLnBhbi55O1xuXG4gIC8vIHdlIHdhbnQgdGhlIGxvdyBxdWFsaXR5IG1vdGlvbmJsdXIgb25seSB3aGVuIHRoZSB2aWV3cG9ydCBpcyBiZWluZyBtYW5pcHVsYXRlZCBldGMgKHdoZXJlIGl0J3Mgbm90IG5vdGljZWQpXG4gIGlmKCAhdmlld3BvcnRJc0RpZmYgJiYgIShpbk5vZGVEcmFnR2VzdHVyZSAmJiAhaGFzQ29tcG91bmROb2RlcykgKXtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgfVxuXG4gIGlmKCBmb3JjZWRQYW4gKXtcbiAgICBlZmZlY3RpdmVQYW4gPSBmb3JjZWRQYW47XG4gIH1cblxuICAvLyBhcHBseSBwaXhlbCByYXRpb1xuXG4gIGVmZmVjdGl2ZVpvb20gKj0gcGl4ZWxSYXRpbztcbiAgZWZmZWN0aXZlUGFuLnggKj0gcGl4ZWxSYXRpbztcbiAgZWZmZWN0aXZlUGFuLnkgKj0gcGl4ZWxSYXRpbztcblxuICB2YXIgZWxlcyA9IHtcbiAgICBkcmFnOiB7XG4gICAgICBub2RlczogW10sXG4gICAgICBlZGdlczogW10sXG4gICAgICBlbGVzOiBbXVxuICAgIH0sXG4gICAgbm9uZHJhZzoge1xuICAgICAgbm9kZXM6IFtdLFxuICAgICAgZWRnZXM6IFtdLFxuICAgICAgZWxlczogW11cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbWJjbGVhciggY29udGV4dCwgeCwgeSwgdywgaCApe1xuICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgci5maWxsU3R5bGUoIGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSApO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG5cbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpe1xuICAgIHZhciBlUGFuLCBlWm9vbSwgdywgaDtcblxuICAgIGlmKCAhci5jbGVhcmluZ01vdGlvbkJsdXIgJiYgKGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pICl7XG4gICAgICBlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgIH07XG5cbiAgICAgIGVab29tID0gem9vbSAqIG1iUHhSYXRpbztcblxuICAgICAgdyA9IHIuY2FudmFzV2lkdGggKiBtYlB4UmF0aW87XG4gICAgICBoID0gci5jYW52YXNIZWlnaHQgKiBtYlB4UmF0aW87XG4gICAgfSBlbHNlIHtcbiAgICAgIGVQYW4gPSBlZmZlY3RpdmVQYW47XG4gICAgICBlWm9vbSA9IGVmZmVjdGl2ZVpvb207XG5cbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgIH1cblxuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgaWYoIGNsZWFyID09PSAnbW90aW9uQmx1cicgKXtcbiAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdywgaCk7XG4gICAgfSBlbHNlIGlmKCAhZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikgKXtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgIH1cblxuICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIGVQYW4ueCwgZVBhbi55ICk7XG4gICAgICBjb250ZXh0LnNjYWxlKCBlWm9vbSwgZVpvb20gKTtcbiAgICB9XG4gICAgaWYoIGZvcmNlZFBhbiApe1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoIGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSApO1xuICAgIH1cbiAgICBpZiggZm9yY2VkWm9vbSApe1xuICAgICAgY29udGV4dC5zY2FsZSggZm9yY2VkWm9vbSwgZm9yY2VkWm9vbSApO1xuICAgIH1cbiAgfVxuXG4gIGlmKCAhdGV4dHVyZURyYXcgKXtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gZmFsc2U7XG4gIH1cblxuICBpZiggdGV4dHVyZURyYXcgKXtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gdHJ1ZTtcblxuICAgIHZhciBiYjtcblxuICAgIGlmKCAhci50ZXh0dXJlQ2FjaGUgKXtcbiAgICAgIHIudGV4dHVyZUNhY2hlID0ge307XG5cbiAgICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmIgPSBjeS5lbGVtZW50cygpLmJvdW5kaW5nQm94KCk7XG5cbiAgICAgIHIudGV4dHVyZUNhY2hlLnRleHR1cmUgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIHIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgdmFyIGN4dCA9IHIuZGF0YS5idWZmZXJDb250ZXh0c1sgci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdCwgci5jYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0KTtcblxuICAgICAgci5yZW5kZXIoe1xuICAgICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICAgIGRyYXdPbmx5Tm9kZUxheWVyOiB0cnVlLFxuICAgICAgICBmb3JjZWRQeFJhdGlvOiBwaXhlbFJhdGlvICogci50ZXh0dXJlTXVsdFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0ID0ge1xuICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgIHdpZHRoOiByLmNhbnZhc1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICB2cC5tcGFuID0ge1xuICAgICAgICB4OiAoMCAtIHZwLnBhbi54KS92cC56b29tLFxuICAgICAgICB5OiAoMCAtIHZwLnBhbi55KS92cC56b29tXG4gICAgICB9O1xuICAgIH1cblxuICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG5cbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcblxuICAgIHZhciB0ZXh0dXJlID0gci50ZXh0dXJlQ2FjaGUudGV4dHVyZTtcbiAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydDtcbiAgICBiYiA9IHIudGV4dHVyZUNhY2hlLmJiO1xuXG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICBpZiggbW90aW9uQmx1ciApe1xuICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIG91dHNpZGVCZ0NvbG9yID0gY29yZVN0eWxlWydvdXRzaWRlLXRleHR1cmUtYmctY29sb3InXS52YWx1ZTtcbiAgICB2YXIgb3V0c2lkZUJnT3BhY2l0eSA9IGNvcmVTdHlsZVsnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknXS52YWx1ZTtcbiAgICByLmZpbGxTdHlsZSggY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSApO1xuICAgIGNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQgKTtcblxuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgZmFsc2UgKTtcblxuICAgIGNvbnRleHQuY2xlYXJSZWN0KCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGgvdnAuem9vbS9waXhlbFJhdGlvLCB2cC5oZWlnaHQvdnAuem9vbS9waXhlbFJhdGlvICk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UoIHRleHR1cmUsIHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aC92cC56b29tL3BpeGVsUmF0aW8sIHZwLmhlaWdodC92cC56b29tL3BpeGVsUmF0aW8gKTtcblxuICB9IGVsc2UgaWYoIHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgKXsgLy8gY2xlYXIgdGhlIGNhY2hlIHNpbmNlIHdlIGRvbid0IG5lZWQgaXRcbiAgICByLnRleHR1cmVDYWNoZSA9IG51bGw7XG4gIH1cblxuICB2YXIgdnBNYW5pcCA9IChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKTtcbiAgdmFyIGhpZGVFZGdlcyA9IHIuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuICB2YXIgaGlkZUxhYmVscyA9IHIuaGlkZUxhYmVsc09uVmlld3BvcnQgJiYgdnBNYW5pcDtcblxuICBpZiAobmVlZERyYXdbci5EUkFHXSB8fCBuZWVkRHJhd1tyLk5PREVdIHx8IGRyYXdBbGxMYXllcnMgfHwgZHJhd09ubHlOb2RlTGF5ZXIpIHtcbiAgICBpZiggaGlkZUVkZ2VzICl7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuZmluZEVkZ2VDb250cm9sUG9pbnRzKGVkZ2VzKTtcbiAgICB9XG5cbiAgICB2YXIgekVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6RWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHpFbGVzW2ldO1xuICAgICAgdmFyIGxpc3Q7XG4gICAgICB2YXIgYmIgPSBmb3JjZWRDb250ZXh0ID8gbnVsbCA6IGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgdmFyIGluc2lkZUV4dGVudCA9IGZvcmNlZENvbnRleHQgPyB0cnVlIDogbWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0KCBleHRlbnQsIGJiICk7XG5cbiAgICAgIGlmKCAhaW5zaWRlRXh0ZW50ICl7IGNvbnRpbnVlOyB9IC8vIG5vIG5lZWQgdG8gcmVuZGVyXG5cbiAgICAgIGlmICggZWxlLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyICkge1xuICAgICAgICBsaXN0ID0gZWxlcy5kcmFnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdCA9IGVsZXMubm9uZHJhZztcbiAgICAgIH1cblxuICAgICAgbGlzdC5lbGVzLnB1c2goIGVsZSApO1xuICAgIH1cblxuICB9XG5cblxuICBmdW5jdGlvbiBkcmF3RWxlbWVudHMoIGxpc3QsIGNvbnRleHQgKXtcbiAgICB2YXIgZWxlcyA9IGxpc3QuZWxlcztcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgci5kcmF3Tm9kZShjb250ZXh0LCBlbGUpO1xuXG4gICAgICAgIGlmKCAhaGlkZUxhYmVscyApe1xuICAgICAgICAgIHIuZHJhd05vZGVUZXh0KGNvbnRleHQsIGVsZSk7XG4gICAgICAgIH1cblxuICAgICAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYoICFoaWRlRWRnZXMgKSB7XG4gICAgICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlKTtcblxuICAgICAgICBpZiggIWhpZGVMYWJlbHMgKXtcbiAgICAgICAgICByLmRyYXdFZGdlVGV4dChjb250ZXh0LCBlbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUsIHRydWUpO1xuICAgICAgfVxuXG5cbiAgICB9XG5cbiAgfVxuXG4gIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuXG4gIG5lZWRNYkNsZWFyW3IuTk9ERV0gPSAhbmVlZERyYXdbci5OT0RFXSAmJiBtb3Rpb25CbHVyICYmICFyLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gIGlmKCBuZWVkTWJDbGVhcltyLk5PREVdICl7IHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSA9IHRydWU7IH1cblxuICBuZWVkTWJDbGVhcltyLkRSQUddID0gIW5lZWREcmF3W3IuRFJBR10gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuICBpZiggbmVlZE1iQ2xlYXJbci5EUkFHXSApeyByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSB0cnVlOyB9XG5cbiAgaWYoIG5lZWREcmF3W3IuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBuZWVkTWJDbGVhcltyLk5PREVdICl7XG4gICAgdmFyIHVzZUJ1ZmZlciA9IG1vdGlvbkJsdXIgJiYgIW5lZWRNYkNsZWFyW3IuTk9ERV0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAoIHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1sgci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFIF0gOiBkYXRhLmNvbnRleHRzW3IuTk9ERV0gKTtcbiAgICB2YXIgY2xlYXIgPSBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQ7XG5cbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBjbGVhciApO1xuICAgIGRyYXdFbGVtZW50cyhlbGVzLm5vbmRyYWcsIGNvbnRleHQpO1xuXG4gICAgaWYoICFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyICl7XG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W3IuRFJBR10gfHwgZHJhd0FsbExheWVycyB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSApIHtcbiAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbci5EUkFHXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8ICggdXNlQnVmZmVyID8gci5kYXRhLmJ1ZmZlckNvbnRleHRzWyByLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgXSA6IGRhdGEuY29udGV4dHNbci5EUkFHXSApO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkICk7XG4gICAgZHJhd0VsZW1lbnRzKGVsZXMuZHJhZywgY29udGV4dCk7XG5cbiAgICBpZiggIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIgKXtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiggci5zaG93RnBzIHx8ICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gJiYgIWRyYXdBbGxMYXllcnMpKSApIHtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgZGF0YS5jb250ZXh0c1tyLlNFTEVDVF9CT1hdO1xuXG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCApO1xuXG4gICAgaWYoIHIuc2VsZWN0aW9uWzRdID09IDEgJiYgKCByLmhvdmVyRGF0YS5zZWxlY3RpbmcgfHwgci50b3VjaERhdGEuc2VsZWN0aW5nICkgKXtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJ10udmFsdWUgLyB6b29tO1xuXG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoXCJcbiAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtY29sb3InXS52YWx1ZVswXSArIFwiLFwiXG4gICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWNvbG9yJ10udmFsdWVbMV0gKyBcIixcIlxuICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1jb2xvciddLnZhbHVlWzJdICsgXCIsXCJcbiAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSddLnZhbHVlICsgXCIpXCI7XG5cbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICByLnNlbGVjdGlvblsxXSxcbiAgICAgICAgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSxcbiAgICAgICAgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG5cbiAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwicmdiYShcIlxuICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvciddLnZhbHVlWzBdICsgXCIsXCJcbiAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InXS52YWx1ZVsxXSArIFwiLFwiXG4gICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMl0gKyBcIixcIlxuICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LW9wYWNpdHknXS52YWx1ZSArIFwiKVwiO1xuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChcbiAgICAgICAgICByLnNlbGVjdGlvblswXSxcbiAgICAgICAgICByLnNlbGVjdGlvblsxXSxcbiAgICAgICAgICByLnNlbGVjdGlvblsyXSAtIHIuc2VsZWN0aW9uWzBdLFxuICAgICAgICAgIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcblxuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoXCJcbiAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzBdICsgXCIsXCJcbiAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzFdICsgXCIsXCJcbiAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzJdICsgXCIsXCJcbiAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1vcGFjaXR5J10udmFsdWUgKyBcIilcIjtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKHBvcy54LCBwb3MueSwgY29yZVN0eWxlWydhY3RpdmUtYmctc2l6ZSddLnBmVmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgdGltZVRvUmVuZGVyID0gci5sYXN0UmVkcmF3VGltZTtcbiAgICBpZiggci5zaG93RnBzICYmIHRpbWVUb1JlbmRlciApe1xuICAgICAgdGltZVRvUmVuZGVyID0gTWF0aC5yb3VuZCggdGltZVRvUmVuZGVyICk7XG4gICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwL3RpbWVUb1JlbmRlcik7XG5cbiAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgY29udGV4dC5maWxsVGV4dCggJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcycsIDAsIDIwKTtcblxuICAgICAgdmFyIG1heEZwcyA9IDYwO1xuICAgICAgY29udGV4dC5zdHJva2VSZWN0KDAsIDMwLCAyNTAsIDIwKTtcbiAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMzAsIDI1MCAqIE1hdGgubWluKGZwcy9tYXhGcHMsIDEpLCAyMCk7XG4gICAgfVxuXG4gICAgaWYoICFkcmF3QWxsTGF5ZXJzICl7XG4gICAgICBuZWVkRHJhd1tyLlNFTEVDVF9CT1hdID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gbW90aW9uYmx1cjogYmxpdCByZW5kZXJlZCBibHVycnkgZnJhbWVzXG4gIGlmKCBtb3Rpb25CbHVyICYmIG1iUHhSYXRpbyAhPT0gMSApe1xuICAgIHZhciBjeHROb2RlID0gZGF0YS5jb250ZXh0c1tyLk5PREVdO1xuICAgIHZhciB0eHROb2RlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyByLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXTtcblxuICAgIHZhciBjeHREcmFnID0gZGF0YS5jb250ZXh0c1tyLkRSQUddO1xuICAgIHZhciB0eHREcmFnID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyByLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgXTtcblxuICAgIHZhciBkcmF3TW90aW9uQmx1ciA9IGZ1bmN0aW9uKCBjeHQsIHR4dCwgbmVlZENsZWFyICl7XG4gICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICBpZiggbmVlZENsZWFyIHx8ICFtb3Rpb25CbHVyRmFkZUVmZmVjdCApe1xuICAgICAgICBjeHQuY2xlYXJSZWN0KCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWJjbGVhciggY3h0LCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHhyID0gbWJQeFJhdGlvO1xuXG4gICAgICBjeHQuZHJhd0ltYWdlKFxuICAgICAgICB0eHQsIC8vIGltZ1xuICAgICAgICAwLCAwLCAvLyBzeCwgc3lcbiAgICAgICAgci5jYW52YXNXaWR0aCAqIHB4ciwgci5jYW52YXNIZWlnaHQgKiBweHIsIC8vIHN3LCBzaFxuICAgICAgICAwLCAwLCAvLyB4LCB5XG4gICAgICAgIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0IC8vIHcsIGhcbiAgICAgICk7XG4gICAgfTtcblxuICAgIGlmKCBuZWVkRHJhd1tyLk5PREVdIHx8IG5lZWRNYkNsZWFyW3IuTk9ERV0gKXtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKCBjeHROb2RlLCB0eHROb2RlLCBuZWVkTWJDbGVhcltyLk5PREVdICk7XG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYoIG5lZWREcmF3W3IuRFJBR10gfHwgbmVlZE1iQ2xlYXJbci5EUkFHXSApe1xuICAgICAgZHJhd01vdGlvbkJsdXIoIGN4dERyYWcsIHR4dERyYWcsIG5lZWRNYkNsZWFyW3IuRFJBR10gKTtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByLmN1cnJlbnRseURyYXdpbmcgPSBmYWxzZTtcblxuICByLnByZXZWaWV3cG9ydCA9IHZwO1xuXG4gIGlmKCByLmNsZWFyaW5nTW90aW9uQmx1ciApe1xuICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmKCBtb3Rpb25CbHVyICl7XG4gICAgci5tb3Rpb25CbHVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBudWxsO1xuXG4gICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuTk9ERV0gPSBmYWxzZTtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSA9IGZhbHNlO1xuICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9ICF0ZXh0dXJlRHJhdztcbiAgICAgIHIubWJGcmFtZXMgPSAwO1xuXG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSB0cnVlO1xuXG4gICAgICByLnJlZHJhdygpO1xuICAgIH0sIG1vdGlvbkJsdXJEZWxheSk7XG4gIH1cblxuICByLmRyYXdpbmdJbWFnZSA9IGZhbHNlO1xuXG5cbiAgaWYoICFmb3JjZWRDb250ZXh0ICYmICFyLmluaXRyZW5kZXIgKXtcbiAgICByLmluaXRyZW5kZXIgPSB0cnVlO1xuICAgIGN5LnRyaWdnZXIoJ2luaXRyZW5kZXInKTtcbiAgfVxuXG4gIGlmKCAhZm9yY2VkQ29udGV4dCApe1xuICAgIGN5LnRyaWdnZXJPblJlbmRlcigpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBtYXRoID0gcmVxdWlyZSgnLi4vLi4vLi4vbWF0aCcpO1xuXG4gIHZhciBDUnAgPSB7fTtcblxuICAvLyBATyBQb2x5Z29uIGRyYXdpbmdcbiAgQ1JwLmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuXG4gICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG5cbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8oIHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdICk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGNvbnRleHQubGluZVRvKCB4ICsgaGFsZlcgKiBwb2ludHNbaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbaSAqIDIgKyAxXSApO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcbiAgQ1JwLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblxuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBtYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgLy8gQXJjIGZyb20gbWlkZGxlIHRvcCB0byByaWdodCBzaWRlXG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBBcmMgZnJvbSByaWdodCBzaWRlIHRvIGJvdHRvbVxuICAgIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIGxlZnQgc2lkZSB0byB0b3BCb3JkZXJcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBKb2luIGxpbmVcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG5cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgdmFyIHNpbjAgPSBNYXRoLnNpbigwKTtcbiAgdmFyIGNvczAgPSBNYXRoLmNvcygwKTtcblxuICB2YXIgc2luID0ge307XG4gIHZhciBjb3MgPSB7fTtcblxuICB2YXIgZWxsaXBzZVN0ZXBTaXplID0gTWF0aC5QSSAvIDQwO1xuXG4gIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApIHtcbiAgICBzaW5baV0gPSBNYXRoLnNpbihpKTtcbiAgICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbiAgfVxuXG4gIENScC5kcmF3RWxsaXBzZVBhdGggPSBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KXtcbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgaWYoIGNvbnRleHQuZWxsaXBzZSApe1xuICAgICAgY29udGV4dC5lbGxpcHNlKCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aC8yLCBoZWlnaHQvMiwgMCwgMCwgMipNYXRoLlBJICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB4UG9zLCB5UG9zO1xuICAgICAgdmFyIHJ3ID0gd2lkdGgvMjtcbiAgICAgIHZhciByaCA9IGhlaWdodC8yO1xuICAgICAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplICkge1xuICAgICAgICB4UG9zID0gY2VudGVyWCAtIChydyAqIHNpbltpXSkgKiBzaW4wICsgKHJ3ICogY29zW2ldKSAqIGNvczA7XG4gICAgICAgIHlQb3MgPSBjZW50ZXJZICsgKHJoICogY29zW2ldKSAqIHNpbjAgKyAocmggKiBzaW5baV0pICogY29zMDtcblxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUnA7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2lzJyk7XG5cbnZhciBDUnAgPSB7fTtcblxuQ1JwLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBidWZmZXIud2lkdGggPSB3O1xuICBidWZmZXIuaGVpZ2h0ID0gaDtcblxuICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoJzJkJyldO1xufTtcblxuQ1JwLmJ1ZmZlckNhbnZhc0ltYWdlID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGJiID0gY3kuZWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuICB2YXIgd2lkdGggPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIudykgOiB0aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi5oKSA6IHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgdmFyIHNjYWxlID0gMTtcblxuICBpZiggb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgd2lkdGggKj0gb3B0aW9ucy5zY2FsZTtcbiAgICBoZWlnaHQgKj0gb3B0aW9ucy5zY2FsZTtcblxuICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgfSBlbHNlIGlmKCBpcy5udW1iZXIob3B0aW9ucy5tYXhXaWR0aCkgfHwgaXMubnVtYmVyKG9wdGlvbnMubWF4SGVpZ2h0KSApe1xuICAgIHZhciBtYXhTY2FsZVcgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4U2NhbGVIID0gSW5maW5pdHk7XG5cbiAgICBpZiggaXMubnVtYmVyKG9wdGlvbnMubWF4V2lkdGgpICl7XG4gICAgICBtYXhTY2FsZVcgPSBzY2FsZSAqIG9wdGlvbnMubWF4V2lkdGggLyB3aWR0aDtcbiAgICB9XG5cbiAgICBpZiggaXMubnVtYmVyKG9wdGlvbnMubWF4SGVpZ2h0KSApe1xuICAgICAgbWF4U2NhbGVIID0gc2NhbGUgKiBvcHRpb25zLm1heEhlaWdodCAvIGhlaWdodDtcbiAgICB9XG5cbiAgICBzY2FsZSA9IE1hdGgubWluKCBtYXhTY2FsZVcsIG1heFNjYWxlSCApO1xuXG4gICAgd2lkdGggKj0gc2NhbGU7XG4gICAgaGVpZ2h0ICo9IHNjYWxlO1xuICB9XG5cbiAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICB2YXIgYnVmZkN4dCA9IGJ1ZmZDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcbiAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XG5cbiAgICBidWZmQ3h0LmNsZWFyUmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgaWYoIG9wdGlvbnMuYmcgKXtcbiAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgIGJ1ZmZDeHQucmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuICAgICAgYnVmZkN4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgaWYoIG9wdGlvbnMuZnVsbCApeyAvLyBkcmF3IHRoZSBmdWxsIGJvdW5kcyBvZiB0aGUgZ3JhcGhcbiAgICAgIHRoaXMucmVuZGVyKHtcbiAgICAgICAgZm9yY2VkQ29udGV4dDogYnVmZkN4dCxcbiAgICAgICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICAgICAgZm9yY2VkWm9vbTogc2NhbGUsXG4gICAgICAgIGZvcmNlZFBhbjogeyB4OiAtYmIueDEqc2NhbGUsIHk6IC1iYi55MSpzY2FsZSB9LFxuICAgICAgICBmb3JjZWRQeFJhdGlvOiAxXG4gICAgICB9KTtcbiAgICB9IGVsc2UgeyAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgIHZhciBjeVBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHBhbiA9IHtcbiAgICAgICAgeDogY3lQYW4ueCAqIHNjYWxlLFxuICAgICAgICB5OiBjeVBhbi55ICogc2NhbGVcbiAgICAgIH07XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKSAqIHNjYWxlO1xuXG4gICAgICB0aGlzLnJlbmRlcih7XG4gICAgICAgIGZvcmNlZENvbnRleHQ6IGJ1ZmZDeHQsXG4gICAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgICAgIGZvcmNlZFBhbjogcGFuLFxuICAgICAgICBmb3JjZWRQeFJhdGlvOiAxXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZkNhbnZhcztcbn07XG5cbkNScC5wbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICByZXR1cm4gdGhpcy5idWZmZXJDYW52YXNJbWFnZSggb3B0aW9ucyApLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG59O1xuXG5DUnAuanBnID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgcmV0dXJuIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2UoIG9wdGlvbnMgKS50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiLypcblRoZSBjYW52YXMgcmVuZGVyZXIgd2FzIHdyaXR0ZW4gYnkgWXVlIERvbmcuXG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vLi4vLi4vaXMnKTtcblxudmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG52YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG5DUnAuQ0FOVkFTX0xBWUVSUyA9IDM7XG4vL1xuQ1JwLlNFTEVDVF9CT1ggPSAwO1xuQ1JwLkRSQUcgPSAxO1xuQ1JwLk5PREUgPSAyO1xuXG5DUnAuQlVGRkVSX0NPVU5UID0gMztcbi8vXG5DUnAuVEVYVFVSRV9CVUZGRVIgPSAwO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX05PREUgPSAxO1xuQ1JwLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcblxuICByLmRhdGEgPSB7XG4gICAgY2FudmFzZXM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY2FudmFzTmVlZHNSZWRyYXc6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG5cbiAgICBidWZmZXJDYW52YXNlczogbmV3IEFycmF5KENScC5CVUZGRVJfQ09VTlQpLFxuICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ1JwLkNBTlZBU19MQVlFUlMpXG4gIH07XG5cbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgY29udGFpbmVyU3R5bGUgPSByLmRhdGEuY2FudmFzQ29udGFpbmVyLnN0eWxlO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOycpO1xuICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgY29udGFpbmVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICB2YXIgY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKCByLmRhdGEuY2FudmFzQ29udGFpbmVyICk7XG4gIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgKCBjb250YWluZXIuZ2V0QXR0cmlidXRlKCdzdHlsZScpIHx8ICcnICkgKyAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOycpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIHZhciBjYW52YXMgPSByLmRhdGEuY2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICByLmRhdGEuY29udGV4dHNbaV0gPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCAnc3R5bGUnLCAnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLW1vei11c2VyLXNlbGVjdDogLW1vei1ub25lOyB1c2VyLXNlbGVjdDogbm9uZTsgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsMCwwLDApOyBvdXRsaW5lLXN0eWxlOiBub25lOycgKyAoIGlzLm1zKCkgPyAnIC1tcy10b3VjaC1hY3Rpb246IG5vbmU7IHRvdWNoLWFjdGlvbjogbm9uZTsgJyA6ICcnICkgKTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgaSk7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDUnAuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgIHIuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tpXSA9IGZhbHNlO1xuICB9XG4gIHIuZGF0YS50b3BDYW52YXMgPSByLmRhdGEuY2FudmFzZXNbMF07XG5cbiAgci5kYXRhLmNhbnZhc2VzW0NScC5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLk5PREUgKyAnLW5vZGUnKTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5TRUxFQ1RfQk9YXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLlNFTEVDVF9CT1ggKyAnLXNlbGVjdGJveCcpO1xuICByLmRhdGEuY2FudmFzZXNbQ1JwLkRSQUddLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDUnAuRFJBRyArICctZHJhZycpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1JwLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzW2ldID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUuekluZGV4ID0gU3RyaW5nKC1pIC0gMSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgfVxuXG4gIHIucGF0aHNFbmFibGVkID0gdHJ1ZTtcbn1cblxuQ1JwLnJlZHJhd0hpbnQgPSBmdW5jdGlvbiggZ3JvdXAsIGJvb2wgKXtcbiAgdmFyIHIgPSB0aGlzO1xuXG4gIHN3aXRjaCggZ3JvdXAgKXtcbiAgICBjYXNlICdlbGVzJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgQ1JwLk5PREUgXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkcmFnJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1sgQ1JwLkRSQUcgXSA9IGJvb2w7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3WyBDUnAuU0VMRUNUX0JPWCBdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vLyB3aGV0aGVyIHRvIHVzZSBQYXRoMkQgY2FjaGluZyBmb3IgZHJhd2luZ1xudmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcblxuQ1JwLnBhdGgyZEVuYWJsZWQgPSBmdW5jdGlvbiggb24gKXtcbiAgaWYoIG9uID09PSB1bmRlZmluZWQgKXtcbiAgICByZXR1cm4gdGhpcy5wYXRoc0VuYWJsZWQ7XG4gIH1cblxuICB0aGlzLnBhdGhzRW5hYmxlZCA9IG9uID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuQ1JwLnVzZVBhdGhzID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHBhdGhzSW1wbGQgJiYgdGhpcy5wYXRoc0VuYWJsZWQ7XG59O1xuXG5bXG4gIHJlcXVpcmUoJy4vYXJyb3ctc2hhcGVzJyksXG4gIHJlcXVpcmUoJy4vZHJhd2luZy1lZGdlcycpLFxuICByZXF1aXJlKCcuL2RyYXdpbmctaW1hZ2VzJyksXG4gIHJlcXVpcmUoJy4vZHJhd2luZy1sYWJlbC10ZXh0JyksXG4gIHJlcXVpcmUoJy4vZHJhd2luZy1ub2RlcycpLFxuICByZXF1aXJlKCcuL2RyYXdpbmctcmVkcmF3JyksXG4gIHJlcXVpcmUoJy4vZHJhd2luZy1zaGFwZXMnKSxcbiAgcmVxdWlyZSgnLi9leHBvcnQtaW1hZ2UnKSxcbiAgcmVxdWlyZSgnLi9ub2RlLXNoYXBlcycpXG5dLmZvckVhY2goZnVuY3Rpb24oIHByb3BzICl7XG4gIHV0aWwuZXh0ZW5kKCBDUnAsIHByb3BzICk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDUjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENScCA9IHt9O1xuXG52YXIgaW1wbDtcblxuQ1JwLm5vZGVTaGFwZUltcGwgPSBmdW5jdGlvbiggbmFtZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgcmV0dXJuICggaW1wbCB8fCAoaW1wbCA9IHtcbiAgICAnZWxsaXBzZSc6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0ICl7XG4gICAgICBzZWxmLmRyYXdFbGxpcHNlUGF0aCggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCApO1xuICAgIH0sXG5cbiAgICAncG9seWdvbic6IGZ1bmN0aW9uKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMgKXtcbiAgICAgIHNlbGYuZHJhd1BvbHlnb25QYXRoKCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMgKTtcbiAgICB9LFxuXG4gICAgJ3JvdW5kcmVjdGFuZ2xlJzogZnVuY3Rpb24oIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgKXtcbiAgICAgIHNlbGYuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aCggY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgMTAgKTtcbiAgICB9XG4gIH0pIClbIG5hbWUgXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1JwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgeyBuYW1lOiAnbnVsbCcsIGltcGw6IHJlcXVpcmUoJy4vbnVsbCcpIH0sXG4gIHsgbmFtZTogJ2Jhc2UnLCBpbXBsOiByZXF1aXJlKCcuL2Jhc2UnKSB9LFxuICB7IG5hbWU6ICdjYW52YXMnLCBpbXBsOiByZXF1aXJlKCcuL2NhbnZhcycpIH1cbl07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIE51bGxSZW5kZXJlcihvcHRpb25zKXtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3Rpbmdcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbigpe307XG5cbk51bGxSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogbm9vcCxcbiAgbm90aWZ5OiBmdW5jdGlvbigpeyB0aGlzLm5vdGlmaWNhdGlvbnMrKzsgfSxcbiAgaW5pdDogbm9vcFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOdWxsUmVuZGVyZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgVGhyZWFkID0gcmVxdWlyZSgnLi90aHJlYWQnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnLi9kZWZpbmUnKTtcblxudmFyIEZhYnJpYyA9IGZ1bmN0aW9uKCBOICl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBGYWJyaWMpICl7XG4gICAgcmV0dXJuIG5ldyBGYWJyaWMoIE4gKTtcbiAgfVxuXG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgcGFzczogW11cbiAgfTtcblxuICB2YXIgZGVmTiA9IDQ7XG5cbiAgaWYoIGlzLm51bWJlcihOKSApe1xuICAgIC8vIHRoZW4gdXNlIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHRocmVhZHNcbiAgfSBpZiggdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgIT0gbnVsbCApe1xuICAgIE4gPSBuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtcbiAgfSBlbHNlIHtcbiAgICB0cnl7XG4gICAgICBOID0gcmVxdWlyZSgnb3MnKS5jcHVzKCkubGVuZ3RoO1xuICAgIH0gY2F0Y2goIGVyciApe1xuICAgICAgTiA9IGRlZk47XG4gICAgfVxuICB9IC8vIFRPRE8gY291bGQgdXNlIGFuIGVzdGltYXRpb24gaGVyZSBidXQgd291bGQgdGhlIGFkZGl0aW9uYWwgZXhwZW5zZSBiZSB3b3J0aCBpdD9cblxuICBmb3IoIHZhciBpID0gMDsgaSA8IE47IGkrKyApe1xuICAgIHRoaXNbaV0gPSBuZXcgVGhyZWFkKCk7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IE47XG59O1xuXG52YXIgZmFiZm4gPSBGYWJyaWMucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG51dGlsLmV4dGVuZChmYWJmbiwge1xuXG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbigpeyByZXR1cm4gJ2ZhYnJpYyc7IH0sXG5cbiAgLy8gcmVxdWlyZSBmbiBpbiBhbGwgdGhyZWFkc1xuICByZXF1aXJlOiBmdW5jdGlvbiggZm4sIGFzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcblxuICAgICAgdGhyZWFkLnJlcXVpcmUoIGZuLCBhcyApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8vIGdldCBhIHJhbmRvbSB0aHJlYWRcbiAgcmFuZG9tOiBmdW5jdGlvbigpe1xuICAgIHZhciBpID0gTWF0aC5yb3VuZCggKHRoaXMubGVuZ3RoIC0gMSkgKiBNYXRoLnJhbmRvbSgpICk7XG4gICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICByZXR1cm4gdGhyZWFkO1xuICB9LFxuXG4gIC8vIHJ1biBvbiByYW5kb20gdGhyZWFkXG4gIHJ1bjogZnVuY3Rpb24oIGZuICl7XG4gICAgdmFyIHBhc3MgPSB0aGlzLl9wcml2YXRlLnBhc3Muc2hpZnQoKTtcblxuICAgIHJldHVybiB0aGlzLnJhbmRvbSgpLnBhc3MoIHBhc3MgKS5ydW4oIGZuICk7XG4gIH0sXG5cbiAgLy8gc2VuZHMgYSByYW5kb20gdGhyZWFkIGEgbWVzc2FnZVxuICBtZXNzYWdlOiBmdW5jdGlvbiggbSApe1xuICAgIHJldHVybiB0aGlzLnJhbmRvbSgpLm1lc3NhZ2UoIG0gKTtcbiAgfSxcblxuICAvLyBzZW5kIGFsbCB0aHJlYWRzIGEgbWVzc2FnZVxuICBicm9hZGNhc3Q6IGZ1bmN0aW9uKCBtICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcblxuICAgICAgdGhyZWFkLm1lc3NhZ2UoIG0gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBzdG9wIGFsbCB0aHJlYWRzXG4gIHN0b3A6IGZ1bmN0aW9uKCl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcblxuICAgICAgdGhyZWFkLnN0b3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICAvLyBwYXNzIGRhdGEgdG8gYmUgdXNlZCB3aXRoIC5zcHJlYWQoKSBldGMuXG4gIHBhc3M6IGZ1bmN0aW9uKCBkYXRhICl7XG4gICAgdmFyIHBhc3MgPSB0aGlzLl9wcml2YXRlLnBhc3M7XG5cbiAgICBpZiggaXMuYXJyYXkoZGF0YSkgKXtcbiAgICAgIHBhc3MucHVzaCggZGF0YSApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyAnT25seSBhcnJheXMgbWF5IGJlIHVzZWQgd2l0aCBmYWJyaWMucGFzcygpJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcblxuICBzcHJlYWRTaXplOiBmdW5jdGlvbigpe1xuICAgIHZhciBzdWJzaXplID0gIE1hdGguY2VpbCggdGhpcy5fcHJpdmF0ZS5wYXNzWzBdLmxlbmd0aCAvIHRoaXMubGVuZ3RoICk7XG5cbiAgICBzdWJzaXplID0gTWF0aC5tYXgoIDEsIHN1YnNpemUgKTsgLy8gZG9uJ3QgcGFzcyBsZXNzIHRoYW4gb25lIGVsZSB0byBlYWNoIHRocmVhZFxuXG4gICAgcmV0dXJuIHN1YnNpemU7XG4gIH0sXG5cbiAgLy8gc3BsaXQgdGhlIGRhdGEgaW50byBzbGljZXMgdG8gc3ByZWFkIHRoZSBkYXRhIGVxdWFsbHkgYW1vbmcgdGhyZWFkc1xuICBzcHJlYWQ6IGZ1bmN0aW9uKCBmbiApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgX3AgPSBzZWxmLl9wcml2YXRlO1xuICAgIHZhciBzdWJzaXplID0gc2VsZi5zcHJlYWRTaXplKCk7IC8vIG51bWJlciBvZiBwYXNzIGVsZXMgdG8gaGFuZGxlIGluIGVhY2ggdGhyZWFkXG4gICAgdmFyIHBhc3MgPSBfcC5wYXNzLnNoaWZ0KCkuY29uY2F0KFtdKTsgLy8ga2VlcCBhIGNvcHlcbiAgICB2YXIgcnVuUHMgPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG4gICAgICB2YXIgc2xpY2UgPSBwYXNzLnNwbGljZSggMCwgc3Vic2l6ZSApO1xuXG4gICAgICB2YXIgcnVuUCA9IHRocmVhZC5wYXNzKCBzbGljZSApLnJ1biggZm4gKTtcblxuICAgICAgcnVuUHMucHVzaCggcnVuUCApO1xuXG4gICAgICB2YXIgZG9uZUVhcmx5ID0gcGFzcy5sZW5ndGggPT09IDA7XG4gICAgICBpZiggZG9uZUVhcmx5ICl7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKCBydW5QcyApLnRoZW4oZnVuY3Rpb24oIHRoZW5zICl7XG4gICAgICB2YXIgcG9zdHBhc3MgPSBbXTtcbiAgICAgIHZhciBwID0gMDtcblxuICAgICAgLy8gZmlsbCBwb3N0cGFzcyB3aXRoIHRoZSB0b3RhbCByZXN1bHQgam9pbmVkIGZyb20gYWxsIHRocmVhZHNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhlbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHRoZW4gPSB0aGVuc1tpXTsgLy8gYXJyYXkgcmVzdWx0IGZyb20gdGhyZWFkIGlcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHRoZW4ubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgdCA9IHRoZW5bal07IC8vIGFycmF5IGVsZW1lbnRcblxuICAgICAgICAgIHBvc3RwYXNzWyBwKysgXSA9IHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc3RwYXNzO1xuICAgIH0pO1xuICB9LFxuXG4gIC8vIHBhcmFsbGVsIHZlcnNpb24gb2YgYXJyYXkubWFwKClcbiAgbWFwOiBmdW5jdGlvbiggZm4gKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLnJlcXVpcmUoIGZuLCAnXyRfJF9mYWJtYXAnICk7XG5cbiAgICByZXR1cm4gc2VsZi5zcHJlYWQoZnVuY3Rpb24oIHNwbGl0ICl7XG4gICAgICB2YXIgbWFwcGVkID0gW107XG4gICAgICB2YXIgb3JpZ1Jlc29sdmUgPSByZXNvbHZlOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgcmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWwgKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIG1hcHBlZC5wdXNoKCB2YWwgKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc3BsaXQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG9sZExlbiA9IG1hcHBlZC5sZW5ndGg7XG4gICAgICAgIHZhciByZXQgPSBfJF8kX2ZhYm1hcCggc3BsaXRbaV0gKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgIHZhciBub3RoaW5nSW5zZEJ5UmVzb2x2ZSA9IG9sZExlbiA9PT0gbWFwcGVkLmxlbmd0aDtcblxuICAgICAgICBpZiggbm90aGluZ0luc2RCeVJlc29sdmUgKXtcbiAgICAgICAgICBtYXBwZWQucHVzaCggcmV0ICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZSA9IG9yaWdSZXNvbHZlOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICB9KTtcblxuICB9LFxuXG4gIC8vIHBhcmFsbGVsIHZlcnNpb24gb2YgYXJyYXkuZmlsdGVyKClcbiAgZmlsdGVyOiBmdW5jdGlvbiggZm4gKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBwYXNzID0gX3AucGFzc1swXTtcblxuICAgIHJldHVybiB0aGlzLm1hcCggZm4gKS50aGVuKGZ1bmN0aW9uKCBpbmNsdWRlICl7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFzcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZGF0dW0gPSBwYXNzW2ldO1xuICAgICAgICB2YXIgaW5jRGF0dW0gPSBpbmNsdWRlW2ldO1xuXG4gICAgICAgIGlmKCBpbmNEYXR1bSApe1xuICAgICAgICAgIHJldC5wdXNoKCBkYXR1bSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgLy8gc29ydHMgdGhlIHBhc3NlZCBhcnJheSB1c2luZyBhIGRpdmlkZSBhbmQgY29ucXVlciBzdHJhdGVneVxuICBzb3J0OiBmdW5jdGlvbiggY21wICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBQID0gdGhpcy5fcHJpdmF0ZS5wYXNzWzBdLmxlbmd0aDtcbiAgICB2YXIgc3Vic2l6ZSA9IHRoaXMuc3ByZWFkU2l6ZSgpO1xuXG4gICAgY21wID0gY21wIHx8IGZ1bmN0aW9uKCBhLCBiICl7IC8vIGRlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgICAgaWYoIGEgPCBiICl7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiggYSA+IGIgKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH07XG5cbiAgICBzZWxmLnJlcXVpcmUoIGNtcCwgJ18kXyRfY21wJyApO1xuXG4gICAgcmV0dXJuIHNlbGYuc3ByZWFkKGZ1bmN0aW9uKCBzcGxpdCApeyAvLyBzb3J0IGVhY2ggc3BsaXQgbm9ybWFsbHlcbiAgICAgIHZhciBzb3J0ZWRTcGxpdCA9IHNwbGl0LnNvcnQoIF8kXyRfY21wICk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgcmVzb2x2ZSggc29ydGVkU3BsaXQgKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICB9KS50aGVuKGZ1bmN0aW9uKCBqb2luZWQgKXtcbiAgICAgIC8vIGRvIGFsbCB0aGUgbWVyZ2luZyBpbiB0aGUgbWFpbiB0aHJlYWQgdG8gbWluaW1pc2UgZGF0YSB0cmFuc2ZlclxuXG4gICAgICAvLyBUT0RPIGNvdWxkIGRvIG1lcmdpbmcgaW4gc2VwYXJhdGUgdGhyZWFkcyBidXQgd291bGQgaW5jdXIgYWRkJ2wgY29zdCBvZiBkYXRhIHRyYW5zZmVyXG4gICAgICAvLyBmb3IgZWFjaCBsZXZlbCBvZiB0aGUgbWVyZ2VcblxuICAgICAgdmFyIG1lcmdlID0gZnVuY3Rpb24oIGksIGosIG1heCApe1xuICAgICAgICAvLyBkb24ndCBvdmVyZmxvdyBhcnJheVxuICAgICAgICBqID0gTWF0aC5taW4oIGosIFAgKTtcbiAgICAgICAgbWF4ID0gTWF0aC5taW4oIG1heCwgUCApO1xuXG4gICAgICAgIC8vIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIG9mIG1lcmdlXG4gICAgICAgIHZhciBsID0gaTtcbiAgICAgICAgdmFyIHIgPSBqO1xuXG4gICAgICAgIHZhciBzb3J0ZWQgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBrID0gbDsgayA8IG1heDsgaysrICl7XG5cbiAgICAgICAgICB2YXIgZWxlSSA9IGpvaW5lZFtpXTtcbiAgICAgICAgICB2YXIgZWxlSiA9IGpvaW5lZFtqXTtcblxuICAgICAgICAgIGlmKCBpIDwgciAmJiAoIGogPj0gbWF4IHx8IGNtcChlbGVJLCBlbGVKKSA8PSAwICkgKXtcbiAgICAgICAgICAgIHNvcnRlZC5wdXNoKCBlbGVJICk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRlZC5wdXNoKCBlbGVKICk7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbiB0aGUgYXJyYXkgcHJvcGVyLCBwdXQgdGhlIHNvcnRlZCB2YWx1ZXNcbiAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBzb3J0ZWQubGVuZ3RoOyBrKysgKXsgLy8ga3RoIHNvcnRlZCBpdGVtXG4gICAgICAgICAgdmFyIGluZGV4ID0gbCArIGs7XG5cbiAgICAgICAgICBqb2luZWRbIGluZGV4IF0gPSBzb3J0ZWRba107XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciggdmFyIHNwbGl0TCA9IHN1YnNpemU7IHNwbGl0TCA8IFA7IHNwbGl0TCAqPSAyICl7IC8vIG1lcmdlIHVudGlsIGFycmF5IGlzIFwic3BsaXRcIiBhcyAxXG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBQOyBpICs9IDIqc3BsaXRMICl7XG4gICAgICAgICAgbWVyZ2UoIGksIGkgKyBzcGxpdEwsIGkgKyAyKnNwbGl0TCApO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGpvaW5lZDtcbiAgICB9KTtcbiAgfVxuXG5cbn0pO1xuXG52YXIgZGVmaW5lUmFuZG9tUGFzc2VyID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCBmbiwgYXJnMSApe1xuICAgIHZhciBwYXNzID0gdGhpcy5fcHJpdmF0ZS5wYXNzLnNoaWZ0KCk7XG5cbiAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5wYXNzKCBwYXNzIClbIG9wdHMudGhyZWFkRm4gXSggZm4sIGFyZzEgKTtcbiAgfTtcbn07XG5cbnV0aWwuZXh0ZW5kKGZhYmZuLCB7XG4gIHJhbmRvbU1hcDogZGVmaW5lUmFuZG9tUGFzc2VyKHsgdGhyZWFkRm46ICdtYXAnIH0pLFxuXG4gIHJlZHVjZTogZGVmaW5lUmFuZG9tUGFzc2VyKHsgdGhyZWFkRm46ICdyZWR1Y2UnIH0pLFxuXG4gIHJlZHVjZVJpZ2h0OiBkZWZpbmVSYW5kb21QYXNzZXIoeyB0aHJlYWRGbjogJ3JlZHVjZVJpZ2h0JyB9KVxufSk7XG5cbi8vIGFsaWFzZXNcbnZhciBmbiA9IGZhYmZuO1xuZm4ucHJvbWlzZSA9IGZuLnJ1bjtcbmZuLnRlcm1pbmF0ZSA9IGZuLmhhbHQgPSBmbi5zdG9wO1xuZm4uaW5jbHVkZSA9IGZuLnJlcXVpcmU7XG5cbi8vIHB1bGwgaW4gZXZlbnQgYXBpc1xudXRpbC5leHRlbmQoZmFiZm4sIHtcbiAgb246IGRlZmluZS5vbigpLFxuICBvbmU6IGRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gIG9mZjogZGVmaW5lLm9mZigpLFxuICB0cmlnZ2VyOiBkZWZpbmUudHJpZ2dlcigpXG59KTtcblxuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCBmYWJmbiApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhYnJpYztcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjguMFxuKGZ1bmN0aW9uKCkge1xuICB2YXIgSGVhcCwgZGVmYXVsdENtcCwgZmxvb3IsIGhlYXBpZnksIGhlYXBwb3AsIGhlYXBwdXNoLCBoZWFwcHVzaHBvcCwgaGVhcHJlcGxhY2UsIGluc29ydCwgbWluLCBubGFyZ2VzdCwgbnNtYWxsZXN0LCB1cGRhdGVJdGVtLCBfc2lmdGRvd24sIF9zaWZ0dXA7XG5cbiAgZmxvb3IgPSBNYXRoLmZsb29yLCBtaW4gPSBNYXRoLm1pbjtcblxuXG4gIC8qXG4gIERlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvbiB0byBiZSB1c2VkXG4gICAqL1xuXG4gIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHggPCB5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmICh4ID4geSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG5cbiAgLypcbiAgSW5zZXJ0IGl0ZW0geCBpbiBsaXN0IGEsIGFuZCBrZWVwIGl0IHNvcnRlZCBhc3N1bWluZyBhIGlzIHNvcnRlZC5cblxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG5cbiAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuICAgKi9cblxuICBpbnNvcnQgPSBmdW5jdGlvbihhLCB4LCBsbywgaGksIGNtcCkge1xuICAgIHZhciBtaWQ7XG4gICAgaWYgKGxvID09IG51bGwpIHtcbiAgICAgIGxvID0gMDtcbiAgICB9XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobG8gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmIChoaSA9PSBudWxsKSB7XG4gICAgICBoaSA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XG4gICAgICAgIGhpID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xuICB9O1xuXG5cbiAgLypcbiAgUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG5cbiAgVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXG4gIG1vcmUgYXBwcm9wcmlhdGUgd2hlbiB1c2luZyBhIGZpeGVkIHNpemUgaGVhcC4gTm90ZSB0aGF0IHRoZSB2YWx1ZVxuICByZXR1cm5lZCBtYXkgYmUgbGFyZ2VyIHRoYW4gaXRlbSEgVGhhdCBjb25zdHJhaW5zIHJlYXNvbmFibGUgdXNlIG9mXG4gIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG4gICAgICBpZiBpdGVtID4gYXJyYXlbMF1cbiAgICAgICAgaXRlbSA9IGhlYXByZXBsYWNlKGFycmF5LCBpdGVtKVxuICAgKi9cblxuICBoZWFwcmVwbGFjZSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICBhcnJheVswXSA9IGl0ZW07XG4gICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIEZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cbiAgICovXG5cbiAgaGVhcHB1c2hwb3AgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAoYXJyYXkubGVuZ3RoICYmIGNtcChhcnJheVswXSwgaXRlbSkgPCAwKSB7XG4gICAgICBfcmVmID0gW2FycmF5WzBdLCBpdGVtXSwgaXRlbSA9IF9yZWZbMF0sIGFycmF5WzBdID0gX3JlZlsxXTtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgVHJhbnNmb3JtIGxpc3QgaW50byBhIGhlYXAsIGluLXBsYWNlLCBpbiBPKGFycmF5Lmxlbmd0aCkgdGltZS5cbiAgICovXG5cbiAgaGVhcGlmeSA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgaSwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIF9yZWYxID0gKGZ1bmN0aW9uKCkge1xuICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICBmb3IgKHZhciBfaiA9IDAsIF9yZWYgPSBmbG9vcihhcnJheS5sZW5ndGggLyAyKTsgMCA8PSBfcmVmID8gX2ogPCBfcmVmIDogX2ogPiBfcmVmOyAwIDw9IF9yZWYgPyBfaisrIDogX2otLSl7IF9yZXN1bHRzMS5wdXNoKF9qKTsgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICB9KS5hcHBseSh0aGlzKS5yZXZlcnNlKCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpID0gX3JlZjFbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChfc2lmdHVwKGFycmF5LCBpLCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG5cbiAgLypcbiAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cbiAgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIGl0ZW0gaXMgYmVpbmcgbW9kaWZpZWQuXG4gICAqL1xuXG4gIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHBvcyA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKHBvcyA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3NpZnRkb3duKGFycmF5LCAwLCBwb3MsIGNtcCk7XG4gICAgcmV0dXJuIF9zaWZ0dXAoYXJyYXksIHBvcywgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gbGFyZ2VzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5sYXJnZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCByZXN1bHQsIF9pLCBfbGVuLCBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbik7XG4gICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KHJlc3VsdCwgY21wKTtcbiAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICBoZWFwcHVzaHBvcChyZXN1bHQsIGVsZW0sIGNtcCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApLnJldmVyc2UoKTtcbiAgfTtcblxuXG4gIC8qXG4gIEZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBuc21hbGxlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIGksIGxvcywgcmVzdWx0LCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChuICogMTAgPD0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKS5zb3J0KGNtcCk7XG4gICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICBfcmVmID0gYXJyYXkuc2xpY2Uobik7XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgICBpZiAoY21wKGVsZW0sIGxvcykgPCAwKSB7XG4gICAgICAgICAgaW5zb3J0KHJlc3VsdCwgZWxlbSwgMCwgbnVsbCwgY21wKTtcbiAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShhcnJheSwgY21wKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoaSA9IF9qID0gMCwgX3JlZjEgPSBtaW4obiwgYXJyYXkubGVuZ3RoKTsgMCA8PSBfcmVmMSA/IF9qIDwgX3JlZjEgOiBfaiA+IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG4gICAgICBfcmVzdWx0cy5wdXNoKGhlYXBwb3AoYXJyYXksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgX3NpZnRkb3duID0gZnVuY3Rpb24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCkge1xuICAgIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIHdoaWxlIChwb3MgPiBzdGFydHBvcykge1xuICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDE7XG4gICAgICBwYXJlbnQgPSBhcnJheVtwYXJlbnRwb3NdO1xuICAgICAgaWYgKGNtcChuZXdpdGVtLCBwYXJlbnQpIDwgMCkge1xuICAgICAgICBhcnJheVtwb3NdID0gcGFyZW50O1xuICAgICAgICBwb3MgPSBwYXJlbnRwb3M7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgfTtcblxuICBfc2lmdHVwID0gZnVuY3Rpb24oYXJyYXksIHBvcywgY21wKSB7XG4gICAgdmFyIGNoaWxkcG9zLCBlbmRwb3MsIG5ld2l0ZW0sIHJpZ2h0cG9zLCBzdGFydHBvcztcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGVuZHBvcyA9IGFycmF5Lmxlbmd0aDtcbiAgICBzdGFydHBvcyA9IHBvcztcbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIHdoaWxlIChjaGlsZHBvcyA8IGVuZHBvcykge1xuICAgICAgcmlnaHRwb3MgPSBjaGlsZHBvcyArIDE7XG4gICAgICBpZiAocmlnaHRwb3MgPCBlbmRwb3MgJiYgIShjbXAoYXJyYXlbY2hpbGRwb3NdLCBhcnJheVtyaWdodHBvc10pIDwgMCkpIHtcbiAgICAgICAgY2hpbGRwb3MgPSByaWdodHBvcztcbiAgICAgIH1cbiAgICAgIGFycmF5W3Bvc10gPSBhcnJheVtjaGlsZHBvc107XG4gICAgICBwb3MgPSBjaGlsZHBvcztcbiAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgfVxuICAgIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCk7XG4gIH07XG5cbiAgSGVhcCA9IChmdW5jdGlvbigpIHtcbiAgICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcblxuICAgIEhlYXAucG9wID0gaGVhcHBvcDtcblxuICAgIEhlYXAucmVwbGFjZSA9IGhlYXByZXBsYWNlO1xuXG4gICAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XG5cbiAgICBIZWFwLmhlYXBpZnkgPSBoZWFwaWZ5O1xuXG4gICAgSGVhcC51cGRhdGVJdGVtID0gdXBkYXRlSXRlbTtcblxuICAgIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcblxuICAgIEhlYXAubnNtYWxsZXN0ID0gbnNtYWxsZXN0O1xuXG4gICAgZnVuY3Rpb24gSGVhcChjbXApIHtcbiAgICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuICAgICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIH1cblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2godGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwcG9wKHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF07XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuaW5kZXhPZih4KSAhPT0gLTE7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHJlcGxhY2UodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNocG9wKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBpZnkodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS51cGRhdGVJdGVtID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUl0ZW0odGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhlYXA7XG4gICAgICBoZWFwID0gbmV3IEhlYXAoKTtcbiAgICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgcmV0dXJuIGhlYXA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLnNsaWNlKDApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9wID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmZyb250ID0gSGVhcC5wcm90b3R5cGUucGVlaztcblxuICAgIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29weSA9IEhlYXAucHJvdG90eXBlLmNsb25lO1xuXG4gICAgcmV0dXJuIEhlYXA7XG5cbiAgfSkoKTtcblxuICAoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIHJldHVybiBkZWZpbmUoW10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb290LkhlYXAgPSBmYWN0b3J5KCk7XG4gICAgfVxuICB9KSh0aGlzLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSGVhcDtcbiAgfSk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCcuL3dpbmRvdycpO1xudmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIENvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciBleHRlbnNpb24gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xudmFyIHJlZ2lzdGVySnF1ZXJ5ID0gcmVxdWlyZSgnLi9qcXVlcnktcGx1Z2luJyk7XG52YXIgU3R5bGVzaGVldCA9IHJlcXVpcmUoJy4vc3R5bGVzaGVldCcpO1xudmFyIFRocmVhZCA9IHJlcXVpcmUoJy4vdGhyZWFkJyk7XG52YXIgRmFicmljID0gcmVxdWlyZSgnLi9mYWJyaWMnKTtcblxudmFyIGN5dG9zY2FwZSA9IGZ1bmN0aW9uKCBvcHRpb25zICl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAvLyBpZiBubyBvcHRpb25zIHNwZWNpZmllZCwgdXNlIGRlZmF1bHRcbiAgaWYoIG9wdGlvbnMgPT09IHVuZGVmaW5lZCApe1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpbnN0YW5jZVxuICBpZiggaXMucGxhaW5PYmplY3QoIG9wdGlvbnMgKSApe1xuICAgIHJldHVybiBuZXcgQ29yZSggb3B0aW9ucyApO1xuICB9XG5cbiAgLy8gYWxsb3cgZm9yIHJlZ2lzdHJhdGlvbiBvZiBleHRlbnNpb25zXG4gIGVsc2UgaWYoIGlzLnN0cmluZyggb3B0aW9ucyApICkge1xuICAgIHJldHVybiBleHRlbnNpb24uYXBwbHkoZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG4vLyByZXBsYWNlZCBieSBidWlsZCBzeXN0ZW1cbmN5dG9zY2FwZS52ZXJzaW9uID0gJ3t7VkVSU0lPTn19JztcblxuLy8gdHJ5IHRvIHJlZ2lzdGVyIHcvIGpxdWVyeVxuaWYoIHdpbmRvdyAmJiB3aW5kb3cualF1ZXJ5ICl7XG4gIHJlZ2lzdGVySnF1ZXJ5KCB3aW5kb3cualF1ZXJ5LCBjeXRvc2NhcGUgKTtcbn1cblxuLy8gZXhwb3NlIHJlZ2lzdGVyIGFwaVxuY3l0b3NjYXBlLnJlZ2lzdGVySnF1ZXJ5ID0gZnVuY3Rpb24oIGpRdWVyeSApe1xuICByZWdpc3RlckpxdWVyeSggalF1ZXJ5LCBjeXRvc2NhcGUgKTtcbn07XG5cbi8vIGV4cG9zZSBwdWJsaWMgYXBpcyAobW9zdGx5IGZvciBleHRlbnNpb25zKVxuY3l0b3NjYXBlLnN0eWxlc2hlZXQgPSBjeXRvc2NhcGUuU3R5bGVzaGVldCA9IFN0eWxlc2hlZXQ7XG5jeXRvc2NhcGUudGhyZWFkID0gY3l0b3NjYXBlLlRocmVhZCA9IFRocmVhZDtcbmN5dG9zY2FwZS5mYWJyaWMgPSBjeXRvc2NhcGUuRmFicmljID0gRmFicmljO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN5dG9zY2FwZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHdpbmRvdyA9IHJlcXVpcmUoJy4vd2luZG93Jyk7XG52YXIgbmF2aWdhdG9yID0gd2luZG93ID8gd2luZG93Lm5hdmlnYXRvciA6IG51bGw7XG5cbnZhciB0eXBlb2ZzdHIgPSB0eXBlb2YgJyc7XG52YXIgdHlwZW9mb2JqID0gdHlwZW9mIHt9O1xudmFyIHR5cGVvZmZuID0gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcbnZhciB0eXBlb2ZodG1sZWxlID0gdHlwZW9mIEhUTUxFbGVtZW50O1xuXG52YXIgaW5zdGFuY2VTdHIgPSBmdW5jdGlvbiggb2JqICl7XG4gIHJldHVybiBvYmogJiYgb2JqLmluc3RhbmNlU3RyaW5nICYmIGlzLmZuKCBvYmouaW5zdGFuY2VTdHJpbmcgKSA/IG9iai5pbnN0YW5jZVN0cmluZygpIDogbnVsbDtcbn07XG5cbnZhciBpcyA9IHtcbiAgZGVmaW5lZDogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gb2JqICE9IG51bGw7IC8vIG5vdCB1bmRlZmluZWQgb3IgbnVsbFxuICB9LFxuXG4gIHN0cmluZzogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PSB0eXBlb2ZzdHI7XG4gIH0sXG5cbiAgZm46IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZmZuO1xuICB9LFxuXG4gIGFycmF5OiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogb2JqICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXk7XG4gIH0sXG5cbiAgcGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZm9iaiAmJiAhaXMuYXJyYXkob2JqKSAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgfSxcblxuICBvYmplY3Q6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZm9iajtcbiAgfSxcblxuICBudW1iZXI6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiAxICYmICFpc05hTihvYmopO1xuICB9LFxuXG4gIGludGVnZXI6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICByZXR1cm4gaXMubnVtYmVyKG9iaikgJiYgTWF0aC5mbG9vcihvYmopID09PSBvYmo7XG4gIH0sXG5cbiAgYm9vbDogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mIHRydWU7XG4gIH0sXG5cbiAgaHRtbEVsZW1lbnQ6IGZ1bmN0aW9uKG9iail7XG4gICAgaWYoICd1bmRlZmluZWQnID09PSB0eXBlb2ZodG1sZWxlICl7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbCAhPSBvYmogJiYgb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgfVxuICB9LFxuXG4gIGVsZW1lbnRPckNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIGlzLmVsZW1lbnQob2JqKSB8fCBpcy5jb2xsZWN0aW9uKG9iaik7XG4gIH0sXG5cbiAgZWxlbWVudDogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG4gIH0sXG5cbiAgY29sbGVjdGlvbjogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xuICB9LFxuXG4gIGNvcmU6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb3JlJztcbiAgfSxcblxuICBzdHlsZTogZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ3N0eWxlJztcbiAgfSxcblxuICBzdHlsZXNoZWV0OiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnc3R5bGVzaGVldCc7XG4gIH0sXG5cbiAgZXZlbnQ6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdldmVudCc7XG4gIH0sXG5cbiAgdGhyZWFkOiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAndGhyZWFkJztcbiAgfSxcblxuICBmYWJyaWM6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdmYWJyaWMnO1xuICB9LFxuXG4gIGVtcHR5U3RyaW5nOiBmdW5jdGlvbihvYmope1xuICAgIGlmKCAhb2JqICl7IC8vIG51bGwgaXMgZW1wdHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiggaXMuc3RyaW5nKG9iaikgKXtcbiAgICAgIGlmKCBvYmogPT09ICcnIHx8IG9iai5tYXRjaCgvXlxccyskLykgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIGVtcHR5IHN0cmluZyBpcyBlbXB0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTsgLy8gb3RoZXJ3aXNlLCB3ZSBkb24ndCBrbm93IHdoYXQgd2UndmUgZ290XG4gIH0sXG5cbiAgbm9uZW1wdHlTdHJpbmc6IGZ1bmN0aW9uKG9iail7XG4gICAgaWYoIG9iaiAmJiBpcy5zdHJpbmcob2JqKSAmJiBvYmogIT09ICcnICYmICFvYmoubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgZG9tRWxlbWVudDogZnVuY3Rpb24ob2JqKXtcbiAgICBpZiggdHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJyApe1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyB3ZSdyZSBub3QgaW4gYSBicm93c2VyIHNvIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICB9XG4gIH0sXG5cbiAgYm91bmRpbmdCb3g6IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIGlzLnBsYWluT2JqZWN0KG9iaikgJiZcbiAgICAgIGlzLm51bWJlcihvYmoueDEpICYmIGlzLm51bWJlcihvYmoueDIpICYmXG4gICAgICBpcy5udW1iZXIob2JqLnkxKSAmJiBpcy5udW1iZXIob2JqLnkyKVxuICAgIDtcbiAgfSxcblxuICBwcm9taXNlOiBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBpcy5vYmplY3Qob2JqKSAmJiBpcy5mbihvYmoudGhlbik7XG4gIH0sXG5cbiAgdG91Y2g6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHdpbmRvdyAmJiAoICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaCApO1xuICB9LFxuXG4gIGdlY2tvOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnIHx8ICgnTW96QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKTtcbiAgfSxcblxuICB3ZWJraXQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHR5cGVvZiB3ZWJraXRVUkwgIT09ICd1bmRlZmluZWQnIHx8ICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKTtcbiAgfSxcblxuICBjaHJvbWl1bTogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdHlwZW9mIGNocm9tZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH0sXG5cbiAga2h0bWw6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudmVuZG9yLm1hdGNoKC9rZGUvaSk7IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuICB9LFxuXG4gIGtodG1sRXRjOiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBpcy5raHRtbCgpIHx8IGlzLndlYmtpdCgpIHx8IGlzLmNocm9taXVtKCk7XG4gIH0sXG5cbiAgbXM6IGZ1bmN0aW9uKCl7XG4gICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvbXNpZXx0cmlkZW50fGVkZ2UvaSk7IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuICB9LFxuXG4gIHdpbmRvd3M6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvV2luL2kpO1xuICB9LFxuXG4gIG1hYzogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9NYWMvaSk7XG4gIH0sXG5cbiAgbGludXg6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTGludXgvaSk7XG4gIH0sXG5cbiAgdW5peDogZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9YMTEvaSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxudmFyIGN5UmVnID0gZnVuY3Rpb24oICRlbGUgKXtcbiAgdmFyIGQgPSAkZWxlWzBdLl9jeXJlZyA9ICRlbGVbMF0uX2N5cmVnIHx8IHt9O1xuXG4gIHJldHVybiBkO1xufTtcblxudmFyIHJlZ2lzdGVySnF1ZXJ5ID0gZnVuY3Rpb24oICQsIGN5dG9zY2FwZSApe1xuICBpZiggISQgKXsgcmV0dXJuOyB9IC8vIG5vIGpxdWVyeSA9PiBkb24ndCBuZWVkIHRoaXNcblxuICBpZiggJC5mbi5jeXRvc2NhcGUgKXsgcmV0dXJuOyB9IC8vIGFscmVhZHkgcmVnaXN0ZXJlZFxuXG4gIC8vIGFsbG93IGNhbGxzIG9uIGEgalF1ZXJ5IHNlbGVjdG9yIGJ5IHByb3h5aW5nIGNhbGxzIHRvICQuY3l0b3NjYXBlXG4gIC8vIGUuZy4gJChcIiNmb29cIikuY3l0b3NjYXBlKG9wdGlvbnMpID0+ICQuY3l0b3NjYXBlKG9wdGlvbnMpIG9uICNmb29cbiAgJC5mbi5jeXRvc2NhcGUgPSBmdW5jdGlvbihvcHRzKXtcbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXG4gICAgLy8gZ2V0IG9iamVjdFxuICAgIGlmKCBvcHRzID09PSAnZ2V0JyApe1xuICAgICAgcmV0dXJuIGN5UmVnKCAkdGhpcyApLmN5O1xuICAgIH1cblxuICAgIC8vIGJpbmQgdG8gcmVhZHlcbiAgICBlbHNlIGlmKCBpcy5mbihvcHRzKSApe1xuXG4gICAgICB2YXIgcmVhZHkgPSBvcHRzO1xuICAgICAgdmFyIGN5ID0gY3lSZWcoICR0aGlzICkuY3k7XG5cbiAgICAgIGlmKCBjeSAmJiBjeS5pc1JlYWR5KCkgKXsgLy8gYWxyZWFkeSByZWFkeSBzbyBqdXN0IHRyaWdnZXIgbm93XG4gICAgICAgIGN5LnRyaWdnZXIoJ3JlYWR5JywgW10sIHJlYWR5KTtcblxuICAgICAgfSBlbHNlIHsgLy8gbm90IHlldCByZWFkeSwgc28gYWRkIHRvIHJlYWRpZXMgbGlzdFxuICAgICAgICB2YXIgZGF0YSA9IGN5UmVnKCAkdGhpcyApO1xuICAgICAgICB2YXIgcmVhZGllcyA9IGRhdGEucmVhZGllcyA9IGRhdGEucmVhZGllcyB8fCBbXTtcblxuICAgICAgICByZWFkaWVzLnB1c2goIHJlYWR5ICk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBwcm94eSB0byBjcmVhdGUgaW5zdGFuY2VcbiAgICBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdChvcHRzKSApe1xuICAgICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0cywge1xuICAgICAgICAgIGNvbnRhaW5lcjogJCh0aGlzKVswXVxuICAgICAgICB9KTtcblxuICAgICAgICBjeXRvc2NhcGUob3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gYWxsb3cgYWNjZXNzIHRvIHRoZSBnbG9iYWwgY3l0b3NjYXBlIG9iamVjdCB1bmRlciBqcXVlcnkgZm9yIGxlZ2FjeSByZWFzb25zXG4gICQuY3l0b3NjYXBlID0gY3l0b3NjYXBlO1xuXG4gIC8vIHVzZSBzaG9ydCBhbGlhcyAoY3kpIGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAgaWYoICQuZm4uY3kgPT0gbnVsbCAmJiAkLmN5ID09IG51bGwgKXtcbiAgICAkLmZuLmN5ID0gJC5mbi5jeXRvc2NhcGU7XG4gICAgJC5jeSA9ICQuY3l0b3NjYXBlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVySnF1ZXJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWF0aCA9IHt9O1xuXG5tYXRoLnNpZ251bSA9IGZ1bmN0aW9uKHgpe1xuICBpZiggeCA+IDAgKXtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmKCB4IDwgMCApe1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxubWF0aC5kaXN0YW5jZSA9IGZ1bmN0aW9uKCBwMSwgcDIgKXtcbiAgcmV0dXJuIE1hdGguc3FydCggbWF0aC5zcURpc3RhbmNlKHAxLCBwMikgKTtcbn07XG5cbm1hdGguc3FEaXN0YW5jZSA9IGZ1bmN0aW9uKCBwMSwgcDIgKXtcbiAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gIHZhciBkeSA9IHAyLnkgLSBwMS55O1xuXG4gIHJldHVybiBkeCpkeCArIGR5KmR5O1xufTtcblxuLy8gZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0LDqXppZXJfY3VydmUjUXVhZHJhdGljX2N1cnZlc1xubWF0aC5xYmV6aWVyQXQgPSBmdW5jdGlvbihwMCwgcDEsIHAyLCB0KXtcbiAgcmV0dXJuICgxIC0gdCkqKDEgLSB0KSpwMCArIDIqKDEgLSB0KSp0KnAxICsgdCp0KnAyO1xufTtcblxubWF0aC5xYmV6aWVyUHRBdCA9IGZ1bmN0aW9uKHAwLCBwMSwgcDIsIHQpe1xuICByZXR1cm4ge1xuICAgIHg6IG1hdGgucWJlemllckF0KCBwMC54LCBwMS54LCBwMi54LCB0ICksXG4gICAgeTogbWF0aC5xYmV6aWVyQXQoIHAwLnksIHAxLnksIHAyLnksIHQgKVxuICB9O1xufTtcblxuLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcbm1hdGgubWFrZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiICl7XG4gIGlmKCBiYi54MSAhPSBudWxsICYmIGJiLnkxICE9IG51bGwgKXtcbiAgICBpZiggYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngyLFxuICAgICAgICB5MjogYmIueTIsXG4gICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgIGg6IGJiLnkyIC0gYmIueTFcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmKCBiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDAgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDEgKyBiYi53LFxuICAgICAgICB5MjogYmIueTEgKyBiYi5oLFxuICAgICAgICB3OiBiYi53LFxuICAgICAgICBoOiBiYi5oXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxubWF0aC5ib3VuZGluZ0JveGVzSW50ZXJzZWN0ID0gZnVuY3Rpb24oIGJiMSwgYmIyICl7XG4gIC8vIGNhc2U6IG9uZSBiYiB0byByaWdodCBvZiBvdGhlclxuICBpZiggYmIxLngxID4gYmIyLngyICl7IHJldHVybiBmYWxzZTsgfVxuICBpZiggYmIyLngxID4gYmIxLngyICl7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG4gIGlmKCBiYjEueDIgPCBiYjIueDEgKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmKCBiYjIueDIgPCBiYjEueDEgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2FzZTogb25lIGJiIGFib3ZlIG90aGVyXG4gIGlmKCBiYjEueTIgPCBiYjIueTEgKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmKCBiYjIueTIgPCBiYjEueTEgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG4gIGlmKCBiYjEueTEgPiBiYjIueTIgKXsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmKCBiYjIueTEgPiBiYjEueTIgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG4gIHJldHVybiB0cnVlO1xufTtcblxubWF0aC5pbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCB4LCB5ICl7XG4gIHJldHVybiBiYi54MSA8PSB4ICYmIHggPD0gYmIueDIgJiYgYmIueTEgPD0geSAmJiB5IDw9IGJiLnkyO1xufTtcblxubWF0aC5wb2ludEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIsIHB0ICl7XG4gIHJldHVybiB0aGlzLmluQm91bmRpbmdCb3goIGJiLCBwdC54LCBwdC55ICk7XG59O1xuXG5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICB4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcblxuICB2YXIgY29ybmVyUmFkaXVzID0gdGhpcy5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcblxuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG5cbiAgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHNcbiAgdmFyIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG5cbiAgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAge1xuICAgIHZhciB0b3BTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCAtIHBhZGRpbmc7XG4gICAgdmFyIHRvcEVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgdmFyIHRvcEVuZFkgPSB0b3BTdGFydFk7XG5cbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcblxuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJpZ2h0IHNlZ21lbnQsIHRvcCB0byBib3R0b21cbiAge1xuICAgIHZhciByaWdodFN0YXJ0WCA9IG5vZGVYICsgaGFsZldpZHRoICsgcGFkZGluZztcbiAgICB2YXIgcmlnaHRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciByaWdodEVuZFggPSByaWdodFN0YXJ0WDtcbiAgICB2YXIgcmlnaHRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSk7XG5cbiAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuICB7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgYm90dG9tU3RhcnRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0ICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcblxuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21TdGFydFgsIGJvdHRvbVN0YXJ0WSwgYm90dG9tRW5kWCwgYm90dG9tRW5kWSwgZmFsc2UpO1xuXG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gTGVmdCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gIHtcbiAgICB2YXIgbGVmdFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGxlZnRFbmRYID0gbGVmdFN0YXJ0WDtcbiAgICB2YXIgbGVmdEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuXG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksIGxlZnRTdGFydFgsIGxlZnRTdGFydFksIGxlZnRFbmRYLCBsZWZ0RW5kWSwgZmFsc2UpO1xuXG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIGFyYyBzZWdtZW50c1xuICB2YXIgYXJjSW50ZXJzZWN0aW9ucztcblxuICAvLyBUb3AgTGVmdFxuICB7XG4gICAgdmFyIHRvcExlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIHRvcExlZnRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksXG4gICAgICB0b3BMZWZ0Q2VudGVyWCwgdG9wTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSB0b3BMZWZ0Q2VudGVyWFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBUb3AgUmlnaHRcbiAge1xuICAgIHZhciB0b3BSaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICB4LCB5LCBub2RlWCwgbm9kZVksXG4gICAgICB0b3BSaWdodENlbnRlclgsIHRvcFJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IHRvcFJpZ2h0Q2VudGVyWFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BSaWdodENlbnRlclkpIHtcbiAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgfVxuICB9XG5cbiAgLy8gQm90dG9tIFJpZ2h0XG4gIHtcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLFxuICAgICAgYm90dG9tUmlnaHRDZW50ZXJYLCBib3R0b21SaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSBib3R0b21SaWdodENlbnRlclhcbiAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tUmlnaHRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBMZWZ0XG4gIHtcbiAgICB2YXIgYm90dG9tTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tTGVmdENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgIHgsIHksIG5vZGVYLCBub2RlWSxcbiAgICAgIGJvdHRvbUxlZnRDZW50ZXJYLCBib3R0b21MZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IGJvdHRvbUxlZnRDZW50ZXJYXG4gICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xufTtcblxubWF0aC5pbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uKHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlKXtcbiAgdmFyIHQgPSB0b2xlcmFuY2U7XG5cbiAgdmFyIHgxID0gTWF0aC5taW4obHgxLCBseDIpO1xuICB2YXIgeDIgPSBNYXRoLm1heChseDEsIGx4Mik7XG4gIHZhciB5MSA9IE1hdGgubWluKGx5MSwgbHkyKTtcbiAgdmFyIHkyID0gTWF0aC5tYXgobHkxLCBseTIpO1xuXG4gIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdFxuICAgICYmIHkxIC0gdCA8PSB5ICYmIHkgPD0geTIgKyB0O1xufTtcblxubWF0aC5pbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24oXG4gIHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuXG4gIHZhciBiYiA9IHtcbiAgICB4MTogTWF0aC5taW4oIHgxLCB4MywgeDIgKSAtIHRvbGVyYW5jZSxcbiAgICB4MjogTWF0aC5tYXgoIHgxLCB4MywgeDIgKSArIHRvbGVyYW5jZSxcbiAgICB5MTogTWF0aC5taW4oIHkxLCB5MywgeTIgKSAtIHRvbGVyYW5jZSxcbiAgICB5MjogTWF0aC5tYXgoIHkxLCB5MywgeTIgKSArIHRvbGVyYW5jZVxuICB9O1xuXG4gIC8vIGlmIG91dHNpZGUgdGhlIHJvdWdoIGJvdW5kaW5nIGJveCBmb3IgdGhlIGJlemllciwgdGhlbiBpdCBjYW4ndCBiZSBhIGhpdFxuICBpZiggeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyICl7XG4gICAgLy8gY29uc29sZS5sb2coJ2JlemllciBvdXQgb2Ygcm91Z2ggYmInKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjb25zb2xlLmxvZygnZG8gbW9yZSBleHBlbnNpdmUgY2hlY2snKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59O1xuXG5tYXRoLnNvbHZlQ3ViaWMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCByZXN1bHQpIHtcblxuICAvLyBTb2x2ZXMgYSBjdWJpYyBmdW5jdGlvbiwgcmV0dXJucyByb290IGluIGZvcm0gW3IxLCBpMSwgcjIsIGkyLCByMywgaTNdLCB3aGVyZVxuICAvLyByIGlzIHRoZSByZWFsIGNvbXBvbmVudCwgaSBpcyB0aGUgaW1hZ2luYXJ5IGNvbXBvbmVudFxuXG4gIC8vIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBDYXJkYW5vIG1ldGhvZCBmcm9tIHRoZSB5ZWFyIDE1NDVcbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19mdW5jdGlvbiNUaGVfbmF0dXJlX29mX3RoZV9yb290c1xuXG4gIGIgLz0gYTtcbiAgYyAvPSBhO1xuICBkIC89IGE7XG5cbiAgdmFyIGRpc2NyaW1pbmFudCwgcSwgciwgZHVtMSwgcywgdCwgdGVybTEsIHIxMztcblxuICBxID0gKDMuMCAqIGMgLSAoYiAqIGIpKSAvIDkuMDtcbiAgciA9IC0oMjcuMCAqIGQpICsgYiAqICg5LjAgKiBjIC0gMi4wICogKGIgKiBiKSk7XG4gIHIgLz0gNTQuMDtcblxuICBkaXNjcmltaW5hbnQgPSBxICogcSAqIHEgKyByICogcjtcbiAgcmVzdWx0WzFdID0gMDtcbiAgdGVybTEgPSAoYiAvIDMuMCk7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA+IDApIHtcbiAgICBzID0gciArIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHMgPSAoKHMgPCAwKSA/IC1NYXRoLnBvdygtcywgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3cocywgKDEuMCAvIDMuMCkpKTtcbiAgICB0ID0gciAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHQgPSAoKHQgPCAwKSA/IC1NYXRoLnBvdygtdCwgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3codCwgKDEuMCAvIDMuMCkpKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyBzICsgdDtcbiAgICB0ZXJtMSArPSAocyArIHQpIC8gMi4wO1xuICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC10ZXJtMTtcbiAgICB0ZXJtMSA9IE1hdGguc3FydCgzLjApICogKC10ICsgcykgLyAyO1xuICAgIHJlc3VsdFszXSA9IHRlcm0xO1xuICAgIHJlc3VsdFs1XSA9IC10ZXJtMTtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXN1bHRbNV0gPSByZXN1bHRbM10gPSAwO1xuXG4gIGlmIChkaXNjcmltaW5hbnQgPT09IDApIHtcbiAgICByMTMgPSAoKHIgPCAwKSA/IC1NYXRoLnBvdygtciwgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3cociwgKDEuMCAvIDMuMCkpKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyAyLjAgKiByMTM7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLShyMTMgKyB0ZXJtMSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcSA9IC1xO1xuICBkdW0xID0gcSAqIHEgKiBxO1xuICBkdW0xID0gTWF0aC5hY29zKHIgLyBNYXRoLnNxcnQoZHVtMSkpO1xuICByMTMgPSAyLjAgKiBNYXRoLnNxcnQocSk7XG4gIHJlc3VsdFswXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKGR1bTEgLyAzLjApO1xuICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDIuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyA0LjAgKiBNYXRoLlBJKSAvIDMuMCk7XG5cbiAgcmV0dXJuO1xufTtcblxubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbihcbiAgeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuXG4gIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2VcbiAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuXG4gIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gIC8vIHdob3NlIHJvb3RzIHRlbGwgdXMgd2hlcmUgYSBwb3NzaWJsZSBtaW5pbXVtIGlzXG4gIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcblxuICB2YXIgYSA9IDEuMCAqIHgxKngxIC0gNCp4MSp4MiArIDIqeDEqeDMgKyA0KngyKngyIC0gNCp4Mip4MyArIHgzKngzXG4gICAgKyB5MSp5MSAtIDQqeTEqeTIgKyAyKnkxKnkzICsgNCp5Mip5MiAtIDQqeTIqeTMgKyB5Myp5MztcblxuICB2YXIgYiA9IDEuMCAqIDkqeDEqeDIgLSAzKngxKngxIC0gMyp4MSp4MyAtIDYqeDIqeDIgKyAzKngyKngzXG4gICAgKyA5KnkxKnkyIC0gMyp5MSp5MSAtIDMqeTEqeTMgLSA2KnkyKnkyICsgMyp5Mip5MztcblxuICB2YXIgYyA9IDEuMCAqIDMqeDEqeDEgLSA2KngxKngyICsgeDEqeDMgLSB4MSp4ICsgMip4Mip4MiArIDIqeDIqeCAtIHgzKnhcbiAgICArIDMqeTEqeTEgLSA2KnkxKnkyICsgeTEqeTMgLSB5MSp5ICsgMip5Mip5MiArIDIqeTIqeSAtIHkzKnk7XG5cbiAgdmFyIGQgPSAxLjAgKiB4MSp4MiAtIHgxKngxICsgeDEqeCAtIHgyKnhcbiAgICArIHkxKnkyIC0geTEqeTEgKyB5MSp5IC0geTIqeTtcblxuICAvLyBkZWJ1ZyhcImNvZWZmaWNpZW50czogXCIgKyBhIC8gYSArIFwiLCBcIiArIGIgLyBhICsgXCIsIFwiICsgYyAvIGEgKyBcIiwgXCIgKyBkIC8gYSk7XG5cbiAgdmFyIHJvb3RzID0gW107XG5cbiAgLy8gVXNlIHRoZSBjdWJpYyBzb2x2aW5nIGFsZ29yaXRobVxuICB0aGlzLnNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuXG4gIHZhciB6ZXJvVGhyZXNob2xkID0gMC4wMDAwMDAxO1xuXG4gIHZhciBwYXJhbXMgPSBbXTtcblxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGRcbiAgICAgICAgJiYgcm9vdHNbaW5kZXhdID49IDBcbiAgICAgICAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICB9XG4gIH1cblxuICBwYXJhbXMucHVzaCgxLjApO1xuICBwYXJhbXMucHVzaCgwLjApO1xuXG4gIHZhciBtaW5EaXN0YW5jZVNxdWFyZWQgPSAtMTtcbiAgdmFyIGNsb3Nlc3RQYXJhbTtcblxuICB2YXIgY3VyWCwgY3VyWSwgZGlzdFNxdWFyZWQ7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY3VyWCA9IE1hdGgucG93KDEuMCAtIHBhcmFtc1tpXSwgMi4wKSAqIHgxXG4gICAgICArIDIuMCAqICgxIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHgyXG4gICAgICArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHgzO1xuXG4gICAgY3VyWSA9IE1hdGgucG93KDEgLSBwYXJhbXNbaV0sIDIuMCkgKiB5MVxuICAgICAgKyAyICogKDEuMCAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB5MlxuICAgICAgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB5MztcblxuICAgIGRpc3RTcXVhcmVkID0gTWF0aC5wb3coY3VyWCAtIHgsIDIpICsgTWF0aC5wb3coY3VyWSAtIHksIDIpO1xuICAgIC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuICAgIGlmIChtaW5EaXN0YW5jZVNxdWFyZWQgPj0gMCkge1xuICAgICAgaWYgKGRpc3RTcXVhcmVkIDwgbWluRGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgICBjbG9zZXN0UGFyYW0gPSBwYXJhbXNbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgY2xvc2VzdFBhcmFtID0gcGFyYW1zW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG59O1xuXG5tYXRoLnNxRGlzdGFuY2VUb0Zpbml0ZUxpbmUgPSBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgb2Zmc2V0ID0gW3ggLSB4MSwgeSAtIHkxXTtcbiAgdmFyIGxpbmUgPSBbeDIgLSB4MSwgeTIgLSB5MV07XG5cbiAgdmFyIGxpbmVTcSA9IGxpbmVbMF0gKiBsaW5lWzBdICsgbGluZVsxXSAqIGxpbmVbMV07XG4gIHZhciBoeXBTcSA9IG9mZnNldFswXSAqIG9mZnNldFswXSArIG9mZnNldFsxXSAqIG9mZnNldFsxXTtcblxuICB2YXIgZG90UHJvZHVjdCA9IG9mZnNldFswXSAqIGxpbmVbMF0gKyBvZmZzZXRbMV0gKiBsaW5lWzFdO1xuICB2YXIgYWRqU3EgPSBkb3RQcm9kdWN0ICogZG90UHJvZHVjdCAvIGxpbmVTcTtcblxuICBpZiAoZG90UHJvZHVjdCA8IDApIHtcbiAgICByZXR1cm4gaHlwU3E7XG4gIH1cblxuICBpZiAoYWRqU3EgPiBsaW5lU3EpIHtcbiAgICByZXR1cm4gKHggLSB4MikgKiAoeCAtIHgyKSArICh5IC0geTIpICogKHkgLSB5Mik7XG4gIH1cblxuICByZXR1cm4gaHlwU3EgLSBhZGpTcTtcbn07XG5cbm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzID0gZnVuY3Rpb24oeCwgeSwgcG9pbnRzKXtcbiAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuICB2YXIgeTM7XG5cbiAgLy8gSW50ZXJzZWN0IHdpdGggdmVydGljYWwgbGluZSB0aHJvdWdoICh4LCB5KVxuICB2YXIgdXAgPSAwO1xuICB2YXIgZG93biA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuXG4gICAgeDEgPSBwb2ludHNbaSAqIDJdO1xuICAgIHkxID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICB5MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyICsgMV07XG4gICAgfVxuXG4gICAgaWYgKHgxID09IHggJiYgeDIgPT0geCkge1xuXG4gICAgfSBlbHNlIGlmICgoeDEgPj0geCAmJiB4ID49IHgyKVxuICAgICAgfHwgKHgxIDw9IHggJiYgeCA8PSB4MikpIHtcblxuICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuXG4gICAgICBpZiAoeTMgPiB5KSB7XG4gICAgICAgIHVwKys7XG4gICAgICB9XG5cbiAgICAgIGlmICh5MyA8IHkpIHtcbiAgICAgICAgZG93bisrO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICB9XG5cbiAgaWYgKHVwICUgMiA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxubWF0aC5wb2ludEluc2lkZVBvbHlnb24gPSBmdW5jdGlvbihcbiAgeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG5cbiAgLy92YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzWzZdO1xuICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuXG4gIC8vIEdpdmVzIG5lZ2F0aXZlIGFuZ2xlXG4gIHZhciBhbmdsZTtcblxuICBpZiggZGlyZWN0aW9uWzBdICE9IG51bGwgKXtcbiAgICBhbmdsZSA9IE1hdGguYXRhbihkaXJlY3Rpb25bMV0gLyBkaXJlY3Rpb25bMF0pO1xuXG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYW5nbGUgPSBkaXJlY3Rpb247XG4gIH1cblxuICB2YXIgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG5cbiAgLy8gICAgY29uc29sZS5sb2coXCJiYXNlOiBcIiArIGJhc2VQb2ludHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9XG4gICAgICB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3NcbiAgICAgICAgLSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBzaW4pO1xuXG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9XG4gICAgICBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvc1xuICAgICAgICArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcblxuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgfVxuXG4gIHZhciBwb2ludHM7XG5cbiAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IHRoaXMuZXhwYW5kUG9seWdvbihcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgLXBhZGRpbmcpO1xuXG4gICAgcG9pbnRzID0gdGhpcy5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgfVxuXG4gIHJldHVybiBtYXRoLnBvaW50SW5zaWRlUG9seWdvblBvaW50cyggeCwgeSwgcG9pbnRzICk7XG59O1xuXG5tYXRoLmpvaW5MaW5lcyA9IGZ1bmN0aW9uKGxpbmVTZXQpIHtcblxuICB2YXIgdmVydGljZXMgPSBuZXcgQXJyYXkobGluZVNldC5sZW5ndGggLyAyKTtcblxuICB2YXIgY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLCBjdXJyZW50TGluZUVuZFgsIGN1cnJlbnRMaW5lRW5kWTtcbiAgdmFyIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQ7IGkrKykge1xuICAgIGN1cnJlbnRMaW5lU3RhcnRYID0gbGluZVNldFtpICogNF07XG4gICAgY3VycmVudExpbmVTdGFydFkgPSBsaW5lU2V0W2kgKiA0ICsgMV07XG4gICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFtpICogNCArIDJdO1xuICAgIGN1cnJlbnRMaW5lRW5kWSA9IGxpbmVTZXRbaSAqIDQgKyAzXTtcblxuICAgIGlmIChpIDwgbGluZVNldC5sZW5ndGggLyA0IC0gMSkge1xuICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WyhpICsgMSkgKiA0XTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsoaSArIDEpICogNCArIDFdO1xuICAgICAgbmV4dExpbmVFbmRYID0gbGluZVNldFsoaSArIDEpICogNCArIDJdO1xuICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFsoaSArIDEpICogNCArIDNdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbMF07XG4gICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WzJdO1xuICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFszXTtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSxcbiAgICAgIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLFxuICAgICAgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLFxuICAgICAgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFksXG4gICAgICB0cnVlKTtcblxuICAgIHZlcnRpY2VzW2kgKiAyXSA9IGludGVyc2VjdGlvblswXTtcbiAgICB2ZXJ0aWNlc1tpICogMiArIDFdID0gaW50ZXJzZWN0aW9uWzFdO1xuICB9XG5cbiAgcmV0dXJuIHZlcnRpY2VzO1xufTtcblxubWF0aC5leHBhbmRQb2x5Z29uID0gZnVuY3Rpb24ocG9pbnRzLCBwYWQpIHtcblxuICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcblxuICB2YXIgY3VycmVudFBvaW50WCwgY3VycmVudFBvaW50WSwgbmV4dFBvaW50WCwgbmV4dFBvaW50WTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICBjdXJyZW50UG9pbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQb2ludFggPSBwb2ludHNbMF07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuXG4gICAgLy8gQXNzdW1lIENDVyBwb2x5Z29uIHdpbmRpbmdcblxuICAgIHZhciBvZmZzZXRYID0gKG5leHRQb2ludFkgLSBjdXJyZW50UG9pbnRZKTtcbiAgICB2YXIgb2Zmc2V0WSA9IC0obmV4dFBvaW50WCAtIGN1cnJlbnRQb2ludFgpO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIG9mZnNldExlbmd0aCA9IE1hdGguc3FydChvZmZzZXRYICogb2Zmc2V0WCArIG9mZnNldFkgKiBvZmZzZXRZKTtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG5cbiAgICBleHBhbmRlZExpbmVTZXRbaSAqIDRdID0gY3VycmVudFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDFdID0gY3VycmVudFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDNdID0gbmV4dFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbn07XG5cbm1hdGguaW50ZXJzZWN0TGluZUVsbGlwc2UgPSBmdW5jdGlvbihcbiAgeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzKSB7XG5cbiAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gIHZhciBkaXNwWSA9IGNlbnRlclkgLSB5O1xuXG4gIGRpc3BYIC89IGVsbGlwc2VXcmFkaXVzO1xuICBkaXNwWSAvPSBlbGxpcHNlSHJhZGl1cztcblxuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGRpc3BYICogZGlzcFggKyBkaXNwWSAqIGRpc3BZKTtcblxuICB2YXIgbmV3TGVuZ3RoID0gbGVuIC0gMTtcblxuICBpZiAobmV3TGVuZ3RoIDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuXG4gIHJldHVybiBbKGNlbnRlclggLSB4KSAqIGxlblByb3BvcnRpb24gKyB4LCAoY2VudGVyWSAtIHkpICogbGVuUHJvcG9ydGlvbiArIHldO1xufTtcblxuLy8gUmV0dXJucyBpbnRlcnNlY3Rpb25zIG9mIGluY3JlYXNpbmcgZGlzdGFuY2UgZnJvbSBsaW5lJ3Mgc3RhcnQgcG9pbnRcbm1hdGguaW50ZXJzZWN0TGluZUNpcmNsZSA9IGZ1bmN0aW9uKFxuICB4MSwgeTEsIHgyLCB5MiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKSB7XG5cbiAgLy8gQ2FsY3VsYXRlIGQsIGRpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICB2YXIgZCA9IFt4MiAtIHgxLCB5MiAtIHkxXTsgLy8gRGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBjID0gW2NlbnRlclgsIGNlbnRlclldOyAvLyBDZW50ZXIgb2YgY2lyY2xlXG4gIHZhciBmID0gW3gxIC0gY2VudGVyWCwgeTEgLSBjZW50ZXJZXTtcblxuICB2YXIgYSA9IGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV07XG4gIHZhciBiID0gMiAqIChmWzBdICogZFswXSArIGZbMV0gKiBkWzFdKTtcbiAgdmFyIGMgPSAoZlswXSAqIGZbMF0gKyBmWzFdICogZlsxXSkgLSByYWRpdXMgKiByYWRpdXMgO1xuXG4gIHZhciBkaXNjcmltaW5hbnQgPSBiKmItNCphKmM7XG5cbiAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuXG4gIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgdmFyIHRNYXggPSBNYXRoLm1heCh0MSwgdDIpO1xuICB2YXIgaW5SYW5nZVBhcmFtcyA9IFtdO1xuXG4gIGlmICh0TWluID49IDAgJiYgdE1pbiA8PSAxKSB7XG4gICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICB9XG5cbiAgaWYgKHRNYXggPj0gMCAmJiB0TWF4IDw9IDEpIHtcbiAgICBpblJhbmdlUGFyYW1zLnB1c2godE1heCk7XG4gIH1cblxuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbmVhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzBdICogZFswXSArIHgxO1xuICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuXG4gIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcblxuICAgIGlmIChpblJhbmdlUGFyYW1zWzBdID09IGluUmFuZ2VQYXJhbXNbMV0pIHtcbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWSA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzFdICsgeTE7XG5cbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gIH1cblxufTtcblxubWF0aC5maW5kQ2lyY2xlTmVhclBvaW50ID0gZnVuY3Rpb24oY2VudGVyWCwgY2VudGVyWSxcbiAgcmFkaXVzLCBmYXJYLCBmYXJZKSB7XG5cbiAgdmFyIGRpc3BsYWNlbWVudFggPSBmYXJYIC0gY2VudGVyWDtcbiAgdmFyIGRpc3BsYWNlbWVudFkgPSBmYXJZIC0gY2VudGVyWTtcbiAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3BsYWNlbWVudFggKiBkaXNwbGFjZW1lbnRYXG4gICAgKyBkaXNwbGFjZW1lbnRZICogZGlzcGxhY2VtZW50WSk7XG5cbiAgdmFyIHVuaXREaXNwbGFjZW1lbnRYID0gZGlzcGxhY2VtZW50WCAvIGRpc3RhbmNlO1xuICB2YXIgdW5pdERpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnRZIC8gZGlzdGFuY2U7XG5cbiAgcmV0dXJuIFtjZW50ZXJYICsgdW5pdERpc3BsYWNlbWVudFggKiByYWRpdXMsXG4gICAgY2VudGVyWSArIHVuaXREaXNwbGFjZW1lbnRZICogcmFkaXVzXTtcbn07XG5cbm1hdGguZmluZE1heFNxRGlzdGFuY2VUb09yaWdpbiA9IGZ1bmN0aW9uKHBvaW50cykge1xuICB2YXIgbWF4U3FEaXN0YW5jZSA9IDAuMDAwMDAxO1xuICB2YXIgc3FEaXN0YW5jZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcblxuICAgIHNxRGlzdGFuY2UgPSBwb2ludHNbaSAqIDJdICogcG9pbnRzW2kgKiAyXVxuICAgICAgKyBwb2ludHNbaSAqIDIgKyAxXSAqIHBvaW50c1tpICogMiArIDFdO1xuXG4gICAgaWYgKHNxRGlzdGFuY2UgPiBtYXhTcURpc3RhbmNlKSB7XG4gICAgICBtYXhTcURpc3RhbmNlID0gc3FEaXN0YW5jZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF4U3FEaXN0YW5jZTtcbn07XG5cbm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbihcbiAgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBpbmZpbml0ZUxpbmVzKSB7XG5cbiAgdmFyIHVhX3QgPSAoeDQgLSB4MykgKiAoeTEgLSB5MykgLSAoeTQgLSB5MykgKiAoeDEgLSB4Myk7XG4gIHZhciB1Yl90ID0gKHgyIC0geDEpICogKHkxIC0geTMpIC0gKHkyIC0geTEpICogKHgxIC0geDMpO1xuICB2YXIgdV9iID0gKHk0IC0geTMpICogKHgyIC0geDEpIC0gKHg0IC0geDMpICogKHkyIC0geTEpO1xuXG4gIGlmICh1X2IgIT09IDApIHtcbiAgICB2YXIgdWEgPSB1YV90IC8gdV9iO1xuICAgIHZhciB1YiA9IHViX3QgLyB1X2I7XG5cbiAgICBpZiAoMCA8PSB1YSAmJiB1YSA8PSAxICYmIDAgPD0gdWIgJiYgdWIgPD0gMSkge1xuICAgICAgcmV0dXJuIFt4MSArIHVhICogKHgyIC0geDEpLCB5MSArIHVhICogKHkyIC0geTEpXTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWluZmluaXRlTGluZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt4MSArIHVhICogKHgyIC0geDEpLCB5MSArIHVhICogKHkyIC0geTEpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHVhX3QgPT09IDAgfHwgdWJfdCA9PT0gMCkge1xuXG4gICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuXG4gICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYgKFt4MSwgeDIsIHg0XS5zb3J0KClbMV0gPT09IHg0KSB7XG4gICAgICAgIHJldHVybiBbeDQsIHk0XTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgIGlmIChbeDEsIHgyLCB4M10uc29ydCgpWzFdID09PSB4Mykge1xuICAgICAgICByZXR1cm4gW3gzLCB5M107XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZHBvaW50IG9mIGZpcnN0IGxpbmVcbiAgICAgIGlmIChbeDMsIHg0LCB4Ml0uc29ydCgpWzFdID09PSB4Mikge1xuICAgICAgICByZXR1cm4gW3gyLCB5Ml07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbn07XG5cbm1hdGgucG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbihcbiAgeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuXG4gIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gIHZhciBpbnRlcnNlY3Rpb247XG5cbiAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IGJhc2VQb2ludHNbaSAqIDJdICogd2lkdGggKyBjZW50ZXJYO1xuICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBoZWlnaHQgKyBjZW50ZXJZO1xuICB9XG5cbiAgdmFyIHBvaW50cztcblxuICBpZiAocGFkZGluZyA+IDApIHtcbiAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbWF0aC5leHBhbmRQb2x5Z29uKFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAtcGFkZGluZyk7XG5cbiAgICBwb2ludHMgPSBtYXRoLmpvaW5MaW5lcyhleHBhbmRlZExpbmVTZXQpO1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICB9XG4gIC8vIHZhciBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcblxuICB2YXIgY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG5cbiAgICBjdXJyZW50WCA9IHBvaW50c1tpICogMl07XG4gICAgY3VycmVudFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICBuZXh0WSA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIGludGVyc2VjdGlvbiA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICB4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgY3VycmVudFgsIGN1cnJlbnRZLFxuICAgICAgbmV4dFgsIG5leHRZKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcblxubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oXG4gIGludGVyc2VjdGlvbiwgb2Zmc2V0LCBhbW91bnQpIHtcblxuICB2YXIgZGlzcCA9IFtpbnRlcnNlY3Rpb25bMF0gLSBvZmZzZXRbMF0sIGludGVyc2VjdGlvblsxXSAtIG9mZnNldFsxXV07XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkaXNwWzBdICogZGlzcFswXSArIGRpc3BbMV0gKiBkaXNwWzFdKTtcblxuICB2YXIgbGVuUmF0aW8gPSAobGVuZ3RoIC0gYW1vdW50KSAvIGxlbmd0aDtcblxuICBpZiAobGVuUmF0aW8gPCAwKSB7XG4gICAgbGVuUmF0aW8gPSAwLjAwMDAxO1xuICB9XG5cbiAgcmV0dXJuIFtvZmZzZXRbMF0gKyBsZW5SYXRpbyAqIGRpc3BbMF0sIG9mZnNldFsxXSArIGxlblJhdGlvICogZGlzcFsxXV07XG59O1xuXG5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSA9IGZ1bmN0aW9uKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgdmFyIHBvaW50cyA9IG1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyhzaWRlcywgcm90YXRpb25SYWRpYW5zKTtcbiAgcG9pbnRzID0gbWF0aC5maXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKTtcblxuICByZXR1cm4gcG9pbnRzO1xufTtcblxubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbihwb2ludHMpe1xuICB2YXIgeCwgeTtcbiAgdmFyIHNpZGVzID0gcG9pbnRzLmxlbmd0aC8yO1xuICB2YXIgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgeCA9IHBvaW50c1syICogaV07XG4gICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuXG4gICAgbWluWCA9IE1hdGgubWluKCBtaW5YLCB4ICk7XG4gICAgbWF4WCA9IE1hdGgubWF4KCBtYXhYLCB4ICk7XG4gICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgbWF4WSA9IE1hdGgubWF4KCBtYXhZLCB5ICk7XG4gIH1cblxuICAvLyBzdHJldGNoIGZhY3RvcnNcbiAgdmFyIHN4ID0gMiAvIChtYXhYIC0gbWluWCk7XG4gIHZhciBzeSA9IDIgLyAobWF4WSAtIG1pblkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKyl7XG4gICAgeCA9IHBvaW50c1syICogaV0gPSBwb2ludHNbMiAqIGldICogc3g7XG4gICAgeSA9IHBvaW50c1syICogaSArIDFdID0gcG9pbnRzWzIgKiBpICsgMV0gKiBzeTtcblxuICAgIG1pblggPSBNYXRoLm1pbiggbWluWCwgeCApO1xuICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgIG1pblkgPSBNYXRoLm1pbiggbWluWSwgeSApO1xuICAgIG1heFkgPSBNYXRoLm1heCggbWF4WSwgeSApO1xuICB9XG5cbiAgaWYoIG1pblkgPCAtMSApe1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKyl7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSArICgtMSAtbWluWSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn07XG5cbm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcblxuICB2YXIgaW5jcmVtZW50ID0gMS4wIC8gc2lkZXMgKiAyICogTWF0aC5QSTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBzaWRlcyAlIDIgPT09IDAgP1xuICAgIE1hdGguUEkgLyAyLjAgKyBpbmNyZW1lbnQgLyAyLjAgOiBNYXRoLlBJIC8gMi4wO1xuICAgIC8vICAgIGNvbnNvbGUubG9nKG5vZGVTaGFwZXNbJ3NxdWFyZSddKTtcbiAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG5cbiAgdmFyIHBvaW50cyA9IG5ldyBBcnJheShzaWRlcyAqIDIpO1xuXG4gIHZhciBjdXJyZW50QW5nbGUsIHgsIHk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIGN1cnJlbnRBbmdsZSA9IGkgKiBpbmNyZW1lbnQgKyBzdGFydEFuZ2xlO1xuXG4gICAgeCA9IHBvaW50c1syICogaV0gPSBNYXRoLmNvcyhjdXJyZW50QW5nbGUpOy8vICogKDEgKyBpLzIpO1xuICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IE1hdGguc2luKC1jdXJyZW50QW5nbGUpOy8vICAqICgxICsgaS8yKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59O1xuXG5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXG4gIC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxuICByZXR1cm4gTWF0aC5taW4od2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0aDtcbiIsIi8vIGludGVybmFsLCBtaW5pbWFsIFByb21pc2UgaW1wbCBzLnQuIGFwaXMgY2FuIHJldHVybiBwcm9taXNlcyBpbiBvbGQgZW52c1xuLy8gYmFzZWQgb24gdGhlbmFibGUgKGh0dHA6Ly9naXRodWIuY29tL3JzZS90aGVuYWJsZSlcblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiAgcHJvbWlzZSBzdGF0ZXMgW1Byb21pc2VzL0ErIDIuMV0gICovXG52YXIgU1RBVEVfUEVORElORyAgID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjFdICAqL1xudmFyIFNUQVRFX0ZVTEZJTExFRCA9IDE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yXSAgKi9cbnZhciBTVEFURV9SRUpFQ1RFRCAgPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuM10gICovXG5cbi8qICBwcm9taXNlIG9iamVjdCBjb25zdHJ1Y3RvciAgKi9cbnZhciBhcGkgPSBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcbiAgLyogIG9wdGlvbmFsbHkgc3VwcG9ydCBub24tY29uc3RydWN0b3IvcGxhaW4tZnVuY3Rpb24gY2FsbCAgKi9cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGFwaSkpXG4gICAgcmV0dXJuIG5ldyBhcGkoZXhlY3V0b3IpO1xuXG4gIC8qICBpbml0aWFsaXplIG9iamVjdCAgKi9cbiAgdGhpcy5pZCAgICAgICAgICAgPSBcIlRoZW5hYmxlLzEuMC43XCI7XG4gIHRoaXMuc3RhdGUgICAgICAgID0gU1RBVEVfUEVORElORzsgLyogIGluaXRpYWwgc3RhdGUgICovXG4gIHRoaXMuZnVsZmlsbFZhbHVlID0gdW5kZWZpbmVkOyAgICAgLyogIGluaXRpYWwgdmFsdWUgICovICAgICAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG4gIHRoaXMucmVqZWN0UmVhc29uID0gdW5kZWZpbmVkOyAgICAgLyogIGluaXRpYWwgcmVhc29uICovICAgICAvKiAgW1Byb21pc2VzL0ErIDEuNSwgMi4xLjMuMl0gICovXG4gIHRoaXMub25GdWxmaWxsZWQgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG4gIHRoaXMub25SZWplY3RlZCAgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgLyogIHByb3ZpZGUgb3B0aW9uYWwgaW5mb3JtYXRpb24taGlkaW5nIHByb3h5ICAqL1xuICB0aGlzLnByb3h5ID0ge1xuICAgIHRoZW46IHRoaXMudGhlbi5iaW5kKHRoaXMpXG4gIH07XG5cbiAgLyogIHN1cHBvcnQgb3B0aW9uYWwgZXhlY3V0b3IgZnVuY3Rpb24gICovXG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgPT09IFwiZnVuY3Rpb25cIilcbiAgICBleGVjdXRvci5jYWxsKHRoaXMsIHRoaXMuZnVsZmlsbC5iaW5kKHRoaXMpLCB0aGlzLnJlamVjdC5iaW5kKHRoaXMpKTtcbn07XG5cbi8qICBwcm9taXNlIEFQSSBtZXRob2RzICAqL1xuYXBpLnByb3RvdHlwZSA9IHtcbiAgLyogIHByb21pc2UgcmVzb2x2aW5nIG1ldGhvZHMgICovXG4gIGZ1bGZpbGw6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9GVUxGSUxMRUQsIFwiZnVsZmlsbFZhbHVlXCIsIHZhbHVlKTsgfSxcbiAgcmVqZWN0OiAgZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX1JFSkVDVEVELCAgXCJyZWplY3RSZWFzb25cIiwgdmFsdWUpOyB9LFxuXG4gIC8qICBcIlRoZSB0aGVuIE1ldGhvZFwiIFtQcm9taXNlcy9BKyAxLjEsIDEuMiwgMi4yXSAgKi9cbiAgdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIGN1cnIgPSB0aGlzO1xuICAgIHZhciBuZXh0ID0gbmV3IGFwaSgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjddICAqL1xuICAgIGN1cnIub25GdWxmaWxsZWQucHVzaChcbiAgICAgIHJlc29sdmVyKG9uRnVsZmlsbGVkLCBuZXh0LCBcImZ1bGZpbGxcIikpOyAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLzIuMi42XSAgKi9cbiAgICBjdXJyLm9uUmVqZWN0ZWQucHVzaChcbiAgICAgIHJlc29sdmVyKG9uUmVqZWN0ZWQsICBuZXh0LCBcInJlamVjdFwiICkpOyAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4zLzIuMi42XSAgKi9cbiAgICBleGVjdXRlKGN1cnIpO1xuICAgIHJldHVybiBuZXh0LnByb3h5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjcsIDMuM10gICovXG4gIH1cbn07XG5cbi8qICBkZWxpdmVyIGFuIGFjdGlvbiAgKi9cbnZhciBkZWxpdmVyID0gZnVuY3Rpb24gKGN1cnIsIHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUEVORElORykge1xuICAgIGN1cnIuc3RhdGUgPSBzdGF0ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4xLjIuMSwgMi4xLjMuMV0gICovXG4gICAgY3VycltuYW1lXSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4yLCAyLjEuMy4yXSAgKi9cbiAgICBleGVjdXRlKGN1cnIpO1xuICB9XG4gIHJldHVybiBjdXJyO1xufTtcblxuLyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xudmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiAoY3Vycikge1xuICBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfRlVMRklMTEVEKVxuICAgIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgXCJvbkZ1bGZpbGxlZFwiLCBjdXJyLmZ1bGZpbGxWYWx1ZSk7XG4gIGVsc2UgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEKVxuICAgIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgXCJvblJlamVjdGVkXCIsICBjdXJyLnJlamVjdFJlYXNvbik7XG59O1xuXG4vKiAgZXhlY3V0ZSBwYXJ0aWN1bGFyIHNldCBvZiBoYW5kbGVycyAgKi9cbnZhciBleGVjdXRlX2hhbmRsZXJzID0gZnVuY3Rpb24gKGN1cnIsIG5hbWUsIHZhbHVlKSB7XG4gIC8qIGdsb2JhbCBzZXRJbW1lZGlhdGU6IHRydWUgKi9cbiAgLyogZ2xvYmFsIHNldFRpbWVvdXQ6IHRydWUgKi9cblxuICAvKiAgc2hvcnQtY2lyY3VpdCBwcm9jZXNzaW5nICAqL1xuICBpZiAoY3VycltuYW1lXS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuXG4gIC8qICBpdGVyYXRlIG92ZXIgYWxsIGhhbmRsZXJzLCBleGFjdGx5IG9uY2UgICovXG4gIHZhciBoYW5kbGVycyA9IGN1cnJbbmFtZV07XG4gIGN1cnJbbmFtZV0gPSBbXTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjMsIDIuMi4zLjNdICAqL1xuICB2YXIgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgaGFuZGxlcnNbaV0odmFsdWUpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi41XSAgKi9cbiAgfTtcblxuICAvKiAgZXhlY3V0ZSBwcm9jZWR1cmUgYXN5bmNocm9ub3VzbHkgICovICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNCwgMy4xXSAgKi9cbiAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICBzZXRJbW1lZGlhdGUoZnVuYyk7XG4gIGVsc2VcbiAgICBzZXRUaW1lb3V0KGZ1bmMsIDApO1xufTtcblxuLyogIGdlbmVyYXRlIGEgcmVzb2x2ZXIgZnVuY3Rpb24gICovXG52YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiAoY2IsIG5leHQsIG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gXCJmdW5jdGlvblwiKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4xLCAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICAgIG5leHRbbWV0aG9kXS5jYWxsKG5leHQsIHZhbHVlKTsgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB0cnkgeyByZXN1bHQgPSBjYih2YWx1ZSk7IH0gICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMSwgMi4yLjMuMSwgMi4yLjUsIDMuMl0gICovXG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBuZXh0LnJlamVjdChlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShuZXh0LCByZXN1bHQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjFdICAqL1xuICAgIH1cbiAgfTtcbn07XG5cbi8qICBcIlByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcIiAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuM10gICovXG52YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChwcm9taXNlLCB4KSB7XG4gIC8qICBzYW5pdHkgY2hlY2sgYXJndW1lbnRzICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4xXSAgKi9cbiAgaWYgKHByb21pc2UgPT09IHggfHwgcHJvbWlzZS5wcm94eSA9PT0geCkge1xuICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJjYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmXCIpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKiAgc3VyZ2ljYWxseSBjaGVjayBmb3IgYSBcInRoZW5cIiBtZXRob2RcbiAgICAobWFpbmx5IHRvIGp1c3QgY2FsbCB0aGUgXCJnZXR0ZXJcIiBvZiBcInRoZW5cIiBvbmx5IG9uY2UpICAqL1xuICB2YXIgdGhlbjtcbiAgaWYgKCh0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdHJ5IHsgdGhlbiA9IHgudGhlbjsgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4xLCAzLjVdICAqL1xuICAgIGNhdGNoIChlKSB7XG4gICAgICBwcm9taXNlLnJlamVjdChlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMl0gICovXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLyogIGhhbmRsZSBvd24gVGhlbmFibGVzICAgIFtQcm9taXNlcy9BKyAyLjMuMl1cbiAgICBhbmQgc2ltaWxhciBcInRoZW5hYmxlc1wiIFtQcm9taXNlcy9BKyAyLjMuM10gICovXG4gIGlmICh0eXBlb2YgdGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi8gICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjNdICAqL1xuICAgICAgdGhlbi5jYWxsKHgsXG4gICAgICAgIC8qICByZXNvbHZlUHJvbWlzZSAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuMV0gICovXG4gICAgICAgIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47IHJlc29sdmVkID0gdHJ1ZTsgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICAgIGlmICh5ID09PSB4KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMy42XSAgKi9cbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJjaXJjdWxhciB0aGVuYWJsZSBjaGFpblwiKSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB5KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiAgcmVqZWN0UHJvbWlzZSAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjJdICAqL1xuICAgICAgICBmdW5jdGlvbiAocikge1xuICAgICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuOyByZXNvbHZlZCA9IHRydWU7ICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghcmVzb2x2ZWQpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICBwcm9taXNlLnJlamVjdChlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvKiAgaGFuZGxlIG90aGVyIHZhbHVlcyAgKi9cbiAgcHJvbWlzZS5mdWxmaWxsKHgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xufTtcblxuLy8gdXNlIG5hdGl2ZSBwcm9taXNlcyB3aGVyZSBwb3NzaWJsZVxudmFyIFByb21pc2UgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyBhcGkgOiBQcm9taXNlO1xuXG4vLyBzbyB3ZSBhbHdheXMgaGF2ZSBQcm9taXNlLmFsbCgpXG5Qcm9taXNlLmFsbCA9IFByb21pc2UuYWxsIHx8IGZ1bmN0aW9uKCBwcyApe1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oIHJlc29sdmVBbGwsIHJlamVjdEFsbCApe1xuICAgIHZhciB2YWxzID0gbmV3IEFycmF5KCBwcy5sZW5ndGggKTtcbiAgICB2YXIgZG9uZUNvdW50ID0gMDtcblxuICAgIHZhciBmdWxmaWxsID0gZnVuY3Rpb24oIGksIHZhbCApe1xuICAgICAgdmFsc1tpXSA9IHZhbDtcbiAgICAgIGRvbmVDb3VudCsrO1xuXG4gICAgICBpZiggZG9uZUNvdW50ID09PSBwcy5sZW5ndGggKXtcbiAgICAgICAgcmVzb2x2ZUFsbCggdmFscyApO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSsrICl7XG4gICAgICAoZnVuY3Rpb24oIGkgKXtcbiAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgdmFyIGlzUHJvbWlzZSA9IHAudGhlbiAhPSBudWxsO1xuXG4gICAgICAgIGlmKCBpc1Byb21pc2UgKXtcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICAgICAgZnVsZmlsbCggaSwgdmFsICk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oIGVyciApe1xuICAgICAgICAgICAgcmVqZWN0QWxsKCBlcnIgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICBmdWxmaWxsKCBpLCB2YWwgKTtcbiAgICAgICAgfVxuICAgICAgfSkoIGkgKTtcbiAgICB9XG5cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBTZWxlY3RvciA9IGZ1bmN0aW9uKCBvbmx5VGhpc0dyb3VwLCBzZWxlY3RvciApe1xuXG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBTZWxlY3RvcikgKXtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKG9ubHlUaGlzR3JvdXAsIHNlbGVjdG9yKTtcbiAgfVxuXG4gIGlmKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICYmIG9ubHlUaGlzR3JvdXAgIT09IHVuZGVmaW5lZCApe1xuICAgIHNlbGVjdG9yID0gb25seVRoaXNHcm91cDtcbiAgICBvbmx5VGhpc0dyb3VwID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuX3ByaXZhdGUgPSB7XG4gICAgc2VsZWN0b3JUZXh0OiBudWxsLFxuICAgIGludmFsaWQ6IHRydWVcbiAgfTtcblxuICBpZiggIXNlbGVjdG9yIHx8ICggaXMuc3RyaW5nKHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5tYXRjaCgvXlxccyokLykgKSApe1xuXG4gICAgaWYoIG9ubHlUaGlzR3JvdXAgPT0gbnVsbCApe1xuICAgICAgLy8gaWdub3JlXG4gICAgICBzZWxmLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgICAgc2VsZlswXS5ncm91cCA9IG9ubHlUaGlzR3JvdXA7XG4gICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiggaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggc2VsZWN0b3IgKSApe1xuICAgIHZhciBjb2xsZWN0aW9uID0gc2VsZWN0b3IuY29sbGVjdGlvbigpO1xuXG4gICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgc2VsZlswXS5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICBzZWxmLmxlbmd0aCA9IDE7XG5cbiAgfSBlbHNlIGlmKCBpcy5mbiggc2VsZWN0b3IgKSApIHtcbiAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICBzZWxmWzBdLmZpbHRlciA9IHNlbGVjdG9yO1xuICAgIHNlbGYubGVuZ3RoID0gMTtcblxuICB9IGVsc2UgaWYoIGlzLnN0cmluZyggc2VsZWN0b3IgKSApe1xuXG4gICAgLy8gdGhlIGN1cnJlbnQgc3ViamVjdCBpbiB0aGUgcXVlcnlcbiAgICB2YXIgY3VycmVudFN1YmplY3QgPSBudWxsO1xuXG4gICAgLy8gc3RvcmFnZSBmb3IgcGFyc2VkIHF1ZXJpZXNcbiAgICB2YXIgbmV3UXVlcnkgPSBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xhc3NlczogW10sXG4gICAgICAgIGNvbG9uU2VsZWN0b3JzOiBbXSxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgICBpZHM6IFtdLFxuICAgICAgICBtZXRhOiBbXSxcblxuICAgICAgICAvLyBmYWtlIHNlbGVjdG9yc1xuICAgICAgICBjb2xsZWN0aW9uOiBudWxsLCAvLyBhIGNvbGxlY3Rpb24gdG8gbWF0Y2ggYWdhaW5zdFxuICAgICAgICBmaWx0ZXI6IG51bGwsIC8vIGZpbHRlciBmdW5jdGlvblxuXG4gICAgICAgIC8vIHRoZXNlIGFyZSBkZWZpbmVkIGluIHRoZSB1cHdhcmQgZGlyZWN0aW9uIHJhdGhlciB0aGFuIGRvd24gKGUuZy4gY2hpbGQpXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBnbyB1cCBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgICAgICBwYXJlbnQ6IG51bGwsIC8vIHBhcmVudCBxdWVyeSBvYmpcbiAgICAgICAgYW5jZXN0b3I6IG51bGwsIC8vIGFuY2VzdG9yIHF1ZXJ5IG9ialxuICAgICAgICBzdWJqZWN0OiBudWxsLCAvLyBkZWZpbmVzIHN1YmplY3QgaW4gY29tcG91bmQgcXVlcnkgKHN1YmplY3QgcXVlcnkgb2JqOyBwb2ludHMgdG8gc2VsZiBpZiBzdWJqZWN0KVxuXG4gICAgICAgIC8vIHVzZSB0aGVzZSBvbmx5IHdoZW4gc3ViamVjdCBoYXMgYmVlbiBkZWZpbmVkXG4gICAgICAgIGNoaWxkOiBudWxsLFxuICAgICAgICBkZXNjZW5kYW50OiBudWxsXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyB0b2tlbnMgaW4gdGhlIHF1ZXJ5IGxhbmd1YWdlXG4gICAgdmFyIHRva2VucyA9IHtcbiAgICAgIG1ldGFDaGFyOiAnW1xcXFwhXFxcXFwiXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwuXFxcXC9cXFxcOlxcXFw7XFxcXDxcXFxcPVxcXFw+XFxcXD9cXFxcQFxcXFxbXFxcXF1cXFxcXlxcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dJywgLy8gY2hhcnMgd2UgbmVlZCB0byBlc2NhcGUgaW4gdmFyIG5hbWVzLCBldGNcbiAgICAgIGNvbXBhcmF0b3JPcDogJz18XFxcXCE9fD58Pj18PHw8PXxcXFxcJD18XFxcXF49fFxcXFwqPScsIC8vIGJpbmFyeSBjb21wYXJpc29uIG9wICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgICAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLCAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgICAgc3RyaW5nOiAnXCIoPzpcXFxcXFxcXFwifFteXCJdKStcIicgKyAnfCcgKyBcIicoPzpcXFxcXFxcXCd8W14nXSkrJ1wiLCAvLyBzdHJpbmcgbGl0ZXJhbHMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tIGRvdWJsZXF1b3RlcyB8IHNpbmdsZXF1b3Rlc1xuICAgICAgbnVtYmVyOiB1dGlsLnJlZ2V4Lm51bWJlciwgLy8gbnVtYmVyIGxpdGVyYWwgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tLSBlLmcuIDAuMTIzNCwgMTIzNCwgMTJlMTIzXG4gICAgICBtZXRhOiAnZGVncmVlfGluZGVncmVlfG91dGRlZ3JlZScsIC8vIGFsbG93ZWQgbWV0YWRhdGEgZmllbGRzIChpLmUuIGFsbG93ZWQgZnVuY3Rpb25zIHRvIHVzZSBmcm9tIENvbGxlY3Rpb24pXG4gICAgICBzZXBhcmF0b3I6ICdcXFxccyosXFxcXHMqJywgLy8gcXVlcmllcyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcywgZS5nLiBlZGdlW2ZvbyA9ICdiYXInXSwgbm9kZS5zb21lQ2xhc3NcbiAgICAgIGRlc2NlbmRhbnQ6ICdcXFxccysnLFxuICAgICAgY2hpbGQ6ICdcXFxccys+XFxcXHMrJyxcbiAgICAgIHN1YmplY3Q6ICdcXFxcJCdcbiAgICB9O1xuICAgIHRva2Vucy52YXJpYWJsZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcrIHRva2Vucy5tZXRhQ2hhciArJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZVxuICAgIHRva2Vucy52YWx1ZSA9IHRva2Vucy5zdHJpbmcgKyAnfCcgKyB0b2tlbnMubnVtYmVyOyAvLyBhIHZhbHVlIGxpdGVyYWwsIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXJcbiAgICB0b2tlbnMuY2xhc3NOYW1lID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhIGNsYXNzIG5hbWUgKGZvbGxvd3MgdmFyaWFibGUgY29udmVudGlvbnMpXG4gICAgdG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4gICAgLy8gd2hlbiBhIHRva2VuIGxpa2UgYSB2YXJpYWJsZSBoYXMgZXNjYXBlZCBtZXRhIGNoYXJhY3RlcnMsIHdlIG5lZWQgdG8gY2xlYW4gdGhlIGJhY2tzbGFzaGVzIG91dFxuICAgIC8vIHNvIHRoYXQgdmFsdWVzIGdldCBjb21wYXJlZCBwcm9wZXJseSBpbiBTZWxlY3Rvci5maWx0ZXIoKVxuICAgIHZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uKHN0cil7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXFxcXFwoJyArIHRva2Vucy5tZXRhQ2hhciArICcpJywgJ2cnKSwgZnVuY3Rpb24obWF0Y2gsICQxLCBvZmZzZXQsIG9yaWdpbmFsKXtcbiAgICAgICAgcmV0dXJuICQxO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIGFkZCBAIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICAgIHZhciBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBvcCA9IG9wc1tpXTtcbiAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICAgIH1cblxuICAgIC8vIGFkZCAhIHZhcmlhbnRzIHRvIGNvbXBhcmF0b3JPcFxuICAgIHZhciBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBvcCA9IG9wc1tpXTtcblxuICAgICAgaWYoIG9wLmluZGV4T2YoJyEnKSA+PSAwICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgb3BzIHRoYXQgZXhwbGljaXRseSBjb250YWluICFcbiAgICAgIGlmKCBvcCA9PT0gJz0nICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgPSBiL2MgIT0gaXMgZXhwbGljaXRseSBkZWZpbmVkXG5cbiAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xcXFxcIScgKyBvcDtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBhZGQgbmV3IGV4cHJlc3Npb24gc3ludGF4IGhlcmUgdG8gaGF2ZSBpdCByZWNvZ25pc2VkIGJ5IHRoZSBwYXJzZXI7XG4gICAgLy8gLSBhIHF1ZXJ5IGNvbnRhaW5zIGFsbCBhZGphY2VudCAoaS5lLiBubyBzZXBhcmF0b3IgaW4gYmV0d2VlbikgZXhwcmVzc2lvbnM7XG4gICAgLy8gLSB0aGUgY3VycmVudCBxdWVyeSBpcyBzdG9yZWQgaW4gc2VsZltpXSAtLS0geW91IGNhbiB1c2UgdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AgaW4gdGhlIHBvcHVsYXRlIGZ1bmN0aW9uO1xuICAgIC8vIC0geW91IG5lZWQgdG8gY2hlY2sgdGhlIHF1ZXJ5IG9iamVjdHMgaW4gU2VsZWN0b3IuZmlsdGVyKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxuICAgIC8vIC0gd2hlbiB5b3UgYWRkIHNvbWV0aGluZyBoZXJlLCBhbHNvIGFkZCB0byBTZWxlY3Rvci50b1N0cmluZygpXG4gICAgdmFyIGV4cHJzID0gW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnZ3JvdXAnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICcobm9kZXxlZGdlfFxcXFwqKScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggZ3JvdXAgKXtcbiAgICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXAgPT0gXCIqXCIgPyBncm91cCA6IGdyb3VwICsgJ3MnO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzdGF0ZScsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAvLyBOQjogaWYgb25lIGNvbG9uIHNlbGVjdG9yIGlzIGEgc3Vic3RyaW5nIG9mIGFub3RoZXIgZnJvbSBpdHMgc3RhcnQsIHBsYWNlIHRoZSBsb25nZXIgb25lIGZpcnN0XG4gICAgICAgIC8vIGUuZy4gOmZvb2Jhcnw6Zm9vXG4gICAgICAgIHJlZ2V4OiAnKDpzZWxlY3RlZHw6dW5zZWxlY3RlZHw6bG9ja2VkfDp1bmxvY2tlZHw6dmlzaWJsZXw6aGlkZGVufDp0cmFuc3BhcmVudHw6Z3JhYmJlZHw6ZnJlZXw6cmVtb3ZlZHw6aW5zaWRlfDpncmFiYmFibGV8OnVuZ3JhYmJhYmxlfDphbmltYXRlZHw6dW5hbmltYXRlZHw6c2VsZWN0YWJsZXw6dW5zZWxlY3RhYmxlfDpvcnBoYW58Om5vbm9ycGhhbnw6cGFyZW50fDpjaGlsZHw6bG9vcHw6c2ltcGxlfDphY3RpdmV8OmluYWN0aXZlfDp0b3VjaHw6YmFja2dyb3VuZGluZ3w6bm9uYmFja2dyb3VuZGluZyknLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHN0YXRlICl7XG4gICAgICAgICAgdGhpcy5jb2xvblNlbGVjdG9ycy5wdXNoKCBzdGF0ZSApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdpZCcsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFwjKCcrIHRva2Vucy5pZCArJyknLFxuICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGlkICl7XG4gICAgICAgICAgdGhpcy5pZHMucHVzaCggY2xlYW5NZXRhQ2hhcnMoaWQpICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2NsYXNzTmFtZScsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFwuKCcrIHRva2Vucy5jbGFzc05hbWUgKycpJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKXtcbiAgICAgICAgICB0aGlzLmNsYXNzZXMucHVzaCggY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKSApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkYXRhRXhpc3RzJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJysgdG9rZW5zLnZhcmlhYmxlICsnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCB2YXJpYWJsZSApe1xuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnZGF0YUNvbXBhcmUnLFxuICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignKyB0b2tlbnMudmFyaWFibGUgKycpXFxcXHMqKCcrIHRva2Vucy5jb21wYXJhdG9yT3AgKycpXFxcXHMqKCcrIHRva2Vucy52YWx1ZSArJylcXFxccypcXFxcXScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggdmFyaWFibGUsIGNvbXBhcmF0b3JPcCwgdmFsdWUgKXtcbiAgICAgICAgICB2YXIgdmFsdWVJc1N0cmluZyA9IG5ldyBSZWdFeHAoJ14nICsgdG9rZW5zLnN0cmluZyArICckJykuZXhlYyh2YWx1ZSkgIT0gbnVsbDtcblxuICAgICAgICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdkYXRhQm9vbCcsXG4gICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcrIHRva2Vucy5ib29sT3AgKycpXFxcXHMqKCcrIHRva2Vucy52YXJpYWJsZSArJylcXFxccypcXFxcXScsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggYm9vbE9wLCB2YXJpYWJsZSApe1xuICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICAgICAgICBvcGVyYXRvcjogYm9vbE9wXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ21ldGFDb21wYXJlJyxcbiAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxcW1xcXFxzKignKyB0b2tlbnMubWV0YSArJylcXFxccyooJysgdG9rZW5zLmNvbXBhcmF0b3JPcCArJylcXFxccyooJysgdG9rZW5zLm51bWJlciArJylcXFxccypcXFxcXVxcXFxdJyxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBtZXRhLCBjb21wYXJhdG9yT3AsIG51bWJlciApe1xuICAgICAgICAgIHRoaXMubWV0YS5wdXNoKHtcbiAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyhtZXRhKSxcbiAgICAgICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ25leHRRdWVyeScsXG4gICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgcmVnZXg6IHRva2Vucy5zZXBhcmF0b3IsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcbiAgICAgICAgICBzZWxmWysraV0gPSBuZXdRdWVyeSgpO1xuICAgICAgICAgIGN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAge1xuICAgICAgICBuYW1lOiAnY2hpbGQnLFxuICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgIHJlZ2V4OiB0b2tlbnMuY2hpbGQsXG4gICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIC8vIHRoaXMgcXVlcnkgaXMgdGhlIHBhcmVudCBvZiB0aGUgZm9sbG93aW5nIHF1ZXJ5XG4gICAgICAgICAgdmFyIGNoaWxkUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICAgIGNoaWxkUXVlcnkucGFyZW50ID0gdGhpcztcbiAgICAgICAgICBjaGlsZFF1ZXJ5LnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcblxuICAgICAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICAgICAgc2VsZltpXSA9IGNoaWxkUXVlcnk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2Rlc2NlbmRhbnQnLFxuICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgLy8gdGhpcyBxdWVyeSBpcyB0aGUgYW5jZXN0b3Igb2YgdGhlIGZvbGxvd2luZyBxdWVyeVxuICAgICAgICAgIHZhciBkZXNjZW5kYW50UXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICAgIGRlc2NlbmRhbnRRdWVyeS5hbmNlc3RvciA9IHRoaXM7XG4gICAgICAgICAgZGVzY2VuZGFudFF1ZXJ5LnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcblxuICAgICAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBkZXNjZW5kYW50IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgICAgICBzZWxmW2ldID0gZGVzY2VuZGFudFF1ZXJ5O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdzdWJqZWN0JyxcbiAgICAgICAgbW9kaWZpZXI6IHRydWUsXG4gICAgICAgIHJlZ2V4OiB0b2tlbnMuc3ViamVjdCxcbiAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgaWYoIGN1cnJlbnRTdWJqZWN0ICE9IG51bGwgJiYgdGhpcy5zdWJqZWN0ICE9IHRoaXMgKXtcbiAgICAgICAgICAgIHV0aWwuZXJyb3IoJ1JlZGVmaW5pdGlvbiBvZiBzdWJqZWN0IGluIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRTdWJqZWN0ID0gdGhpcztcbiAgICAgICAgICB0aGlzLnN1YmplY3QgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICBdO1xuXG4gICAgc2VsZi5fcHJpdmF0ZS5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICB2YXIgcmVtYWluaW5nID0gc2VsZWN0b3I7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgLy8gb2YgYWxsIHRoZSBleHByZXNzaW9ucywgZmluZCB0aGUgZmlyc3QgbWF0Y2ggaW4gdGhlIHJlbWFpbmluZyB0ZXh0XG4gICAgdmFyIGNvbnN1bWVFeHByID0gZnVuY3Rpb24oIGV4cGVjdGF0aW9uICl7XG4gICAgICB2YXIgZXhwcjtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBuYW1lO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGV4cHJzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgICAgIHZhciBuID0gZS5uYW1lO1xuXG4gICAgICAgIC8vIGlnbm9yZSB0aGlzIGV4cHJlc3Npb24gaWYgaXQgZG9lc24ndCBtZWV0IHRoZSBleHBlY3RhdGlvbiBmdW5jdGlvblxuICAgICAgICBpZiggaXMuZm4oIGV4cGVjdGF0aW9uICkgJiYgIWV4cGVjdGF0aW9uKG4sIGUpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2gobmV3IFJlZ0V4cCggJ14nICsgZS5yZWdleCApKTtcblxuICAgICAgICBpZiggbSAhPSBudWxsICl7XG4gICAgICAgICAgbWF0Y2ggPSBtO1xuICAgICAgICAgIGV4cHIgPSBlO1xuICAgICAgICAgIG5hbWUgPSBuO1xuXG4gICAgICAgICAgdmFyIGNvbnN1bWVkID0gbVswXTtcbiAgICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBjb25zdW1lZC5sZW5ndGggKTtcblxuICAgICAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHByOiBleHByLFxuICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIGNvbnN1bWUgYWxsIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgIHZhciBjb25zdW1lV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG5cbiAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICB2YXIgY29uc3VtZWQgPSBtYXRjaFswXTtcbiAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggY29uc3VtZWQubGVuZ3RoICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpOyAvLyBnZXQgc3RhcnRlZFxuXG4gICAgY29uc3VtZVdoaXRlc3BhY2UoKTsgLy8gZ2V0IHJpZCBvZiBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICBmb3IoOzspe1xuICAgICAgdmFyIGNoZWNrID0gY29uc3VtZUV4cHIoKTtcblxuICAgICAgaWYoIGNoZWNrLmV4cHIgPT0gbnVsbCApe1xuICAgICAgICB1dGlsLmVycm9yKCdUaGUgc2VsZWN0b3IgYCcrIHNlbGVjdG9yICsnYGlzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yKHZhciBqID0gMTsgaiA8IGNoZWNrLm1hdGNoLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICBhcmdzLnB1c2goIGNoZWNrLm1hdGNoW2pdICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXQgdGhlIHRva2VuIHBvcHVsYXRlIHRoZSBzZWxlY3RvciBvYmplY3QgKGkuZS4gaW4gc2VsZltpXSlcbiAgICAgICAgdmFyIHJldCA9IGNoZWNrLmV4cHIucG9wdWxhdGUuYXBwbHkoIHNlbGZbaV0sIGFyZ3MgKTtcblxuICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyByZXR1cm47IH0gLy8gZXhpdCBpZiBwb3B1bGF0aW9uIGZhaWxlZFxuICAgICAgfVxuXG4gICAgICAvLyB3ZSdyZSBkb25lIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gcGFyc2VcbiAgICAgIGlmKCByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pICl7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYubGVuZ3RoID0gaSArIDE7XG5cbiAgICAvLyBhZGp1c3QgcmVmZXJlbmNlcyBmb3Igc3ViamVjdFxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ICE9IG51bGwgKXtcbiAgICAgICAgLy8gZ28gdXAgdGhlIHRyZWUgdW50aWwgd2UgcmVhY2ggdGhlIHN1YmplY3RcbiAgICAgICAgZm9yKDs7KXtcbiAgICAgICAgICBpZiggcXVlcnkuc3ViamVjdCA9PSBxdWVyeSApeyBicmVhazsgfSAvLyBkb25lIGlmIHN1YmplY3QgaXMgc2VsZlxuXG4gICAgICAgICAgaWYoIHF1ZXJ5LnBhcmVudCAhPSBudWxsICl7IC8vIHN3YXAgcGFyZW50L2NoaWxkIHJlZmVyZW5jZVxuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHF1ZXJ5LnBhcmVudDtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgcGFyZW50LmNoaWxkID0gY2hpbGQ7XG5cbiAgICAgICAgICAgIHF1ZXJ5ID0gcGFyZW50OyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICAgIH0gZWxzZSBpZiggcXVlcnkuYW5jZXN0b3IgIT0gbnVsbCApeyAvLyBzd2FwIGFuY2VzdG9yL2Rlc2NlbmRhbnRcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHF1ZXJ5LmFuY2VzdG9yO1xuICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnQgPSBxdWVyeTtcblxuICAgICAgICAgICAgZGVzY2VuZGFudC5hbmNlc3RvciA9IG51bGw7XG4gICAgICAgICAgICBhbmNlc3Rvci5kZXNjZW5kYW50ID0gZGVzY2VuZGFudDtcblxuICAgICAgICAgICAgcXVlcnkgPSBhbmNlc3RvcjsgLy8gZ28gdXAgdGhlIHRyZWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5lcnJvcignV2hlbiBhZGp1c3RpbmcgcmVmZXJlbmNlcyBmb3IgdGhlIHNlbGVjdG9yIGAnKyBxdWVyeSArJ2AsIG5laXRoZXIgcGFyZW50IG5vciBhbmNlc3RvciB3YXMgZm91bmQnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3JcblxuICAgICAgICBzZWxmW2pdID0gcXVlcnkuc3ViamVjdDsgLy8gc3ViamVjdCBzaG91bGQgYmUgdGhlIHJvb3QgcXVlcnlcbiAgICAgIH0gLy8gaWZcbiAgICB9IC8vIGZvclxuXG4gICAgLy8gbWFrZSBzdXJlIGZvciBlYWNoIHF1ZXJ5IHRoYXQgdGhlIHN1YmplY3QgZ3JvdXAgbWF0Y2hlcyB0aGUgaW1wbGljaXQgZ3JvdXAgaWYgYW55XG4gICAgaWYoIG9ubHlUaGlzR3JvdXAgIT0gbnVsbCApe1xuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgICBpZiggc2VsZltqXS5ncm91cCAhPSBudWxsICYmIHNlbGZbal0uZ3JvdXAgIT0gb25seVRoaXNHcm91cCApe1xuICAgICAgICAgIHV0aWwuZXJyb3IoJ0dyb3VwIGAnKyBzZWxmW2pdLmdyb3VwICsnYCBjb25mbGljdHMgd2l0aCBpbXBsaWNpdCBncm91cCBgJysgb25seVRoaXNHcm91cCArJ2AgaW4gc2VsZWN0b3IgYCcrIHNlbGVjdG9yICsnYCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGZbal0uZ3JvdXAgPSBvbmx5VGhpc0dyb3VwOyAvLyBzZXQgdG8gaW1wbGljaXQgZ3JvdXBcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB1dGlsLmVycm9yKCdBIHNlbGVjdG9yIG11c3QgYmUgY3JlYXRlZCBmcm9tIGEgc3RyaW5nOyBmb3VuZCAnICsgc2VsZWN0b3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYuX3ByaXZhdGUuaW52YWxpZCA9IGZhbHNlO1xuXG59O1xuXG52YXIgc2VsZm4gPSBTZWxlY3Rvci5wcm90b3R5cGU7XG5cbnNlbGZuLnNpemUgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5zZWxmbi5lcSA9IGZ1bmN0aW9uKGkpe1xuICByZXR1cm4gdGhpc1tpXTtcbn07XG5cbnZhciBxdWVyeU1hdGNoZXMgPSBmdW5jdGlvbihxdWVyeSwgZWxlbWVudCl7XG4gIC8vIGNoZWNrIGdyb3VwXG4gIGlmKCBxdWVyeS5ncm91cCAhPSBudWxsICYmIHF1ZXJ5Lmdyb3VwICE9ICcqJyAmJiBxdWVyeS5ncm91cCAhPSBlbGVtZW50Ll9wcml2YXRlLmdyb3VwICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGN5ID0gZWxlbWVudC5jeSgpO1xuXG4gIC8vIGNoZWNrIGNvbG9uIHNlbGVjdG9yc1xuICB2YXIgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IHRydWU7XG4gIGZvcih2YXIgayA9IDA7IGsgPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGsrKyl7XG4gICAgdmFyIHNlbCA9IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzW2tdO1xuXG4gICAgc3dpdGNoKHNlbCl7XG4gICAgY2FzZSAnOnNlbGVjdGVkJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnNlbGVjdGVkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6dW5zZWxlY3RlZCc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuc2VsZWN0ZWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpzZWxlY3RhYmxlJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnNlbGVjdGFibGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzp1bnNlbGVjdGFibGUnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnNlbGVjdGFibGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpsb2NrZWQnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQubG9ja2VkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6dW5sb2NrZWQnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmxvY2tlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOnZpc2libGUnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQudmlzaWJsZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOmhpZGRlbic6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQudmlzaWJsZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOnRyYW5zcGFyZW50JzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnRyYW5zcGFyZW50KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6Z3JhYmJlZCc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5ncmFiYmVkKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6ZnJlZSc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuZ3JhYmJlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOnJlbW92ZWQnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQucmVtb3ZlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOmluc2lkZSc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQucmVtb3ZlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOmdyYWJiYWJsZSc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5ncmFiYmFibGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzp1bmdyYWJiYWJsZSc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuZ3JhYmJhYmxlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6YW5pbWF0ZWQnOlxuICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuYW5pbWF0ZWQoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzp1bmFuaW1hdGVkJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5hbmltYXRlZCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOnBhcmVudCc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc05vZGUoKSAmJiBlbGVtZW50LmNoaWxkcmVuKCkubm9uZW1wdHkoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpjaGlsZCc6XG4gICAgY2FzZSAnOm5vbm9ycGhhbic6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc05vZGUoKSAmJiBlbGVtZW50LnBhcmVudCgpLm5vbmVtcHR5KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6b3JwaGFuJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzTm9kZSgpICYmIGVsZW1lbnQucGFyZW50KCkuZW1wdHkoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpsb29wJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzRWRnZSgpICYmIGVsZW1lbnQuZGF0YSgnc291cmNlJykgPT09IGVsZW1lbnQuZGF0YSgndGFyZ2V0Jyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6c2ltcGxlJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzRWRnZSgpICYmIGVsZW1lbnQuZGF0YSgnc291cmNlJykgIT09IGVsZW1lbnQuZGF0YSgndGFyZ2V0Jyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc6YWN0aXZlJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmFjdGl2ZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnOmluYWN0aXZlJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5hY3RpdmUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzp0b3VjaCc6XG4gICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gaXMudG91Y2goKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpiYWNrZ3JvdW5kaW5nJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmJhY2tncm91bmRpbmcoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzpub25iYWNrZ3JvdW5kaW5nJzpcbiAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5iYWNrZ3JvdW5kaW5nKCk7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiggIWFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggKSBicmVhaztcbiAgfVxuICBpZiggIWFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gY2hlY2sgaWRcbiAgdmFyIGFsbElkc01hdGNoID0gdHJ1ZTtcbiAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGsrKyl7XG4gICAgdmFyIGlkID0gcXVlcnkuaWRzW2tdO1xuICAgIHZhciBhY3R1YWxJZCA9IGVsZW1lbnQuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgIGFsbElkc01hdGNoID0gYWxsSWRzTWF0Y2ggJiYgKGlkID09IGFjdHVhbElkKTtcblxuICAgIGlmKCAhYWxsSWRzTWF0Y2ggKSBicmVhaztcbiAgfVxuICBpZiggIWFsbElkc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGNoZWNrIGNsYXNzZXNcbiAgdmFyIGFsbENsYXNzZXNNYXRjaCA9IHRydWU7XG4gIGZvcih2YXIgayA9IDA7IGsgPCBxdWVyeS5jbGFzc2VzLmxlbmd0aDsgaysrKXtcbiAgICB2YXIgY2xzID0gcXVlcnkuY2xhc3Nlc1trXTtcblxuICAgIGFsbENsYXNzZXNNYXRjaCA9IGFsbENsYXNzZXNNYXRjaCAmJiBlbGVtZW50Lmhhc0NsYXNzKGNscyk7XG5cbiAgICBpZiggIWFsbENsYXNzZXNNYXRjaCApIGJyZWFrO1xuICB9XG4gIGlmKCAhYWxsQ2xhc3Nlc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGdlbmVyaWMgY2hlY2tpbmcgZm9yIGRhdGEvbWV0YWRhdGFcbiAgdmFyIG9wZXJhbmRzTWF0Y2ggPSBmdW5jdGlvbihwYXJhbXMpe1xuICAgIHZhciBhbGxEYXRhTWF0Y2hlcyA9IHRydWU7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5W3BhcmFtcy5uYW1lXS5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgZGF0YSA9IHF1ZXJ5W3BhcmFtcy5uYW1lXVtrXTtcbiAgICAgIHZhciBvcGVyYXRvciA9IGRhdGEub3BlcmF0b3I7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgdmFyIGZpZWxkID0gZGF0YS5maWVsZDtcbiAgICAgIHZhciBtYXRjaGVzO1xuXG4gICAgICBpZiggb3BlcmF0b3IgIT0gbnVsbCAmJiB2YWx1ZSAhPSBudWxsICl7XG5cbiAgICAgICAgdmFyIGZpZWxkVmFsID0gcGFyYW1zLmZpZWxkVmFsdWUoZmllbGQpO1xuICAgICAgICB2YXIgZmllbGRTdHIgPSAhaXMuc3RyaW5nKGZpZWxkVmFsKSAmJiAhaXMubnVtYmVyKGZpZWxkVmFsKSA/ICcnIDogJycgKyBmaWVsZFZhbDtcbiAgICAgICAgdmFyIHZhbFN0ciA9ICcnICsgdmFsdWU7XG5cbiAgICAgICAgdmFyIGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiggb3BlcmF0b3IuaW5kZXhPZignQCcpID49IDAgKXtcbiAgICAgICAgICBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFsU3RyID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJ0AnLCAnJyk7XG4gICAgICAgICAgY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub3RFeHByID0gZmFsc2U7XG4gICAgICAgIHZhciBoYW5kbGVkTm90RXhwciA9IGZhbHNlO1xuICAgICAgICBpZiggb3BlcmF0b3IuaW5kZXhPZignIScpID49IDAgKXtcbiAgICAgICAgICBvcGVyYXRvciA9IG9wZXJhdG9yLnJlcGxhY2UoJyEnLCAnJyk7XG4gICAgICAgICAgbm90RXhwciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSdyZSBkb2luZyBhIGNhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiwgdGhlbiB3ZSdyZSB1c2luZyBhIFNUUklORyBjb21wYXJpc29uXG4gICAgICAgIC8vIGV2ZW4gaWYgd2UncmUgY29tcGFyaW5nIG51bWJlcnNcbiAgICAgICAgaWYoIGNhc2VJbnNlbnNpdGl2ZSApe1xuICAgICAgICAgIHZhbHVlID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgZmllbGRWYWwgPSBmaWVsZFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoKG9wZXJhdG9yKXtcbiAgICAgICAgY2FzZSAnKj0nOlxuICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5zZWFyY2godmFsU3RyKSA+PSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICckPSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAodmFsU3RyICsgJyQnKS5leGVjKGZpZWxkU3RyKSAhPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdePSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAoJ14nICsgdmFsU3RyKS5leGVjKGZpZWxkU3RyKSAhPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICchPSc6XG4gICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsICE9PSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPiB2YWx1ZSA6IGZpZWxkVmFsIDw9IHZhbHVlO1xuICAgICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgIG1hdGNoZXMgPSAhbm90RXhwciA/IGZpZWxkVmFsID49IHZhbHVlIDogZmllbGRWYWwgPCB2YWx1ZTtcbiAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIG1hdGNoZXMgPSAhbm90RXhwciA/IGZpZWxkVmFsIDwgdmFsdWUgOiBmaWVsZFZhbCA+PSB2YWx1ZTtcbiAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA8PSB2YWx1ZSA6IGZpZWxkVmFsID4gdmFsdWU7XG4gICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoIG9wZXJhdG9yICE9IG51bGwgKXtcbiAgICAgICAgc3dpdGNoKG9wZXJhdG9yKXtcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFRydXRoeShmaWVsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgIG1hdGNoZXMgPSAhcGFyYW1zLmZpZWxkVHJ1dGh5KGZpZWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFVuZGVmaW5lZChmaWVsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoZXMgPSAhcGFyYW1zLmZpZWxkVW5kZWZpbmVkKGZpZWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG5vdEV4cHIgJiYgIWhhbmRsZWROb3RFeHByICl7XG4gICAgICAgIG1hdGNoZXMgPSAhbWF0Y2hlcztcbiAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggIW1hdGNoZXMgKXtcbiAgICAgICAgYWxsRGF0YU1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBmb3JcblxuICAgIHJldHVybiBhbGxEYXRhTWF0Y2hlcztcbiAgfTsgLy8gb3BlcmFuZHNNYXRjaFxuXG4gIC8vIGNoZWNrIGRhdGEgbWF0Y2hlc1xuICB2YXIgYWxsRGF0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHtcbiAgICBuYW1lOiAnZGF0YScsXG4gICAgZmllbGRWYWx1ZTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF07XG4gICAgfSxcbiAgICBmaWVsZFJlZjogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgcmV0dXJuICdlbGVtZW50Ll9wcml2YXRlLmRhdGEuJyArIGZpZWxkO1xuICAgIH0sXG4gICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgIHJldHVybiBlbGVtZW50Ll9wcml2YXRlLmRhdGFbZmllbGRdID09PSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgaWYoIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF0gKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcblxuICBpZiggIWFsbERhdGFNYXRjaGVzICl7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2hlY2sgbWV0YWRhdGEgbWF0Y2hlc1xuICB2YXIgYWxsTWV0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHtcbiAgICBuYW1lOiAnbWV0YScsXG4gICAgZmllbGRWYWx1ZTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgcmV0dXJuIGVsZW1lbnRbZmllbGRdKCk7XG4gICAgfSxcbiAgICBmaWVsZFJlZjogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgcmV0dXJuICdlbGVtZW50LicgKyBmaWVsZCArICcoKSc7XG4gICAgfSxcbiAgICBmaWVsZFVuZGVmaW5lZDogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgcmV0dXJuIGVsZW1lbnRbZmllbGRdKCkgPT0gbnVsbDtcbiAgICB9LFxuICAgIGZpZWxkVHJ1dGh5OiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICBpZiggZWxlbWVudFtmaWVsZF0oKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmKCAhYWxsTWV0YU1hdGNoZXMgKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBjaGVjayBjb2xsZWN0aW9uXG4gIGlmKCBxdWVyeS5jb2xsZWN0aW9uICE9IG51bGwgKXtcbiAgICB2YXIgbWF0Y2hlc0FueSA9IHF1ZXJ5LmNvbGxlY3Rpb24uX3ByaXZhdGUuaWRzWyBlbGVtZW50LmlkKCkgXSAhPSBudWxsO1xuXG4gICAgaWYoICFtYXRjaGVzQW55ICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgZmlsdGVyIGZ1bmN0aW9uXG4gIGlmKCBxdWVyeS5maWx0ZXIgIT0gbnVsbCAmJiBlbGVtZW50LmNvbGxlY3Rpb24oKS5maWx0ZXIoIHF1ZXJ5LmZpbHRlciApLnNpemUoKSA9PT0gMCApe1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG5cbiAgLy8gY2hlY2sgcGFyZW50L2NoaWxkIHJlbGF0aW9uc1xuICB2YXIgY29uZmlybVJlbGF0aW9ucyA9IGZ1bmN0aW9uKCBxdWVyeSwgZWxlbWVudHMgKXtcbiAgICBpZiggcXVlcnkgIT0gbnVsbCApe1xuICAgICAgdmFyIG1hdGNoZXMgPSBmYWxzZTtcblxuICAgICAgaWYoICFjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzKCk7IC8vIG1ha2UgZWxlbWVudHMgZnVuY3Rpb25hbCBzbyB3ZSBzYXZlIGN5Y2xlcyBpZiBxdWVyeSA9PSBudWxsXG5cbiAgICAgIC8vIHF1ZXJ5IG11c3QgbWF0Y2ggZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50IChtYXkgYmUgcmVjdXJzaXZlKVxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyggcXVlcnksIGVsZW1lbnRzW2ldICkgKXtcbiAgICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gIGlmICghIGNvbmZpcm1SZWxhdGlvbnMocXVlcnkucGFyZW50LCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBlbGVtZW50LnBhcmVudCgpO1xuICB9KSApeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmFuY2VzdG9yLCBmdW5jdGlvbigpe1xuICAgIHJldHVybiBlbGVtZW50LnBhcmVudHMoKTtcbiAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5jaGlsZCwgZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbigpO1xuICB9KSApeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmRlc2NlbmRhbnQsIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGVzY2VuZGFudHMoKTtcbiAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2UndmUgcmVhY2hlZCB0aGUgZW5kLCBzbyB3ZSd2ZSBtYXRjaGVkIGV2ZXJ5dGhpbmcgZm9yIHRoaXMgcXVlcnlcbiAgcmV0dXJuIHRydWU7XG59OyAvLyBxdWVyeU1hdGNoZXNcblxuLy8gZmlsdGVyIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb25cbnNlbGZuLmZpbHRlciA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeSA9IGNvbGxlY3Rpb24uY3koKTtcblxuICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICBpZiggc2VsZi5fcHJpdmF0ZS5pbnZhbGlkICl7XG4gICAgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcblxuICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZWxlbWVudCkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIGlmKCBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9PSBudWxsICl7XG4gICAgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlOyB9O1xuICB9XG5cbiAgdmFyIGZpbHRlcmVkQ29sbGVjdGlvbiA9IGNvbGxlY3Rpb24uZmlsdGVyKCBzZWxlY3RvckZ1bmN0aW9uICk7XG5cbiAgcmV0dXJuIGZpbHRlcmVkQ29sbGVjdGlvbjtcbn07IC8vIGZpbHRlclxuXG4vLyBkb2VzIHNlbGVjdG9yIG1hdGNoIGEgc2luZ2xlIGVsZW1lbnQ/XG5zZWxmbi5tYXRjaGVzID0gZnVuY3Rpb24oZWxlKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRvbid0IGJvdGhlciB0cnlpbmcgaWYgaXQncyBpbnZhbGlkXG4gIGlmKCBzZWxmLl9wcml2YXRlLmludmFsaWQgKXtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyl7XG4gICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcblxuICAgIGlmKCBxdWVyeU1hdGNoZXMocXVlcnksIGVsZSkgKXtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07IC8vIGZpbHRlclxuXG4vLyBpdGggcXVlcnkgdG8gc3RyaW5nXG5zZWxmbi50b1N0cmluZyA9IHNlbGZuLnNlbGVjdG9yID0gZnVuY3Rpb24oKXtcblxuICB2YXIgc3RyID0gJyc7XG5cbiAgdmFyIGNsZWFuID0gZnVuY3Rpb24ob2JqLCBpc1ZhbHVlKXtcbiAgICBpZiggaXMuc3RyaW5nKG9iaikgKXtcbiAgICAgIHJldHVybiBpc1ZhbHVlID8gJ1wiJyArIG9iaiArICdcIicgOiBvYmo7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfTtcblxuICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uKHF1ZXJ5KXtcbiAgICB2YXIgc3RyID0gJyc7XG5cbiAgICBpZiggcXVlcnkuc3ViamVjdCA9PT0gcXVlcnkgKXtcbiAgICAgIHN0ciArPSAnJCc7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwID0gY2xlYW4ocXVlcnkuZ3JvdXApO1xuICAgIHN0ciArPSBncm91cC5zdWJzdHJpbmcoMCwgZ3JvdXAubGVuZ3RoIC0gMSk7XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkuZGF0YS5sZW5ndGg7IGorKyl7XG4gICAgICB2YXIgZGF0YSA9IHF1ZXJ5LmRhdGFbal07XG5cbiAgICAgIGlmKCBkYXRhLnZhbHVlICl7XG4gICAgICAgIHN0ciArPSAnWycgKyBkYXRhLmZpZWxkICsgY2xlYW4oZGF0YS5vcGVyYXRvcikgKyBjbGVhbihkYXRhLnZhbHVlLCB0cnVlKSArICddJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSAnWycgKyBjbGVhbihkYXRhLm9wZXJhdG9yKSArIGRhdGEuZmllbGQgKyAnXSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5Lm1ldGEubGVuZ3RoOyBqKyspe1xuICAgICAgdmFyIG1ldGEgPSBxdWVyeS5tZXRhW2pdO1xuICAgICAgc3RyICs9ICdbWycgKyBtZXRhLmZpZWxkICsgY2xlYW4obWV0YS5vcGVyYXRvcikgKyBjbGVhbihtZXRhLnZhbHVlLCB0cnVlKSArICddXSc7XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzLmxlbmd0aDsgaisrKXtcbiAgICAgIHZhciBzZWwgPSBxdWVyeS5jb2xvblNlbGVjdG9yc1tpXTtcbiAgICAgIHN0ciArPSBzZWw7XG4gICAgfVxuXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGorKyl7XG4gICAgICB2YXIgc2VsID0gJyMnICsgcXVlcnkuaWRzW2ldO1xuICAgICAgc3RyICs9IHNlbDtcbiAgICB9XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGorKyl7XG4gICAgICB2YXIgc2VsID0gJy4nICsgcXVlcnkuY2xhc3Nlc1tqXTtcbiAgICAgIHN0ciArPSBzZWw7XG4gICAgfVxuXG4gICAgaWYoIHF1ZXJ5LnBhcmVudCAhPSBudWxsICl7XG4gICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5wYXJlbnQgKSArICcgPiAnICsgc3RyO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7XG4gICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5hbmNlc3RvciApICsgJyAnICsgc3RyO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5jaGlsZCAhPSBudWxsICl7XG4gICAgICBzdHIgKz0gJyA+ICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5jaGlsZCApO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeS5kZXNjZW5kYW50ICE9IG51bGwgKXtcbiAgICAgIHN0ciArPSAnICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5kZXNjZW5kYW50ICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpc1tpXTtcblxuICAgIHN0ciArPSBxdWVyeVRvU3RyaW5nKCBxdWVyeSApO1xuXG4gICAgaWYoIHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxICl7XG4gICAgICBzdHIgKz0gJywgJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZWxlY3RvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gKHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBjYWxjdWxhdGlvbilcbi8vIGFwcGx5IHRoZSBzdHlsZSB0byB0aGUgZWxlbWVudCBiYXNlZCBvblxuLy8gLSBpdHMgYnlwYXNzXG4vLyAtIHdoYXQgc2VsZWN0b3JzIG1hdGNoIGl0XG5zdHlmbi5hcHBseSA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiggc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSApeyAvLyBjbGVhciBzdHlsZSBjYWNoZXNcbiAgICB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB7fTtcbiAgICB0aGlzLl9wcml2YXRlLnByb3BEaWZmcyA9IHt9O1xuICB9XG5cbiAgZm9yKCB2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrICl7XG4gICAgdmFyIGVsZSA9IGVsZXNbaWVdO1xuICAgIHZhciBjeHRNZXRhID0gc2VsZi5nZXRDb250ZXh0TWV0YSggZWxlICk7XG4gICAgdmFyIGN4dFN0eWxlID0gc2VsZi5nZXRDb250ZXh0U3R5bGUoIGN4dE1ldGEgKTtcbiAgICB2YXIgYXBwID0gc2VsZi5hcHBseUNvbnRleHRTdHlsZSggY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSApO1xuXG4gICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBhcHAuZGlmZlByb3BzICk7XG4gICAgc2VsZi51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcblxuICB9IC8vIGZvciBlbGVtZW50c1xuXG4gIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgPSBmYWxzZTtcbn07XG5cbnN0eWZuLmdldFByb3BlcnRpZXNEaWZmID0gZnVuY3Rpb24oIG9sZEN4dEtleSwgbmV3Q3h0S2V5ICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgdmFyIGR1YWxDeHRLZXkgPSBvbGRDeHRLZXkgKyAnLScgKyBuZXdDeHRLZXk7XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtkdWFsQ3h0S2V5XTtcblxuICBpZiggY2FjaGVkVmFsICl7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfVxuXG4gIHZhciBkaWZmUHJvcHMgPSBbXTtcbiAgdmFyIGFkZGVkUHJvcCA9IHt9O1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbaV0gPT09ICd0JztcbiAgICB2YXIgbmV3SGFzQ3h0ID0gbmV3Q3h0S2V5W2ldID09PSAndCc7XG4gICAgdmFyIGN4dEhhc0RpZmZlZCA9IG9sZEhhc0N4dCAhPT0gbmV3SGFzQ3h0O1xuICAgIHZhciBjeHRIYXNNYXBwZWRQcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzLmxlbmd0aCA+IDA7XG5cbiAgICBpZiggY3h0SGFzRGlmZmVkIHx8IGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICB2YXIgcHJvcHM7XG5cbiAgICAgIGlmKCBjeHRIYXNEaWZmZWQgJiYgY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gc3VmZmljZXMgYi9jIG1hcHBlZFByb3BlcnRpZXMgaXMgYSBzdWJzZXQgb2YgcHJvcGVydGllc1xuICAgICAgfSBlbHNlIGlmKCBjeHRIYXNEaWZmZWQgKXtcbiAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gbmVlZCB0byBjaGVjayB0aGVtIGFsbFxuICAgICAgfSBlbHNlIGlmKCBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgICBwcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzOyAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgbWFwcGVkXG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgLy8gaWYgYSBsYXRlciBjb250ZXh0IG92ZXJyaWRlcyB0aGlzIHByb3BlcnR5LCB0aGVuIHRoZSBmYWN0IHRoYXQgdGhpcyBjb250ZXh0IGhhcyBzd2l0Y2hlZC9kaWZmZWQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgLy8gKHNlbWkgZXhwZW5zaXZlIGNoZWNrIHNpbmNlIGl0IG1ha2VzIHRoaXMgZnVuY3Rpb24gTyhuXjIpIG9uIGNvbnRleHQgbGVuZ3RoLCBidXQgd29ydGggaXQgc2luY2Ugb3ZlcmFsbCByZXN1bHRcbiAgICAgICAgLy8gaXMgY2FjaGVkKVxuICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yKCB2YXIgayA9IGkgKyAxOyBrIDwgc2VsZi5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgIHZhciBsYXRlckN4dCA9IHNlbGZba107XG4gICAgICAgICAgdmFyIGhhc0xhdGVyQ3h0ID0gbmV3Q3h0S2V5W2tdID09PSAndCc7XG5cbiAgICAgICAgICBpZiggIWhhc0xhdGVyQ3h0ICl7IGNvbnRpbnVlOyB9IC8vIGNhbid0IG92ZXJyaWRlIHVubGVzcyB0aGUgY29udGV4dCBpcyBhY3RpdmVcblxuICAgICAgICAgIGxhdGVyQ3h0T3ZlcnJpZGVzID0gbGF0ZXJDeHQucHJvcGVydGllc1sgcHJvcC5uYW1lIF0gIT0gbnVsbDtcblxuICAgICAgICAgIGlmKCBsYXRlckN4dE92ZXJyaWRlcyApeyBicmVhazsgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWFkZGVkUHJvcFtuYW1lXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMgKXtcbiAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGRpZmZQcm9wcy5wdXNoKCBuYW1lICk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIHByb3BzXG4gICAgfSAvLyBpZlxuXG4gIH0gLy8gZm9yIGNvbnRleHRzXG5cbiAgY2FjaGVbIGR1YWxDeHRLZXkgXSA9IGRpZmZQcm9wcztcbiAgcmV0dXJuIGRpZmZQcm9wcztcbn07XG5cbnN0eWZuLmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24oIGVsZSApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjeHRLZXkgPSAnJztcbiAgdmFyIGRpZmZQcm9wcztcbiAgdmFyIHByZXZLZXkgPSBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgfHwgJyc7XG5cbiAgaWYoIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgKXtcbiAgICBwcmV2S2V5ID0gJyc7IC8vIHNpbmNlIHdlIG5lZWQgdG8gYXBwbHkgYWxsIHN0eWxlIGlmIGEgZnJlc2ggc3R5bGVzaGVldFxuICB9XG5cbiAgLy8gZ2V0IHRoZSBjeHQga2V5XG4gIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBjb250ZXh0ID0gc2VsZltpXTtcbiAgICB2YXIgY29udGV4dFNlbGVjdG9yTWF0Y2hlcyA9IGNvbnRleHQuc2VsZWN0b3IgJiYgY29udGV4dC5zZWxlY3Rvci5tYXRjaGVzKCBlbGUgKTsgLy8gTkI6IGNvbnRleHQuc2VsZWN0b3IgbWF5IGJlIG51bGwgZm9yICdjb3JlJ1xuXG4gICAgaWYoIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgKXtcbiAgICAgIGN4dEtleSArPSAndCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN4dEtleSArPSAnZic7XG4gICAgfVxuICB9IC8vIGZvciBjb250ZXh0XG5cbiAgZGlmZlByb3BzID0gc2VsZi5nZXRQcm9wZXJ0aWVzRGlmZiggcHJldktleSwgY3h0S2V5ICk7XG5cbiAgZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5ID0gY3h0S2V5O1xuXG4gIHJldHVybiB7XG4gICAga2V5OiBjeHRLZXksXG4gICAgZGlmZlByb3BOYW1lczogZGlmZlByb3BzXG4gIH07XG59O1xuXG4vLyBnZXRzIGEgY29tcHV0ZWQgZWxlIHN0eWxlIG9iamVjdCBiYXNlZCBvbiBtYXRjaGVkIGNvbnRleHRzXG5zdHlmbi5nZXRDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiggY3h0TWV0YSApe1xuICB2YXIgY3h0S2V5ID0gY3h0TWV0YS5rZXk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyB8fCB7fTtcblxuICAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuICBpZiggY3h0U3R5bGVzW2N4dEtleV0gKXsgcmV0dXJuIGN4dFN0eWxlc1tjeHRLZXldOyB9XG5cbiAgdmFyIHN0eWxlID0ge1xuICAgIF9wcml2YXRlOiB7XG4gICAgICBrZXk6IGN4dEtleVxuICAgIH1cbiAgfTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICB2YXIgaGFzQ3h0ID0gY3h0S2V5W2ldID09PSAndCc7XG5cbiAgICBpZiggIWhhc0N4dCApeyBjb250aW51ZTsgfVxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjeHQucHJvcGVydGllcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBjeHQucHJvcGVydGllc1tqXTtcbiAgICAgIHZhciBzdHlQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDtcblxuICAgICAgc3R5UHJvcC5jb250ZXh0ID0gY3h0O1xuICAgIH1cbiAgfVxuXG4gIGN4dFN0eWxlc1tjeHRLZXldID0gc3R5bGU7XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbnN0eWZuLmFwcGx5Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZGlmZlByb3BzID0gY3h0TWV0YS5kaWZmUHJvcE5hbWVzO1xuICB2YXIgcmV0RGlmZlByb3BzID0ge307XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZGlmZlByb3BOYW1lID0gZGlmZlByb3BzW2ldO1xuICAgIHZhciBjeHRQcm9wID0gY3h0U3R5bGVbIGRpZmZQcm9wTmFtZSBdO1xuICAgIHZhciBlbGVQcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcblxuICAgIC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuICAgIGlmKCAhY3h0UHJvcCB8fCBlbGVQcm9wID09PSBjeHRQcm9wICl7IGNvbnRpbnVlOyB9XG5cbiAgICB2YXIgcmV0RGlmZlByb3AgPSByZXREaWZmUHJvcHNbIGRpZmZQcm9wTmFtZSBdID0ge1xuICAgICAgcHJldjogZWxlUHJvcFxuICAgIH07XG5cbiAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgY3h0UHJvcCApO1xuXG4gICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgZGlmZlByb3BOYW1lIF07XG5cbiAgICBpZiggcmV0RGlmZlByb3AubmV4dCAmJiByZXREaWZmUHJvcC5uZXh0LmJ5cGFzcyApe1xuICAgICAgcmV0RGlmZlByb3AubmV4dCA9IHJldERpZmZQcm9wLm5leHQuYnlwYXNzZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaWZmUHJvcHM6IHJldERpZmZQcm9wc1xuICB9O1xufTtcblxuc3R5Zm4udXBkYXRlU3R5bGVIaW50cyA9IGZ1bmN0aW9uKGVsZSl7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcblxuICBpZiggZWxlLnJlbW92ZWQoKSApeyByZXR1cm47IH1cblxuICAvLyBzZXQgd2hldGhlciBoYXMgcGllIG9yIG5vdDsgZm9yIGdyZWF0ZXIgZWZmaWNpZW5jeVxuICB2YXIgaGFzUGllID0gZmFsc2U7XG4gIGlmKCBfcC5ncm91cCA9PT0gJ25vZGVzJyAmJiBzZWxmLl9wcml2YXRlLmhhc1BpZSApe1xuICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IHNlbGYucGllQmFja2dyb3VuZE47IGkrKyApeyAvLyAxLi5OXG4gICAgICB2YXIgc2l6ZSA9IF9wLnN0eWxlWydwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZSddLnZhbHVlO1xuXG4gICAgICBpZiggc2l6ZSA+IDAgKXtcbiAgICAgICAgaGFzUGllID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3AuaGFzUGllID0gaGFzUGllO1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBzdHlsZVsndGV4dC10cmFuc2Zvcm0nXS5zdHJWYWx1ZTtcbiAgdmFyIGNvbnRlbnQgPSBzdHlsZVsnbGFiZWwnXS5zdHJWYWx1ZTtcbiAgdmFyIGZTdHlsZSA9IHN0eWxlWydmb250LXN0eWxlJ10uc3RyVmFsdWU7XG4gIHZhciBzaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddLnBmVmFsdWUgKyAncHgnO1xuICB2YXIgZmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gIC8vIHZhciB2YXJpYW50ID0gc3R5bGVbJ2ZvbnQtdmFyaWFudCddLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gc3R5bGVbJ2ZvbnQtd2VpZ2h0J10uc3RyVmFsdWU7XG4gIHZhciB2YWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgdmFyIGhhbGlnbiA9IHN0eWxlWyd0ZXh0LXZhbGlnbiddLnN0clZhbHVlO1xuICB2YXIgb1dpZHRoID0gc3R5bGVbJ3RleHQtb3V0bGluZS13aWR0aCddLnBmVmFsdWU7XG4gIHZhciB3cmFwID0gc3R5bGVbJ3RleHQtd3JhcCddLnN0clZhbHVlO1xuICB2YXIgd3JhcFcgPSBzdHlsZVsndGV4dC1tYXgtd2lkdGgnXS5wZlZhbHVlO1xuICBfcC5sYWJlbEtleSA9IGZTdHlsZSArJyQnKyBzaXplICsnJCcrIGZhbWlseSArJyQnKyB3ZWlnaHQgKyckJysgY29udGVudCArJyQnKyB0cmFuc2Zvcm0gKyckJysgdmFsaWduICsnJCcrIGhhbGlnbiArJyQnKyBvV2lkdGggKyAnJCcgKyB3cmFwICsgJyQnICsgd3JhcFc7XG4gIF9wLmZvbnRLZXkgPSBmU3R5bGUgKyckJysgd2VpZ2h0ICsnJCcrIHNpemUgKyckJysgZmFtaWx5O1xuXG4gIHZhciB3aWR0aCA9IHN0eWxlWyd3aWR0aCddLnBmVmFsdWU7XG4gIHZhciBoZWlnaHQgPSBzdHlsZVsnaGVpZ2h0J10ucGZWYWx1ZTtcbiAgdmFyIGJvcmRlclcgPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucGZWYWx1ZTtcbiAgX3AuYm91bmRpbmdCb3hLZXkgPSB3aWR0aCArJyQnKyBoZWlnaHQgKyckJysgYm9yZGVyVztcblxuICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnZWRnZXMnICl7XG4gICAgdmFyIGNwc3MgPSBzdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5wZlZhbHVlO1xuICAgIHZhciBjcGQgPSBzdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnXSA/IHN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlcyddLnBmVmFsdWUuam9pbignXycpIDogdW5kZWZpbmVkO1xuICAgIHZhciBjcHcgPSBzdHlsZVsnY29udHJvbC1wb2ludC13ZWlnaHRzJ10udmFsdWUuam9pbignXycpO1xuICAgIHZhciBjdXJ2ZSA9IHN0eWxlWydjdXJ2ZS1zdHlsZSddLnN0clZhbHVlO1xuICAgIHZhciBzZCA9IHN0eWxlWydzZWdtZW50LWRpc3RhbmNlcyddID8gc3R5bGVbJ3NlZ21lbnQtZGlzdGFuY2VzJ10ucGZWYWx1ZS5qb2luKCdfJykgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHN3ID0gc3R5bGVbJ3NlZ21lbnQtd2VpZ2h0cyddLnZhbHVlLmpvaW4oJ18nKTtcblxuICAgIF9wLmJvdW5kaW5nQm94S2V5ICs9ICckJysgY3BzcyArJyQnKyBjcGQgKyckJysgY3B3ICsnJCcrIHNkICsnJCcrIHN3ICsnJCcrIGN1cnZlO1xuICB9XG5cbiAgX3Auc3R5bGVLZXkgPSBEYXRlLm5vdygpO1xufTtcblxuLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4vLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbi8vXG4vLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSwgZGVsZXRlQnlwYXNzOiB0cnVlIH1cbi8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4vLyBmaWVsZCBpbiB0aGUgYnlwYXNzIHByb3BlcnR5IChpLmUuIHJlc3RvcmluZyB0aGUgcHJvcGVydHkgdGhlXG4vLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4vL1xuLy8gZm9yIHBhcnNlZFByb3A6eyBtYXBwZWQ6IHRydXRoeSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSB9XG4vLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBieXBhc3NlZDogcGFyc2VkUHJvcCB9XG5zdHlmbi5hcHBseVBhcnNlZFByb3BlcnR5ID0gZnVuY3Rpb24oIGVsZSwgcGFyc2VkUHJvcCApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wID0gcGFyc2VkUHJvcDtcbiAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICB2YXIgZmllbGRWYWwsIGZsYXRQcm9wO1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICB2YXIgdHlwZSA9IHNlbGYucHJvcGVydGllc1sgcHJvcC5uYW1lIF0udHlwZTtcbiAgdmFyIHByb3BJc0J5cGFzcyA9IHByb3AuYnlwYXNzO1xuICB2YXIgb3JpZ1Byb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgLy8gY2FuJ3QgYXBwbHkgYXV0byB0byB3aWR0aCBvciBoZWlnaHQgdW5sZXNzIGl0J3MgYSBwYXJlbnQgbm9kZVxuICBpZiggKHBhcnNlZFByb3AubmFtZSA9PT0gJ2hlaWdodCcgfHwgcGFyc2VkUHJvcC5uYW1lID09PSAnd2lkdGgnKSAmJiBlbGUuaXNOb2RlKCkgKXtcbiAgICBpZiggcGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2F1dG8nICYmICFlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiggcGFyc2VkUHJvcC52YWx1ZSAhPT0gJ2F1dG8nICYmIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICBwcm9wID0gcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoIHBhcnNlZFByb3AubmFtZSwgJ2F1dG8nLCBwcm9wSXNCeXBhc3MgKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBieXBhc3NcbiAgaWYoIHByb3BJc0J5cGFzcyAmJiBwcm9wLmRlbGV0ZUJ5cGFzcyApeyAvLyB0aGVuIHRoaXMgcHJvcGVydHkgaXMganVzdCBoZXJlIHRvIGluZGljYXRlIHdlIG5lZWQgdG8gZGVsZXRlXG4gICAgdmFyIGN1cnJlbnRQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgLy8gY2FuIG9ubHkgZGVsZXRlIGlmIHRoZSBjdXJyZW50IHByb3AgaXMgYSBieXBhc3MgYW5kIGl0IHBvaW50cyB0byB0aGUgcHJvcGVydHkgaXQgd2FzIG92ZXJyaWRpbmdcbiAgICBpZiggIWN1cnJlbnRQcm9wICl7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gcHJvcGVydHkgaXMgYWxyZWFkeSBub3QgZGVmaW5lZFxuICAgIH0gZWxzZSBpZiggY3VycmVudFByb3AuYnlwYXNzICYmIGN1cnJlbnRQcm9wLmJ5cGFzc2VkICl7IC8vIHRoZW4gcmVwbGFjZSB0aGUgYnlwYXNzIHByb3BlcnR5IHdpdGggdGhlIG9yaWdpbmFsXG5cbiAgICAgIC8vIGJlY2F1c2UgdGhlIGJ5cGFzc2VkIHByb3BlcnR5IHdhcyBhbHJlYWR5IGFwcGxpZWQgKGFuZCB0aGVyZWZvcmUgcGFyc2VkKSwgd2UgY2FuIGp1c3QgcmVwbGFjZSBpdCAobm8gcmVhcHBseWluZyBuZWNlc3NhcnkpXG4gICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBjdXJyZW50UHJvcC5ieXBhc3NlZDtcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NcbiAgICB9XG4gIH1cblxuICB2YXIgcHJpbnRNYXBwaW5nRXJyID0gZnVuY3Rpb24oKXtcbiAgICB1dGlsLmVycm9yKCdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChlLmcuIGVsZSBgJysgZWxlLmlkKCkgKydgIGZvciBwcm9wZXJ0eSBgJysgcHJvcC5uYW1lICsnYCB3aXRoIGRhdGEgZmllbGQgYCcrIHByb3AuZmllbGQgKydgKTsgdHJ5IGEgYFsnKyBwcm9wLmZpZWxkICsnXWAgc2VsZWN0b3IgdG8gbGltaXQgc2NvcGUgdG8gZWxlbWVudHMgd2l0aCBgJysgcHJvcC5maWVsZCArJ2AgZGVmaW5lZCcpO1xuICB9O1xuXG4gIC8vIHB1dCB0aGUgcHJvcGVydHkgaW4gdGhlIHN0eWxlIG9iamVjdHNcbiAgc3dpdGNoKCBwcm9wLm1hcHBlZCApeyAvLyBmbGF0dGVuIHRoZSBwcm9wZXJ0eSBpZiBtYXBwZWRcbiAgY2FzZSB0eXBlcy5tYXBEYXRhOlxuICBjYXNlIHR5cGVzLm1hcExheW91dERhdGE6XG4gIGNhc2UgdHlwZXMubWFwU2NyYXRjaDpcblxuICAgIHZhciBpc0xheW91dCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5tYXBMYXlvdXREYXRhO1xuICAgIHZhciBpc1NjcmF0Y2ggPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubWFwU2NyYXRjaDtcblxuICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdChcIi5cIik7XG4gICAgdmFyIGZpZWxkVmFsO1xuXG4gICAgaWYoIGlzU2NyYXRjaCB8fCBpc0xheW91dCApe1xuICAgICAgZmllbGRWYWwgPSBfcC5zY3JhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZFZhbCA9IF9wLmRhdGE7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoICYmIGZpZWxkVmFsOyBpKysgKXtcbiAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbIGZpZWxkIF07XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQ7XG4gICAgaWYoICFpcy5udW1iZXIoZmllbGRWYWwpICl7IC8vIHRoZW4ga2VlcCB0aGUgbWFwcGluZyBidXQgYXNzdW1lIDAlIGZvciBub3dcbiAgICAgIHBlcmNlbnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJjZW50ID0gKGZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyAocHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW4pO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0byBib3VuZCBwZXJjZW50IHZhbHVlXG4gICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICBwZXJjZW50ID0gMDtcbiAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICBwZXJjZW50ID0gMTtcbiAgICB9XG5cbiAgICBpZiggdHlwZS5jb2xvciApe1xuICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgIHZhciByMiA9IHByb3AudmFsdWVNYXhbMF07XG4gICAgICB2YXIgZzEgPSBwcm9wLnZhbHVlTWluWzFdO1xuICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgIHZhciBiMSA9IHByb3AudmFsdWVNaW5bMl07XG4gICAgICB2YXIgYjIgPSBwcm9wLnZhbHVlTWF4WzJdO1xuICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICB2YXIgYTIgPSBwcm9wLnZhbHVlTWF4WzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1heFszXTtcblxuICAgICAgdmFyIGNsciA9IFtcbiAgICAgICAgTWF0aC5yb3VuZCggcjEgKyAocjIgLSByMSkqcGVyY2VudCApLFxuICAgICAgICBNYXRoLnJvdW5kKCBnMSArIChnMiAtIGcxKSpwZXJjZW50ICksXG4gICAgICAgIE1hdGgucm91bmQoIGIxICsgKGIyIC0gYjEpKnBlcmNlbnQgKSxcbiAgICAgICAgTWF0aC5yb3VuZCggYTEgKyAoYTIgLSBhMSkqcGVyY2VudCApXG4gICAgICBdO1xuXG4gICAgICBmbGF0UHJvcCA9IHsgLy8gY29sb3VycyBhcmUgc2ltcGxlLCBzbyBqdXN0IGNyZWF0ZSB0aGUgZmxhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGV4cGVuc2l2ZSBzdHJpbmcgcGFyc2luZ1xuICAgICAgICBieXBhc3M6IHByb3AuYnlwYXNzLCAvLyB3ZSdyZSBhIGJ5cGFzcyBpZiB0aGUgbWFwcGluZyBwcm9wZXJ0eSBpcyBhIGJ5cGFzc1xuICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgIHZhbHVlOiBjbHIsXG4gICAgICAgIHN0clZhbHVlOiAncmdiKCcgKyBjbHJbMF0gKyAnLCAnICsgY2xyWzFdICsgJywgJyArIGNsclsyXSArICcpJ1xuICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5udW1iZXIgKXtcbiAgICAgIHZhciBjYWxjVmFsdWUgPSBwcm9wLnZhbHVlTWluICsgKHByb3AudmFsdWVNYXggLSBwcm9wLnZhbHVlTWluKSAqIHBlcmNlbnQ7XG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuIG9ubHkgbWFwIHRvIGNvbG91cnMgYW5kIG51bWJlcnNcbiAgICB9XG5cbiAgICBpZiggIWZsYXRQcm9wICl7IC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIHVzZSB0aGUgb3JpZ1Byb3Agc28gd2Ugc3RpbGwga2VlcCB0aGUgbWFwcGluZyBpdHNlbGZcbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBvcmlnUHJvcC5zdHJWYWx1ZSwgcHJvcC5ieXBhc3MsIHRydWUgKTtcbiAgICB9XG5cbiAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICBicmVhaztcblxuICAvLyBkaXJlY3QgbWFwcGluZ1xuICBjYXNlIHR5cGVzLmRhdGE6XG4gIGNhc2UgdHlwZXMubGF5b3V0RGF0YTpcbiAgY2FzZSB0eXBlcy5zY3JhdGNoOlxuICAgIHZhciBpc0xheW91dCA9IHByb3AubWFwcGVkID09PSB0eXBlcy5sYXlvdXREYXRhO1xuICAgIHZhciBpc1NjcmF0Y2ggPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMuc2NyYXRjaDtcblxuICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdChcIi5cIik7XG4gICAgdmFyIGZpZWxkVmFsO1xuXG4gICAgaWYoIGlzU2NyYXRjaCB8fCBpc0xheW91dCApe1xuICAgICAgZmllbGRWYWwgPSBfcC5zY3JhdGNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWVsZFZhbCA9IF9wLmRhdGE7XG4gICAgfVxuXG4gICAgaWYoIGZpZWxkVmFsICl7IGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgIH0gfVxuXG4gICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGZpZWxkVmFsLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuXG4gICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICB2YXIgZmxhdFByb3BWYWwgPSBvcmlnUHJvcCA/IG9yaWdQcm9wLnN0clZhbHVlIDogJyc7XG5cbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmbGF0UHJvcFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcbiAgICB9XG5cbiAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICBicmVhaztcblxuICBjYXNlIHR5cGVzLmZuOlxuICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgdmFyIGZuUmV0VmFsID0gZm4oIGVsZSApO1xuXG4gICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGZuUmV0VmFsLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgYnJlYWs7XG5cbiAgY2FzZSB1bmRlZmluZWQ6XG4gICAgYnJlYWs7IC8vIGp1c3Qgc2V0IHRoZSBwcm9wZXJ0eVxuXG4gIGRlZmF1bHQ6XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBub3QgYSB2YWxpZCBtYXBwaW5nXG4gIH1cblxuICAvLyBpZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHksIHRoZW4gbGluayB0aGUgcmVzdWx0YW50IHByb3BlcnR5IHRvIHRoZSBvcmlnaW5hbCBvbmVcbiAgaWYoIHByb3BJc0J5cGFzcyApe1xuICAgIGlmKCBvcmlnUHJvcElzQnlwYXNzICl7IC8vIHRoZW4gdGhpcyBieXBhc3Mgb3ZlcnJpZGVzIHRoZSBleGlzdGluZyBvbmVcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcC5ieXBhc3NlZDsgLy8gc3RlYWwgYnlwYXNzZWQgcHJvcCBmcm9tIG9sZCBieXBhc3NcbiAgICB9IGVsc2UgeyAvLyB0aGVuIGxpbmsgdGhlIG9yaWcgcHJvcCB0byB0aGUgbmV3IGJ5cGFzc1xuICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wO1xuICAgIH1cblxuICAgIHN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3A7IC8vIGFuZCBzZXRcblxuICB9IGVsc2UgeyAvLyBwcm9wIGlzIG5vdCBieXBhc3NcbiAgICBpZiggb3JpZ1Byb3BJc0J5cGFzcyApeyAvLyB0aGVuIGtlZXAgdGhlIG9yaWcgcHJvcCAoc2luY2UgaXQncyBhIGJ5cGFzcykgYW5kIGxpbmsgdG8gdGhlIG5ldyBwcm9wXG4gICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHByb3A7XG4gICAgfSBlbHNlIHsgLy8gdGhlbiBqdXN0IHJlcGxhY2UgdGhlIG9sZCBwcm9wIHdpdGggdGhlIG5ldyBvbmVcbiAgICAgIHN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyB1cGRhdGVzIHRoZSB2aXN1YWwgc3R5bGUgZm9yIGFsbCBlbGVtZW50cyAodXNlZnVsIGZvciBtYW51YWwgc3R5bGUgbW9kaWZpY2F0aW9uIGFmdGVyIGluaXQpXG5zdHlmbi51cGRhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG5cbiAgZWxlcy51cGRhdGVTdHlsZSgpO1xufTtcblxuLy8ganVzdCB1cGRhdGUgdGhlIGZ1bmN0aW9uYWwgcHJvcGVydGllcyAoaS5lLiBtYXBwaW5ncykgaW4gdGhlIGVsZW1lbnRzJ1xuLy8gc3R5bGVzIChsZXNzIGV4cGVuc2l2ZSB0aGFuIHJlY2FsY3VsYXRpb24pXG5zdHlmbi51cGRhdGVNYXBwZXJzID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgZWFjaCBlbGVcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGorKyApeyAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tqXTtcbiAgICAgIHZhciBwcm9wSW5TdHlsZSA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgaWYoIHByb3BJblN0eWxlICYmIHByb3BJblN0eWxlLm1hcHBpbmcgKXtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBwcm9wSW5TdHlsZS5tYXBwaW5nO1xuICAgICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgbWFwcGluZyApOyAvLyByZWFwcGx5IHRoZSBtYXBwaW5nIHByb3BlcnR5XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcbiAgfVxufTtcblxuLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cbnN0eWZuLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gIHZhciBwcm9wcyA9IHN0eWxlWyd0cmFuc2l0aW9uLXByb3BlcnR5J10udmFsdWU7XG4gIHZhciBkdXJhdGlvbiA9IHN0eWxlWyd0cmFuc2l0aW9uLWR1cmF0aW9uJ10ucGZWYWx1ZTtcbiAgdmFyIGRlbGF5ID0gc3R5bGVbJ3RyYW5zaXRpb24tZGVsYXknXS5wZlZhbHVlO1xuICB2YXIgY3NzID0ge307XG5cbiAgaWYoIHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwICl7XG5cbiAgICAvLyBidWlsZCB1cCB0aGUgc3R5bGUgdG8gYW5pbWF0ZSB0b3dhcmRzXG4gICAgdmFyIGFueVByZXYgPSBmYWxzZTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgdmFyIHN0eVByb3AgPSBzdHlsZVsgcHJvcCBdO1xuICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wIF07XG5cbiAgICAgIGlmKCAhZGlmZlByb3AgKXsgY29udGludWU7IH1cblxuICAgICAgdmFyIHByZXZQcm9wID0gZGlmZlByb3AucHJldjtcbiAgICAgIHZhciBmcm9tUHJvcCA9IHByZXZQcm9wO1xuICAgICAgdmFyIHRvUHJvcCA9IGRpZmZQcm9wLm5leHQgIT0gbnVsbCA/IGRpZmZQcm9wLm5leHQgOiBzdHlQcm9wO1xuICAgICAgdmFyIGRpZmYgPSBmYWxzZTtcbiAgICAgIHZhciBpbml0VmFsO1xuICAgICAgdmFyIGluaXREdCA9IDAuMDAwMDAxOyAvLyBkZWx0YSB0aW1lICUgdmFsdWUgZm9yIGluaXRWYWwgKGFsbG93cyBhbmltYXRpbmcgb3V0IG9mIGluaXQgemVybyBvcGFjaXR5KVxuXG4gICAgICBpZiggIWZyb21Qcm9wICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIC8vIGNvbnNpZGVyIHB4IHZhbHVlc1xuICAgICAgaWYoIGlzLm51bWJlciggZnJvbVByb3AucGZWYWx1ZSApICYmIGlzLm51bWJlciggdG9Qcm9wLnBmVmFsdWUgKSApe1xuICAgICAgICBkaWZmID0gdG9Qcm9wLnBmVmFsdWUgLSBmcm9tUHJvcC5wZlZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3AucGZWYWx1ZSArIGluaXREdCAqIGRpZmY7XG5cbiAgICAgIC8vIGNvbnNpZGVyIG51bWVyaWNhbCB2YWx1ZXNcbiAgICAgIH0gZWxzZSBpZiggaXMubnVtYmVyKCBmcm9tUHJvcC52YWx1ZSApICYmIGlzLm51bWJlciggdG9Qcm9wLnZhbHVlICkgKXtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC52YWx1ZSAtIGZyb21Qcm9wLnZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3AudmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAvLyBjb25zaWRlciBjb2xvdXIgdmFsdWVzXG4gICAgICB9IGVsc2UgaWYoIGlzLmFycmF5KCBmcm9tUHJvcC52YWx1ZSApICYmIGlzLmFycmF5KCB0b1Byb3AudmFsdWUgKSApe1xuICAgICAgICBkaWZmID0gZnJvbVByb3AudmFsdWVbMF0gIT09IHRvUHJvcC52YWx1ZVswXVxuICAgICAgICAgIHx8IGZyb21Qcm9wLnZhbHVlWzFdICE9PSB0b1Byb3AudmFsdWVbMV1cbiAgICAgICAgICB8fCBmcm9tUHJvcC52YWx1ZVsyXSAhPT0gdG9Qcm9wLnZhbHVlWzJdXG4gICAgICAgIDtcblxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3Auc3RyVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBnb29kIGZvciBhbiBhbmltYXRpb24gb25seSBpZiBpdCdzIGRpZmZlcmVudFxuICAgICAgaWYoIGRpZmYgKXtcbiAgICAgICAgY3NzWyBwcm9wIF0gPSB0b1Byb3Auc3RyVmFsdWU7IC8vIHRvIHZhbFxuICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKCBlbGUsIHByb3AsIGluaXRWYWwgKTsgLy8gZnJvbSB2YWxcbiAgICAgICAgYW55UHJldiA9IHRydWU7XG4gICAgICB9XG5cbiAgICB9IC8vIGVuZCBpZiBwcm9wcyBhbGxvdyBhbmlcblxuICAgIC8vIGNhbid0IHRyYW5zaXRpb24gaWYgdGhlcmUncyBub3RoaW5nIHByZXZpb3VzIHRvIHRyYW5zaXRpb24gZnJvbVxuICAgIGlmKCAhYW55UHJldiApeyByZXR1cm47IH1cblxuICAgIF9wLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG4gICAgZWxlLnN0b3AoKTtcblxuICAgIGlmKCBkZWxheSA+IDAgKXtcbiAgICAgIGVsZS5kZWxheSggZGVsYXkgKTtcbiAgICB9XG5cbiAgICBlbGUuYW5pbWF0ZSh7XG4gICAgICBjc3M6IGNzc1xuICAgIH0sIHtcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgIGVhc2luZzogc3R5bGVbJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJ10udmFsdWUsXG4gICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFpc0J5cGFzcyApe1xuICAgICAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9IGVsc2UgaWYoIF9wLnRyYW5zaXRpb25pbmcgKXtcbiAgICBlbGUuc3RvcCgpO1xuXG4gICAgdGhpcy5yZW1vdmVCeXBhc3NlcyggZWxlLCBwcm9wcyApO1xuXG4gICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbi8vIHJldHVybnMgdHJ1ZSBpZmYgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwgZm9yIGF0IGxlYXN0IDEgc3BlY2lmaWVkIHByb3BlcnR5XG5zdHlmbi5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcHMgPSBbXTtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG4gIGlmKCBuYW1lID09PSBcIipcIiB8fCBuYW1lID09PSBcIioqXCIgKXsgLy8gYXBwbHkgdG8gYWxsIHByb3BlcnR5IG5hbWVzXG5cbiAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIGlmKCBpcy5zdHJpbmcobmFtZSkgKXsgLy8gdGhlbiBwYXJzZSB0aGUgc2luZ2xlIHByb3BlcnR5XG4gICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcblxuICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgfVxuICB9IGVsc2UgaWYoIGlzLnBsYWluT2JqZWN0KG5hbWUpICl7IC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgIHZhciBzcGVjaWZpZWRQcm9wcyA9IG5hbWU7XG4gICAgdXBkYXRlVHJhbnNpdGlvbnMgPSB2YWx1ZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgdmFyIHZhbHVlID0gc3BlY2lmaWVkUHJvcHNbIG5hbWUgXTtcblxuICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdHJ5IGNhbWVsIGNhc2UgbmFtZSB0b29cbiAgICAgICAgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgdXRpbC5kYXNoMmNhbWVsKG5hbWUpIF07XG4gICAgICB9XG5cbiAgICAgIGlmKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7IC8vIGNhbid0IGRvIGFueXRoaW5nIHdpdGhvdXQgd2VsbCBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSd2ZSBmYWlsZWQgaWYgdGhlcmUgYXJlIG5vIHZhbGlkIHByb3BlcnRpZXNcbiAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcbiAgdmFyIHJldCA9IGZhbHNlOyAvLyByZXR1cm4gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgc3VjY2VzZnVsIGJ5cGFzcyBhcHBsaWVkXG4gIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgZWFjaCBlbGVcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgIHZhciBkaWZmUHJvcDtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2ggcHJvcFxuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AubmFtZSBdID0geyBwcmV2OiBwcmV2UHJvcCB9O1xuICAgICAgfVxuXG4gICAgICByZXQgPSB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgcHJvcCApIHx8IHJldDtcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICB9XG5cbiAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgaWYoIHJldCApe1xuICAgICAgdGhpcy51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcbiAgICB9XG5cbiAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuc3R5Zm4ub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiggZWxlcywgbmFtZSwgdmFsdWUgKXtcbiAgbmFtZSA9IHV0aWwuY2FtZWwyZGFzaChuYW1lKTtcblxuICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgbmFtZSBdO1xuICAgIHZhciB0eXBlID0gdGhpcy5wcm9wZXJ0aWVzWyBuYW1lIF0udHlwZTtcbiAgICB2YXIgaXNDb2xvciA9IHR5cGUuY29sb3I7XG4gICAgdmFyIGlzTXVsdGkgPSB0eXBlLm11dGlwbGU7XG5cbiAgICBpZiggIXByb3AuYnlwYXNzICl7IC8vIG5lZWQgYSBieXBhc3MgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgIHRoaXMuYXBwbHlCeXBhc3MoIGVsZSwgbmFtZSwgdmFsdWUgKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHByb3AudmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmKCBwcm9wLnBmVmFsdWUgIT0gbnVsbCApe1xuICAgICAgcHJvcC5wZlZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYoIGlzQ29sb3IgKXtcbiAgICAgIHByb3Auc3RyVmFsdWUgPSAncmdiKCcgKyB2YWx1ZS5qb2luKCcsJykgKyAnKSc7XG4gICAgfSBlbHNlIGlmKCBpc011bHRpICl7XG4gICAgICBwcm9wLnN0clZhbHVlID0gdmFsdWUuam9pbignICcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnN0clZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbnN0eWZuLnJlbW92ZUFsbEJ5cGFzc2VzID0gZnVuY3Rpb24oIGVsZXMsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gIHJldHVybiB0aGlzLnJlbW92ZUJ5cGFzc2VzKCBlbGVzLCB0aGlzLnByb3BlcnR5TmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG59O1xuXG5zdHlmbi5yZW1vdmVCeXBhc3NlcyA9IGZ1bmN0aW9uKCBlbGVzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICBmb3IoIHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKysgKXtcbiAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXTtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzWyBuYW1lIF07XG4gICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcC5uYW1lIF0gPSB7IHByZXY6IHByZXZQcm9wIH07XG5cbiAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuXG4gICAgICBkaWZmUHJvcC5uZXh0ID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuXG4gICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKTtcbiAgICB9XG4gIH0gLy8gZm9yIGVsZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCcuLi93aW5kb3cnKTtcblxudmFyIHN0eWZuID0ge307XG5cbi8vIGdldHMgd2hhdCBhbiBlbSBzaXplIGNvcnJlc3BvbmRzIHRvIGluIHBpeGVscyByZWxhdGl2ZSB0byBhIGRvbSBlbGVtZW50XG5zdHlmbi5nZXRFbVNpemVJblBpeGVscyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBweCA9IHRoaXMuY29udGFpbmVyQ3NzKCdmb250LXNpemUnKTtcblxuICBpZiggcHggIT0gbnVsbCApe1xuICAgIHJldHVybiBwYXJzZUZsb2F0KCBweCApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxOyAvLyBmb3IgaGVhZGxlc3NcbiAgfVxufTtcblxuLy8gZ2V0cyBjc3MgcHJvcGVydHkgZnJvbSB0aGUgY29yZSBjb250YWluZXJcbnN0eWZuLmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZG9tRWxlbWVudCA9IGN5LmNvbnRhaW5lcigpO1xuXG4gIGlmKCB3aW5kb3cgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApe1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCBwcm9wTmFtZSApO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0eWZuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4uL2lzJyk7XG5cbnZhciBzdHlmbiA9IHt9O1xuXG4vLyBnZXRzIHRoZSByZW5kZXJlZCBzdHlsZSBmb3IgYW4gZWxlbWVudFxuc3R5Zm4uZ2V0UmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgcmV0dXJuIHRoaXMuZ2V0UmF3U3R5bGUoIGVsZSwgdHJ1ZSApO1xufTtcblxuLy8gZ2V0cyB0aGUgcmF3IHN0eWxlIGZvciBhbiBlbGVtZW50XG5zdHlmbi5nZXRSYXdTdHlsZSA9IGZ1bmN0aW9uKCBlbGUsIGlzUmVuZGVyZWRWYWwgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYoIGVsZSApe1xuICAgIHZhciByc3R5bGUgPSB7fTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1tpXTtcbiAgICAgIHZhciB2YWwgPSBzZWxmLmdldFN0eWxlUHJvcGVydHlWYWx1ZSggZWxlLCBwcm9wLm5hbWUsIGlzUmVuZGVyZWRWYWwgKTtcblxuICAgICAgaWYoIHZhbCApe1xuICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gdmFsO1xuICAgICAgICByc3R5bGVbIHV0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpIF0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdHlsZTtcbiAgfVxufTtcblxuc3R5Zm4uZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24oIGVsZSwgcHJvcE5hbWUsIGlzUmVuZGVyZWRWYWwgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgaWYoIGVsZSApe1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1sgcHJvcE5hbWUgXTtcbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgIHZhciB6b29tID0gZWxlLmN5KCkuem9vbSgpO1xuXG4gICAgaWYoIHN0eWxlUHJvcCApe1xuICAgICAgdmFyIHVuaXRzID0gc3R5bGVQcm9wLnVuaXRzID8gdHlwZS5pbXBsaWNpdFVuaXRzIHx8ICdweCcgOiBudWxsO1xuICAgICAgdmFyIHZhbCA9IHVuaXRzID8gW10uY29uY2F0KCBzdHlsZVByb3AucGZWYWx1ZSApLm1hcChmdW5jdGlvbiggcGZWYWx1ZSApe1xuICAgICAgICByZXR1cm4gKCBwZlZhbHVlICogKGlzUmVuZGVyZWRWYWwgPyB6b29tIDogMSkgKSArIHVuaXRzO1xuICAgICAgfSkuam9pbignICcpIDogc3R5bGVQcm9wLnN0clZhbHVlO1xuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxufTtcblxuLy8gZ2V0cyB0aGUgdmFsdWUgc3R5bGUgZm9yIGFuIGVsZW1lbnQgKHVzZWZ1bCBmb3IgdGhpbmdzIGxpa2UgYW5pbWF0aW9ucylcbnN0eWZuLmdldFZhbHVlU3R5bGUgPSBmdW5jdGlvbiggZWxlICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJzdHlsZSA9IHt9O1xuICB2YXIgc3R5bGU7XG4gIHZhciBpc0VsZSA9IGlzLmVsZW1lbnQoZWxlKTtcblxuICBpZiggaXNFbGUgKXtcbiAgICBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGVsZTsgLy8ganVzdCBwYXNzZWQgdGhlIHN0eWxlIGl0c2VsZlxuICB9XG5cbiAgaWYoIHN0eWxlICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXSB8fCBzdHlsZVsgdXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcblxuICAgICAgaWYoIHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBzdHlsZVByb3AgKSApe1xuICAgICAgICAgIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgc3R5bGVQcm9wLnN0clZhbHVlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBzdHlsZVByb3AgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgIHJzdHlsZVsgcHJvcC5uYW1lIF0gPSBzdHlsZVByb3A7XG4gICAgICAgIHJzdHlsZVsgdXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHN0eWxlUHJvcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0eWxlO1xufTtcblxuc3R5Zm4uZ2V0UHJvcHNMaXN0ID0gZnVuY3Rpb24oIHByb3BzT2JqICl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJzdHlsZSA9IFtdO1xuICB2YXIgc3R5bGUgPSBwcm9wc09iajtcbiAgdmFyIHByb3BzID0gc2VsZi5wcm9wZXJ0aWVzO1xuXG4gIGlmKCBzdHlsZSApe1xuICAgIGZvciggdmFyIG5hbWUgaW4gc3R5bGUgKXtcbiAgICAgIHZhciB2YWwgPSBzdHlsZVtuYW1lXTtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbbmFtZV0gfHwgcHJvcHNbIHV0aWwuY2FtZWwyZGFzaChuYW1lKSBdO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgdmFsICk7XG5cbiAgICAgIHJzdHlsZS5wdXNoKCBzdHlsZVByb3AgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnN0eWxlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSgnLi4vc2VsZWN0b3InKTtcblxudmFyIFN0eWxlID0gZnVuY3Rpb24oIGN5ICl7XG5cbiAgaWYoICEodGhpcyBpbnN0YW5jZW9mIFN0eWxlKSApe1xuICAgIHJldHVybiBuZXcgU3R5bGUoY3kpO1xuICB9XG5cbiAgaWYoICFpcy5jb3JlKGN5KSApe1xuICAgIHV0aWwuZXJyb3IoJ0Egc3R5bGUgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9wcml2YXRlID0ge1xuICAgIGN5OiBjeSxcbiAgICBjb3JlU3R5bGU6IHt9LFxuICAgIG5ld1N0eWxlOiB0cnVlXG4gIH07XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcbn07XG5cbnZhciBzdHlmbiA9IFN0eWxlLnByb3RvdHlwZTtcblxuc3R5Zm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ3N0eWxlJztcbn07XG5cbi8vIHJlbW92ZSBhbGwgY29udGV4dHNcbnN0eWZuLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMuX3ByaXZhdGUubmV3U3R5bGUgPSB0cnVlO1xuXG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuc3R5Zm4ucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNsZWFyKCk7XG4gIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGJ1aWxkcyBhIHN0eWxlIG9iamVjdCBmb3IgdGhlICdjb3JlJyBzZWxlY3Rvclxuc3R5Zm4uY29yZSA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZTtcbn07XG5cbi8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcbnN0eWZuLnNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbGVjdG9yU3RyICl7XG4gIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3IFNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuXG4gIHZhciBpID0gdGhpcy5sZW5ndGgrKzsgLy8gbmV3IGNvbnRleHQgbWVhbnMgbmV3IGluZGV4XG4gIHRoaXNbaV0gPSB7XG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFtdLFxuICAgIG1hcHBlZFByb3BlcnRpZXM6IFtdLFxuICAgIGluZGV4OiBpXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBhZGQgb25lIG9yIG1hbnkgY3NzIHJ1bGVzIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzcyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICBjYXNlIDE6XG4gICAgdmFyIG1hcCA9IGFyZ3NbMF07XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgaWYoIG1hcFZhbCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIG1hcFZhbCA9IG1hcFsgdXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcbiAgICAgIH1cblxuICAgICAgaWYoIG1hcFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuY3NzUnVsZSggcHJvcC5uYW1lLCBtYXBWYWwgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBicmVhaztcblxuICBjYXNlIDI6XG4gICAgdGhpcy5jc3NSdWxlKCBhcmdzWzBdLCBhcmdzWzFdICk7XG4gICAgYnJlYWs7XG5cbiAgZGVmYXVsdDpcbiAgICBicmVhazsgLy8gZG8gbm90aGluZyBpZiBhcmdzIGFyZSBpbnZhbGlkXG4gIH1cblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5zdHlmbi5zdHlsZSA9IHN0eWZuLmNzcztcblxuLy8gYWRkIGEgc2luZ2xlIGNzcyBydWxlIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzc1J1bGUgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UoIG5hbWUsIHZhbHVlICk7XG5cbiAgLy8gYWRkIHByb3BlcnR5IHRvIGN1cnJlbnQgY29udGV4dCBpZiB2YWxpZFxuICBpZiggcHJvcGVydHkgKXtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCggcHJvcGVydHkgKTtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXNbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICBpZiggcHJvcGVydHkubmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiBwcm9wZXJ0eS52YWx1ZSApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmKCBwcm9wZXJ0eS5tYXBwZWQgKXtcbiAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKCBwcm9wZXJ0eSApO1xuICAgIH1cblxuICAgIC8vIGFkZCB0byBjb3JlIHN0eWxlIGlmIG5lY2Vzc2FyeVxuICAgIHZhciBjdXJyZW50U2VsZWN0b3JJc0NvcmUgPSAhdGhpc1tpXS5zZWxlY3RvcjtcbiAgICBpZiggY3VycmVudFNlbGVjdG9ySXNDb3JlICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVsgcHJvcGVydHkubmFtZSBdID0gcHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBzdGF0aWMgZnVuY3Rpb25cblN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24oIGN5LCBqc29uICl7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZSggY3kgKTtcblxuICBzdHlsZS5mcm9tSnNvbigganNvbiApO1xuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cblN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiggY3ksIHN0cmluZyApe1xuICByZXR1cm4gbmV3IFN0eWxlKCBjeSApLmZyb21TdHJpbmcoIHN0cmluZyApO1xufTtcblxuW1xuICByZXF1aXJlKCcuL2FwcGx5JyksXG4gIHJlcXVpcmUoJy4vYnlwYXNzJyksXG4gIHJlcXVpcmUoJy4vY29udGFpbmVyJyksXG4gIHJlcXVpcmUoJy4vZ2V0LWZvci1lbGUnKSxcbiAgcmVxdWlyZSgnLi9qc29uJyksXG4gIHJlcXVpcmUoJy4vc3RyaW5nLXNoZWV0JyksXG4gIHJlcXVpcmUoJy4vcHJvcGVydGllcycpLFxuICByZXF1aXJlKCcuL3BhcnNlJylcbl0uZm9yRWFjaChmdW5jdGlvbiggcHJvcHMgKXtcbiAgdXRpbC5leHRlbmQoIHN0eWZuLCBwcm9wcyApO1xufSk7XG5cblxuU3R5bGUudHlwZXMgPSBzdHlmbi50eXBlcztcblN0eWxlLnByb3BlcnRpZXMgPSBzdHlmbi5wcm9wZXJ0aWVzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuc3R5Zm4uYXBwbHlGcm9tSnNvbiA9IGZ1bmN0aW9uKCBqc29uICl7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29uLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbnRleHQgPSBqc29uW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5zdHlsZSB8fCBjb250ZXh0LmNzcztcblxuICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvciApOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yKCB2YXIgbmFtZSBpbiBwcm9wcyApe1xuICAgICAgdmFyIHZhbHVlID0gcHJvcHNbbmFtZV07XG5cbiAgICAgIHN0eWxlLmNzcyggbmFtZSwgdmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBhY2Nlc3NpYmxlIGN5LnN0eWxlKCkgZnVuY3Rpb25cbnN0eWZuLmZyb21Kc29uID0gZnVuY3Rpb24oIGpzb24gKXtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBseUZyb21Kc29uKCBqc29uICk7XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuc3R5Zm4uanNvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBqc29uID0gW107XG5cbiAgZm9yKCB2YXIgaSA9IHRoaXMuZGVmYXVsdExlbmd0aDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgY3h0ID0gdGhpc1tpXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjeHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY3h0LnByb3BlcnRpZXM7XG4gICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgIGNzc1sgcHJvcC5uYW1lIF0gPSBwcm9wLnN0clZhbHVlO1xuICAgIH1cblxuICAgIGpzb24ucHVzaCh7XG4gICAgICBzZWxlY3RvcjogIXNlbGVjdG9yID8gJ2NvcmUnIDogc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgIHN0eWxlOiBjc3NcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBqc29uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHlmbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuLy8gYSBjYWNoaW5nIGxheWVyIGZvciBwcm9wZXJ0eSBwYXJzaW5nXG5zdHlmbi5wYXJzZSA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0ICl7XG4gIHZhciBhcmdIYXNoID0gWyBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0IF0uam9pbignJCcpO1xuICB2YXIgcHJvcENhY2hlID0gdGhpcy5wcm9wQ2FjaGUgPSB0aGlzLnByb3BDYWNoZSB8fCB7fTtcbiAgdmFyIHJldDtcbiAgdmFyIGltcGwgPSBwYXJzZUltcGwuYmluZCggdGhpcyApO1xuXG4gIGlmKCAhKHJldCA9IHByb3BDYWNoZVthcmdIYXNoXSkgKXtcbiAgICByZXQgPSBwcm9wQ2FjaGVbYXJnSGFzaF0gPSBpbXBsKCBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0ICk7XG4gIH1cblxuICAvLyBhbHdheXMgbmVlZCBhIGNvcHkgc2luY2UgcHJvcHMgYXJlIG11dGF0ZWQgbGF0ZXIgaW4gdGhlaXIgbGlmZWN5Y2xlc1xuICByZXQgPSB1dGlsLmNvcHkoIHJldCApO1xuXG4gIGlmKCByZXQgKXtcbiAgICByZXQudmFsdWUgPSB1dGlsLmNvcHkoIHJldC52YWx1ZSApOyAvLyBiZWNhdXNlIGl0IGNvdWxkIGJlIGFuIGFycmF5LCBlLmcuIGNvbG91clxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4vLyBmaWVsZHMgOlxuLy8gLSBuYW1lIDogdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4vLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4vLyAtIGJ5cGFzcyA6IHRydWUgaWZmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eVxudmFyIHBhcnNlSW1wbCA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSwgcHJvcElzQnlwYXNzLCBwcm9wSXNGbGF0ICl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBuYW1lID0gdXRpbC5jYW1lbDJkYXNoKCBuYW1lICk7IC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydHkgbmFtZSBpcyBpbiBkYXNoIGZvcm0gKGUuZy4gJ3Byb3BlcnR5LW5hbWUnIG5vdCAncHJvcGVydHlOYW1lJylcblxuICB2YXIgcHJvcGVydHkgPSBzZWxmLnByb3BlcnRpZXNbIG5hbWUgXTtcbiAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG5cbiAgaWYoICFwcm9wZXJ0eSApeyByZXR1cm4gbnVsbDsgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcbiAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgKXsgcmV0dXJuIG51bGw7IH0gLy8gY2FuJ3QgYXNzaWduIG51bGxcblxuICAvLyB0aGUgcHJvcGVydHkgbWF5IGJlIGFuIGFsaWFzXG4gIGlmKCBwcm9wZXJ0eS5hbGlhcyApe1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucG9pbnRzVG87XG4gICAgbmFtZSA9IHByb3BlcnR5Lm5hbWU7XG4gIH1cblxuICB2YXIgdmFsdWVJc1N0cmluZyA9IGlzLnN0cmluZyh2YWx1ZSk7XG4gIGlmKCB2YWx1ZUlzU3RyaW5nICl7IC8vIHRyaW0gdGhlIHZhbHVlIHRvIG1ha2UgcGFyc2luZyBlYXNpZXJcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gcHJvcGVydHkudHlwZTtcbiAgaWYoICF0eXBlICl7IHJldHVybiBudWxsOyB9IC8vIG5vIHR5cGUsIG5vIGx1Y2tcblxuICAvLyBjaGVjayBpZiBieXBhc3MgaXMgbnVsbCBvciBlbXB0eSBzdHJpbmcgKGkuZS4gaW5kaWNhdGlvbiB0byBkZWxldGUgYnlwYXNzIHByb3BlcnR5KVxuICBpZiggcHJvcElzQnlwYXNzICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwpICl7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBieXBhc3M6IHRydWUsXG4gICAgICBkZWxldGVCeXBhc3M6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgYSBmdW5jdGlvbiB1c2VkIGFzIGEgbWFwcGVyXG4gIGlmKCBpcy5mbih2YWx1ZSkgKXtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuICB2YXIgZGF0YSwgbWFwRGF0YSwgbGF5b3V0RGF0YSwgbWFwTGF5b3V0RGF0YSwgc2NyYXRjaCwgbWFwU2NyYXRjaDtcbiAgaWYoICF2YWx1ZUlzU3RyaW5nIHx8IHByb3BJc0ZsYXQgKXtcbiAgICAvLyB0aGVuIGRvbid0IGJvdGhlciB0byBkbyB0aGUgZXhwZW5zaXZlIHJlZ2V4IGNoZWNrc1xuXG4gIH0gZWxzZSBpZihcbiAgICAoIGRhdGEgPSBuZXcgUmVnRXhwKCB0eXBlcy5kYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApIHx8XG4gICAgKCBsYXlvdXREYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubGF5b3V0RGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICggc2NyYXRjaCA9IG5ldyBSZWdFeHAoIHR5cGVzLnNjcmF0Y2gucmVnZXggKS5leGVjKCB2YWx1ZSApIClcbiAgKXtcbiAgICBpZiggcHJvcElzQnlwYXNzICl7IHJldHVybiBmYWxzZTsgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuXG4gICAgdmFyIG1hcHBlZDtcbiAgICBpZiggZGF0YSApe1xuICAgICAgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICB9IGVsc2UgaWYoIGxheW91dERhdGEgKXtcbiAgICAgIG1hcHBlZCA9IHR5cGVzLmxheW91dERhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcHBlZCA9IHR5cGVzLnNjcmF0Y2g7XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEgfHwgbGF5b3V0RGF0YSB8fCBzY3JhdGNoO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBtYXBwZWQsXG4gICAgICBmaWVsZDogZGF0YVsxXSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICB9IGVsc2UgaWYoXG4gICAgKCBtYXBEYXRhID0gbmV3IFJlZ0V4cCggdHlwZXMubWFwRGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICggbWFwTGF5b3V0RGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLm1hcExheW91dERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAoIG1hcFNjcmF0Y2ggPSBuZXcgUmVnRXhwKCB0eXBlcy5tYXBTY3JhdGNoLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApXG4gICl7XG4gICAgaWYoIHByb3BJc0J5cGFzcyApeyByZXR1cm4gZmFsc2U7IH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcbiAgICBpZiggdHlwZS5tdWx0aXBsZSApeyByZXR1cm4gZmFsc2U7IH0gLy8gaW1wb3NzaWJsZSB0byBtYXAgdG8gbnVtXG5cbiAgICB2YXIgbWFwcGVkO1xuICAgIGlmKCBtYXBEYXRhICl7XG4gICAgICBtYXBwZWQgPSB0eXBlcy5tYXBEYXRhO1xuICAgIH0gZWxzZSBpZiggbWFwTGF5b3V0RGF0YSApe1xuICAgICAgbWFwcGVkID0gdHlwZXMubWFwTGF5b3V0RGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwcGVkID0gdHlwZXMubWFwU2NyYXRjaDtcbiAgICB9XG5cbiAgICBtYXBEYXRhID0gbWFwRGF0YSB8fCBtYXBMYXlvdXREYXRhIHx8IG1hcFNjcmF0Y2g7XG5cbiAgICAvLyB3ZSBjYW4gbWFwIG9ubHkgaWYgdGhlIHR5cGUgaXMgYSBjb2xvdXIgb3IgYSBudW1iZXJcbiAgICBpZiggISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UoIG5hbWUsIG1hcERhdGFbNF0gKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiggIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIHZhciB2YWx1ZU1heCA9IHRoaXMucGFyc2UoIG5hbWUsIG1hcERhdGFbNV0gKTsgLy8gcGFyc2UgdG8gdmFsaWRhdGVcbiAgICBpZiggIXZhbHVlTWF4IHx8IHZhbHVlTWF4Lm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcbiAgICBpZiggdmFsdWVNaW4udmFsdWUgPT09IHZhbHVlTWF4LnZhbHVlICl7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbid0IG1ha2UgbXVjaCBvZiBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcblxuICAgIH0gZWxzZSBpZiggdHlwZS5jb2xvciApe1xuICAgICAgdmFyIGMxID0gdmFsdWVNaW4udmFsdWU7XG4gICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcblxuICAgICAgdmFyIHNhbWUgPSBjMVswXSA9PT0gYzJbMF0gLy8gcmVkXG4gICAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgICAmJiAoIC8vIG9wdGlvbmFsIGFscGhhXG4gICAgICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgICAgICB8fCAoXG4gICAgICAgICAgICAoYzFbM10gPT0gbnVsbCB8fCBjMVszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMT9cbiAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoYzJbM10gPT0gbnVsbCB8fCBjMlszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMj9cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIDtcblxuICAgICAgaWYoIHNhbWUgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGNhbid0IG1ha2UgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgbWFwcGVkOiBtYXBwZWQsXG4gICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KCBtYXBEYXRhWzJdICksIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQoIG1hcERhdGFbM10gKSxcbiAgICAgIHZhbHVlTWluOiB2YWx1ZU1pbi52YWx1ZSxcbiAgICAgIHZhbHVlTWF4OiB2YWx1ZU1heC52YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIGlmKCB0eXBlLm11bHRpcGxlICYmIHByb3BJc0ZsYXQgIT09ICdtdWx0aXBsZScgKXtcbiAgICB2YXIgdmFscztcblxuICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7XG4gICAgICB2YWxzID0gdmFsdWUuc3BsaXQoL1xccysvKTtcbiAgICB9IGVsc2UgaWYoIGlzLmFycmF5KHZhbHVlKSApe1xuICAgICAgdmFscyA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxzID0gWyB2YWx1ZSBdO1xuICAgIH1cblxuICAgIGlmKCB0eXBlLmV2ZW5NdWx0aXBsZSAmJiB2YWxzLmxlbmd0aCAlIDIgIT09IDAgKXsgcmV0dXJuIG51bGw7IH1cblxuICAgIHZhciB2YWxBcnIgPSB2YWxzLm1hcChmdW5jdGlvbiggdiApe1xuICAgICAgdmFyIHAgPSBzZWxmLnBhcnNlKCBuYW1lLCB2LCBwcm9wSXNCeXBhc3MsICdtdWx0aXBsZScgKTtcblxuICAgICAgaWYoIHAucGZWYWx1ZSAhPSBudWxsICl7XG4gICAgICAgIHJldHVybiBwLnBmVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcC52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbEFycixcbiAgICAgIHBmVmFsdWU6IHZhbEFycixcbiAgICAgIHN0clZhbHVlOiB2YWxBcnIuam9pbignICcpLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICB1bml0czogdHlwZS5udW1iZXIgJiYgIXR5cGUudW5pdGxlc3MgPyB0eXBlLmltcGxpY2l0VW5pdHMgfHwgJ3B4JyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvLyBzZXZlcmFsIHR5cGVzIGFsc28gYWxsb3cgZW51bXNcbiAgdmFyIGNoZWNrRW51bXMgPSBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZS5lbnVtcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVuID0gdHlwZS5lbnVtc1tpXTtcblxuICAgICAgaWYoIGVuID09PSB2YWx1ZSApe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG4gIGlmKCB0eXBlLm51bWJlciApe1xuICAgIHZhciB1bml0cztcbiAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgIGlmKCB0eXBlLnVuaXRzICl7IC8vIHVzZSBzcGVjaWZpZWQgdW5pdHMgaWYgc2V0XG4gICAgICB1bml0cyA9IHR5cGUudW5pdHM7XG4gICAgfVxuXG4gICAgaWYoIHR5cGUuaW1wbGljaXRVbml0cyApe1xuICAgICAgaW1wbGljaXRVbml0cyA9IHR5cGUuaW1wbGljaXRVbml0cztcbiAgICB9XG5cbiAgICBpZiggIXR5cGUudW5pdGxlc3MgKXtcbiAgICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7XG4gICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuICAgICAgICBpZiggdW5pdHMgKXsgdW5pdHNSZWdleCA9IHVuaXRzOyB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG4gICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKCAnXignICsgdXRpbC5yZWdleC5udW1iZXIgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcgKTtcblxuICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoICF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMgKSB7XG4gICAgICAgIHVuaXRzID0gaW1wbGljaXRVbml0czsgLy8gaW1wbGljaXRseSBweCBpZiB1bnNwZWNpZmllZFxuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcblxuICAgIC8vIGlmIG5vdCBhIG51bWJlciBhbmQgZW51bXMgbm90IGFsbG93ZWQsIHRoZW4gdGhlIHZhbHVlIGlzIGludmFsaWRcbiAgICBpZiggaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdGhpcyBudW1iZXIgdHlwZSBhbHNvIGFjY2VwdHMgc3BlY2lhbCBrZXl3b3JkcyBpbiBwbGFjZSBvZiBudW1iZXJzXG4gICAgLy8gKGkuZS4gYGxlZnRgLCBgYXV0b2AsIGV0YylcbiAgICBpZiggaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdmFsdWUgPSBwYXNzZWRWYWx1ZTtcblxuICAgICAgcmV0dXJuIGNoZWNrRW51bXMoKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXJcbiAgICBpZiggdHlwZS5pbnRlZ2VyICYmICFpcy5pbnRlZ2VyKHZhbHVlKSApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdmFsdWUgaXMgd2l0aGluIHJhbmdlXG4gICAgaWYoICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgdHlwZS5taW4pXG4gICAgfHwgKHR5cGUubWF4ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPiB0eXBlLm1heClcbiAgICApe1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJldCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSArICh1bml0cyA/IHVuaXRzIDogJycpLFxuICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuICAgIGlmKCB0eXBlLnVuaXRsZXNzIHx8ICh1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykgKXtcbiAgICAgIHJldC5wZlZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldC5wZlZhbHVlID0gKCB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyAodmFsdWUpIDogKHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlKSApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBtc1xuICAgIGlmKCB1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnICl7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHJhZFxuICAgIGlmKCB1bml0cyA9PT0gJ2RlZycgfHwgdW5pdHMgPT09ICdyYWQnICl7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncmFkJyA/IHZhbHVlIDogdmFsdWUgKiBNYXRoLlBJLzE4MDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuXG4gIH0gZWxzZSBpZiggdHlwZS5wcm9wTGlzdCApIHtcblxuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIHZhciBwcm9wc1N0ciA9ICcnICsgdmFsdWU7XG5cbiAgICBpZiggcHJvcHNTdHIgPT09ICdub25lJyApe1xuICAgICAgLy8gbGVhdmUgZW1wdHlcblxuICAgIH0gZWxzZSB7IC8vIGdvIG92ZXIgZWFjaCBwcm9wXG5cbiAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoJywnKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHNTcGxpdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wc1NwbGl0W2ldLnRyaW0oKTtcblxuICAgICAgICBpZiggc2VsZi5wcm9wZXJ0aWVzW3Byb3BOYW1lXSApe1xuICAgICAgICAgIHByb3BzLnB1c2goIHByb3BOYW1lICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gbnVsbDsgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHByb3BzLFxuICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oJywgJyksXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG5cbiAgfSBlbHNlIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgdmFyIHR1cGxlID0gdXRpbC5jb2xvcjJ0dXBsZSggdmFsdWUgKTtcblxuICAgIGlmKCAhdHVwbGUgKXsgcmV0dXJuIG51bGw7IH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHR1cGxlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzcyxcbiAgICAgIHJvdW5kVmFsdWU6IHRydWVcbiAgICB9O1xuXG4gIH0gZWxzZSBpZiggdHlwZS5yZWdleCB8fCB0eXBlLnJlZ2V4ZXMgKXtcblxuICAgIC8vIGZpcnN0IGNoZWNrIGVudW1zXG4gICAgaWYoIHR5cGUuZW51bXMgKXtcbiAgICAgIHZhciBlbnVtUHJvcCA9IGNoZWNrRW51bXMoKTtcblxuICAgICAgaWYoIGVudW1Qcm9wICl7IHJldHVybiBlbnVtUHJvcDsgfVxuICAgIH1cblxuICAgIHZhciByZWdleGVzID0gdHlwZS5yZWdleGVzID8gdHlwZS5yZWdleGVzIDogWyB0eXBlLnJlZ2V4IF07XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHJlZ2V4ZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoIHJlZ2V4ZXNbaV0gKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGUgc3RyaW5nXG4gICAgICB2YXIgbSA9IHJlZ2V4LmV4ZWMoIHZhbHVlICk7XG5cbiAgICAgIGlmKCBtICl7IC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiBtLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIGFueVxuXG4gIH0gZWxzZSBpZiggdHlwZS5zdHJpbmcgKXtcbiAgICAvLyBqdXN0IHJldHVyblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG5cbiAgfSBlbHNlIGlmKCB0eXBlLmVudW1zICl7IC8vIGNoZWNrIGVudW1zIGxhc3QgYmVjYXVzZSBpdCdzIGEgY29tYm8gdHlwZSBpbiBvdGhlcnNcbiAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vdCBhIHR5cGUgd2UgY2FuIGhhbmRsZVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgc3R5Zm4gPSB7fTtcblxuKGZ1bmN0aW9uKCl7XG4gIHZhciBudW1iZXIgPSB1dGlsLnJlZ2V4Lm51bWJlcjtcbiAgdmFyIHJnYmEgPSB1dGlsLnJlZ2V4LnJnYmFOb0JhY2tSZWZzO1xuICB2YXIgaHNsYSA9IHV0aWwucmVnZXguaHNsYU5vQmFja1JlZnM7XG4gIHZhciBoZXgzID0gdXRpbC5yZWdleC5oZXgzO1xuICB2YXIgaGV4NiA9IHV0aWwucmVnZXguaGV4NjtcbiAgdmFyIGRhdGEgPSBmdW5jdGlvbiggcHJlZml4ICl7IHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXChcXFxccyooW1xcXFx3XFxcXC5dKylcXFxccypcXFxcKSQnOyB9O1xuICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uKCBwcmVmaXggKXtcbiAgICB2YXIgbWFwQXJnID0gbnVtYmVyICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyArICd8JyArIGhleDY7XG4gICAgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKChbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG1hcEFyZyArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG1hcEFyZyArICcpXFxcXCkkJztcbiAgfTtcblxuICAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG4gIHN0eWZuLnR5cGVzID0ge1xuICAgIHRpbWU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIHVuaXRzOiAnc3xtcycsIGltcGxpY2l0VW5pdHM6ICdtcycgfSxcbiAgICBwZXJjZW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEwMCwgdW5pdHM6ICclJywgaW1wbGljaXRVbml0czogJyUnIH0sXG4gICAgemVyb09uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgIG5PbmVPbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IC0xLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgbm9uTmVnYXRpdmVJbnQ6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGludGVnZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgcG9zaXRpb246IHsgZW51bXM6IFsncGFyZW50JywgJ29yaWdpbiddIH0sXG4gICAgbm9kZVNpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGVudW1zOiBbJ2F1dG8nLCAnbGFiZWwnXSB9LFxuICAgIG51bWJlcjogeyBudW1iZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgbnVtYmVyczogeyBudW1iZXI6IHRydWUsIHVuaXRsZXNzOiB0cnVlLCBtdWx0aXBsZTogdHJ1ZSB9LFxuICAgIHNpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAgfSxcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZTogeyBudW1iZXI6IHRydWUgfSwgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmlkaXJlY3Rpb25hbFNpemVzOiB7IG51bWJlcjogdHJ1ZSwgbXVsdGlwbGU6IHRydWUgfSwgLy8gYWxsb3dzIG5lZ2F0aXZlXG4gICAgYmdTaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBhbGxvd1BlcmNlbnQ6IHRydWUgfSxcbiAgICBiZ1dIOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBhbGxvd1BlcmNlbnQ6IHRydWUsIGVudW1zOiBbJ2F1dG8nXSB9LFxuICAgIGJnUG9zOiB7IG51bWJlcjogdHJ1ZSwgYWxsb3dQZXJjZW50OiB0cnVlIH0sXG4gICAgYmdSZXBlYXQ6IHsgZW51bXM6IFsncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15JywgJ25vLXJlcGVhdCddIH0sXG4gICAgYmdGaXQ6IHsgZW51bXM6IFsnbm9uZScsICdjb250YWluJywgJ2NvdmVyJ10gfSxcbiAgICBiZ0NsaXA6IHsgZW51bXM6IFsnbm9uZScsICdub2RlJ10gfSxcbiAgICBjb2xvcjogeyBjb2xvcjogdHJ1ZSB9LFxuICAgIGJvb2w6IHsgZW51bXM6IFsneWVzJywgJ25vJ10gfSxcbiAgICBsaW5lU3R5bGU6IHsgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddIH0sXG4gICAgYm9yZGVyU3R5bGU6IHsgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcsICdkb3VibGUnXSB9LFxuICAgIGN1cnZlU3R5bGU6IHsgZW51bXM6IFsnYmV6aWVyJywgJ3VuYnVuZGxlZC1iZXppZXInLCAnaGF5c3RhY2snLCAnc2VnbWVudHMnXSB9LFxuICAgIGZvbnRGYW1pbHk6IHsgcmVnZXg6ICdeKFtcXFxcdy0gXFxcXFwiXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBcXFxcXCJdKykqKSQnIH0sXG4gICAgZm9udFZhcmlhbnQ6IHsgZW51bXM6IFsnc21hbGwtY2FwcycsICdub3JtYWwnXSB9LFxuICAgIGZvbnRTdHlsZTogeyBlbnVtczogWydpdGFsaWMnLCAnbm9ybWFsJywgJ29ibGlxdWUnXSB9LFxuICAgIGZvbnRXZWlnaHQ6IHsgZW51bXM6IFsnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInLCAnMTAwJywgJzIwMCcsICczMDAnLCAnNDAwJywgJzUwMCcsICc2MDAnLCAnODAwJywgJzkwMCcsIDEwMCwgMjAwLCAzMDAsIDQwMCwgNTAwLCA2MDAsIDcwMCwgODAwLCA5MDBdIH0sXG4gICAgdGV4dERlY29yYXRpb246IHsgZW51bXM6IFsnbm9uZScsICd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJ10gfSxcbiAgICB0ZXh0VHJhbnNmb3JtOiB7IGVudW1zOiBbJ25vbmUnLCAndXBwZXJjYXNlJywgJ2xvd2VyY2FzZSddIH0sXG4gICAgdGV4dFdyYXA6IHsgZW51bXM6IFsnbm9uZScsICd3cmFwJ10gfSxcbiAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7IGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZSddfSxcbiAgICBub2RlU2hhcGU6IHsgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ2VsbGlwc2UnLCAndHJpYW5nbGUnLCAnc3F1YXJlJywgJ3BlbnRhZ29uJywgJ2hleGFnb24nLCAnaGVwdGFnb24nLCAnb2N0YWdvbicsICdzdGFyJywgJ2RpYW1vbmQnLCAndmVlJywgJ3Job21ib2lkJywgJ3BvbHlnb24nXSB9LFxuICAgIGNvbXBvdW5kSW5jbHVkZUxhYmVsczogeyBlbnVtczogWydpbmNsdWRlJywgJ2V4Y2x1ZGUnXSB9LFxuICAgIGFycm93U2hhcGU6IHsgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICd0cmlhbmdsZS1iYWNrY3VydmUnLCAnaGFsZi10cmlhbmdsZS1vdmVyc2hvdCcsICd2ZWUnLCAnc3F1YXJlJywgJ2NpcmNsZScsICdkaWFtb25kJywgJ25vbmUnXSB9LFxuICAgIGFycm93RmlsbDogeyBlbnVtczogWydmaWxsZWQnLCAnaG9sbG93J10gfSxcbiAgICBkaXNwbGF5OiB7IGVudW1zOiBbJ2VsZW1lbnQnLCAnbm9uZSddIH0sXG4gICAgdmlzaWJpbGl0eTogeyBlbnVtczogWydoaWRkZW4nLCAndmlzaWJsZSddIH0sXG4gICAgdmFsaWduOiB7IGVudW1zOiBbJ3RvcCcsICdjZW50ZXInLCAnYm90dG9tJ10gfSxcbiAgICBoYWxpZ246IHsgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSB9LFxuICAgIHRleHQ6IHsgc3RyaW5nOiB0cnVlIH0sXG4gICAgZGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSgnZGF0YScpIH0sXG4gICAgbGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSgnbGF5b3V0RGF0YScpIH0sXG4gICAgc2NyYXRjaDogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSgnc2NyYXRjaCcpIH0sXG4gICAgbWFwRGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSgnbWFwRGF0YScpIH0sXG4gICAgbWFwTGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSgnbWFwTGF5b3V0RGF0YScpIH0sXG4gICAgbWFwU2NyYXRjaDogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSgnbWFwU2NyYXRjaCcpIH0sXG4gICAgZm46IHsgbWFwcGluZzogdHJ1ZSwgZm46IHRydWUgfSxcbiAgICB1cmw6IHsgcmVnZXg6ICdedXJsXFxcXHMqXFxcXChcXFxccyooW15cXFxcc10rKVxcXFxzKlxcXFxzKlxcXFwpfG5vbmV8KC4rKSQnIH0sXG4gICAgcHJvcExpc3Q6IHsgcHJvcExpc3Q6IHRydWUgfSxcbiAgICBhbmdsZTogeyBudW1iZXI6IHRydWUsIHVuaXRzOiAnZGVnfHJhZCcsIGltcGxpY2l0VW5pdHM6ICdyYWQnIH0sXG4gICAgdGV4dFJvdGF0aW9uOiB7IGVudW1zOiBbJ25vbmUnLCAnYXV0b3JvdGF0ZSddIH0sXG4gICAgcG9seWdvblBvaW50TGlzdDogeyBudW1iZXI6IHRydWUsIG11bHRpcGxlOiB0cnVlLCBldmVuTXVsdGlwbGU6IHRydWUsIG1pbjogLTEsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICBlYXNpbmc6IHtcbiAgICAgIHJlZ2V4ZXM6IFtcbiAgICAgICAgJ14oc3ByaW5nKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqXFxcXCkkJyxcbiAgICAgICAgJ14oY3ViaWMtYmV6aWVyKVxcXFxzKlxcXFwoXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwpJCdcbiAgICAgIF0sXG4gICAgICBlbnVtczogW1xuICAgICAgICAnbGluZWFyJyxcbiAgICAgICAgJ2Vhc2UnLCAnZWFzZS1pbicsICdlYXNlLW91dCcsICdlYXNlLWluLW91dCcsXG4gICAgICAgICdlYXNlLWluLXNpbmUnLCAnZWFzZS1vdXQtc2luZScsICdlYXNlLWluLW91dC1zaW5lJyxcbiAgICAgICAgJ2Vhc2UtaW4tcXVhZCcsICdlYXNlLW91dC1xdWFkJywgJ2Vhc2UtaW4tb3V0LXF1YWQnLFxuICAgICAgICAnZWFzZS1pbi1jdWJpYycsICdlYXNlLW91dC1jdWJpYycsICdlYXNlLWluLW91dC1jdWJpYycsXG4gICAgICAgICdlYXNlLWluLXF1YXJ0JywgJ2Vhc2Utb3V0LXF1YXJ0JywgJ2Vhc2UtaW4tb3V0LXF1YXJ0JyxcbiAgICAgICAgJ2Vhc2UtaW4tcXVpbnQnLCAnZWFzZS1vdXQtcXVpbnQnLCAnZWFzZS1pbi1vdXQtcXVpbnQnLFxuICAgICAgICAnZWFzZS1pbi1leHBvJywgJ2Vhc2Utb3V0LWV4cG8nLCAnZWFzZS1pbi1vdXQtZXhwbycsXG4gICAgICAgICdlYXNlLWluLWNpcmMnLCAnZWFzZS1vdXQtY2lyYycsICdlYXNlLWluLW91dC1jaXJjJ1xuICAgICAgXVxuICAgIH1cbiAgfTtcblxuICAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgdmFyIHQgPSBzdHlmbi50eXBlcztcbiAgdmFyIHByb3BzID0gc3R5Zm4ucHJvcGVydGllcyA9IFtcbiAgICAvLyBsYWJlbHNcbiAgICB7IG5hbWU6ICd0ZXh0LXZhbGlnbicsIHR5cGU6IHQudmFsaWduIH0sXG4gICAgeyBuYW1lOiAndGV4dC1oYWxpZ24nLCB0eXBlOiB0LmhhbGlnbiB9LFxuICAgIHsgbmFtZTogJ2NvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2xhYmVsJywgdHlwZTogdC50ZXh0IH0sXG4gICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1ib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1ib3JkZXItc3R5bGUnLCB0eXBlOiB0LmJvcmRlclN0eWxlIH0sXG4gICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJywgdHlwZTogdC50ZXh0QmFja2dyb3VuZFNoYXBlfSxcbiAgICAvLyB7IG5hbWU6ICd0ZXh0LWRlY29yYXRpb24nLCB0eXBlOiB0LnRleHREZWNvcmF0aW9uIH0sIC8vIG5vdCBzdXBwb3J0ZWQgaW4gY2FudmFzXG4gICAgeyBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLCB0eXBlOiB0LnRleHRUcmFuc2Zvcm0gfSxcbiAgICB7IG5hbWU6ICd0ZXh0LXdyYXAnLCB0eXBlOiB0LnRleHRXcmFwIH0sXG4gICAgeyBuYW1lOiAndGV4dC1tYXgtd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LWV2ZW50cycsIHR5cGU6IHQuYm9vbCB9LFxuXG4gICAgLy8geyBuYW1lOiAndGV4dC1yb3RhdGlvbicsIHR5cGU6IHQuYW5nbGUgfSwgLy8gVE9ETyBkaXNhYmxlZCBiL2Mgcm90YXRpb24gYnJlYWtzIGJvdW5kaW5nIGJveGVzXG4gICAgeyBuYW1lOiAnZm9udC1mYW1pbHknLCB0eXBlOiB0LmZvbnRGYW1pbHkgfSxcbiAgICB7IG5hbWU6ICdmb250LXN0eWxlJywgdHlwZTogdC5mb250U3R5bGUgfSxcbiAgICAvLyB7IG5hbWU6ICdmb250LXZhcmlhbnQnLCB0eXBlOiB0LmZvbnRWYXJpYW50IH0sIC8vIG5vdCB1c2VmdWxcbiAgICB7IG5hbWU6ICdmb250LXdlaWdodCcsIHR5cGU6IHQuZm9udFdlaWdodCB9LFxuICAgIHsgbmFtZTogJ2ZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ21pbi16b29tZWQtZm9udC1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnZWRnZS10ZXh0LXJvdGF0aW9uJywgdHlwZTogdC50ZXh0Um90YXRpb24gfSxcblxuICAgIC8vIGJlaGF2aW91clxuICAgIHsgbmFtZTogJ2V2ZW50cycsIHR5cGU6IHQuYm9vbCB9LFxuXG4gICAgLy8gdmlzaWJpbGl0eVxuICAgIHsgbmFtZTogJ2Rpc3BsYXknLCB0eXBlOiB0LmRpc3BsYXkgfSxcbiAgICB7IG5hbWU6ICd2aXNpYmlsaXR5JywgdHlwZTogdC52aXNpYmlsaXR5IH0sXG4gICAgeyBuYW1lOiAnb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ3otaW5kZXgnLCB0eXBlOiB0Lm5vbk5lZ2F0aXZlSW50IH0sXG5cbiAgICAvLyBvdmVybGF5c1xuICAgIHsgbmFtZTogJ292ZXJsYXktcGFkZGluZycsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ292ZXJsYXktY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnb3ZlcmxheS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG5cbiAgICAvLyBzaGFkb3dzXG4gICAgeyBuYW1lOiAnc2hhZG93LWJsdXInLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdzaGFkb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnc2hhZG93LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdzaGFkb3ctb2Zmc2V0LXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAnc2hhZG93LW9mZnNldC15JywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSB9LFxuXG4gICAgLy8gbGFiZWwgc2hhZG93c1xuICAgIHsgbmFtZTogJ3RleHQtc2hhZG93LWJsdXInLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctb2Zmc2V0LXgnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG4gICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctb2Zmc2V0LXknLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplIH0sXG5cbiAgICAvLyB0cmFuc2l0aW9uIGFuaXNcbiAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLXByb3BlcnR5JywgdHlwZTogdC5wcm9wTGlzdCB9LFxuICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLCB0eXBlOiB0LnRpbWUgfSxcbiAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLWRlbGF5JywgdHlwZTogdC50aW1lIH0sXG4gICAgeyBuYW1lOiAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLCB0eXBlOiB0LmVhc2luZyB9LFxuXG4gICAgLy8gbm9kZSBib2R5XG4gICAgeyBuYW1lOiAnaGVpZ2h0JywgdHlwZTogdC5ub2RlU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3dpZHRoJywgdHlwZTogdC5ub2RlU2l6ZSB9LFxuICAgIHsgbmFtZTogJ3NoYXBlJywgdHlwZTogdC5ub2RlU2hhcGUgfSxcbiAgICB7IG5hbWU6ICdzaGFwZS1wb2x5Z29uLXBvaW50cycsIHR5cGU6IHQucG9seWdvblBvaW50TGlzdCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJywgdHlwZTogdC5uT25lT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy1sZWZ0JywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy1yaWdodCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ3BhZGRpbmctdG9wJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAncGFkZGluZy1ib3R0b20nLCB0eXBlOiB0LnNpemUgfSxcblxuICAgIC8vIG5vZGUgYm9yZGVyXG4gICAgeyBuYW1lOiAnYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgIHsgbmFtZTogJ2JvcmRlci1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnYm9yZGVyLXN0eWxlJywgdHlwZTogdC5ib3JkZXJTdHlsZSB9LFxuXG4gICAgLy8gbm9kZSBiYWNrZ3JvdW5kIGltYWdlc1xuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLCB0eXBlOiB0LnVybCB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teCcsIHR5cGU6IHQuYmdQb3MgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1yZXBlYXQnLCB0eXBlOiB0LmJnUmVwZWF0IH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1maXQnLCB0eXBlOiB0LmJnRml0IH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJywgdHlwZTogdC5iZ0NsaXAgfSxcbiAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoJywgdHlwZTogdC5iZ1dIIH0sXG4gICAgeyBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQnLCB0eXBlOiB0LmJnV0ggfSxcblxuICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgeyBuYW1lOiAncG9zaXRpb24nLCB0eXBlOiB0LnBvc2l0aW9uIH0sXG4gICAgeyBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLCB0eXBlOiB0LmNvbXBvdW5kSW5jbHVkZUxhYmVscyB9LFxuXG4gICAgLy8gZWRnZSBsaW5lXG4gICAgeyBuYW1lOiAnbGluZS1zdHlsZScsIHR5cGU6IHQubGluZVN0eWxlIH0sXG4gICAgeyBuYW1lOiAnbGluZS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdjdXJ2ZS1zdHlsZScsIHR5cGU6IHQuY3VydmVTdHlsZSB9LFxuICAgIHsgbmFtZTogJ2hheXN0YWNrLXJhZGl1cycsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnLCB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyB9LFxuICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cycsIHR5cGU6IHQubnVtYmVycyB9LFxuICAgIHsgbmFtZTogJ3NlZ21lbnQtZGlzdGFuY2VzJywgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMgfSxcbiAgICB7IG5hbWU6ICdzZWdtZW50LXdlaWdodHMnLCB0eXBlOiB0Lm51bWJlcnMgfSxcblxuICAgIC8vIHRoZXNlIGFyZSBqdXN0IGZvciB0aGUgY29yZVxuICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICB7IG5hbWU6ICdhY3RpdmUtYmctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgeyBuYW1lOiAnYWN0aXZlLWJnLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICB7IG5hbWU6ICdhY3RpdmUtYmctc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgIHsgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9XG4gIF07XG5cbiAgLy8gZGVmaW5lIGFsaWFzZXNcbiAgdmFyIGFsaWFzZXMgPSBzdHlmbi5hbGlhc2VzID0gW1xuICAgIHsgbmFtZTogJ2NvbnRlbnQnLCBwb2ludHNUbzogJ2xhYmVsJyB9LFxuICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnLCBwb2ludHNUbzogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyB9LFxuICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JywgcG9pbnRzVG86ICdjb250cm9sLXBvaW50LXdlaWdodHMnIH1cbiAgXTtcblxuICAvLyBwaWUgYmFja2dyb3VuZHMgZm9yIG5vZGVzXG4gIHN0eWZuLnBpZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHBpZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS1zaXplJywgdHlwZTogdC5iZ1NpemUgfSk7XG4gIGZvciggdmFyIGkgPSAxOyBpIDw9IHN0eWZuLnBpZUJhY2tncm91bmROOyBpKysgKXtcbiAgICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS0nK2krJy1iYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9KTtcbiAgICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS0nK2krJy1iYWNrZ3JvdW5kLXNpemUnLCB0eXBlOiB0LnBlcmNlbnQgfSk7XG4gICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJytpKyctYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0pO1xuICB9XG5cbiAgLy8gZWRnZSBhcnJvd3NcbiAgdmFyIGFycm93UHJlZml4ZXMgPSBzdHlmbi5hcnJvd1ByZWZpeGVzID0gWydzb3VyY2UnLCAnbWlkLXNvdXJjZScsICd0YXJnZXQnLCAnbWlkLXRhcmdldCddO1xuICBbXG4gICAgeyBuYW1lOiAnYXJyb3ctc2hhcGUnLCB0eXBlOiB0LmFycm93U2hhcGUgfSxcbiAgICB7IG5hbWU6ICdhcnJvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICB7IG5hbWU6ICdhcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfVxuICBdLmZvckVhY2goZnVuY3Rpb24oIHByb3AgKXtcbiAgICBhcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24oIHByZWZpeCApe1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcblxuICAgICAgcHJvcHMucHVzaCh7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUgfSk7XG4gICAgfSk7XG4gIH0sIHt9KTtcblxuICAvLyBsaXN0IG9mIHByb3BlcnR5IG5hbWVzXG4gIHN0eWZuLnByb3BlcnR5TmFtZXMgPSBwcm9wcy5tYXAoZnVuY3Rpb24ocCl7IHJldHVybiBwLm5hbWU7IH0pO1xuXG4gIC8vIGFsbG93IGFjY2VzcyBvZiBwcm9wZXJ0aWVzIGJ5IG5hbWUgKCBlLmcuIHN0eWxlLnByb3BlcnRpZXMuaGVpZ2h0IClcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG5cbiAgICBwcm9wc1sgcHJvcC5uYW1lIF0gPSBwcm9wOyAvLyBhbGxvdyBsb29rdXAgYnkgbmFtZVxuICB9XG5cbiAgLy8gbWFwIGFsaWFzZXNcbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGlhc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGFsaWFzID0gYWxpYXNlc1tpXTtcbiAgICB2YXIgcG9pbnRzVG9Qcm9wID0gcHJvcHNbIGFsaWFzLnBvaW50c1RvIF07XG4gICAgdmFyIGFsaWFzUHJvcCA9IHtcbiAgICAgIG5hbWU6IGFsaWFzLm5hbWUsXG4gICAgICBhbGlhczogdHJ1ZSxcbiAgICAgIHBvaW50c1RvOiBwb2ludHNUb1Byb3BcbiAgICB9O1xuXG4gICAgLy8gYWRkIGFsaWFzIHByb3AgZm9yIHBhcnNpbmdcbiAgICBwcm9wcy5wdXNoKCBhbGlhc1Byb3AgKTtcblxuICAgIHByb3BzWyBhbGlhcy5uYW1lIF0gPSBhbGlhc1Byb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cbn0pKCk7XG5cbi8vIGFkZHMgdGhlIGRlZmF1bHQgc3R5bGVzaGVldCB0byB0aGUgY3VycmVudCBzdHlsZVxuc3R5Zm4uYWRkRGVmYXVsdFN0eWxlc2hlZXQgPSBmdW5jdGlvbigpe1xuICAvLyBmaWxsIHRoZSBzdHlsZSB3aXRoIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXRcbiAgdGhpc1xuICAgIC5zZWxlY3Rvcignbm9kZSwgZWRnZScpIC8vIGNvbW1vbiBwcm9wZXJ0aWVzXG4gICAgICAuY3NzKCB1dGlsLmV4dGVuZCgge1xuICAgICAgICAnZXZlbnRzJzogJ3llcycsXG4gICAgICAgICd0ZXh0LWV2ZW50cyc6ICdubycsXG4gICAgICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgJ2NvbG9yJzogJyMwMDAnLFxuICAgICAgICAndGV4dC1vdXRsaW5lLWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAndGV4dC1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAgICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAgICAgJ3RleHQtb3BhY2l0eSc6IDEsXG4gICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAnbm9uZScsXG4gICAgICAgICd0ZXh0LXRyYW5zZm9ybSc6ICdub25lJyxcbiAgICAgICAgJ3RleHQtd3JhcCc6ICdub25lJyxcbiAgICAgICAgJ3RleHQtbWF4LXdpZHRoJzogOTk5OSxcbiAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JzogMCxcbiAgICAgICAgJ3RleHQtYm9yZGVyLW9wYWNpdHknOiAwLFxuICAgICAgICAndGV4dC1ib3JkZXItd2lkdGgnOiAwLFxuICAgICAgICAndGV4dC1ib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICAgICAndGV4dC1ib3JkZXItY29sb3InOicjMDAwJyxcbiAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1zaGFwZSc6J3JlY3RhbmdsZScsXG4gICAgICAgICdmb250LWZhbWlseSc6ICdIZWx2ZXRpY2EgTmV1ZSwgSGVsdmV0aWNhLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgJ2ZvbnQtc3R5bGUnOiAnbm9ybWFsJyxcbiAgICAgICAgLy8gJ2ZvbnQtdmFyaWFudCc6IGZvbnRWYXJpYW50LFxuICAgICAgICAnZm9udC13ZWlnaHQnOiAnbm9ybWFsJyxcbiAgICAgICAgJ2ZvbnQtc2l6ZSc6IDE2LFxuICAgICAgICAnbWluLXpvb21lZC1mb250LXNpemUnOiAwLFxuICAgICAgICAnZWRnZS10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgJ2Rpc3BsYXknOiAnZWxlbWVudCcsXG4gICAgICAgICdvcGFjaXR5JzogMSxcbiAgICAgICAgJ3otaW5kZXgnOiAwLFxuICAgICAgICAnbGFiZWwnOiAnJyxcbiAgICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgICAgICdvdmVybGF5LWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICdzaGFkb3ctb3BhY2l0eSc6IDAsXG4gICAgICAgICdzaGFkb3ctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICdzaGFkb3ctYmx1cic6IDEwLFxuICAgICAgICAnc2hhZG93LW9mZnNldC14JzogMCxcbiAgICAgICAgJ3NoYWRvdy1vZmZzZXQteSc6IDAsXG4gICAgICAgICd0ZXh0LXNoYWRvdy1vcGFjaXR5JzogMCxcbiAgICAgICAgJ3RleHQtc2hhZG93LWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAndGV4dC1zaGFkb3ctYmx1cic6IDUsXG4gICAgICAgICd0ZXh0LXNoYWRvdy1vZmZzZXQteCc6IDAsXG4gICAgICAgICd0ZXh0LXNoYWRvdy1vZmZzZXQteSc6IDAsXG4gICAgICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JzogJ25vbmUnLFxuICAgICAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IDAsXG4gICAgICAgICd0cmFuc2l0aW9uLWRlbGF5JzogMCxcbiAgICAgICAgJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJzogJ2xpbmVhcicsXG5cbiAgICAgICAgLy8gbm9kZSBwcm9wc1xuICAgICAgICAnYmFja2dyb3VuZC1ibGFja2VuJzogMCxcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzg4OCcsXG4gICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICdub25lJyxcbiAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSc6IDEsXG4gICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnOiAnNTAlJyxcbiAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICc1MCUnLFxuICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgJ2JhY2tncm91bmQtZml0JzogJ25vbmUnLFxuICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vZGUnLFxuICAgICAgICAnYmFja2dyb3VuZC13aWR0aCc6ICdhdXRvJyxcbiAgICAgICAgJ2JhY2tncm91bmQtaGVpZ2h0JzogJ2F1dG8nLFxuICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAnYm9yZGVyLW9wYWNpdHknOiAxLFxuICAgICAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICdoZWlnaHQnOiAzMCxcbiAgICAgICAgJ3dpZHRoJzogMzAsXG4gICAgICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcbiAgICAgICAgJ3NoYXBlLXBvbHlnb24tcG9pbnRzJzogJy0xLCAtMSwgICAxLCAtMSwgICAxLCAxLCAgIC0xLCAxJyxcblxuICAgICAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgICAgICAncGFkZGluZy10b3AnOiAwLFxuICAgICAgICAncGFkZGluZy1ib3R0b20nOiAwLFxuICAgICAgICAncGFkZGluZy1sZWZ0JzogMCxcbiAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAwLFxuICAgICAgICAncG9zaXRpb24nOiAnb3JpZ2luJyxcbiAgICAgICAgJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJzogJ2luY2x1ZGUnXG4gICAgICB9LCB7XG4gICAgICAgIC8vIG5vZGUgcGllIGJnXG4gICAgICAgICdwaWUtc2l6ZSc6ICcxMDAlJ1xuICAgICAgfSwgW1xuICAgICAgICB7IG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1jb2xvcicsIHZhbHVlOiAnYmxhY2snIH0sXG4gICAgICAgIHsgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLXNpemUnLCB2YWx1ZTogJzAlJyB9LFxuICAgICAgICB7IG5hbWU6ICdwaWUte3tpfX0tYmFja2dyb3VuZC1vcGFjaXR5JywgdmFsdWU6IDEgfVxuICAgICAgXS5yZWR1Y2UoZnVuY3Rpb24oIGNzcywgcHJvcCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMTsgaSA8PSBzdHlmbi5waWVCYWNrZ3JvdW5kTjsgaSsrICl7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWUucmVwbGFjZSgne3tpfX0nLCBpKTtcbiAgICAgICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcblxuICAgICAgICAgIGNzc1sgbmFtZSBdID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNzcztcbiAgICAgIH0sIHt9KSwge1xuICAgICAgICAvLyBlZGdlIHByb3BzXG4gICAgICAgICdsaW5lLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAgICAgJ2xpbmUtY29sb3InOiAnI2RkZCcsXG4gICAgICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICAgICAnY29udHJvbC1wb2ludC13ZWlnaHRzJzogMC41LFxuICAgICAgICAnc2VnbWVudC13ZWlnaHRzJzogMC41LFxuICAgICAgICAnc2VnbWVudC1kaXN0YW5jZXMnOiAyMCxcbiAgICAgICAgJ2N1cnZlLXN0eWxlJzogJ2JlemllcicsXG4gICAgICAgICdoYXlzdGFjay1yYWRpdXMnOiAwLjhcbiAgICAgIH0sIFtcbiAgICAgICAgeyBuYW1lOiAnYXJyb3ctc2hhcGUnLCB2YWx1ZTogJ25vbmUnIH0sXG4gICAgICAgIHsgbmFtZTogJ2Fycm93LWNvbG9yJywgdmFsdWU6ICcjZGRkJyB9LFxuICAgICAgICB7IG5hbWU6ICdhcnJvdy1maWxsJywgdmFsdWU6ICdmaWxsZWQnIH1cbiAgICAgIF0ucmVkdWNlKGZ1bmN0aW9uKCBjc3MsIHByb3AgKXtcbiAgICAgICAgc3R5Zm4uYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uKCBwcmVmaXggKXtcbiAgICAgICAgICB2YXIgbmFtZSA9IHByZWZpeCArICctJyArIHByb3AubmFtZTtcbiAgICAgICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcblxuICAgICAgICAgIGNzc1sgbmFtZSBdID0gdmFsO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gY3NzO1xuICAgICAgfSwge30pICkgKVxuICAgIC5zZWxlY3RvcignJG5vZGUgPiBub2RlJykgLy8gY29tcG91bmQgKHBhcmVudCkgbm9kZSBwcm9wZXJ0aWVzXG4gICAgICAuY3NzKHtcbiAgICAgICAgJ3dpZHRoJzogJ2F1dG8nLFxuICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nLFxuICAgICAgICAnc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAgICAgJ3BhZGRpbmctdG9wJzogMTAsXG4gICAgICAgICdwYWRkaW5nLXJpZ2h0JzogMTAsXG4gICAgICAgICdwYWRkaW5nLWxlZnQnOiAxMCxcbiAgICAgICAgJ3BhZGRpbmctYm90dG9tJzogMTBcbiAgICAgIH0pXG4gICAgLnNlbGVjdG9yKCdlZGdlJykgLy8ganVzdCBlZGdlIHByb3BlcnRpZXNcbiAgICAgIC5jc3Moe1xuICAgICAgICAnd2lkdGgnOiAxXG4gICAgICB9KVxuICAgIC5zZWxlY3RvcignOmFjdGl2ZScpXG4gICAgICAuY3NzKHtcbiAgICAgICAgJ292ZXJsYXktY29sb3InOiAnYmxhY2snLFxuICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICdvdmVybGF5LW9wYWNpdHknOiAwLjI1XG4gICAgICB9KVxuICAgIC5zZWxlY3RvcignY29yZScpIC8vIGp1c3QgY29yZSBwcm9wZXJ0aWVzXG4gICAgICAuY3NzKHtcbiAgICAgICAgJ3NlbGVjdGlvbi1ib3gtY29sb3InOiAnI2RkZCcsXG4gICAgICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAwLjY1LFxuICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InOiAnI2FhYScsXG4gICAgICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCc6IDEsXG4gICAgICAgICdhY3RpdmUtYmctY29sb3InOiAnYmxhY2snLFxuICAgICAgICAnYWN0aXZlLWJnLW9wYWNpdHknOiAwLjE1LFxuICAgICAgICAnYWN0aXZlLWJnLXNpemUnOiAzMCxcbiAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JzogMC4xMjVcbiAgICAgIH0pXG4gIDtcblxuICB0aGlzLmRlZmF1bHRMZW5ndGggPSB0aGlzLmxlbmd0aDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIFNlbGVjdG9yID0gcmVxdWlyZSgnLi4vc2VsZWN0b3InKTtcblxudmFyIHN0eWZuID0ge307XG5cbnN0eWZuLmFwcGx5RnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3R5bGUgPSB0aGlzO1xuICB2YXIgcmVtYWluaW5nID0gJycgKyBzdHJpbmc7XG4gIHZhciBzZWxBbmRCbG9ja1N0cjtcbiAgdmFyIGJsb2NrUmVtO1xuICB2YXIgcHJvcEFuZFZhbFN0cjtcblxuICAvLyByZW1vdmUgY29tbWVudHMgZnJvbSB0aGUgc3R5bGUgc3RyaW5nXG4gIHJlbWFpbmluZyA9IHJlbWFpbmluZy5yZXBsYWNlKC9bL11bKl0oXFxzfC4pKz9bKl1bL10vZywgJycpO1xuXG4gIGZ1bmN0aW9uIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpe1xuICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHNlbGVjdG9yIGFuZCBibG9jayBmcm9tIHRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICAgIGlmKCByZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoICl7XG4gICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKCBzZWxBbmRCbG9ja1N0ci5sZW5ndGggKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKXtcbiAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBwcm9wZXJ0eSBhbmQgdmFsdWUgZnJvbSB0aGUgcmVtYWluaW5nIGJsb2NrIHRleHQgdG8gcGFyc2VcbiAgICBpZiggYmxvY2tSZW0ubGVuZ3RoID4gcHJvcEFuZFZhbFN0ci5sZW5ndGggKXtcbiAgICAgIGJsb2NrUmVtID0gYmxvY2tSZW0uc3Vic3RyKCBwcm9wQW5kVmFsU3RyLmxlbmd0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBibG9ja1JlbSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlKHRydWUpe1xuICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pO1xuICAgIGlmKCBub3RoaW5nTGVmdFRvUGFyc2UgKXsgYnJlYWs7IH1cblxuICAgIHZhciBzZWxBbmRCbG9jayA9IHJlbWFpbmluZy5tYXRjaCgvXlxccyooKD86LnxcXHMpKz8pXFxzKlxceygoPzoufFxccykrPylcXH0vKTtcblxuICAgIGlmKCAhc2VsQW5kQmxvY2sgKXtcbiAgICAgIHV0aWwuZXJyb3IoJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTtcblxuICAgIC8vIHBhcnNlIHRoZSBzZWxlY3RvclxuICAgIHZhciBzZWxlY3RvclN0ciA9IHNlbEFuZEJsb2NrWzFdO1xuICAgIGlmKCBzZWxlY3RvclN0ciAhPT0gJ2NvcmUnICl7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBuZXcgU2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG4gICAgICBpZiggc2VsZWN0b3IuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgICAgICB1dGlsLmVycm9yKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBzZWxlY3RvciBhbmQgYmxvY2tcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgIHdoaWxlKHRydWUpe1xuICAgICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgIGlmKCBub3RoaW5nTGVmdFRvUGFyc2UgKXsgYnJlYWs7IH1cblxuICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCgvXlxccyooLis/KVxccyo6XFxzKiguKz8pXFxzKjsvKTtcblxuICAgICAgaWYoICFwcm9wQW5kVmFsICl7XG4gICAgICAgIHV0aWwuZXJyb3IoJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgZm9ybWF0dGluZyBvZiBzdHlsZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVmaW5pdGlvbnMgZm91bmQgaW46JyArIGJsb2NrU3RyKTtcbiAgICAgICAgaW52YWxpZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByb3BBbmRWYWxTdHIgPSBwcm9wQW5kVmFsWzBdO1xuICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgdmFyIHZhbFN0ciA9IHByb3BBbmRWYWxbMl07XG5cbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzWyBwcm9wU3RyIF07XG4gICAgICBpZiggIXByb3AgKXtcbiAgICAgICAgdXRpbC5lcnJvcignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJzZWRQcm9wID0gc3R5bGUucGFyc2UoIHByb3BTdHIsIHZhbFN0ciApO1xuXG4gICAgICBpZiggIXBhcnNlZFByb3AgKXtcbiAgICAgICAgdXRpbC5lcnJvcignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgZGVmaW5pdGlvbiBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHByb3BzLnB1c2goe1xuICAgICAgICBuYW1lOiBwcm9wU3RyLFxuICAgICAgICB2YWw6IHZhbFN0clxuICAgICAgfSk7XG4gICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgIH1cblxuICAgIGlmKCBpbnZhbGlkQmxvY2sgKXtcbiAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gcHV0IHRoZSBwYXJzZWQgYmxvY2sgaW4gdGhlIHN0eWxlXG4gICAgc3R5bGUuc2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIHN0eWxlLmNzcyggcHJvcC5uYW1lLCBwcm9wLnZhbCApO1xuICAgIH1cblxuICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxuc3R5Zm4uZnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgdmFyIHN0eWxlID0gdGhpcztcblxuICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuICBzdHlsZS5hcHBseUZyb21TdHJpbmcoIHN0cmluZyApO1xuXG4gIHJldHVybiBzdHlsZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3R5Zm47XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgU3R5bGUgPSByZXF1aXJlKCcuL3N0eWxlJyk7XG5cbi8vIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3QgdGhhdCBkb2Vzbid0IG5lZWQgYSByZWZlcmVuY2UgdG8gdGhlIGNvcmVcbi8vICh1c2VmdWwgZm9yIGluaXQpXG52YXIgU3R5bGVzaGVldCA9IGZ1bmN0aW9uKCl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBTdHlsZXNoZWV0KSApe1xuICAgIHJldHVybiBuZXcgU3R5bGVzaGVldCgpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxudmFyIHNoZWV0Zm4gPSBTdHlsZXNoZWV0LnByb3RvdHlwZTtcblxuc2hlZXRmbi5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAnc3R5bGVzaGVldCc7XG59O1xuXG4vLyBqdXN0IHN0b3JlIHRoZSBzZWxlY3RvciB0byBiZSBwYXJzZWQgbGF0ZXJcbnNoZWV0Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuXG4gIHRoaXNbaV0gPSB7XG4gICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFtdXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vLyBqdXN0IHN0b3JlIHRoZSBwcm9wZXJ0eSB0byBiZSBwYXJzZWQgbGF0ZXJcbnNoZWV0Zm4uY3NzID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICl7XG4gIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gIGlmKCBpcy5zdHJpbmcobmFtZSkgKXtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiggaXMucGxhaW5PYmplY3QobmFtZSkgKXtcbiAgICB2YXIgbWFwID0gbmFtZTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgU3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBTdHlsZS5wcm9wZXJ0aWVzW2pdO1xuICAgICAgdmFyIG1hcFZhbCA9IG1hcFsgcHJvcC5uYW1lIF07XG5cbiAgICAgIGlmKCBtYXBWYWwgPT09IHVuZGVmaW5lZCApeyAvLyBhbHNvIHRyeSBjYW1lbCBjYXNlIG5hbWVcbiAgICAgICAgbWFwVmFsID0gbWFwWyB1dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdO1xuICAgICAgfVxuXG4gICAgICBpZiggbWFwVmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1hcFZhbDtcblxuICAgICAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG5zaGVldGZuLnN0eWxlID0gc2hlZXRmbi5jc3M7XG5cbi8vIGdlbmVyYXRlIGEgcmVhbCBzdHlsZSBvYmplY3QgZnJvbSB0aGUgZHVtbXkgc3R5bGVzaGVldFxuc2hlZXRmbi5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24oIGN5ICl7XG4gIHZhciBzdHlsZSA9IG5ldyBTdHlsZShjeSk7XG5cbiAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuXG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgc3R5bGUuY3NzKCBwcm9wLm5hbWUsIHByb3AudmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0eWxlc2hlZXQ7XG4iLCIvLyBjcm9zcy1lbnYgdGhyZWFkL3dvcmtlclxuLy8gTkIgOiB1c2VzIChoZWF2eXdlaWdodCkgcHJvY2Vzc2VzIG9uIG5vZGVqcyBzbyBiZXN0IG5vdCB0byBjcmVhdGUgdG9vIG1hbnkgdGhyZWFkc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3aW5kb3cgPSByZXF1aXJlKCcuL3dpbmRvdycpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyk7XG52YXIgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnLi9kZWZpbmUnKTtcbnZhciBpcyA9IHJlcXVpcmUoJy4vaXMnKTtcblxudmFyIFRocmVhZCA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiBUaHJlYWQpICl7XG4gICAgcmV0dXJuIG5ldyBUaHJlYWQoIG9wdHMgKTtcbiAgfVxuXG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgcmVxdWlyZXM6IFtdLFxuICAgIGZpbGVzOiBbXSxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBwYXNzOiBbXSxcbiAgICBkaXNhYmxlZDogZmFsc2VcbiAgfTtcblxuICBpZiggaXMucGxhaW5PYmplY3Qob3B0cykgKXtcbiAgICBpZiggb3B0cy5kaXNhYmxlZCAhPSBudWxsICl7XG4gICAgICBfcC5kaXNhYmxlZCA9ICEhb3B0cy5kaXNhYmxlZDtcbiAgICB9XG4gIH1cblxufTtcblxudmFyIHRoZGZuID0gVGhyZWFkLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxudmFyIHN0cmluZ2lmeUZpZWxkVmFsID0gZnVuY3Rpb24oIHZhbCApe1xuICB2YXIgdmFsU3RyID0gaXMuZm4oIHZhbCApID8gdmFsLnRvU3RyaW5nKCkgOiBcIkpTT04ucGFyc2UoJ1wiICsgSlNPTi5zdHJpbmdpZnkodmFsKSArIFwiJylcIjtcblxuICByZXR1cm4gdmFsU3RyO1xufTtcblxuLy8gYWxsb3dzIGZvciByZXF1aXJlcyB3aXRoIHByb3RvdHlwZXMgYW5kIHN1Ym9ianMgZXRjXG52YXIgZm5Bc1JlcXVpcmUgPSBmdW5jdGlvbiggZm4gKXtcbiAgdmFyIHJlcTtcbiAgdmFyIGZuTmFtZTtcblxuICBpZiggaXMub2JqZWN0KGZuKSAmJiBmbi5mbiApeyAvLyBtYW51YWwgZm5cbiAgICByZXEgPSBmbkFzKCBmbi5mbiwgZm4ubmFtZSApO1xuICAgIGZuTmFtZSA9IGZuLm5hbWU7XG4gICAgZm4gPSBmbi5mbjtcbiAgfSBlbHNlIGlmKCBpcy5mbihmbikgKXsgLy8gYXV0byBmblxuICAgIHJlcSA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgfSBlbHNlIGlmKCBpcy5zdHJpbmcoZm4pICl7IC8vIHN0cmluZ2lmaWVkIGZuXG4gICAgcmVxID0gZm47XG4gIH0gZWxzZSBpZiggaXMub2JqZWN0KGZuKSApeyAvLyBwbGFpbiBvYmplY3RcbiAgICBpZiggZm4ucHJvdG8gKXtcbiAgICAgIHJlcSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXEgPSBmbi5uYW1lICsgJyA9IHt9Oyc7XG4gICAgfVxuXG4gICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgICBmbiA9IGZuLm9iajtcbiAgfVxuXG4gIHJlcSArPSAnXFxuJztcblxuICB2YXIgcHJvdG9yZXEgPSBmdW5jdGlvbiggdmFsLCBzdWJuYW1lICl7XG4gICAgaWYoIHZhbC5wcm90b3R5cGUgKXtcbiAgICAgIHZhciBwcm90b05vbmVtcHR5ID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBwcm9wIGluIHZhbC5wcm90b3R5cGUgKXsgcHJvdG9Ob25lbXB0eSA9IHRydWU7IGJyZWFrOyB9IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgICBpZiggcHJvdG9Ob25lbXB0eSApe1xuICAgICAgICByZXEgKz0gZm5Bc1JlcXVpcmUoIHtcbiAgICAgICAgICBuYW1lOiBzdWJuYW1lLFxuICAgICAgICAgIG9iajogdmFsLFxuICAgICAgICAgIHByb3RvOiB0cnVlXG4gICAgICAgIH0sIHZhbCApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBwdWxsIGluIHByb3RvdHlwZVxuICBpZiggZm4ucHJvdG90eXBlICYmIGZuTmFtZSAhPSBudWxsICl7XG5cbiAgICBmb3IoIHZhciBuYW1lIGluIGZuLnByb3RvdHlwZSApe1xuICAgICAgdmFyIHByb3RvU3RyID0gJyc7XG5cbiAgICAgIHZhciB2YWwgPSBmbi5wcm90b3R5cGVbIG5hbWUgXTtcbiAgICAgIHZhciB2YWxTdHIgPSBzdHJpbmdpZnlGaWVsZFZhbCggdmFsICk7XG4gICAgICB2YXIgc3VibmFtZSA9IGZuTmFtZSArICcucHJvdG90eXBlLicgKyBuYW1lO1xuXG4gICAgICBwcm90b1N0ciArPSBzdWJuYW1lICsgJyA9ICcgKyB2YWxTdHIgKyAnO1xcbic7XG5cbiAgICAgIGlmKCBwcm90b1N0ciApe1xuICAgICAgICByZXEgKz0gcHJvdG9TdHI7XG4gICAgICB9XG5cbiAgICAgIHByb3RvcmVxKCB2YWwsIHN1Ym5hbWUgKTsgLy8gc3Vib2JqZWN0IHdpdGggcHJvdG90eXBlXG4gICAgfVxuXG4gIH1cblxuICAvLyBwdWxsIGluIHByb3BlcnRpZXMgZm9yIG9iai9mbnNcbiAgaWYoICFpcy5zdHJpbmcoZm4pICl7IGZvciggdmFyIG5hbWUgaW4gZm4gKXtcbiAgICB2YXIgcHJvcHNTdHIgPSAnJztcblxuICAgIGlmKCBmbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSApe1xuICAgICAgdmFyIHZhbCA9IGZuWyBuYW1lIF07XG4gICAgICB2YXIgdmFsU3RyID0gc3RyaW5naWZ5RmllbGRWYWwoIHZhbCApO1xuICAgICAgdmFyIHN1Ym5hbWUgPSBmbk5hbWUgKyAnW1wiJyArIG5hbWUgKyAnXCJdJztcblxuICAgICAgcHJvcHNTdHIgKz0gc3VibmFtZSArICcgPSAnICsgdmFsU3RyICsgJztcXG4nO1xuICAgIH1cblxuICAgIGlmKCBwcm9wc1N0ciApe1xuICAgICAgcmVxICs9IHByb3BzU3RyO1xuICAgIH1cblxuICAgIHByb3RvcmVxKCB2YWwsIHN1Ym5hbWUgKTsgLy8gc3Vib2JqZWN0IHdpdGggcHJvdG90eXBlXG4gIH0gfVxuXG4gIHJldHVybiByZXE7XG59O1xuXG52YXIgaXNQYXRoU3RyID0gZnVuY3Rpb24oIHN0ciApe1xuICByZXR1cm4gaXMuc3RyaW5nKHN0cikgJiYgc3RyLm1hdGNoKC9cXC5qcyQvKTtcbn07XG5cbnV0aWwuZXh0ZW5kKHRoZGZuLCB7XG5cbiAgaW5zdGFuY2VTdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiAndGhyZWFkJzsgfSxcblxuICByZXF1aXJlOiBmdW5jdGlvbiggZm4sIGFzICl7XG4gICAgdmFyIHJlcXVpcmVzID0gdGhpcy5fcHJpdmF0ZS5yZXF1aXJlcztcblxuICAgIGlmKCBpc1BhdGhTdHIoZm4pICl7XG4gICAgICB0aGlzLl9wcml2YXRlLmZpbGVzLnB1c2goIGZuICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmKCBhcyApe1xuICAgICAgaWYoIGlzLmZuKGZuKSApe1xuICAgICAgICBmbiA9IHsgbmFtZTogYXMsIGZuOiBmbiB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4gPSB7IG5hbWU6IGFzLCBvYmo6IGZuIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCBpcy5mbihmbikgKXtcbiAgICAgICAgaWYoICFmbi5uYW1lICl7XG4gICAgICAgICAgdGhyb3cgJ1RoZSBmdW5jdGlvbiBuYW1lIGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGRldGVybWluZWQuICBVc2UgdGhyZWFkLnJlcXVpcmUoIHNvbWVGdW5jdGlvbiwgXCJzb21lRnVuY3Rpb25cIiApJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZuID0geyBuYW1lOiBmbi5uYW1lLCBmbjogZm4gfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1aXJlcy5wdXNoKCBmbiApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcGFzczogZnVuY3Rpb24oIGRhdGEgKXtcbiAgICB0aGlzLl9wcml2YXRlLnBhc3MucHVzaCggZGF0YSApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgcnVuOiBmdW5jdGlvbiggZm4sIHBhc3MgKXsgLy8gZm4gdXNlZCBsaWtlIG1haW4oKVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHBhc3MgPSBwYXNzIHx8IF9wLnBhc3Muc2hpZnQoKTtcblxuICAgIGlmKCBfcC5zdG9wcGVkICl7XG4gICAgICB0aHJvdyAnQXR0ZW1wdGVkIHRvIHJ1biBhIHN0b3BwZWQgdGhyZWFkISAgU3RhcnQgYSBuZXcgdGhyZWFkIG9yIGRvIG5vdCBzdG9wIHRoZSBleGlzdGluZyB0aHJlYWQgYW5kIHJldXNlIGl0Lic7XG4gICAgfVxuXG4gICAgaWYoIF9wLnJ1bm5pbmcgKXtcbiAgICAgIHJldHVybiAoIF9wLnF1ZXVlID0gX3AucXVldWUudGhlbihmdW5jdGlvbigpeyAvLyBpbmR1Y3RpdmUgc3RlcFxuICAgICAgICByZXR1cm4gc2VsZi5ydW4oIGZuLCBwYXNzICk7XG4gICAgICB9KSApO1xuICAgIH1cblxuICAgIHZhciB1c2VXVyA9IHdpbmRvdyAhPSBudWxsICYmICFfcC5kaXNhYmxlZDtcbiAgICB2YXIgdXNlTm9kZSA9ICF3aW5kb3cgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIV9wLmRpc2FibGVkO1xuXG4gICAgc2VsZi50cmlnZ2VyKCdydW4nKTtcblxuICAgIHZhciBydW5QID0gbmV3IFByb21pc2UoZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApe1xuXG4gICAgICBfcC5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgdmFyIHRocmVhZFRlY2hBbHJlYWR5RXhpc3RzID0gX3AucmFuO1xuXG4gICAgICB2YXIgZm5JbXBsU3RyID0gaXMuc3RyaW5nKCBmbiApID8gZm4gOiBmbi50b1N0cmluZygpO1xuXG4gICAgICAvLyB3b3JrZXIgY29kZSB0byBleGVjXG4gICAgICB2YXIgZm5TdHIgPSAnXFxuJyArICggX3AucmVxdWlyZXMubWFwKGZ1bmN0aW9uKCByICl7XG4gICAgICAgIHJldHVybiBmbkFzUmVxdWlyZSggciApO1xuICAgICAgfSkgKS5jb25jYXQoIF9wLmZpbGVzLm1hcChmdW5jdGlvbiggZiApe1xuICAgICAgICBpZiggdXNlV1cgKXtcbiAgICAgICAgICB2YXIgd3dpZnlGaWxlID0gZnVuY3Rpb24oIGZpbGUgKXtcbiAgICAgICAgICAgIGlmKCBmaWxlLm1hdGNoKC9eXFwuXFwvLykgfHwgZmlsZS5tYXRjaCgvXlxcLlxcLi8pICl7XG4gICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgZmlsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggZmlsZS5tYXRjaCgvXlxcLy8pICl7XG4gICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgJy8nICsgZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICByZXR1cm4gJ2ltcG9ydFNjcmlwdHMoXCInICsgd3dpZnlGaWxlKGYpICsgJ1wiKTsnO1xuICAgICAgICB9IGVsc2UgaWYoIHVzZU5vZGUgKSB7XG4gICAgICAgICAgcmV0dXJuICdldmFsKCByZXF1aXJlKFwiZnNcIikucmVhZEZpbGVTeW5jKFwiJyArIGYgKyAnXCIsIHsgZW5jb2Rpbmc6IFwidXRmOFwiIH0pICk7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyAnRXh0ZXJuYWwgZmlsZSBgJyArIGYgKyAnYCBjYW4gbm90IGJlIHJlcXVpcmVkIHdpdGhvdXQgYW55IHRocmVhZGluZyB0ZWNobm9sb2d5Lic7XG4gICAgICAgIH1cbiAgICAgIH0pICkuY29uY2F0KFtcbiAgICAgICAgJyggZnVuY3Rpb24oKXsnLFxuICAgICAgICAgICd2YXIgcmV0ID0gKCcgKyBmbkltcGxTdHIgKyAnKSgnICsgSlNPTi5zdHJpbmdpZnkocGFzcykgKyAnKTsnLFxuICAgICAgICAgICdpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgcmVzb2x2ZShyZXQpOyB9JywgLy8gYXNzdW1lIGlmIHJhbiBmbiByZXR1cm5zIGRlZmluZWQgdmFsdWUgKGluY2wuIG51bGwpLCB0aGF0IHdlIHdhbnQgdG8gcmVzb2x2ZSB0byBpdFxuICAgICAgICAnfSApKClcXG4nXG4gICAgICBdKS5qb2luKCdcXG4nKTtcblxuICAgICAgLy8gYmVjYXVzZSB3ZSd2ZSBub3cgY29uc3VtZWQgdGhlIHJlcXVpcmVzLCBlbXB0eSB0aGUgbGlzdCBzbyB3ZSBkb24ndCBkdXBlIG9uIG5leHQgcnVuKClcbiAgICAgIF9wLnJlcXVpcmVzID0gW107XG4gICAgICBfcC5maWxlcyA9IFtdO1xuXG4gICAgICBpZiggdXNlV1cgKXtcbiAgICAgICAgdmFyIGZuQmxvYiwgZm5Vcmw7XG5cbiAgICAgICAgLy8gYWRkIG5vcm1hbGlzZWQgdGhyZWFkIGFwaSBmdW5jdGlvbnNcbiAgICAgICAgaWYoICF0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyApe1xuICAgICAgICAgIHZhciBmblByZSA9IGZuU3RyICsgJyc7XG5cbiAgICAgICAgICBmblN0ciA9IFtcbiAgICAgICAgICAgICdmdW5jdGlvbiBfcmVmXyhvKXsgcmV0dXJuIGV2YWwobyk7IH07JyxcbiAgICAgICAgICAgICdmdW5jdGlvbiBicm9hZGNhc3QobSl7IHJldHVybiBtZXNzYWdlKG0pOyB9OycsIC8vIGFsaWFzXG4gICAgICAgICAgICAnZnVuY3Rpb24gbWVzc2FnZShtKXsgcG9zdE1lc3NhZ2UobSk7IH07JyxcbiAgICAgICAgICAgICdmdW5jdGlvbiBsaXN0ZW4oZm4peycsXG4gICAgICAgICAgICAnICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKG0peyAnLFxuICAgICAgICAgICAgJyAgICBpZiggdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgKG0uZGF0YS4kJGV2YWwgfHwgbS5kYXRhID09PSBcIiQkc3RhcnRcIikgKXsnLFxuICAgICAgICAgICAgJyAgICB9IGVsc2UgeyAnLFxuICAgICAgICAgICAgJyAgICAgIGZuKCBtLmRhdGEgKTsnLFxuICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICcgIH0pOycsXG4gICAgICAgICAgICAnfTsnLFxuICAgICAgICAgICAgJ3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24obSl7ICBpZiggbS5kYXRhLiQkZXZhbCApeyBldmFsKCBtLmRhdGEuJCRldmFsICk7IH0gIH0pOycsXG4gICAgICAgICAgICAnZnVuY3Rpb24gcmVzb2x2ZSh2KXsgcG9zdE1lc3NhZ2UoeyAkJHJlc29sdmU6IHYgfSk7IH07JyxcbiAgICAgICAgICAgICdmdW5jdGlvbiByZWplY3Qodil7IHBvc3RNZXNzYWdlKHsgJCRyZWplY3Q6IHYgfSk7IH07J1xuICAgICAgICAgIF0uam9pbignXFxuJyk7XG5cbiAgICAgICAgICBmblN0ciArPSBmblByZTtcblxuICAgICAgICAgIGZuQmxvYiA9IG5ldyBCbG9iKFsgZm5TdHIgXSwge1xuICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm5VcmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCggZm5CbG9iICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIHdlYndvcmtlciBhbmQgbGV0IGl0IGV4ZWMgdGhlIHNlcmlhbGlzZWQgY29kZVxuICAgICAgICB2YXIgd3cgPSBfcC53ZWJ3b3JrZXIgPSBfcC53ZWJ3b3JrZXIgfHwgbmV3IFdvcmtlciggZm5VcmwgKTtcblxuICAgICAgICBpZiggdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgKXsgLy8gdGhlbiBqdXN0IGV4ZWMgbmV3IHJ1bigpIGNvZGVcbiAgICAgICAgICB3dy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAkJGV2YWw6IGZuU3RyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3b3JrZXIgbWVzc2FnZXMgPT4gZXZlbnRzXG4gICAgICAgIHZhciBjYjtcbiAgICAgICAgd3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGNiID0gZnVuY3Rpb24oIG0gKXtcbiAgICAgICAgICB2YXIgaXNPYmplY3QgPSBpcy5vYmplY3QobSkgJiYgaXMub2JqZWN0KCBtLmRhdGEgKTtcblxuICAgICAgICAgIGlmKCBpc09iamVjdCAmJiAoJyQkcmVzb2x2ZScgaW4gbS5kYXRhKSApe1xuICAgICAgICAgICAgd3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGNiKTsgLy8gZG9uZSBsaXN0ZW5pbmcgYi9jIHJlc29sdmUoKVxuXG4gICAgICAgICAgICByZXNvbHZlKCBtLmRhdGEuJCRyZXNvbHZlICk7XG4gICAgICAgICAgfSBlbHNlIGlmKCBpc09iamVjdCAmJiAoJyQkcmVqZWN0JyBpbiBtLmRhdGEpICl7XG4gICAgICAgICAgICB3dy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVqZWN0KClcblxuICAgICAgICAgICAgcmVqZWN0KCBtLmRhdGEuJCRyZWplY3QgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCBuZXcgRXZlbnQobSwgeyB0eXBlOiAnbWVzc2FnZScsIG1lc3NhZ2U6IG0uZGF0YSB9KSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGlmKCAhdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgKXtcbiAgICAgICAgICB3dy5wb3N0TWVzc2FnZSgnJCRzdGFydCcpOyAvLyBzdGFydCB1cCB0aGUgd29ya2VyXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmKCB1c2VOb2RlICl7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBwcm9jZXNzXG5cbiAgICAgICAgaWYoICFfcC5jaGlsZCApe1xuICAgICAgICAgIF9wLmNoaWxkID0gKCByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuZm9yayggcmVxdWlyZSgncGF0aCcpLmpvaW4oX19kaXJuYW1lLCAndGhyZWFkLW5vZGUtZm9yaycpICkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZCA9IF9wLmNoaWxkO1xuXG4gICAgICAgIC8vIGNoaWxkIHByb2Nlc3MgbWVzc2FnZXMgPT4gZXZlbnRzXG4gICAgICAgIHZhciBjYjtcbiAgICAgICAgY2hpbGQub24oJ21lc3NhZ2UnLCBjYiA9IGZ1bmN0aW9uKCBtICl7XG4gICAgICAgICAgaWYoIGlzLm9iamVjdChtKSAmJiAoJyQkcmVzb2x2ZScgaW4gbSkgKXtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVzb2x2ZSgpXG5cbiAgICAgICAgICAgIHJlc29sdmUoIG0uJCRyZXNvbHZlICk7XG4gICAgICAgICAgfSBlbHNlIGlmKCBpcy5vYmplY3QobSkgJiYgKCckJHJlamVjdCcgaW4gbSkgKXtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVqZWN0KClcblxuICAgICAgICAgICAgcmVqZWN0KCBtLiQkcmVqZWN0ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYudHJpZ2dlciggbmV3IEV2ZW50KHt9LCB7IHR5cGU6ICdtZXNzYWdlJywgbWVzc2FnZTogbSB9KSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYXNrIHRoZSBjaGlsZCBwcm9jZXNzIHRvIGV2YWwgdGhlIHdvcmtlciBjb2RlXG4gICAgICAgIGNoaWxkLnNlbmQoe1xuICAgICAgICAgICQkZXZhbDogZm5TdHJcbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIHVzZSBhIGZhbGxiYWNrIG1lY2hhbmlzbSB1c2luZyBhIHRpbWVvdXRcblxuICAgICAgICB2YXIgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB2YXIgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcblxuICAgICAgICB2YXIgdGltZXIgPSBfcC50aW1lciA9IF9wLnRpbWVyIHx8IHtcblxuICAgICAgICAgIGxpc3RlbmVyczogW10sXG5cbiAgICAgICAgICBleGVjOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gYXMgYSBzdHJpbmcgc28gaXQgY2FuJ3QgYmUgbWFuZ2xlZCBieSBtaW5pZmllcnMgYW5kIHByb2Nlc3NvcnNcbiAgICAgICAgICAgIGZuU3RyID0gW1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gX3JlZl8obyl7IHJldHVybiBldmFsKG8pOyB9OycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBicm9hZGNhc3QobSl7IHJldHVybiBtZXNzYWdlKG0pOyB9OycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBtZXNzYWdlKG0peyBzZWxmLnRyaWdnZXIoIG5ldyBFdmVudCh7fSwgeyB0eXBlOiBcIm1lc3NhZ2VcIiwgbWVzc2FnZTogbSB9KSApOyB9OycsXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBsaXN0ZW4oZm4peyB0aW1lci5saXN0ZW5lcnMucHVzaCggZm4gKTsgfTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gcmVzb2x2ZSh2KXsgcHJvbWlzZVJlc29sdmUodik7IH07JyxcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIHJlamVjdCh2KXsgcHJvbWlzZVJlamVjdCh2KTsgfTsnXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpICsgZm5TdHI7XG5cbiAgICAgICAgICAgIC8vIHRoZSAucnVuKCkgY29kZVxuICAgICAgICAgICAgZXZhbCggZm5TdHIgKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgfSxcblxuICAgICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uKCBtICl7XG4gICAgICAgICAgICB2YXIgbHMgPSB0aW1lci5saXN0ZW5lcnM7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIGZuID0gbHNbaV07XG5cbiAgICAgICAgICAgICAgZm4oIG0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aW1lci5leGVjKCk7XG4gICAgICB9XG5cbiAgICB9KS50aGVuKGZ1bmN0aW9uKCB2ICl7XG4gICAgICBfcC5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBfcC5yYW4gPSB0cnVlO1xuXG4gICAgICBzZWxmLnRyaWdnZXIoJ3JhbicpO1xuXG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcblxuICAgIGlmKCBfcC5xdWV1ZSA9PSBudWxsICl7XG4gICAgICBfcC5xdWV1ZSA9IHJ1blA7IC8vIGkuZS4gZmlyc3Qgc3RlcCBvZiBpbmR1Y3RpdmUgcHJvbWlzZSBjaGFpbiAoZm9yIHF1ZXVlKVxuICAgIH1cblxuICAgIHJldHVybiBydW5QO1xuICB9LFxuXG4gIC8vIHNlbmQgdGhlIHRocmVhZCBhIG1lc3NhZ2VcbiAgbWVzc2FnZTogZnVuY3Rpb24oIG0gKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLndlYndvcmtlciApe1xuICAgICAgX3Aud2Vid29ya2VyLnBvc3RNZXNzYWdlKCBtICk7XG4gICAgfVxuXG4gICAgaWYoIF9wLmNoaWxkICl7XG4gICAgICBfcC5jaGlsZC5zZW5kKCBtICk7XG4gICAgfVxuXG4gICAgaWYoIF9wLnRpbWVyICl7XG4gICAgICBfcC50aW1lci5tZXNzYWdlKCBtICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgaWYoIF9wLndlYndvcmtlciApe1xuICAgICAgX3Aud2Vid29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIH1cblxuICAgIGlmKCBfcC5jaGlsZCApe1xuICAgICAgX3AuY2hpbGQua2lsbCgpO1xuICAgIH1cblxuICAgIGlmKCBfcC50aW1lciApe1xuICAgICAgLy8gbm90aGluZyB3ZSBjYW4gZG8gaWYgd2UndmUgcnVuIGEgdGltZW91dFxuICAgIH1cblxuICAgIF9wLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlcignc3RvcCcpOyAvLyBjaGFpbmluZ1xuICB9LFxuXG4gIHN0b3BwZWQ6IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3RvcHBlZDtcbiAgfVxuXG59KTtcblxuLy8gdHVybnMgYSBzdHJpbmdpZmllZCBmdW5jdGlvbiBpbnRvIGEgKHJlKW5hbWVkIGZ1bmN0aW9uXG52YXIgZm5BcyA9IGZ1bmN0aW9uKCBmbiwgbmFtZSApe1xuICB2YXIgZm5TdHIgPSBmbi50b1N0cmluZygpO1xuICBmblN0ciA9IGZuU3RyLnJlcGxhY2UoL2Z1bmN0aW9uXFxzKj9cXFMqP1xccyo/XFwoLywgJ2Z1bmN0aW9uICcgKyBuYW1lICsgJygnKTtcblxuICByZXR1cm4gZm5TdHI7XG59O1xuXG52YXIgZGVmaW5lRm5hbCA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHJldHVybiBmdW5jdGlvbiBmbmFsSW1wbCggZm4sIGFyZzEgKXtcbiAgICB2YXIgZm5TdHIgPSBmbkFzKCBmbiwgJ18kXyRfJyArIG9wdHMubmFtZSApO1xuXG4gICAgdGhpcy5yZXF1aXJlKCBmblN0ciApO1xuXG4gICAgcmV0dXJuIHRoaXMucnVuKCBbXG4gICAgICAnZnVuY3Rpb24oIGRhdGEgKXsnLFxuICAgICAgJyAgdmFyIG9yaWdSZXNvbHZlID0gcmVzb2x2ZTsnLFxuICAgICAgJyAgdmFyIHJlcyA9IFtdOycsXG4gICAgICAnICAnLFxuICAgICAgJyAgcmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWwgKXsnLFxuICAgICAgJyAgICByZXMucHVzaCggdmFsICk7JyxcbiAgICAgICcgIH07JyxcbiAgICAgICcgICcsXG4gICAgICAnICB2YXIgcmV0ID0gZGF0YS4nICsgb3B0cy5uYW1lICsgJyggXyRfJF8nICsgb3B0cy5uYW1lICsgKCBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICcsICcgKyBKU09OLnN0cmluZ2lmeShhcmcxKSA6ICcnICkgKyAnICk7JyxcbiAgICAgICcgICcsXG4gICAgICAnICByZXNvbHZlID0gb3JpZ1Jlc29sdmU7JyxcbiAgICAgICcgIHJlc29sdmUoIHJlcy5sZW5ndGggPiAwID8gcmVzIDogcmV0ICk7JyxcbiAgICAgICd9J1xuICAgIF0uam9pbignXFxuJykgKTtcbiAgfTtcbn07XG5cbnV0aWwuZXh0ZW5kKHRoZGZuLCB7XG4gIHJlZHVjZTogZGVmaW5lRm5hbCh7IG5hbWU6ICdyZWR1Y2UnIH0pLFxuXG4gIHJlZHVjZVJpZ2h0OiBkZWZpbmVGbmFsKHsgbmFtZTogJ3JlZHVjZVJpZ2h0JyB9KSxcblxuICBtYXA6IGRlZmluZUZuYWwoeyBuYW1lOiAnbWFwJyB9KVxufSk7XG5cbi8vIGFsaWFzZXNcbnZhciBmbiA9IHRoZGZuO1xuZm4ucHJvbWlzZSA9IGZuLnJ1bjtcbmZuLnRlcm1pbmF0ZSA9IGZuLmhhbHQgPSBmbi5zdG9wO1xuZm4uaW5jbHVkZSA9IGZuLnJlcXVpcmU7XG5cbi8vIHB1bGwgaW4gZXZlbnQgYXBpc1xudXRpbC5leHRlbmQodGhkZm4sIHtcbiAgb246IGRlZmluZS5vbigpLFxuICBvbmU6IGRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gIG9mZjogZGVmaW5lLm9mZigpLFxuICB0cmlnZ2VyOiBkZWZpbmUudHJpZ2dlcigpXG59KTtcblxuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCB0aGRmbiApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRocmVhZDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGdldCBbciwgZywgYl0gZnJvbSAjYWJjIG9yICNhYWJiY2NcbiAgaGV4MnR1cGxlOiBmdW5jdGlvbiggaGV4ICl7XG4gICAgaWYoICEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09IFwiI1wiICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHNob3J0SGV4ID0gaGV4Lmxlbmd0aCA9PT0gNDtcbiAgICB2YXIgciwgZywgYjtcbiAgICB2YXIgYmFzZSA9IDE2O1xuXG4gICAgaWYoIHNob3J0SGV4ICl7XG4gICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsxXSwgYmFzZSApO1xuICAgICAgZyA9IHBhcnNlSW50KCBoZXhbMl0gKyBoZXhbMl0sIGJhc2UgKTtcbiAgICAgIGIgPSBwYXJzZUludCggaGV4WzNdICsgaGV4WzNdLCBiYXNlICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBwYXJzZUludCggaGV4WzFdICsgaGV4WzJdLCBiYXNlICk7XG4gICAgICBnID0gcGFyc2VJbnQoIGhleFszXSArIGhleFs0XSwgYmFzZSApO1xuICAgICAgYiA9IHBhcnNlSW50KCBoZXhbNV0gKyBoZXhbNl0sIGJhc2UgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9LFxuXG4gIC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSBoc2woMCwgMCwgMCkgb3IgaHNsYSgwLCAwLCAwLCAwKVxuICBoc2wydHVwbGU6IGZ1bmN0aW9uKCBoc2wgKXtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBoLCBzLCBsLCBhLCByLCBnLCBiO1xuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCl7XG4gICAgICBpZih0IDwgMCkgdCArPSAxO1xuICAgICAgaWYodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYodCA8IDEvMikgcmV0dXJuIHE7XG4gICAgICBpZih0IDwgMi8zKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMi8zIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgdmFyIG0gPSBuZXcgUmVnRXhwKFwiXlwiICsgdGhpcy5yZWdleC5oc2xhICsgXCIkXCIpLmV4ZWMoaHNsKTtcbiAgICBpZiggbSApe1xuXG4gICAgICAvLyBnZXQgaHVlXG4gICAgICBoID0gcGFyc2VJbnQoIG1bMV0gKTtcbiAgICAgIGlmKCBoIDwgMCApe1xuICAgICAgICBoID0gKCAzNjAgLSAoLTEqaCAlIDM2MCkgKSAlIDM2MDtcbiAgICAgIH0gZWxzZSBpZiggaCA+IDM2MCApe1xuICAgICAgICBoID0gaCAlIDM2MDtcbiAgICAgIH1cbiAgICAgIGggLz0gMzYwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIHMgPSBwYXJzZUZsb2F0KCBtWzJdICk7XG4gICAgICBpZiggcyA8IDAgfHwgcyA+IDEwMCApeyByZXR1cm47IH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuICAgICAgcyA9IHMvMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgIGwgPSBwYXJzZUZsb2F0KCBtWzNdICk7XG4gICAgICBpZiggbCA8IDAgfHwgbCA+IDEwMCApeyByZXR1cm47IH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG4gICAgICBsID0gbC8xMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgYSA9IG1bNF07XG4gICAgICBpZiggYSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGEgPSBwYXJzZUZsb2F0KCBhICk7XG5cbiAgICAgICAgaWYoIGEgPCAwIHx8IGEgPiAxICl7IHJldHVybjsgfSAvLyBhbHBoYSBpcyBbMCwgMV1cbiAgICAgIH1cblxuICAgICAgLy8gbm93LCBjb252ZXJ0IHRvIHJnYlxuICAgICAgLy8gY29kZSBmcm9tIGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHRcbiAgICAgIGlmKCBzID09PSAwICl7XG4gICAgICAgIHIgPSBnID0gYiA9IE1hdGgucm91bmQobCAqIDI1NSk7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgIHIgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKHAsIHEsIGggKyAxLzMpICk7XG4gICAgICAgIGcgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKHAsIHEsIGgpICk7XG4gICAgICAgIGIgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKHAsIHEsIGggLSAxLzMpICk7XG4gICAgICB9XG5cbiAgICAgIHJldCA9IFtyLCBnLCBiLCBhXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSByZ2IoMCwgMCwgMCkgb3IgcmdiYSgwLCAwLCAwLCAwKVxuICByZ2IydHVwbGU6IGZ1bmN0aW9uKCByZ2IgKXtcbiAgICB2YXIgcmV0O1xuXG4gICAgdmFyIG0gPSBuZXcgUmVnRXhwKFwiXlwiICsgdGhpcy5yZWdleC5yZ2JhICsgXCIkXCIpLmV4ZWMocmdiKTtcbiAgICBpZiggbSApe1xuICAgICAgcmV0ID0gW107XG5cbiAgICAgIHZhciBpc1BjdCA9IFtdO1xuICAgICAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gMzsgaSsrICl7XG4gICAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcblxuICAgICAgICBpZiggY2hhbm5lbFsgY2hhbm5lbC5sZW5ndGggLSAxIF0gPT09IFwiJVwiICl7XG4gICAgICAgICAgaXNQY3RbaV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KCBjaGFubmVsICk7XG5cbiAgICAgICAgaWYoIGlzUGN0W2ldICl7XG4gICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwvMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBjaGFubmVsIDwgMCB8fCBjaGFubmVsID4gMjU1ICl7IHJldHVybjsgfSAvLyBpbnZhbGlkIGNoYW5uZWwgdmFsdWVcblxuICAgICAgICByZXQucHVzaCggTWF0aC5mbG9vcihjaGFubmVsKSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXRMZWFzdE9uZUlzUGN0ID0gaXNQY3RbMV0gfHwgaXNQY3RbMl0gfHwgaXNQY3RbM107XG4gICAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG4gICAgICBpZiggYXRMZWFzdE9uZUlzUGN0ICYmICFhbGxBcmVQY3QgKXsgcmV0dXJuOyB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG4gICAgICB2YXIgYWxwaGEgPSBtWzRdO1xuICAgICAgaWYoIGFscGhhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KCBhbHBoYSApO1xuXG4gICAgICAgIGlmKCBhbHBoYSA8IDAgfHwgYWxwaGEgPiAxICl7IHJldHVybjsgfSAvLyBpbnZhbGlkIGFscGhhIHZhbHVlXG5cbiAgICAgICAgcmV0LnB1c2goIGFscGhhICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBjb2xvcm5hbWUydHVwbGU6IGZ1bmN0aW9uKCBjb2xvciApe1xuICAgIHJldHVybiB0aGlzLmNvbG9yc1sgY29sb3IudG9Mb3dlckNhc2UoKSBdO1xuICB9LFxuXG4gIGNvbG9yMnR1cGxlOiBmdW5jdGlvbiggY29sb3IgKXtcbiAgICByZXR1cm4gKCBpcy5hcnJheShjb2xvcikgPyBjb2xvciA6IG51bGwgKVxuICAgICAgfHwgdGhpcy5jb2xvcm5hbWUydHVwbGUoY29sb3IpXG4gICAgICB8fCB0aGlzLmhleDJ0dXBsZShjb2xvcilcbiAgICAgIHx8IHRoaXMucmdiMnR1cGxlKGNvbG9yKVxuICAgICAgfHwgdGhpcy5oc2wydHVwbGUoY29sb3IpO1xuICB9LFxuXG4gIGNvbG9yczoge1xuICAgIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gICAgdHJhbnNwYXJlbnQ6IFswLCAwLCAwLCAwXSwgLy8gTkIgYWxwaGEgPT09IDBcblxuICAgIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICAgIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxuICAgIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICAgIGFxdWE6IFswLCAyNTUsIDI1NV0sXG4gICAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxuICAgIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gICAgYmVpZ2U6IFsyNDUsIDI0NSwgMjIwXSxcbiAgICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcbiAgICBibGFjazogWzAsIDAsIDBdLFxuICAgIGJsYW5jaGVkYWxtb25kOiBbMjU1LCAyMzUsIDIwNV0sXG4gICAgYmx1ZTogWzAsIDAsIDI1NV0sXG4gICAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gICAgYnJvd246IFsxNjUsIDQyLCA0Ml0sXG4gICAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXG4gICAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgICBjaGFydHJldXNlOiBbMTI3LCAyNTUsIDBdLFxuICAgIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXG4gICAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICAgIGNvcm5mbG93ZXJibHVlOiBbMTAwLCAxNDksIDIzN10sXG4gICAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcbiAgICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICAgIGN5YW46IFswLCAyNTUsIDI1NV0sXG4gICAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICAgIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICAgIGRhcmtnb2xkZW5yb2Q6IFsxODQsIDEzNCwgMTFdLFxuICAgIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgICBkYXJrZ3JleTogWzE2OSwgMTY5LCAxNjldLFxuICAgIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxuICAgIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICAgIGRhcmtvbGl2ZWdyZWVuOiBbODUsIDEwNywgNDddLFxuICAgIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXG4gICAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gICAgZGFya3JlZDogWzEzOSwgMCwgMF0sXG4gICAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxuICAgIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICAgIGRhcmtzbGF0ZWJsdWU6IFs3MiwgNjEsIDEzOV0sXG4gICAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxuICAgIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgICBkYXJrdHVycXVvaXNlOiBbMCwgMjA2LCAyMDldLFxuICAgIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gICAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICAgIGRlZXBza3libHVlOiBbMCwgMTkxLCAyNTVdLFxuICAgIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gICAgZG9kZ2VyYmx1ZTogWzMwLCAxNDQsIDI1NV0sXG4gICAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxuICAgIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG4gICAgZm9yZXN0Z3JlZW46IFszNCwgMTM5LCAzNF0sXG4gICAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcbiAgICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgICBnaG9zdHdoaXRlOiBbMjQ4LCAyNDgsIDI1NV0sXG4gICAgZ29sZDogWzI1NSwgMjE1LCAwXSxcbiAgICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICAgIGdyYXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICAgIGdyZWVueWVsbG93OiBbMTczLCAyNTUsIDQ3XSxcbiAgICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxuICAgIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgICBpbmRpYW5yZWQ6IFsyMDUsIDkyLCA5Ml0sXG4gICAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gICAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICBraGFraTogWzI0MCwgMjMwLCAxNDBdLFxuICAgIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXG4gICAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICAgIGxhd25ncmVlbjogWzEyNCwgMjUyLCAwXSxcbiAgICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcbiAgICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgICBsaWdodGNvcmFsOiBbMjQwLCAxMjgsIDEyOF0sXG4gICAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXG4gICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgICBsaWdodGdyYXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXG4gICAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgbGlnaHRwaW5rOiBbMjU1LCAxODIsIDE5M10sXG4gICAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcbiAgICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgICBsaWdodHNreWJsdWU6IFsxMzUsIDIwNiwgMjUwXSxcbiAgICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxuICAgIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gICAgbGlnaHRzdGVlbGJsdWU6IFsxNzYsIDE5NiwgMjIyXSxcbiAgICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxuICAgIGxpbWU6IFswLCAyNTUsIDBdLFxuICAgIGxpbWVncmVlbjogWzUwLCAyMDUsIDUwXSxcbiAgICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxuICAgIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gICAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXG4gICAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gICAgbWVkaXVtb3JjaGlkOiBbMTg2LCA4NSwgMjExXSxcbiAgICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcbiAgICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gICAgbWVkaXVtc2xhdGVibHVlOiBbMTIzLCAxMDQsIDIzOF0sXG4gICAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXG4gICAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgICBtZWRpdW12aW9sZXRyZWQ6IFsxOTksIDIxLCAxMzNdLFxuICAgIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcbiAgICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgICBtaXN0eXJvc2U6IFsyNTUsIDIyOCwgMjI1XSxcbiAgICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxuICAgIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gICAgbmF2eTogWzAsIDAsIDEyOF0sXG4gICAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxuICAgIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICAgIG9saXZlZHJhYjogWzEwNywgMTQyLCAzNV0sXG4gICAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxuICAgIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICAgIG9yY2hpZDogWzIxOCwgMTEyLCAyMTRdLFxuICAgIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcbiAgICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgICBwYWxldHVycXVvaXNlOiBbMTc1LCAyMzgsIDIzOF0sXG4gICAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxuICAgIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgICBwZWFjaHB1ZmY6IFsyNTUsIDIxOCwgMTg1XSxcbiAgICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcbiAgICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gICAgcGx1bTogWzIyMSwgMTYwLCAyMjFdLFxuICAgIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcbiAgICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gICAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICAgIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxuICAgIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICAgIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICAgIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxuICAgIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gICAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICAgIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICAgIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICAgIHNsYXRlZ3JheTogWzExMiwgMTI4LCAxNDRdLFxuICAgIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuICAgIHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcbiAgICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcbiAgICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICAgIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICAgIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gICAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICAgIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgICB0dXJxdW9pc2U6IFs2NCwgMjI0LCAyMDhdLFxuICAgIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICAgIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gICAgd2hpdGU6IFsyNTUsIDI1NSwgMjU1XSxcbiAgICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICAgIHllbGxvd2dyZWVuOiBbMTU0LCAyMDUsIDUwXVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xudmFyIG1hdGggPSByZXF1aXJlKCcuLi9tYXRoJyk7XG5cbnZhciB1dGlsID0ge1xuXG4gIGZhbHNpZnk6IGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfSxcblxuICB6ZXJvaWZ5OiBmdW5jdGlvbigpeyByZXR1cm4gMDsgfSxcblxuICBub29wOiBmdW5jdGlvbigpe30sXG5cbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICBlcnJvcjogZnVuY3Rpb24oIG1zZyApe1xuICAgIGlmKCBjb25zb2xlLmVycm9yICl7XG4gICAgICBjb25zb2xlLmVycm9yLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcblxuICAgICAgaWYoIGNvbnNvbGUudHJhY2UgKXsgY29uc29sZS50cmFjZSgpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcblxuICAgICAgaWYoIGNvbnNvbGUudHJhY2UgKXsgY29uc29sZS50cmFjZSgpOyB9XG4gICAgfVxuICB9LFxuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIGNsb25lOiBmdW5jdGlvbiggb2JqICl7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKCB7fSwgb2JqICk7XG4gIH0sXG5cbiAgLy8gZ2V0cyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJndW1lbnRcbiAgY29weTogZnVuY3Rpb24oIG9iaiApe1xuICAgIGlmKCBvYmogPT0gbnVsbCApe1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGlmKCBpcy5hcnJheShvYmopICl7XG4gICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmKCBpcy5wbGFpbk9iamVjdChvYmopICl7XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSggb2JqICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XG5cbn07XG5cbnV0aWwubWFrZUJvdW5kaW5nQm94ID0gbWF0aC5tYWtlQm91bmRpbmdCb3guYmluZCggbWF0aCApO1xuXG51dGlsLl9zdGF0aWNFbXB0eU9iamVjdCA9IHt9O1xuXG51dGlsLnN0YXRpY0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHV0aWwuX3N0YXRpY0VtcHR5T2JqZWN0O1xufTtcblxudXRpbC5leHRlbmQgPSBPYmplY3QuYXNzaWduICE9IG51bGwgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24oIHRndCApe1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuICBmb3IoIHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKysgKXtcbiAgICB2YXIgb2JqID0gYXJnc1tpXTtcblxuICAgIGZvciggdmFyIGsgaW4gb2JqICl7XG4gICAgICB0Z3Rba10gPSBvYmpba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRndDtcbn07XG5cbltcbiAgcmVxdWlyZSgnLi9jb2xvcnMnKSxcbiAgcmVxdWlyZSgnLi9tYXBzJyksXG4gIHsgbWVtb2l6ZTogcmVxdWlyZSgnLi9tZW1vaXplJykgfSxcbiAgcmVxdWlyZSgnLi9yZWdleCcpLFxuICByZXF1aXJlKCcuL3N0cmluZ3MnKSxcbiAgcmVxdWlyZSgnLi90aW1pbmcnKVxuXS5mb3JFYWNoKGZ1bmN0aW9uKCByZXEgKXtcbiAgdXRpbC5leHRlbmQoIHV0aWwsIHJlcSApO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzID0gcmVxdWlyZSgnLi4vaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGhhcyBhbnl0aGluZyBiZWVuIHNldCBpbiB0aGUgbWFwXG4gIG1hcEVtcHR5OiBmdW5jdGlvbiggbWFwICl7XG4gICAgdmFyIGVtcHR5ID0gdHJ1ZTtcblxuICAgIGlmKCBtYXAgIT0gbnVsbCApe1xuICAgICAgZm9yKHZhciBpIGluIG1hcCl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW1wdHk7XG4gIH0sXG5cbiAgLy8gcHVzaGVzIHRvIHRoZSBhcnJheSBhdCB0aGUgZW5kIG9mIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgcHVzaE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLmdldE1hcChvcHRpb25zKTtcblxuICAgIGlmKCBhcnJheSA9PSBudWxsICl7IC8vIGlmIGVtcHR5LCBwdXQgaW5pdGlhbCBhcnJheVxuICAgICAgdGhpcy5zZXRNYXAoIHRoaXMuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHZhbHVlOiBbIG9wdGlvbnMudmFsdWUgXVxuICAgICAgfSkgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXkucHVzaCggb3B0aW9ucy52YWx1ZSApO1xuICAgIH1cbiAgfSxcblxuICAvLyBzZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG4gIHNldE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgdmFyIGtleTtcbiAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYoIGlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICB0aGlzLmVycm9yKCdUcmllZCB0byBzZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgfVxuXG4gICAgICBpZiggaSA8IGtleXMubGVuZ3RoIC0gMSApe1xuXG4gICAgICAgIC8vIGV4dGVuZCB0aGUgbWFwIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiggb2JqW2tleV0gPT0gbnVsbCApe1xuICAgICAgICAgIG9ialtrZXldID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWVcbiAgICAgICAgb2JqW2tleV0gPSBvcHRpb25zLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvLyBnZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCBldmVuIGlmIGl0J3Mgbm90IGJ1aWx0IGluIHBsYWNlc1xuICBnZXRNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKXtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiggaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgIHRoaXMuZXJyb3IoJ1RyaWVkIHRvIGdldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICB9XG5cbiAgICAgIG9iaiA9IG9ialtrZXldO1xuXG4gICAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIC8vIGRlbGV0ZXMgdGhlIGVudHJ5IGluIHRoZSBtYXBcbiAgZGVsZXRlTWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBrZWVwQ2hpbGRyZW4gPSBvcHRpb25zLmtlZXBDaGlsZHJlbjtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmKCBpcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgdGhpcy5lcnJvcignVHJpZWQgdG8gZGVsZXRlIG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3RLZXkgPSBpID09PSBvcHRpb25zLmtleXMubGVuZ3RoIC0gMTtcbiAgICAgIGlmKCBsYXN0S2V5ICl7XG5cbiAgICAgICAgaWYoIGtlZXBDaGlsZHJlbiApeyAvLyB0aGVuIG9ubHkgZGVsZXRlIGNoaWxkIGZpZWxkcyBub3QgaW4ga2VlcENoaWxkcmVuXG4gICAgICAgICAgZm9yKCB2YXIgY2hpbGQgaW4gb2JqICl7XG4gICAgICAgICAgICBpZiggIWtlZXBDaGlsZHJlbltjaGlsZF0gKXtcbiAgICAgICAgICAgICAgb2JqW2NoaWxkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lbW9pemUoIGZuLCBrZXlGbiApe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjYWNoZSA9IHt9O1xuXG4gIGlmKCAha2V5Rm4gKXtcbiAgICBrZXlGbiA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApe1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBhcmdzLnB1c2goIGFyZ3VtZW50c1tpXSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJncy5qb2luKCckJyk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBtZW1vaXplZEZuKCl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHJldDtcbiAgICB2YXIgayA9IGtleUZuLmFwcGx5KCBzZWxmLCBhcmdzICk7XG5cbiAgICBpZiggIShyZXQgPSBjYWNoZVtrXSkgKXtcbiAgICAgIHJldCA9IGNhY2hlW2tdID0gZm4uYXBwbHkoIHNlbGYsIGFyZ3MgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG51bWJlciA9IFwiKD86Wy0rXT8oPzooPzpcXFxcZCt8XFxcXGQqXFxcXC5cXFxcZCspKD86W0VlXVsrLV0/XFxcXGQrKT8pKVwiO1xuXG52YXIgcmdiYSA9IFwicmdiW2FdP1xcXFwoKFwiKyBudW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKFwiKyBudW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKFwiKyBudW1iZXIgK1wiWyVdPykoPzpcXFxccyosXFxcXHMqKFwiKyBudW1iZXIgK1wiKSk/XFxcXClcIjtcbnZhciByZ2JhTm9CYWNrUmVmcyA9IFwicmdiW2FdP1xcXFwoKD86XCIrIG51bWJlciArXCJbJV0/KVxcXFxzKixcXFxccyooPzpcIisgbnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKig/OlwiKyBudW1iZXIgK1wiWyVdPykoPzpcXFxccyosXFxcXHMqKD86XCIrIG51bWJlciArXCIpKT9cXFxcKVwiO1xuXG52YXIgaHNsYSA9IFwiaHNsW2FdP1xcXFwoKFwiKyBudW1iZXIgK1wiKVxcXFxzKixcXFxccyooXCIrIG51bWJlciArXCJbJV0pXFxcXHMqLFxcXFxzKihcIisgbnVtYmVyICtcIlslXSkoPzpcXFxccyosXFxcXHMqKFwiKyBudW1iZXIgK1wiKSk/XFxcXClcIjtcbnZhciBoc2xhTm9CYWNrUmVmcyA9IFwiaHNsW2FdP1xcXFwoKD86XCIrIG51bWJlciArXCIpXFxcXHMqLFxcXFxzKig/OlwiKyBudW1iZXIgK1wiWyVdKVxcXFxzKixcXFxccyooPzpcIisgbnVtYmVyICtcIlslXSkoPzpcXFxccyosXFxcXHMqKD86XCIrIG51bWJlciArXCIpKT9cXFxcKVwiO1xuXG52YXIgaGV4MyA9IFwiXFxcXCNbMC05YS1mQS1GXXszfVwiO1xudmFyIGhleDYgPSBcIlxcXFwjWzAtOWEtZkEtRl17Nn1cIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlZ2V4OiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgcmdiYTogcmdiYSxcbiAgICByZ2JhTm9CYWNrUmVmczogcmdiYU5vQmFja1JlZnMsXG4gICAgaHNsYTogaHNsYSxcbiAgICBoc2xhTm9CYWNrUmVmczogaHNsYU5vQmFja1JlZnMsXG4gICAgaGV4MzogaGV4MyxcbiAgICBoZXg2OiBoZXg2XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBjYW1lbDJkYXNoOiBtZW1vaXplKCBmdW5jdGlvbiggc3RyICl7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csIGZ1bmN0aW9uKCB2ICl7XG4gICAgICByZXR1cm4gJy0nICsgdi50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9ICksXG5cbiAgZGFzaDJjYW1lbDogbWVtb2l6ZSggZnVuY3Rpb24oIHN0ciApe1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKC1cXHcpL2csIGZ1bmN0aW9uKCB2ICl7XG4gICAgICByZXR1cm4gdlsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9ICksXG5cbiAgY2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKXtcbiAgICBpZiggaXMuZW1wdHlTdHJpbmcoc3RyKSApe1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfVxuXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luZG93ID0gcmVxdWlyZSgnLi4vd2luZG93Jyk7XG52YXIgaXMgPSByZXF1aXJlKCcuLi9pcycpO1xudmFyIHBlcmZvcm1hbmNlID0gd2luZG93ID8gd2luZG93LnBlcmZvcm1hbmNlIDogbnVsbDtcblxudmFyIHV0aWwgPSB7fTtcblxudmFyIHJhZiA9ICF3aW5kb3cgPyBudWxsIDogKCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICk7XG5cbnJhZiA9IHJhZiB8fCBmdW5jdGlvbiggZm4gKXtcbiAgaWYoIGZuICl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZm4oIHBub3coKSApO1xuICAgIH0sIDEwMDAvNjApO1xuICB9XG59O1xuXG51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGZuKXtcbiAgcmFmKCBmbiApO1xufTtcblxudmFyIHBub3cgPSBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZS5ub3cgPyBmdW5jdGlvbigpeyByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7IH0gOiBmdW5jdGlvbigpeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcblxudXRpbC5wZXJmb3JtYW5jZU5vdyA9IHBub3c7XG5cbi8vIHBvcnRlZCBsb2Rhc2ggdGhyb3R0bGUgZnVuY3Rpb25cbnV0aWwudGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICBsZWFkaW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXMucGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICBvcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICBvcHRpb25zLnRyYWlsaW5nID0gdHJhaWxpbmc7XG5cbiAgcmV0dXJuIHV0aWwuZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucyk7XG59O1xuXG51dGlsLm5vdyA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcblxudXRpbC5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHsgLy8gcG9ydGVkIGxvZGFzaCBkZWJvdW5jZSBmdW5jdGlvblxuICB2YXIgdXRpbCA9IHRoaXM7XG4gIHZhciBhcmdzLFxuICAgICAgbWF4VGltZW91dElkLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhbXAsXG4gICAgICB0aGlzQXJnLFxuICAgICAgdGltZW91dElkLFxuICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgbGFzdENhbGxlZCA9IDAsXG4gICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKCFpcy5mbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YWl0ID0gTWF0aC5tYXgoMCwgd2FpdCkgfHwgMDtcbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgdHJhaWxpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChpcy5wbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4V2FpdCA9ICdtYXhXYWl0JyBpbiBvcHRpb25zICYmIChNYXRoLm1heCh3YWl0LCBvcHRpb25zLm1heFdhaXQpIHx8IDApO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHZhciBkZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAodXRpbC5ub3coKSAtIHN0YW1wKTtcbiAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNDYWxsZWQgPSB0cmFpbGluZ0NhbGw7XG4gICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgbGFzdENhbGxlZCA9IHV0aWwubm93KCk7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRyYWlsaW5nIHx8IChtYXhXYWl0ICE9PSB3YWl0KSkge1xuICAgICAgbGFzdENhbGxlZCA9IHV0aWwubm93KCk7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN0YW1wID0gdXRpbC5ub3coKTtcbiAgICB0aGlzQXJnID0gdGhpcztcbiAgICB0cmFpbGluZ0NhbGwgPSB0cmFpbGluZyAmJiAodGltZW91dElkIHx8ICFsZWFkaW5nKTtcblxuICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICB9XG4gICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgIGlmIChpc0NhbGxlZCkge1xuICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgIHRpbWVvdXRJZCA9IGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZGVsYXllZCwgd2FpdCk7XG4gICAgfVxuICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgaXNDYWxsZWQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICB9XG4gICAgaWYgKGlzQ2FsbGVkICYmICF0aW1lb3V0SWQgJiYgIW1heFRpbWVvdXRJZCkge1xuICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsO1xuIiwibW9kdWxlLmV4cG9ydHMgPSAoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuIl19
